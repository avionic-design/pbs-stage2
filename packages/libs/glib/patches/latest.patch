diff --git a/HACKING b/HACKING
index e7e2fc5..a1f613a 100644
--- a/HACKING
+++ b/HACKING
@@ -1,28 +1,30 @@
 If you want to hack on the GLib project, you'll need to have the
 following packages installed:
 
-	- GNU autoconf 2.54
-	- GNU automake 1.7
-	- GNU libtool 1.4
+        - GNU autoconf 2.62
+        - GNU automake 1.11
+        - GNU libtool 2.2
         - GNU gettext 0.10.40
+        - pkg-config 0.16
         - gtk-doc
+        - libffi 3.0.0
 
 These should be available by ftp from ftp.gnu.org or any of the
 fine GNU mirrors.  Beta software can be found at alpha.gnu.org.
 
-To compile a CVS version of glib on your system, you will need to take
+To compile a GIT version of glib on your system, you will need to take
 several steps to setup the tree for compilation.  You can do all these
 steps at once by running:
 
-        cvsroot/glib# ./autogen.sh
- 
+        checkout/glib# ./autogen.sh
+
 Basically this does the following for you:
 
-  	cvsroot/glib# aclocal; automake; autoconf
+        checkout/glib# aclocal; automake; autoconf
 
         The above commands create the "configure" script.  Now you
-	can run the configure script in cvsroot/glib to create all
-	the Makefiles.
+        can run the configure script in checkout/glib to create all
+        the Makefiles.
 
 Before running autogen.sh or configure, make sure you have libtool
 in your path.
diff --git a/build/win32/vs10/gio.vcxprojin b/build/win32/vs10/gio.vcxprojin
index e223b23..bf43db5 100644
--- a/build/win32/vs10/gio.vcxprojin
+++ b/build/win32/vs10/gio.vcxprojin
@@ -82,7 +82,7 @@
       <CompileAs>CompileAsC</CompileAs>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>zdll.lib;ws2_32.lib;shlwapi.lib;dnsapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>zlib1d.lib;ws2_32.lib;shlwapi.lib;dnsapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <OutputFile>$(OutDir)$(GlibDllPrefix)$(ProjectName)$(GlibDllSuffix).dll</OutputFile>
       <ModuleDefinitionFile>$(IntDir)gio.def</ModuleDefinitionFile>
       <GenerateDebugInformation>true</GenerateDebugInformation>
@@ -106,7 +106,7 @@
       <CompileAs>CompileAsC</CompileAs>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>zdll.lib;ws2_32.lib;shlwapi.lib;dnsapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>zlib1.lib;ws2_32.lib;shlwapi.lib;dnsapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <OutputFile>$(OutDir)$(GlibDllPrefix)$(ProjectName)$(GlibDllSuffix).dll</OutputFile>
       <ModuleDefinitionFile>$(IntDir)gio.def</ModuleDefinitionFile>
       <GenerateDebugInformation>true</GenerateDebugInformation>
@@ -135,7 +135,7 @@
       <CompileAs>CompileAsC</CompileAs>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>zdll.lib;ws2_32.lib;shlwapi.lib;dnsapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>zlib1d.lib;ws2_32.lib;shlwapi.lib;dnsapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <OutputFile>$(OutDir)$(GlibDllPrefix)$(ProjectName)$(GlibDllSuffix).dll</OutputFile>
       <ModuleDefinitionFile>$(IntDir)gio.def</ModuleDefinitionFile>
       <GenerateDebugInformation>true</GenerateDebugInformation>
@@ -159,7 +159,7 @@
       <CompileAs>CompileAsC</CompileAs>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>zdll.lib;ws2_32.lib;shlwapi.lib;dnsapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>zlib1.lib;ws2_32.lib;shlwapi.lib;dnsapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <OutputFile>$(OutDir)$(GlibDllPrefix)$(ProjectName)$(GlibDllSuffix).dll</OutputFile>
       <ModuleDefinitionFile>$(IntDir)gio.def</ModuleDefinitionFile>
       <GenerateDebugInformation>true</GenerateDebugInformation>
diff --git a/build/win32/vs10/glib.props b/build/win32/vs10/glib.props
index 5ae052c..cfaaea8 100644
--- a/build/win32/vs10/glib.props
+++ b/build/win32/vs10/glib.props
@@ -415,6 +415,8 @@ copy ..\..\..\gio\gproxyaddressenumerator.h $(CopyDir)\include\glib-$(ApiVersion
 
 copy ..\..\..\gio\gproxyresolver.h $(CopyDir)\include\glib-$(ApiVersion)\gio
 
+copy ..\..\..\gio\gremoteactiongroup.h $(CopyDir)\include\glib-$(ApiVersion)\gio
+
 copy ..\..\..\gio\gresolver.h $(CopyDir)\include\glib-$(ApiVersion)\gio
 
 copy ..\..\..\gio\gseekable.h $(CopyDir)\include\glib-$(ApiVersion)\gio
diff --git a/build/win32/vs9/gio.vcprojin b/build/win32/vs9/gio.vcprojin
index f5a70e0..48b9123 100644
--- a/build/win32/vs9/gio.vcprojin
+++ b/build/win32/vs9/gio.vcprojin
@@ -39,7 +39,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="zdll.lib ws2_32.lib shlwapi.lib dnsapi.lib"
+				AdditionalDependencies="zlib1d.lib ws2_32.lib shlwapi.lib dnsapi.lib"
 				OutputFile="$(OutDir)\$(GlibDllPrefix)$(ProjectName)$(GlibDllSuffix).dll"
 				LinkIncremental="2"
 				ModuleDefinitionFile="$(IntDir)\gio.def"
@@ -70,7 +70,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="zdll.lib ws2_32.lib shlwapi.lib dnsapi.lib"
+				AdditionalDependencies="zlib1.lib ws2_32.lib shlwapi.lib dnsapi.lib"
 				OutputFile="$(OutDir)\$(GlibDllPrefix)$(ProjectName)$(GlibDllSuffix).dll"
 				LinkIncremental="1"
 				ModuleDefinitionFile="$(IntDir)\gio.def"
@@ -105,7 +105,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="zdll.lib ws2_32.lib shlwapi.lib dnsapi.lib"
+				AdditionalDependencies="zlib1d.lib ws2_32.lib shlwapi.lib dnsapi.lib"
 				OutputFile="$(OutDir)\$(GlibDllPrefix)$(ProjectName)$(GlibDllSuffix).dll"
 				LinkIncremental="2"
 				ModuleDefinitionFile="$(IntDir)\gio.def"
@@ -136,7 +136,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="zdll.lib ws2_32.lib shlwapi.lib dnsapi.lib"
+				AdditionalDependencies="zlib1.lib ws2_32.lib shlwapi.lib dnsapi.lib"
 				OutputFile="$(OutDir)\$(GlibDllPrefix)$(ProjectName)$(GlibDllSuffix).dll"
 				LinkIncremental="1"
 				ModuleDefinitionFile="$(IntDir)\gio.def"
diff --git a/build/win32/vs9/glib.vsprops b/build/win32/vs9/glib.vsprops
index 5513879..41291b9 100644
--- a/build/win32/vs9/glib.vsprops
+++ b/build/win32/vs9/glib.vsprops
@@ -249,6 +249,7 @@ copy ..\..\..\gio\gproxy.h $(OutDir)\include\glib-$(ApiVersion)\gio&#x0D;&#x0A;
 copy ..\..\..\gio\gproxyaddress.h $(OutDir)\include\glib-$(ApiVersion)\gio&#x0D;&#x0A;
 copy ..\..\..\gio\gproxyaddressenumerator.h $(OutDir)\include\glib-$(ApiVersion)\gio&#x0D;&#x0A;
 copy ..\..\..\gio\gproxyresolver.h $(OutDir)\include\glib-$(ApiVersion)\gio&#x0D;&#x0A;
+copy ..\..\..\gio\gremoteactiongroup.h $(OutDir)\include\glib-$(ApiVersion)\gio&#x0D;&#x0A;
 copy ..\..\..\gio\gresolver.h $(OutDir)\include\glib-$(ApiVersion)\gio&#x0D;&#x0A;
 copy ..\..\..\gio\gseekable.h $(OutDir)\include\glib-$(ApiVersion)\gio&#x0D;&#x0A;
 copy ..\..\..\gio\gsettingsschema.h $(OutDir)\include\glib-$(ApiVersion)\gio&#x0D;&#x0A;
diff --git a/config.h.win32.in b/config.h.win32.in
index 3b74b43..1e54ab3 100644
--- a/config.h.win32.in
+++ b/config.h.win32.in
@@ -5,9 +5,6 @@
 /* Define if building universal (internal helper macro) */
 /* #undef AC_APPLE_UNIVERSAL_BUILD */
 
-/* define if asm blocks can use numeric local labels */
-/* #undef ASM_NUMERIC_LABELS */
-
 /* poll doesn't work on devices */
 #define BROKEN_POLL 1
 
@@ -37,9 +34,6 @@
 /* Define to the GLIB binary age */
 #define GLIB_BINARY_AGE @GLIB_BINARY_AGE@
 
-/* Byte contents of gmutex */
-/* #undef GLIB_BYTE_CONTENTS_GMUTEX */
-
 /* Define to the GLIB interface age */
 #define GLIB_INTERFACE_AGE @GLIB_INTERFACE_AGE@
 
@@ -55,15 +49,6 @@
 /* Define to the GLIB minor version */
 #define GLIB_MINOR_VERSION @GLIB_MINOR_VERSION@
 
-/* The size of gmutex, as computed by sizeof. */
-/* #undef GLIB_SIZEOF_GMUTEX */
-
-/* The size of system_thread, as computed by sizeof. */
-#define GLIB_SIZEOF_SYSTEM_THREAD 4
-
-/* whether GCC supports built-in atomic intrinsics */
-/* #undef HAVE_GCC_BUILTINS_FOR_ATOMIC_OPERATIONS */
-
 /* Have inline keyword */
 #ifndef _MSC_VER
 #define G_HAVE_INLINE 1
@@ -200,24 +185,21 @@
 /* we have the futex(2) system call */
 /* #undef HAVE_FUTEX */
 
-/* Whether you have gcov */
-/* #undef HAVE_GCOV */
-
 /* Define to 1 if you have the `getcwd' function. */
 #define HAVE_GETCWD 1
 
 /* Define to 1 if you have the `getc_unlocked' function. */
 /* #undef HAVE_GETC_UNLOCKED */
 
+/* Define to 1 if you have the `getfsstat' function. */
+/* #undef HAVE_GETFSSTAT */
+
 /* Define to 1 if you have the `getgrgid' function. */
 /* #undef HAVE_GETGRGID */
 
 /* Define to 1 if you have the `getmntent_r' function. */
 /* #undef HAVE_GETMNTENT_R */
 
-/* Define to 1 if you have the `getmntinfo' function. */
-/* #undef HAVE_GETMNTINFO */
-
 /* Define to 1 if you have the `getprotobyname_r' function. */
 /* #undef HAVE_GETPROTOBYNAME_R */
 
@@ -227,6 +209,9 @@
 /* Define if the GNU gettext() function is already present or preinstalled. */
 #define HAVE_GETTEXT 1
 
+/* Define to 1 if you have the `getvfsstat' function. */
+/* #undef HAVE_GETVFSSTAT */
+
 /* Define to 1 if you have the `gmtime_r' function. */
 /* #undef HAVE_GMTIME_R */
 
@@ -273,6 +258,9 @@
 /* Define if you have <langinfo.h> and nl_langinfo(CODESET). */
 /* #undef HAVE_LANGINFO_CODESET */
 
+/* Have nl_langinfo (_NL_CTYPE_OUTDIGITn_WC) */
+/* #undef HAVE_LANGINFO_OUTDIGIT */
+
 /* Have nl_langinfo (PM_STR) */
 /* #undef HAVE_LANGINFO_TIME */
 
@@ -337,12 +325,18 @@
 /* Define to 1 if you have the <mntent.h> header file. */
 /* #undef HAVE_MNTENT_H */
 
-/* Have a monotonic clock */
-/* #undef HAVE_MONOTONIC_CLOCK */
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+/* #undef HAVE_NDIR_H */
 
 /* Define to 1 if you have the <netdb.h> header file. */
 /* #undef HAVE_NETDB_H */
 
+/* We have AF_NETLINK sockets */
+/* #undef HAVE_NETLINK */
+
+/* Define to 1 if you have the `newlocale' function. */
+/* #undef HAVE_NEWLOCALE */
+
 /* Have non-POSIX function getgrgid_r */
 /* #undef HAVE_NONPOSIX_GETGRGID_R */
 
@@ -367,6 +361,9 @@
 /* Define to 1 if you have the `posix_memalign' function. */
 /* #undef HAVE_POSIX_MEMALIGN */
 
+/* Define to 1 if you have the `prlimit' function. */
+/* #undef HAVE_PRLIMIT */
+
 /* Have function pthread_attr_setstacksize */
 /* #undef HAVE_PTHREAD_ATTR_SETSTACKSIZE */
 
@@ -403,9 +400,6 @@
 /* Define to 1 if you have the `setresuid' function. */
 /* #undef HAVE_SETRESUID */
 
-/* Define to 1 if you have the `setreuid' function. */
-/* #undef HAVE_SETREUID */
-
 /* Define to 1 if you have the `snprintf' function. */
 #ifndef _MSC_VER
 #define HAVE_SNPRINTF 1
@@ -495,6 +489,18 @@
 /* Define to 1 if you have the `strsignal' function. */
 /* #undef HAVE_STRSIGNAL */
 
+/* Define to 1 if you have the `strtod_l' function. */
+/* #undef HAVE_STRTOD_L */
+
+/* Define to 1 if you have the `strtoll_l' function. */
+/* #undef HAVE_STRTOLL_L */
+
+/* Define to 1 if you have the `strtoull_l' function. */
+/* #undef HAVE_STRTOULL_L */
+
+/* Define to 1 if `d_type' is a member of `struct dirent'. */
+/* #undef HAVE_STRUCT_DIRENT_D_TYPE */
+
 /* Define to 1 if `f_bavail' is a member of `struct statfs'. */
 /* #undef HAVE_STRUCT_STATFS_F_BAVAIL */
 
@@ -504,6 +510,9 @@
 /* Define to 1 if `f_basetype' is a member of `struct statvfs'. */
 /* #undef HAVE_STRUCT_STATVFS_F_BASETYPE */
 
+/* Define to 1 if `f_fstypename' is a member of `struct statvfs'. */
+/* #undef HAVE_STRUCT_STATVFS_F_FSTYPENAME */
+
 /* Define to 1 if `st_atimensec' is a member of `struct stat'. */
 /* #undef HAVE_STRUCT_STAT_ST_ATIMENSEC */
 
@@ -537,6 +546,10 @@
 /* Define to 1 if you have the `symlink' function. */
 /* #undef HAVE_SYMLINK */
 
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_DIR_H */
+
 /* Define to 1 if you have the <sys/inotify.h> header file. */
 /* #undef HAVE_SYS_INOTIFY_H */
 
@@ -552,6 +565,10 @@
 /* Define to 1 if you have the <sys/mount.h> header file. */
 /* #undef HAVE_SYS_MOUNT_H */
 
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_NDIR_H */
+
 /* Define to 1 if you have the <sys/param.h> header file. */
 #if !defined(_MSC_VER) && !defined(__DMC__)
 #define HAVE_SYS_PARAM_H 1
@@ -631,6 +648,9 @@
 /* Define to 1 if you have the `unsetenv' function. */
 /* #undef HAVE_UNSETENV */
 
+/* Define to 1 if you have the `uselocale' function. */
+/* #undef HAVE_USELOCALE */
+
 /* Define to 1 if you have the `utimes' function. */
 /* #undef HAVE_UTIMES */
 
@@ -669,11 +689,6 @@
 /* Define to 1 if you have the `wcslen' function. */
 #define HAVE_WCSLEN 1
 
-/* Have Win32 atomic intrinsics */
-#ifdef _MSC_VER
-#define HAVE_WIN32_BUILTINS_FOR_ATOMIC_OPERATIONS 1
-#endif
-
 /* Define if you have the 'wint_t' type. */
 #define HAVE_WINT_T 1
 
@@ -693,6 +708,9 @@
 /* Define to 1 if xattr API uses XATTR_NOFOLLOW */
 /* #undef HAVE_XATTR_NOFOLLOW */
 
+/* Define to 1 if you have the <xlocale.h> header file. */
+/* #undef HAVE_XLOCALE_H */
+
 /* Define to 1 if you have the `_NSGetEnviron' function. */
 /* #undef HAVE__NSGETENVIRON */
 
@@ -709,15 +727,6 @@
 /* Define to 1 if your C compiler doesn't accept -c and -o together. */
 /* #undef NO_MINUS_C_MINUS_O */
 
-/* global 'sys_errlist' not found */
-#define NO_SYS_ERRLIST 1
-
-/* global 'sys_siglist' not found */
-#define NO_SYS_SIGLIST 1
-
-/* global 'sys_siglist' not declared */
-#define NO_SYS_SIGLIST_DECL 1
-
 /* Define to the address where bug reports for this package should be sent. */
 #define PACKAGE_BUGREPORT "http://bugzilla.gnome.org/enter_bug.cgi?product=glib"
 
@@ -736,18 +745,9 @@
 /* Define to the version of this package. */
 #define PACKAGE_VERSION "@GLIB_MAJOR_VERSION@.@GLIB_MINOR_VERSION@.@GLIB_MICRO_VERSION@"
 
-/* Maximum POSIX RT priority */
-/* #undef POSIX_MAX_PRIORITY */
-
 /* define if posix_memalign() can allocate any size */
 /* #undef POSIX_MEMALIGN_WITH_COMPLIANT_ALLOCS */
 
-/* Minimum POSIX RT priority */
-/* #undef POSIX_MIN_PRIORITY */
-
-/* The POSIX RT yield function */
-/* #undef POSIX_YIELD_FUNC */
-
 /* whether realloc (NULL,) works */
 #define REALLOC_0_WORKS 1
 
@@ -781,7 +781,15 @@
 #define SIZEOF_SIZE_T 4
 
 /* The size of `void *', as computed by sizeof. */
+#ifdef _MSC_VER
+#if (defined(_M_X64) || defined(_M_AMD64))
+#define SIZEOF_VOID_P 8
+#elif (defined(_M_IX86))
 #define SIZEOF_VOID_P 4
+#endif
+#else
+#define SIZEOF_VOID_P 4
+#endif
 
 /* The size of `__int64', as computed by sizeof. */
 #define SIZEOF___INT64 8
diff --git a/configure.ac b/configure.ac
index 54dc680..5662b53 100644
--- a/configure.ac
+++ b/configure.ac
@@ -27,7 +27,7 @@ m4_define(glib_configure_ac)
 
 m4_define([glib_major_version], [2])
 m4_define([glib_minor_version], [31])
-m4_define([glib_micro_version], [6])
+m4_define([glib_micro_version], [7])
 m4_define([glib_interface_age], [0])
 m4_define([glib_binary_age],
           [m4_eval(100 * glib_minor_version + glib_micro_version)])
@@ -243,7 +243,6 @@ if test "x$disable_mem_pools" = "xno"; then
   AC_MSG_RESULT([no])
 else
   AC_DEFINE(DISABLE_MEM_POOLS, [1], [Whether to disable memory pools])
-  AC_SUBST(DISABLE_MEM_POOLS)
   AC_MSG_RESULT([yes])
 fi
 
@@ -283,7 +282,6 @@ if test "x$enable_debug" = "xyes"; then
       *) CFLAGS="$CFLAGS -g" ;;
       esac
   fi
-	
   GLIB_DEBUG_FLAGS="-DG_ENABLE_DEBUG"
 else
   GLIB_DEBUG_FLAGS="-DG_DISABLE_CAST_CHECKS"
@@ -561,9 +559,6 @@ AC_TRY_COMPILE([#include <dirent.h>], [DIR *dir;],
     CFLAGS=$glib_save_CFLAGS
     AC_MSG_WARN([Could not determine POSIX flag. (-posix didn't work.)])))
 
-# Checks for header files.
-AC_HEADER_STDC
-
 # Checks for library functions.
 AC_FUNC_VPRINTF
 AC_FUNC_ALLOCA
@@ -670,8 +665,6 @@ elif test x$ac_cv_sizeof___int64 = x8; then
 	AC_DEFINE(HAVE_INT64_AND_I64,1,[define to support printing 64-bit integers with format I64])
 fi
 
-dnl long doubles were not used, and a portability problem
-dnl AC_C_LONG_DOUBLE
 AC_C_CONST
 
 dnl ok, here we try to check whether the systems prototypes for
@@ -1869,18 +1862,13 @@ dnl ***********************
 AC_ARG_WITH(threads,
            [AC_HELP_STRING([--with-threads=@<:@posix/win32@:>@],
                            [specify a thread implementation to use])],
-           [if test "x$with_threads" = x; then
-		want_threads=yes
-	    else
-		want_threads=$with_threads
-	    fi],
-	   [want_threads=yes])
+           [],
+           [with_threads=yes])
 
 dnl error and warning message
 dnl *************************
 
-THREAD_NO_IMPLEMENTATION="You do not have any known thread system on your
-                computer."
+THREAD_NO_IMPLEMENTATION="No thread implementation found."
 
 FLAG_DOES_NOT_WORK="I can't find the MACRO to enable thread safety on your
                 platform (normally it's "_REENTRANT"). I'll not use any flag on
@@ -1888,10 +1876,10 @@ FLAG_DOES_NOT_WORK="I can't find the MACRO to enable thread safety on your
                 Please provide information on how it is done on your system."
 
 LIBS_NOT_FOUND_1="I can't find the libraries for the thread implementation
-		"
+                 "
 
 LIBS_NOT_FOUND_2=". Please choose another thread implementation or
-		provide information on your thread implementation."
+                  provide information on your thread implementation."
 
 FUNC_NO_GETPWUID_R="the 'g_get_(user_name|real_name|home_dir|tmp_dir)'
 		functions will not be MT-safe during their first call because
@@ -1900,16 +1888,6 @@ FUNC_NO_GETPWUID_R="the 'g_get_(user_name|real_name|home_dir|tmp_dir)'
 FUNC_NO_LOCALTIME_R="the 'g_date_set_time' function will not be MT-safe
 		because there is no 'localtime_r' on your system."
 
-POSIX_NO_YIELD="I can not find a yield functions for your platform. A rather
-		crude surrogate will be used. If you happen to know a 
-		yield function for your system, please inform the GLib 
-		developers."
-
-POSIX_NO_PRIORITIES="I can not find the minimal and maximal priorities for 
-		threads on your system. Thus threads can only have the default 
-		priority. If you happen to know these main/max
-		priorities, please inform the GLib developers."
-
 AIX_COMPILE_INFO="AIX's C compiler needs to be called by a different name, when
 		linking threaded applications. As GLib cannot do that 
 		automatically, you will get an linkg error everytime you are 
@@ -1920,9 +1898,10 @@ AIX_COMPILE_INFO="AIX's C compiler needs to be called by a different name, when
 dnl determination of thread implementation
 dnl ***************************************
 
+AC_MSG_CHECKING(for thread implementation)
+
 have_threads=no
-if test "x$want_threads" = xyes || test "x$want_threads" = xposix \
-				|| test "x$want_threads" = xdce; then
+if test "x$with_threads" = xyes || test "x$with_threads" = xposix; then
 	# -D_POSIX4_DRAFT_SOURCE -D_POSIX4A_DRAFT10_SOURCE is for DG/UX
 	# -U_OSF_SOURCE is for Digital UNIX 4.0d
 	GTHREAD_COMPILE_IMPL_DEFINES="-D_POSIX4_DRAFT_SOURCE -D_POSIX4A_DRAFT10_SOURCE -U_OSF_SOURCE"
@@ -1942,21 +1921,19 @@ if test "x$want_threads" = xyes || test "x$want_threads" = xposix \
         fi
 	CPPFLAGS="$glib_save_CPPFLAGS"
 fi
-if test "x$want_threads" = xyes || test "x$want_threads" = xwin32; then
-       	case $host in
-               	*-*-mingw*)
-		have_threads=win32
-		;;
-	esac
+if test "x$with_threads" = xyes || test "x$with_threads" = xwin32; then
+        case $host in
+                *-*-mingw*)
+                have_threads=win32
+                ;;
+        esac
 fi
 
-AC_MSG_CHECKING(for thread implementation)
-
 if test "x$have_threads" = xno; then
-	AC_MSG_RESULT(none available)
+        AC_MSG_RESULT(none available)
         AC_MSG_ERROR($THREAD_NO_IMPLEMENTATION)
 else
-	AC_MSG_RESULT($have_threads)
+        AC_MSG_RESULT($have_threads)
 fi
 
 
@@ -1982,18 +1959,6 @@ int main()
    return (check_me != 42 || ret != &check_me);
 }])
 
-dnl
-dnl Test program for sched_get_priority_min()
-dnl
-m4_define([glib_sched_priority_test],[
-#include <sched.h>
-#include <errno.h>
-int main() {
-    errno = 0;
-    return sched_get_priority_min(SCHED_OTHER)==-1
- 	   && errno != 0;
-}])
-
 if test x"$have_threads" = xposix; then
   # First we test for posix, whether -pthread or -pthreads do the trick as 
   # both CPPFLAG and LIBS. 
@@ -2151,34 +2116,6 @@ case $have_threads in
             esac
           fi
 
-          glib_save_LIBS="$LIBS"
-	  for thread_lib in "" rt rte; do
-	    if test x"$thread_lib" = x; then
-	      add_thread_lib=""
-	      IN=""
-	    else
-	      add_thread_lib="-l$thread_lib"
-	      IN=" in -l$thread_lib"
-	    fi
-	    LIBS="$add_thread_lib $glib_save_LIBS"
-	    
-            AC_MSG_CHECKING(for sched_get_priority_min$IN)
-	    AC_TRY_RUN(glib_sched_priority_test,
-                       glib_result=yes,
-                       glib_result=no,
-                       [AC_LINK_IFELSE([AC_LANG_SOURCE(glib_sched_priority_test)],
-                                       glib_result=yes,
-                                       glib_result=no)])
-	    AC_MSG_RESULT($glib_result)
-
-	    if test "$glib_result" = "yes" ; then	    
- 	       G_THREAD_LIBS="$G_THREAD_LIBS $add_thread_lib"
-	       posix_priority_min="sched_get_priority_min(SCHED_OTHER)"
-	       posix_priority_max="sched_get_priority_max(SCHED_OTHER)"
-	       break
-            fi
-	  done
-	  LIBS="$glib_save_LIBS"
 	  g_threads_impl="POSIX"
 	  AC_SUBST(GTHREAD_COMPILE_IMPL_DEFINES)
           CPPFLAGS="$glib_save_CPPFLAGS"
@@ -2296,78 +2233,17 @@ int main () {
 fi
 LIBS="$G_THREAD_LIBS $LIBS"
 if test x"$have_threads" = xposix; then
-	glib_save_CPPFLAGS="$CPPFLAGS"
-	CPPFLAGS="$CPPFLAGS $GTHREAD_COMPILE_IMPL_DEFINES"
-	dnl we might grow sizeof(pthread_t) later on, so use a dummy name here
-	GLIB_SIZEOF([#include <pthread.h>], pthread_t, system_thread)
-	# This is not AC_CHECK_FUNC to also work with function
-	# name mangling in header files.
-	AC_MSG_CHECKING(for pthread_attr_setstacksize)
-	AC_TRY_LINK([#include <pthread.h>],
-		[pthread_attr_t t; pthread_attr_setstacksize(&t,0)],
-		[AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_PTHREAD_ATTR_SETSTACKSIZE,1,
-			  [Have function pthread_attr_setstacksize])],
-		[AC_MSG_RESULT(no)])
-	AC_MSG_CHECKING(for minimal/maximal thread priority)
-	if test x"$posix_priority_min" = x; then
-		AC_EGREP_CPP(PX_PRIO_MIN,[#include <pthread.h>
-			PX_PRIO_MIN],,[
-			posix_priority_min=PX_PRIO_MIN
-			posix_priority_max=PX_PRIO_MAX])
-	fi
-	if test x"$posix_priority_min" = x; then
-		# AIX
-		AC_EGREP_CPP(PTHREAD_PRIO_MIN,[#include <pthread.h>
-			PTHREAD_PRIO_MIN],,[
-			posix_priority_min=PTHREAD_PRIO_MIN
-			posix_priority_max=PTHREAD_PRIO_MAX])
-	fi
-	if test x"$posix_priority_min" = x; then
-		AC_EGREP_CPP(PRI_OTHER_MIN,[#include <pthread.h>
-			PRI_OTHER_MIN],,[
-			posix_priority_min=PRI_OTHER_MIN	
-			posix_priority_max=PRI_OTHER_MAX])
-	fi
-	if test x"$posix_priority_min" = x; then
-		AC_MSG_RESULT(none found)
-		AC_MSG_WARN($POSIX_NO_PRIORITIES)
-                posix_priority_min=-1
-		posix_priority_max=-1
-	else
-		AC_MSG_RESULT($posix_priority_min/$posix_priority_max)
-		AC_MSG_CHECKING(for pthread_setschedparam)
-		AC_TRY_LINK([#include <pthread.h>],
-	          [pthread_t t; pthread_setschedparam(t, 0, NULL)],
-		  [AC_MSG_RESULT(yes)
-		AC_DEFINE_UNQUOTED(POSIX_MIN_PRIORITY,$posix_priority_min,[Minimum POSIX RT priority])
-		   AC_DEFINE_UNQUOTED(POSIX_MAX_PRIORITY,$posix_priority_max,[Maximum POSIX RT priority])],
-                  [AC_MSG_RESULT(no)
-                   AC_MSG_WARN($POSIX_NO_PRIORITIES)])
-	fi
-	posix_yield_func=none
-	AC_MSG_CHECKING(for posix yield function)
-	for yield_func in sched_yield pthread_yield_np pthread_yield \
-						thr_yield; do
-		AC_TRY_LINK([#include <pthread.h>],
-			[$yield_func()],
-			[posix_yield_func="$yield_func"
-			break])
-	done		
-	if test x"$posix_yield_func" = xnone; then
-		AC_MSG_RESULT(none found)
-		AC_MSG_WARN($POSIX_NO_YIELD)
-                posix_yield_func="g_usleep(1000)"
-	else
-		AC_MSG_RESULT($posix_yield_func)
-		posix_yield_func="$posix_yield_func()"
-	fi
-	AC_DEFINE_UNQUOTED(POSIX_YIELD_FUNC,$posix_yield_func,[The POSIX RT yield function])
-	CPPFLAGS="$glib_save_CPPFLAGS"
-   
-elif test x"$have_threads" = xwin32; then
-	# It's a pointer to a private struct
-	GLIB_SIZEOF(,struct _GThreadData *, system_thread)
+        glib_save_CPPFLAGS="$CPPFLAGS"
+        CPPFLAGS="$CPPFLAGS $GTHREAD_COMPILE_IMPL_DEFINES"
+        # This is not AC_CHECK_FUNC to also work with function
+        # name mangling in header files.
+        AC_MSG_CHECKING(for pthread_attr_setstacksize)
+        AC_TRY_LINK([#include <pthread.h>],
+                    [pthread_attr_t t; pthread_attr_setstacksize(&t,0)],
+                    [AC_MSG_RESULT(yes)
+                     AC_DEFINE(HAVE_PTHREAD_ATTR_SETSTACKSIZE,1,[Have function pthread_attr_setstacksize])],
+                    [AC_MSG_RESULT(no)])
+        CPPFLAGS="$glib_save_CPPFLAGS"
 fi
 
 LIBS="$glib_save_LIBS"
@@ -2381,11 +2257,6 @@ if test "$ac_cv_func_localtime_r" != "yes"; then
 	AC_MSG_WARN($FUNC_NO_LOCALTIME_R)
 fi
 
-if test x"$glib_cv_sizeof_system_thread" = x; then
-   # use a pointer as a fallback.
-   GLIB_SIZEOF(,void *, system_thread)
-fi
-
 #
 # Hack to deal with:
 # 
@@ -2837,8 +2708,6 @@ if test "x$use_gcov" = "xyes"; then
     AC_MSG_ERROR([Could not find genhtml from the LTP package])
   fi
 
-  AC_DEFINE(HAVE_GCOV, 1, [Whether you have gcov])
-
   dnl Remove all optimization flags from CFLAGS
   changequote({,})
   CFLAGS=`echo "$CFLAGS" | $SED -e 's/-O[0-9]*//g'`
@@ -2864,8 +2733,8 @@ AC_CONFIG_COMMANDS([glib/glibconfig.h],
  * This is a generated file.  Please modify 'configure.ac'
  */
 
-#ifndef __G_LIBCONFIG_H__
-#define __G_LIBCONFIG_H__
+#ifndef __GLIBCONFIG_H__
+#define __GLIBCONFIG_H__
 
 #include <glib/gmacros.h>
 
@@ -3165,13 +3034,6 @@ _______EOF
 
 #define G_MODULE_SUFFIX "$g_module_suffix"
 
-/* A GPid is an abstraction for a process "handle". It is *not* an
- * abstraction for a process identifier in general. GPid is used in
- * GLib only for descendant processes spawned with the g_spawn*
- * functions. On POSIX there is no "process handle" concept as such,
- * but on Windows a GPid is a handle to a process, a kind of pointer,
- * not a process identifier.
- */
 typedef $g_pid_type GPid;
 
 #define GLIB_SYSDEF_AF_UNIX $g_af_unix
@@ -3184,7 +3046,7 @@ typedef $g_pid_type GPid;
 
 G_END_DECLS
 
-#endif /* GLIBCONFIG_H */
+#endif /* __GLIBCONFIG_H__ */
 _______EOF
 
 
@@ -3495,8 +3357,6 @@ g_have_eilseq=$have_eilseq
 
 g_threads_impl_def=$g_threads_impl
 
-g_system_thread_sizeof="$glib_cv_sizeof_system_thread"
-
 g_atomic_lock_free="$glib_cv_g_atomic_lock_free"
 g_memory_barrier_needed="$glib_memory_barrier_needed"
 g_gcc_atomic_ops="$glib_cv_gcc_has_builtin_atomic_operations"
@@ -3557,7 +3417,7 @@ AC_ARG_ENABLE(Bsymbolic,
                            enable_Bsymbolic=no)
                LDFLAGS="${SAVED_LDFLAGS}"])
 
-if test "x${enable_Bsymbolic}" == "xyes"; then
+if test "x${enable_Bsymbolic}" = "xyes"; then
   GLIB_LINK_FLAGS=-Wl,-Bsymbolic-functions
 fi
 
diff --git a/docs/reference/gio/gio-sections.txt b/docs/reference/gio/gio-sections.txt
index 1cea4f3..62b233a 100644
--- a/docs/reference/gio/gio-sections.txt
+++ b/docs/reference/gio/gio-sections.txt
@@ -1838,7 +1838,7 @@ GSocketPrivate
 <FILE>gsocketclient</FILE>
 <TITLE>GSocketClient</TITLE>
 GSocketClient
-g_socket_client_add_application_proxy
+GSocketClientEvent
 g_socket_client_new
 g_socket_client_connect
 g_socket_client_connect_async
@@ -1868,6 +1868,7 @@ g_socket_client_get_timeout
 g_socket_client_get_enable_proxy
 g_socket_client_get_tls
 g_socket_client_get_tls_validation_flags
+g_socket_client_add_application_proxy
 <SUBSECTION Standard>
 GSocketClientClass
 G_IS_SOCKET_CLIENT
@@ -1885,6 +1886,11 @@ g_socket_client_get_type
 <FILE>gsocketconnection</FILE>
 <TITLE>GSocketConnection</TITLE>
 GSocketConnection
+g_socket_connection_connect
+g_socket_connection_connect_async
+g_socket_connection_connect_finish
+<SUBSECTION>
+g_socket_connection_is_connected
 g_socket_connection_get_local_address
 g_socket_connection_get_remote_address
 g_socket_connection_get_socket
diff --git a/docs/reference/gio/gio.types b/docs/reference/gio/gio.types
index d547711..ac06893 100644
--- a/docs/reference/gio/gio.types
+++ b/docs/reference/gio/gio.types
@@ -51,7 +51,6 @@ g_memory_output_stream_get_type
 g_menu_attribute_iter_get_type
 g_menu_get_type
 g_menu_link_iter_get_type
-g_menu_model_get_type
 g_mount_get_type
 g_mount_operation_get_type
 g_native_volume_monitor_get_type
diff --git a/docs/reference/glib/building.sgml b/docs/reference/glib/building.sgml
index 55c3d12..750d61a 100644
--- a/docs/reference/glib/building.sgml
+++ b/docs/reference/glib/building.sgml
@@ -291,16 +291,6 @@
         <itemizedlist>
           <listitem>
             <para>
-              <structname>GList</structname>, <structname>GSList</structname>,
-              <structname>GNode</structname>, <structname>GHash</structname>
-              allocations. The functions g_list_push_allocator(),
-              g_list_pop_allocator(), g_slist_push_allocator(),
-              g_slist_pop_allocator(), g_node_push_allocator() and
-              g_node_pop_allocator() are not available
-            </para>
-          </listitem>
-          <listitem>
-            <para>
               <structname>GMemChunk</structname>s become basically non-effective
             </para>
           </listitem>
diff --git a/docs/reference/glib/gtester.xml b/docs/reference/glib/gtester.xml
index dcaae7d..75a1cea 100644
--- a/docs/reference/glib/gtester.xml
+++ b/docs/reference/glib/gtester.xml
@@ -70,7 +70,38 @@ list paths of available test cases
 <varlistentry>
 <term><option>-m=<replaceable>MODE</replaceable></option></term>
 <listitem><para>
-run test cases in <replaceable>MODE</replaceable>, which can be perf, slow, thorough or quick. The default mode is quick.
+    run test cases in <replaceable>MODE</replaceable>, which can be one of:
+
+    <variablelist>
+      <term><option>perf</option></term>
+      <listitem><para>
+          run performance tests
+      </para></listitem>
+
+      <term><option>slow</option>, <option>thorough</option></term>
+      <listitem><para>
+          run slow tests, or repeat non-deterministic tests more often
+      </para></listitem>
+
+      <term><option>quick</option></term>
+      <listitem><para>
+          do not run slow or performance tests, or do extra repeats
+          of non-deterministic tests (default)
+      </para></listitem>
+
+      <term><option>undefined</option></term>
+      <listitem><para>
+          run test cases that deliberately provoke checks or assertion
+          failures, if implemented (default)
+      </para></listitem>
+
+      <term><option>no-undefined</option></term>
+      <listitem><para>
+          do not run test cases that deliberately provoke checks or
+          assertion failures
+      </para></listitem>
+    </variablelist>
+
 </para></listitem>
 </varlistentry>
 
diff --git a/docs/reference/gobject/gobject-sections.txt b/docs/reference/gobject/gobject-sections.txt
index 2ed3cd8..552635e 100644
--- a/docs/reference/gobject/gobject-sections.txt
+++ b/docs/reference/gobject/gobject-sections.txt
@@ -286,6 +286,13 @@ g_object_watch_closure
 g_object_run_dispose
 G_OBJECT_WARN_INVALID_PROPERTY_ID
 
+<SUBSECTION Weak references>
+GWeakRef
+g_weak_ref_init
+g_weak_ref_clear
+g_weak_ref_get
+g_weak_ref_set
+
 <SUBSECTION Standard>
 G_INITIALLY_UNOWNED
 G_INITIALLY_UNOWNED_CLASS
diff --git a/gio/Makefile.am b/gio/Makefile.am
index ef5869e..d237787 100644
--- a/gio/Makefile.am
+++ b/gio/Makefile.am
@@ -124,6 +124,13 @@ settings_sources += \
 	gregistrysettingsbackend.c
 endif
 
+if OS_CARBON
+AM_CPPFLAGS += -DG_OS_CARBON
+
+settings_sources += \
+	gnextstepsettingsbackend.c
+endif
+
 application_headers = \
 	gapplication.h			\
 	gapplicationcommandline.h	\
@@ -447,6 +454,10 @@ libgio_2_0_la_LIBADD = \
 
 libgio_2_0_la_CPPFLAGS = $(ZLIB_CFLAGS) $(AM_CPPFLAGS)
 
+if OS_CARBON
+libgio_2_0_la_CFLAGS = -xobjective-c
+endif
+
 if PLATFORM_WIN32
 no_undefined = -no-undefined
 endif
diff --git a/gio/gaction.c b/gio/gaction.c
index 18318b0..3329830 100644
--- a/gio/gaction.c
+++ b/gio/gaction.c
@@ -94,8 +94,7 @@ g_action_default_init (GActionInterface *iface)
                                                             P_("Action Name"),
                                                             P_("The name used to invoke the action"),
                                                             NULL,
-                                                            G_PARAM_READWRITE |
-							    G_PARAM_CONSTRUCT_ONLY |
+                                                            G_PARAM_READABLE |
                                                             G_PARAM_STATIC_STRINGS));
 
   /**
@@ -111,8 +110,7 @@ g_action_default_init (GActionInterface *iface)
                                                            P_("Parameter Type"),
                                                            P_("The type of GVariant passed to activate()"),
                                                            G_TYPE_VARIANT_TYPE,
-							   G_PARAM_READWRITE |
-							   G_PARAM_CONSTRUCT_ONLY |
+                                                           G_PARAM_READABLE |
                                                            G_PARAM_STATIC_STRINGS));
 
   /**
@@ -130,8 +128,7 @@ g_action_default_init (GActionInterface *iface)
                                                              P_("Enabled"),
                                                              P_("If the action can be activated"),
                                                              TRUE,
-							     G_PARAM_READWRITE |
-							     G_PARAM_CONSTRUCT_ONLY |
+                                                             G_PARAM_READABLE |
                                                              G_PARAM_STATIC_STRINGS));
 
   /**
@@ -163,8 +160,7 @@ g_action_default_init (GActionInterface *iface)
                                                              P_("The state the action is in"),
                                                              G_VARIANT_TYPE_ANY,
                                                              NULL,
-							     G_PARAM_READWRITE |
-							     G_PARAM_CONSTRUCT_ONLY |
+                                                             G_PARAM_READABLE |
                                                              G_PARAM_STATIC_STRINGS));
 }
 
diff --git a/gio/gactiongroupexporter.c b/gio/gactiongroupexporter.c
index 67cfa49..d1e9243 100644
--- a/gio/gactiongroupexporter.c
+++ b/gio/gactiongroupexporter.c
@@ -79,104 +79,14 @@ g_action_group_describe_action (GActionGroup *action_group,
   return g_variant_builder_end (&builder);
 }
 
-/* The org.gtk.Actions interface
- * =============================
- *
- * This interface describes a group of actions.
- *
- * Each action:
- * - has a unique string name
- * - can be activated
- * - optionally has a parameter type that must be given to the activation
- * - has an enabled state that may be true or false
- * - optionally has a state which can change value, but not type
- *
- * Methods
- * -------
- *
- * List :: () → (as)
- *
- *   Lists the names of the actions exported at this object path.
- *
- * Describe :: (s) → (bgav)
- *
- *   Describes a single action, or a given name.
- *
- *   The return value has the following components:
- *   b: specifies if the action is currently enabled. This is
- *      a hint that attempting to interact with the action will
- *      produce no effect.
- *   g: specifies the optional parameter type. If not "",
- *      the string specifies the type of argument that must
- *      be passed to the activation.
- *   av: specifies the optional state. If not empty, the array
- *       contains the current value of the state as a variant
- *
- * DescribeAll :: () → (a{s(bgav)})
- *
- *   Describes all actions in a single round-trip.
- *
- *   The dictionary maps action name strings to their descriptions
- *   (in the format discussed above).
- *
- * Activate :: (sava{sv}) → ()
- *
- *   Requests activation of the named action.
- *
- *   The action is named by the first parameter (s).
- *
- *   If the action activation requires a parameter then this parameter
- *   must be given in the second parameter (av). If there is no parameter
- *   to be specified, the array must be empty.
- *
- *   The final parameter (a{sv}) is a list of "platform data".
- *
- *   This method is not guaranteed to have any particular effect. The
- *   implementation may take some action (including changing the state
- *   of the action, if it is stateful) or it may take none at all. In
- *   particular, callers should expect their request to be completely
- *   ignored when the enabled flag is false (but even this is not
- *   guaranteed).
- *
- * SetState :: (sva{sv}) → ()
- *
- *   Requests the state of an action to be changed to the given value.
- *
- *   The action is named by the first parameter (s).
- *
- *   The requested new state is given in the second parameter (v).
- *   It must be equal in type to the existing state.
- *
- *   The final parameter (a{sv}) is a list of "platform data".
- *
- *   This method is not guaranteed to have any particular effect.
- *   The implementation of an action can choose to ignore the requested
- *   state change, or choose to change its state to something else or
- *   to trigger other side effects. In particular, callers should expect
- *   their request to be completely ignored when the enabled flag is
- *   false (but even this is not guaranteed).
- *
- * Signals
- * -------
- *
- * Changed :: (asa{sb}a{sv}a{s(bgav)})
- *
- *   Signals that some change has occured to the action group.
- *
- *   Four separate types of changes are possible, and the 4 parameters
- *   of the change signal reflect these possibilities:
- *   as: a list of removed actions
- *   a{sb}: a list of actions that had their enabled flag changed
- *   a{sv}: a list of actions that had their state changed
- *   a{s(bgav)}: a list of new actions added in the same format as
- *               the return value of the DescribeAll method
- */
-
 /* Using XML saves us dozens of relocations vs. using the introspection
  * structure types.  We only need to burn cycles and memory if we
  * actually use the exporter -- not in every single app using GIO.
  *
  * It's also a lot easier to read. :)
+ *
+ * For documentation of this interface, see
+ * http://live.gnome.org/GTK+/GApplication-dbus-apis
  */
 const char org_gtk_Actions_xml[] =
   "<node>"
diff --git a/gio/gapplicationimpl-dbus.c b/gio/gapplicationimpl-dbus.c
index aaf3787..d307f2a 100644
--- a/gio/gapplicationimpl-dbus.c
+++ b/gio/gapplicationimpl-dbus.c
@@ -45,6 +45,10 @@ g_dbus_action_group_sync (GDBusActionGroup  *group,
 
 
 /* DBus Interface definition {{{1 */
+
+/* For documentation of these interfaces, see
+ * http://live.gnome.org/GTK+/GApplication-dbus-apis
+ */
 static const gchar org_gtk_Application_xml[] =
   "<node>"
   "  <interface name='org.gtk.Application'>"
diff --git a/gio/gcontenttype.c b/gio/gcontenttype.c
index ce8ab6c..b817f83 100644
--- a/gio/gcontenttype.c
+++ b/gio/gcontenttype.c
@@ -1063,8 +1063,7 @@ enumerate_mimetypes_dir (const char *dir,
  * Gets a list of strings containing all the registered content types
  * known to the system. The list and its data should be freed using
  * <programlisting>
- * g_list_foreach (list, g_free, NULL);
- * g_list_free (list);
+ * g_list_free_full (list, g_free);
  * </programlisting>
  *
  * Returns: (element-type utf8) (transfer full): #GList of the registered content types
@@ -1130,8 +1129,7 @@ typedef struct
 static void
 tree_matchlet_free (TreeMatchlet *matchlet)
 {
-  g_list_foreach (matchlet->matches, (GFunc)tree_matchlet_free, NULL);
-  g_list_free (matchlet->matches);
+  g_list_free_full (matchlet->matches, (GDestroyNotify) tree_matchlet_free);
   g_free (matchlet->path);
   g_free (matchlet->mimetype);
   g_slice_free (TreeMatchlet, matchlet);
@@ -1140,8 +1138,7 @@ tree_matchlet_free (TreeMatchlet *matchlet)
 static void
 tree_match_free (TreeMatch *match)
 {
-  g_list_foreach (match->matches, (GFunc)tree_matchlet_free, NULL);
-  g_list_free (match->matches);
+  g_list_free_full (match->matches, (GDestroyNotify) tree_matchlet_free);
   g_free (match->contenttype);
   g_slice_free (TreeMatch, match);
 }
@@ -1330,8 +1327,7 @@ xdg_mime_reload (void *user_data)
 static void
 tree_magic_shutdown (void)
 {
-  g_list_foreach (tree_matches, (GFunc)tree_match_free, NULL);
-  g_list_free (tree_matches);
+  g_list_free_full (tree_matches, (GDestroyNotify) tree_match_free);
   tree_matches = NULL;
 }
 
diff --git a/gio/gdbus-2.0/codegen/codegen.py b/gio/gdbus-2.0/codegen/codegen.py
index af142e8..958a935 100644
--- a/gio/gdbus-2.0/codegen/codegen.py
+++ b/gio/gdbus-2.0/codegen/codegen.py
@@ -2330,8 +2330,7 @@ class CodeGenerator:
                          '    }\n'
                          %(i.name, s.name))
             self.c.write('  g_variant_unref (signal_variant);\n')
-            self.c.write('  g_list_foreach (connections, (GFunc)g_object_unref, NULL);\n')
-            self.c.write('  g_list_free (connections);\n')
+            self.c.write('  g_list_free_full (connections, g_object_unref);\n')
             self.c.write('}\n'
                          '\n')
 
@@ -2348,8 +2347,7 @@ class CodeGenerator:
         self.c.write('  %sSkeleton *skeleton = %s%s_SKELETON (object);\n'%(i.camel_name, i.ns_upper, i.name_upper))
         if len(i.properties) > 0:
             self.c.write('  g_value_array_free (skeleton->priv->properties);\n')
-        self.c.write('  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);\n')
-        self.c.write('  g_list_free (skeleton->priv->changed_properties);\n')
+        self.c.write('  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);\n')
         self.c.write('  if (skeleton->priv->changed_properties_idle_source != NULL)\n')
         self.c.write('    g_source_destroy (skeleton->priv->changed_properties_idle_source);\n')
         self.c.write('  g_main_context_unref (skeleton->priv->context);\n')
@@ -2435,8 +2433,7 @@ class CodeGenerator:
                          '                                         NULL);\n'
                          '        }\n'
                          '      g_variant_unref (signal_variant);\n'
-                         '      g_list_foreach (connections, (GFunc)g_object_unref, NULL);\n'
-                         '      g_list_free (connections);\n'
+                         '      g_list_free_full (connections, g_object_unref);\n'
                          '    }\n'
                          '  else\n'
                          '    {\n'
@@ -2444,8 +2441,7 @@ class CodeGenerator:
                          '      g_variant_builder_clear (&invalidated_builder);\n'
                          '    }\n'
                          %(i.name))
-            self.c.write('  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);\n')
-            self.c.write('  g_list_free (skeleton->priv->changed_properties);\n')
+            self.c.write('  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);\n')
             self.c.write('  skeleton->priv->changed_properties = NULL;\n')
             self.c.write('  skeleton->priv->changed_properties_idle_source = NULL;\n')
             self.c.write('  g_mutex_unlock (&skeleton->priv->lock);\n')
diff --git a/gio/gdbusauth.c b/gio/gdbusauth.c
index 7033f29..768635b 100644
--- a/gio/gdbusauth.c
+++ b/gio/gdbusauth.c
@@ -115,8 +115,7 @@ _g_dbus_auth_finalize (GObject *object)
 
   if (auth->priv->stream != NULL)
     g_object_unref (auth->priv->stream);
-  g_list_foreach (auth->priv->available_mechanisms, (GFunc) mechanism_free, NULL);
-  g_list_free (auth->priv->available_mechanisms);
+  g_list_free_full (auth->priv->available_mechanisms, (GDestroyNotify) mechanism_free);
 
   if (G_OBJECT_CLASS (_g_dbus_auth_parent_class)->finalize != NULL)
     G_OBJECT_CLASS (_g_dbus_auth_parent_class)->finalize (object);
diff --git a/gio/gdbusconnection.c b/gio/gdbusconnection.c
index 36d7bfa..849d287 100644
--- a/gio/gdbusconnection.c
+++ b/gio/gdbusconnection.c
@@ -208,8 +208,8 @@ struct _GDBusConnectionClass
 
 G_LOCK_DEFINE_STATIC (message_bus_lock);
 
-static GDBusConnection *the_session_bus = NULL;
-static GDBusConnection *the_system_bus = NULL;
+static GWeakRef the_session_bus;
+static GWeakRef the_system_bus;
 
 /* Extra pseudo-member of GDBusSendMessageFlags.
  * Set by initable_init() to indicate that despite not being initialized yet,
@@ -606,14 +606,6 @@ g_dbus_connection_dispose (GObject *object)
   GDBusConnection *connection = G_DBUS_CONNECTION (object);
 
   G_LOCK (message_bus_lock);
-  if (connection == the_session_bus)
-    {
-      the_session_bus = NULL;
-    }
-  else if (connection == the_system_bus)
-    {
-      the_system_bus = NULL;
-    }
   CONNECTION_LOCK (connection);
   if (connection->worker != NULL)
     {
@@ -6652,11 +6644,11 @@ distribute_method_call (GDBusConnection *connection,
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* Called in any user thread, with the message_bus_lock held. */
-static GDBusConnection **
+static GWeakRef *
 message_bus_get_singleton (GBusType   bus_type,
                            GError   **error)
 {
-  GDBusConnection **ret;
+  GWeakRef *ret;
   const gchar *starter_bus;
 
   ret = NULL;
@@ -6720,7 +6712,7 @@ get_uninitialized_connection (GBusType       bus_type,
                               GCancellable  *cancellable,
                               GError       **error)
 {
-  GDBusConnection **singleton;
+  GWeakRef *singleton;
   GDBusConnection *ret;
 
   ret = NULL;
@@ -6730,24 +6722,24 @@ get_uninitialized_connection (GBusType       bus_type,
   if (singleton == NULL)
     goto out;
 
-  if (*singleton == NULL)
+  ret = g_weak_ref_get (singleton);
+
+  if (ret == NULL)
     {
       gchar *address;
       address = g_dbus_address_get_for_bus_sync (bus_type, cancellable, error);
       if (address == NULL)
         goto out;
-      ret = *singleton = g_object_new (G_TYPE_DBUS_CONNECTION,
-                                       "address", address,
-                                       "flags", G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT |
-                                                G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,
-                                       "exit-on-close", TRUE,
-                                       NULL);
+      ret = g_object_new (G_TYPE_DBUS_CONNECTION,
+                          "address", address,
+                          "flags", G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT |
+                                   G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,
+                          "exit-on-close", TRUE,
+                          NULL);
+
+      g_weak_ref_set (singleton, ret);
       g_free (address);
     }
-  else
-    {
-      ret = g_object_ref (*singleton);
-    }
 
   g_assert (ret != NULL);
 
diff --git a/gio/gdbusobjectmanagerclient.c b/gio/gdbusobjectmanagerclient.c
index e6f18bf..aeff7e4 100644
--- a/gio/gdbusobjectmanagerclient.c
+++ b/gio/gdbusobjectmanagerclient.c
@@ -1252,8 +1252,7 @@ on_notify_g_name_owner (GObject    *object,
           GDBusObjectProxy *object_proxy = G_DBUS_OBJECT_PROXY (l->data);
           g_signal_emit_by_name (manager, "object-removed", object_proxy);
         }
-      g_list_foreach (proxies, (GFunc) g_object_unref, NULL);
-      g_list_free (proxies);
+      g_list_free_full (proxies, g_object_unref);
 
       /* nuke local filter */
       maybe_unsubscribe_signals (manager);
@@ -1573,8 +1572,7 @@ remove_interfaces (GDBusObjectManagerClient   *manager,
 
   interfaces = g_dbus_object_get_interfaces (G_DBUS_OBJECT (op));
   num_interfaces = g_list_length (interfaces);
-  g_list_foreach (interfaces, (GFunc) g_object_unref, NULL);
-  g_list_free (interfaces);
+  g_list_free_full (interfaces, g_object_unref);
 
   num_interfaces_to_remove = g_strv_length ((gchar **) interface_names);
 
diff --git a/gio/gdbusobjectmanagerserver.c b/gio/gdbusobjectmanagerserver.c
index c9a2673..cc436f8 100644
--- a/gio/gdbusobjectmanagerserver.c
+++ b/gio/gdbusobjectmanagerserver.c
@@ -497,8 +497,7 @@ g_dbus_object_manager_server_export_unlocked (GDBusObjectManagerServer  *manager
       registration_data_export_interface (data, interface_skeleton, object_path);
       g_ptr_array_add (interface_names, g_dbus_interface_skeleton_get_info (interface_skeleton)->name);
     }
-  g_list_foreach (existing_interfaces, (GFunc) g_object_unref, NULL);
-  g_list_free (existing_interfaces);
+  g_list_free_full (existing_interfaces, g_object_unref);
   g_ptr_array_add (interface_names, NULL);
 
   data->exported = TRUE;
diff --git a/gio/gdbusobjectskeleton.c b/gio/gdbusobjectskeleton.c
index 1f9deaf..28881e6 100644
--- a/gio/gdbusobjectskeleton.c
+++ b/gio/gdbusobjectskeleton.c
@@ -484,8 +484,7 @@ g_dbus_object_skeleton_flush (GDBusObjectSkeleton *object)
   for (l = to_flush; l != NULL; l = l->next)
     g_dbus_interface_skeleton_flush (G_DBUS_INTERFACE_SKELETON (l->data));
 
-  g_list_foreach (to_flush, (GFunc) g_object_unref, NULL);
-  g_list_free (to_flush);
+  g_list_free_full (to_flush, g_object_unref);
 }
 
 static void
diff --git a/gio/gdbusserver.c b/gio/gdbusserver.c
index 3fd383f..15b0856 100644
--- a/gio/gdbusserver.c
+++ b/gio/gdbusserver.c
@@ -891,8 +891,7 @@ try_tcp (GDBusServer  *server,
   ret = TRUE;
 
  out:
-  g_list_foreach (resolved_addresses, (GFunc) g_object_unref, NULL);
-  g_list_free (resolved_addresses);
+  g_list_free_full (resolved_addresses, g_object_unref);
   g_object_unref (resolver);
   return ret;
 }
diff --git a/gio/gdesktopappinfo.c b/gio/gdesktopappinfo.c
index 1d831ef..453ff69 100644
--- a/gio/gdesktopappinfo.c
+++ b/gio/gdesktopappinfo.c
@@ -1292,6 +1292,10 @@ _g_desktop_app_info_launch_uris_internal (GAppInfo                   *appinfo,
                                    TRUE);
           data.pid_envvar = (char *)g_environ_getenv (envp, "GIO_LAUNCHED_DESKTOP_FILE_PID");
         }
+      else
+        {
+          data.pid_envvar = NULL;
+        }
 
       display = NULL;
       sn_id = NULL;
@@ -1312,8 +1316,7 @@ _g_desktop_app_info_launch_uris_internal (GAppInfo                   *appinfo,
               envp = g_environ_setenv (envp, "DESKTOP_STARTUP_ID", sn_id, TRUE);
             }
 
-          g_list_foreach (launched_files, (GFunc)g_object_unref, NULL);
-          g_list_free (launched_files);
+          g_list_free_full (launched_files, g_object_unref);
         }
 
       if (!g_spawn_async (info->path,
@@ -1431,8 +1434,7 @@ g_desktop_app_info_launch (GAppInfo           *appinfo,
   
   res = g_desktop_app_info_launch_uris (appinfo, uris, launch_context, error);
   
-  g_list_foreach  (uris, (GFunc)g_free, NULL);
-  g_list_free (uris);
+  g_list_free_full (uris, g_free);
   
   return res;
 }
@@ -2628,8 +2630,7 @@ destroy_info_cache_value (gpointer  key,
                           GList    *value, 
                           gpointer  data)
 {
-  g_list_foreach (value, (GFunc)g_free, NULL);
-  g_list_free (value);
+  g_list_free_full (value, g_free);
 }
 
 static void
@@ -3147,10 +3148,7 @@ mime_info_cache_free (MimeInfoCache *cache)
   if (cache == NULL)
     return;
   
-  g_list_foreach (cache->dirs,
-		  (GFunc) mime_info_cache_dir_free,
-		  NULL);
-  g_list_free (cache->dirs);
+  g_list_free_full (cache->dirs, (GDestroyNotify) mime_info_cache_dir_free);
   g_hash_table_destroy (cache->global_defaults_cache);
   g_free (cache);
 }
@@ -3345,8 +3343,7 @@ get_all_desktop_entries_for_mime_type (const char  *base_mime_type,
   else
     g_free (default_entry);
 
-  g_list_foreach (removed_entries, (GFunc)g_free, NULL);
-  g_list_free (removed_entries);
+  g_list_free_full (removed_entries, g_free);
 
   desktop_entries = g_list_reverse (desktop_entries);
   
diff --git a/gio/gemblemedicon.c b/gio/gemblemedicon.c
index 6f7af0e..b02ec44 100644
--- a/gio/gemblemedicon.c
+++ b/gio/gemblemedicon.c
@@ -73,8 +73,7 @@ g_emblemed_icon_finalize (GObject *object)
   emblemed = G_EMBLEMED_ICON (object);
 
   g_object_unref (emblemed->priv->icon);
-  g_list_foreach (emblemed->priv->emblems, (GFunc) g_object_unref, NULL);
-  g_list_free (emblemed->priv->emblems);
+  g_list_free_full (emblemed->priv->emblems, g_object_unref);
 
   (*G_OBJECT_CLASS (g_emblemed_icon_parent_class)->finalize) (object);
 }
diff --git a/gio/gfileenumerator.c b/gio/gfileenumerator.c
index ef9d56a..654c691 100644
--- a/gio/gfileenumerator.c
+++ b/gio/gfileenumerator.c
@@ -607,8 +607,7 @@ static void
 next_async_op_free (NextAsyncOp *op)
 {
   /* Free the list, if finish wasn't called */
-  g_list_foreach (op->files, (GFunc)g_object_unref, NULL);
-  g_list_free (op->files);
+  g_list_free_full (op->files, g_object_unref);
   
   g_free (op);
 }
diff --git a/gio/gfilemonitor.c b/gio/gfilemonitor.c
index 6bad280..27b800a 100644
--- a/gio/gfilemonitor.c
+++ b/gio/gfilemonitor.c
@@ -195,8 +195,7 @@ g_file_monitor_dispose (GObject *object)
       g_source_unref (priv->pending_file_change_source);
       priv->pending_file_change_source = NULL;
     }
-  g_slist_foreach (priv->pending_file_changes, (GFunc) file_change_free, NULL);
-  g_slist_free (priv->pending_file_changes);
+  g_slist_free_full (priv->pending_file_changes, (GDestroyNotify) file_change_free);
   priv->pending_file_changes = NULL;
 
   /* Make sure we cancel on last unref */
diff --git a/gio/gfilenamecompleter.c b/gio/gfilenamecompleter.c
index fc9afeb..f841c16 100644
--- a/gio/gfilenamecompleter.c
+++ b/gio/gfilenamecompleter.c
@@ -86,8 +86,7 @@ g_filename_completer_finalize (GObject *object)
   if (completer->basenames_dir)
     g_object_unref (completer->basenames_dir);
 
-  g_list_foreach (completer->basenames, (GFunc)g_free, NULL);
-  g_list_free (completer->basenames);
+  g_list_free_full (completer->basenames, g_free);
 
   G_OBJECT_CLASS (g_filename_completer_parent_class)->finalize (object);
 }
@@ -155,8 +154,7 @@ load_basenames_data_free (LoadBasenamesData *data)
   g_object_unref (data->cancellable);
   g_object_unref (data->dir);
   
-  g_list_foreach (data->basenames, (GFunc)g_free, NULL);
-  g_list_free (data->basenames);
+  g_list_free_full (data->basenames, g_free);
   
   g_free (data);
 }
@@ -243,8 +241,7 @@ got_more_files (GObject *source_object,
       
       if (data->completer->basenames_dir)
 	g_object_unref (data->completer->basenames_dir);
-      g_list_foreach (data->completer->basenames, (GFunc)g_free, NULL);
-      g_list_free (data->completer->basenames);
+      g_list_free_full (data->completer->basenames, g_free);
       
       data->completer->basenames_dir = g_object_ref (data->dir);
       data->completer->basenames = data->basenames;
@@ -281,8 +278,7 @@ got_enum (GObject *source_object,
 
       if (data->completer->basenames_dir)
 	g_object_unref (data->completer->basenames_dir);
-      g_list_foreach (data->completer->basenames, (GFunc)g_free, NULL);
-      g_list_free (data->completer->basenames);
+      g_list_free_full (data->completer->basenames, g_free);
 
       /* Mark uptodate with no basenames */
       data->completer->basenames_dir = g_object_ref (data->dir);
diff --git a/gio/ginetaddressmask.c b/gio/ginetaddressmask.c
index 5794a56..560f47c 100644
--- a/gio/ginetaddressmask.c
+++ b/gio/ginetaddressmask.c
@@ -124,6 +124,16 @@ g_inet_address_mask_get_property (GObject    *object,
 }
 
 static void
+g_inet_address_mask_dispose (GObject *object)
+{
+  GInetAddressMask *mask = G_INET_ADDRESS_MASK (object);
+
+  g_clear_object (&mask->priv->addr);
+
+  G_OBJECT_CLASS (g_inet_address_mask_parent_class)->dispose (object);
+}
+
+static void
 g_inet_address_mask_class_init (GInetAddressMaskClass *klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
@@ -132,6 +142,7 @@ g_inet_address_mask_class_init (GInetAddressMaskClass *klass)
 
   gobject_class->set_property = g_inet_address_mask_set_property;
   gobject_class->get_property = g_inet_address_mask_get_property;
+  gobject_class->dispose = g_inet_address_mask_dispose;
 
   g_object_class_install_property (gobject_class, PROP_FAMILY,
                                    g_param_spec_enum ("family",
diff --git a/gio/gio.symbols b/gio/gio.symbols
index 3ea45b7..e91be95 100644
--- a/gio/gio.symbols
+++ b/gio/gio.symbols
@@ -998,6 +998,7 @@ g_socket_client_connect_to_service_finish
 g_socket_client_connect_to_uri
 g_socket_client_connect_to_uri_async
 g_socket_client_connect_to_uri_finish
+g_socket_client_event_get_type
 g_socket_client_get_enable_proxy
 g_socket_client_get_family
 g_socket_client_get_local_address
@@ -1022,6 +1023,10 @@ g_socket_connection_factory_register_type
 g_socket_connection_get_local_address
 g_socket_connection_get_remote_address
 g_socket_connection_get_socket
+g_socket_connection_is_connected
+g_socket_connection_connect
+g_socket_connection_connect_async
+g_socket_connection_connect_finish
 g_socket_listener_get_type
 g_socket_listener_accept
 g_socket_listener_accept_async
diff --git a/gio/gioenums.h b/gio/gioenums.h
index 47d72bd..122eb7e 100644
--- a/gio/gioenums.h
+++ b/gio/gioenums.h
@@ -1517,6 +1517,44 @@ typedef enum {
   G_IO_MODULE_SCOPE_BLOCK_DUPLICATES
 } GIOModuleScopeFlags;
 
+/**
+ * GSocketClientEvent:
+ * @G_SOCKET_CLIENT_RESOLVING: The client is doing a DNS lookup.
+ * @G_SOCKET_CLIENT_RESOLVED: The client has completed a DNS lookup.
+ * @G_SOCKET_CLIENT_CONNECTING: The client is connecting to a remote
+ *   host (either a proxy or the destination server).
+ * @G_SOCKET_CLIENT_CONNECTED: The client has connected to a remote
+ *   host.
+ * @G_SOCKET_CLIENT_PROXY_NEGOTIATING: The client is negotiating
+ *   with a proxy to connect to the destination server.
+ * @G_SOCKET_CLIENT_PROXY_NEGOTIATED: The client has negotiated
+ *   with the proxy server.
+ * @G_SOCKET_CLIENT_TLS_HANDSHAKING: The client is performing a
+ *   TLS handshake.
+ * @G_SOCKET_CLIENT_TLS_HANDSHAKED: The client has performed a
+ *   TLS handshake.
+ * @G_SOCKET_CLIENT_COMPLETE: The client is done with a particular
+ *   #GSocketConnectable.
+ *
+ * Describes an event occurring on a #GSocketClient. See the
+ * #GSocketClient::event signal for more details.
+ *
+ * Additional values may be added to this type in the future.
+ *
+ * Since: 2.32
+ */
+typedef enum {
+  G_SOCKET_CLIENT_RESOLVING,
+  G_SOCKET_CLIENT_RESOLVED,
+  G_SOCKET_CLIENT_CONNECTING,
+  G_SOCKET_CLIENT_CONNECTED,
+  G_SOCKET_CLIENT_PROXY_NEGOTIATING,
+  G_SOCKET_CLIENT_PROXY_NEGOTIATED,
+  G_SOCKET_CLIENT_TLS_HANDSHAKING,
+  G_SOCKET_CLIENT_TLS_HANDSHAKED,
+  G_SOCKET_CLIENT_COMPLETE
+} GSocketClientEvent;
+
 G_END_DECLS
 
 #endif /* __GIO_ENUMS_H__ */
diff --git a/gio/giomodule.c b/gio/giomodule.c
index efd8388..c7b16f8 100644
--- a/gio/giomodule.c
+++ b/gio/giomodule.c
@@ -916,6 +916,9 @@ _g_io_modules_ensure_loaded (void)
       g_win32_directory_monitor_get_type ();
       g_registry_backend_get_type ();
 #endif
+#ifdef G_OS_CARBON
+      g_nextstep_settings_backend_get_type ();
+#endif
 #ifdef G_OS_UNIX
       _g_unix_volume_monitor_get_type ();
 #endif
diff --git a/gio/gmemoryinputstream.c b/gio/gmemoryinputstream.c
index 2a57dbd..f990c7b 100644
--- a/gio/gmemoryinputstream.c
+++ b/gio/gmemoryinputstream.c
@@ -160,8 +160,7 @@ g_memory_input_stream_finalize (GObject *object)
   stream = G_MEMORY_INPUT_STREAM (object);
   priv = stream->priv;
 
-  g_slist_foreach (priv->chunks, free_chunk, NULL);
-  g_slist_free (priv->chunks);
+  g_slist_free_full (priv->chunks, free_chunk);
 
   G_OBJECT_CLASS (g_memory_input_stream_parent_class)->finalize (object);
 }
diff --git a/gio/gmenu.c b/gio/gmenu.c
index d012595..0873d39 100644
--- a/gio/gmenu.c
+++ b/gio/gmenu.c
@@ -324,7 +324,7 @@ g_menu_append (GMenu       *menu,
  * @section: a #GMenuModel with the items of the section
  *
  * Convenience function for inserting a section menu item into @menu.
- * Combine g_menu_new_section() and g_menu_insert_item() for a more
+ * Combine g_menu_item_new_section() and g_menu_insert_item() for a more
  * flexible alternative.
  *
  * Since: 2.32
@@ -350,7 +350,7 @@ g_menu_insert_section (GMenu       *menu,
  * @section: a #GMenuModel with the items of the section
  *
  * Convenience function for prepending a section menu item to the start
- * of @menu.  Combine g_menu_new_section() and g_menu_insert_item() for
+ * of @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for
  * a more flexible alternative.
  *
  * Since: 2.32
@@ -370,7 +370,7 @@ g_menu_prepend_section (GMenu       *menu,
  * @section: a #GMenuModel with the items of the section
  *
  * Convenience function for appending a section menu item to the end of
- * @menu.  Combine g_menu_new_section() and g_menu_insert_item() for a
+ * @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for a
  * more flexible alternative.
  *
  * Since: 2.32
diff --git a/gio/gmenuexporter.c b/gio/gmenuexporter.c
index 4fab789..e57ad47 100644
--- a/gio/gmenuexporter.c
+++ b/gio/gmenuexporter.c
@@ -42,104 +42,8 @@
 
 /* {{{1 D-Bus Interface description */
 
-/* The org.gtk.Menus interface
- * ===========================
- *
- * The interface is primarily concerned with three things:
- *
- * - communicating menus to the client
- * - establishing links between menus and other menus
- * - notifying clients of changes
- *
- * As a basic principle, it is recognised that the menu structure
- * of an application is often large. It is also recognised that some
- * menus are liable to frequently change without the user ever having
- * opened the menu. For both of these reasons, the individual menus are
- * arranged into subscription groups. Each subscription group is specified
- * by an unsigned integer. The assignment of integers need not be consecutive.
- *
- * Within a subscription group there are multiple menus. Each menu is
- * identified with an unsigned integer, unique to its subscription group.
- *
- * By convention, the primary menu is numbered 0 without subscription group 0.
- *
- * Actionable menu items (ie: those that produce some effect in the
- * application when they are activated) have a related action, specified by
- * a string. This string specifies the name of the action, according to the
- * org.gtk.Actions interface, at the same object path as the menu.
- *
- * Methods
- * -------
- *
- * Start :: (au) → (a(uuaa{sv}))
- *
- *   The Start method is used to indicate that a client is interested in
- *   tracking and displaying the content of the menus of a particular list
- *   of subscription groups.
- *
- *   Most typically, the client will request subscription group 0 to start.
- *
- *   The call has two effects. First, it replies with all menus defined
- *   within the requested subscription groups. The format of the reply is
- *   an array of tuples, where the items in each tuple are:
- *   - the subscription group of the menu
- *   - the number of the menu within that group
- *   - an array of menu items
- *
- *   Each menu item is a dictionary of attributes (a{sv}).
- *
- *   Secondly, this call has a side effect: it atomically requests that
- *   the Changed signal start to be emitted for the requested subscription
- *   group. Each group has a subscription count and only signals changes
- *   on itself when this count is greater than zero.
- *
- *   If a group is specified multiple times then the result is that the
- *   contents of that group is only returned once, but the subscription
- *   count is increased multiple times.
- *
- *   If a client disconnects from the bus while holding subscriptions then
- *   its subscriptions will be cancelled. This prevents "leaking" subscriptions
- *   in the case of crashes and is also useful for applications that want
- *   to exit without manually cleaning up.
- *
- * End :: (au)
- *
- *   The End method reverses the previous effects of a call to Start.
- *
- *   When clients are no longer interested in the contents of a subscription
- *   group, they should call the End method.
- *
- *   The parameter lists the subscription groups. A subscription group
- *   needs to be cancelled the same number of times as it was requested.
- *   For this reason, it might make sense to specify the same subscription
- *   group multiple times (if multiple Start calls were made for this group).
- *
- * Signals
- * -------
- *
- * Changed :: (a(uuuuaa{sv}))
- *
- *   The changed signal indicates changes to a particular menu.
- *
- *   The changes come as an array of tuples where the items in each tuple are:
- *   - the subscription group of the menu
- *   - the number of the menu within that group
- *   - the position in the menu at which to make the change
- *   - the number of items to delete from that position
- *   - a list of new items to insert at that position
- *
- *   Each new menu item is a dictionary of attributes (a{sv}).
- *
- * Attributes
- * ----------
- *
- * label (string): the label to display
- * action (string): the name of the action
- * target (variant): the parameter to pass when activating the action
- * :section ((uu)): the menu to use to populate that section, specified
- *     as a pair of subscription group and menu within that group
- * :submenu ((uu)): the menu to use as a submenu, specified
- *     as a pair of subscription group and menu within that group
+/* For documentation of this interface, see
+ * http://live.gnome.org/GTK+/GApplication-dbus-apis
  */
 
 static GDBusInterfaceInfo *
diff --git a/gio/gmenumarkup.c b/gio/gmenumarkup.c
index c0df3b6..4cdd985 100644
--- a/gio/gmenumarkup.c
+++ b/gio/gmenumarkup.c
@@ -118,6 +118,25 @@ add_string_attributes (GMenuItem    *item,
     }
 }
 
+static gboolean
+find_id_attribute (const gchar **names,
+                   const gchar **values,
+                   const gchar **id)
+{
+  gint i;
+
+  for (i = 0; names[i]; i++)
+    {
+      if (strcmp (names[i], "id") == 0)
+        {
+          *id = values[i];
+          return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
 static void
 g_menu_markup_start_element (GMarkupParseContext  *context,
                              const gchar          *element_name,
@@ -133,10 +152,8 @@ g_menu_markup_start_element (GMarkupParseContext  *context,
                                attribute_names, attribute_values, error,     \
                                first, __VA_ARGS__, G_MARKUP_COLLECT_INVALID)
 #define OPTIONAL   G_MARKUP_COLLECT_OPTIONAL
-#define STRDUP     G_MARKUP_COLLECT_STRDUP
 #define BOOLEAN    G_MARKUP_COLLECT_BOOLEAN
 #define STRING     G_MARKUP_COLLECT_STRING
-#define NO_ATTRS() COLLECT (G_MARKUP_COLLECT_INVALID, NULL)
 
   if (!(state->frame.menu || state->frame.item || state->string))
     {
@@ -176,11 +193,20 @@ g_menu_markup_start_element (GMarkupParseContext  *context,
         {
           GMenuItem *item;
           GMenu *menu;
+          gchar *id;
 
           menu = g_menu_new ();
           item = g_menu_item_new_submenu (NULL, G_MENU_MODEL (menu));
           add_string_attributes (item, attribute_names, attribute_values);
           g_menu_markup_push_frame (state, menu, item);
+
+          if (find_id_attribute (attribute_names, attribute_values, &id))
+            {
+              if (state->objects)
+                g_hash_table_insert (state->objects, g_strdup (id), g_object_ref (menu));
+            }
+          g_object_unref (menu);
+
           return;
         }
 
@@ -188,11 +214,20 @@ g_menu_markup_start_element (GMarkupParseContext  *context,
         {
           GMenuItem *item;
           GMenu *menu;
+          gchar *id;
 
           menu = g_menu_new ();
           item = g_menu_item_new_section (NULL, G_MENU_MODEL (menu));
           add_string_attributes (item, attribute_names, attribute_values);
           g_menu_markup_push_frame (state, menu, item);
+
+          if (find_id_attribute (attribute_names, attribute_values, &id))
+            {
+              if (state->objects)
+                g_hash_table_insert (state->objects, g_strdup (id), g_object_ref (menu));
+            }
+          g_object_unref (menu);
+
           return;
         }
     }
@@ -247,6 +282,7 @@ g_menu_markup_start_element (GMarkupParseContext  *context,
 
               if (id != NULL && state->objects)
                 g_hash_table_insert (state->objects, g_strdup (id), g_object_ref (menu));
+              g_object_unref (menu);
             }
 
           return;
@@ -402,9 +438,12 @@ static GMarkupParser g_menu_subparser =
  *
  * If @objects is specified then it must be a #GHashTable that was
  * created using g_hash_table_new_full() with g_str_hash(),
- * g_str_equal(), g_free() and g_object_unref().  Any named menus (ie:
- * those with an id='' attribute) that are encountered while parsing
- * will be added to this table.  Each toplevel menu must be named.
+ * g_str_equal(), g_free() and g_object_unref().
+ * Any named menus (ie: <tag class="starttag">menu</tag>,
+ * <tag class="starttag">submenu</tag>,
+ * <tag class="starttag">section</tag> or <tag class="starttag">link</tag>
+ * elements with an id='' attribute) that are encountered while parsing
+ * will be added to this table. Each toplevel menu must be named.
  *
  * If @objects is %NULL then an empty hash table will be created.
  *
@@ -485,9 +524,13 @@ g_menu_markup_parser_end (GMarkupParseContext *context)
  *
  * If @objects is specified then it must be a #GHashTable that was
  * created using g_hash_table_new_full() with g_str_hash(),
- * g_str_equal(), g_free() and g_object_unref().  Any named menus (ie:
- * those with an * id='' attribute) that are encountered while parsing
+ * g_str_equal(), g_free() and g_object_unref().
+ * Any named menus (ie: <tag class="starttag">submenu</tag>,
+ * <tag class="starttag">section</tag> or <tag class="starttag">link</tag>
+ * elements with an id='' attribute) that are encountered while parsing
  * will be added to this table.
+ * Note that toplevel <tag class="starttag">menu</tag> is not added to
+ * the hash table, even if it has an id attribute.
  *
  * If @objects is %NULL then named menus will not be supported.
  *
diff --git a/gio/gnetworkmonitornetlink.c b/gio/gnetworkmonitornetlink.c
index ecdc0d4..7fac1bc 100644
--- a/gio/gnetworkmonitornetlink.c
+++ b/gio/gnetworkmonitornetlink.c
@@ -296,7 +296,7 @@ read_netlink_messages (GSocket      *socket,
 {
   GNetworkMonitorNetlink *nl = user_data;
   GInputVector iv;
-  gsize len;
+  gssize len;
   GSocketControlMessage **cmsgs = NULL;
   gint num_cmsgs = 0, i, flags;
   GError *error = NULL;
diff --git a/gio/gnextstepsettingsbackend.c b/gio/gnextstepsettingsbackend.c
new file mode 100644
index 0000000..3f609dd
--- /dev/null
+++ b/gio/gnextstepsettingsbackend.c
@@ -0,0 +1,468 @@
+/*
+ * Copyright © 2011 William Hua
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the licence, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Author: William Hua <william@attente.ca>
+ */
+
+#include "gsettingsbackendinternal.h"
+#include "gsimplepermission.h"
+#include "giomodule.h"
+
+#import <Foundation/Foundation.h>
+
+#define G_NEXTSTEP_SETTINGS_BACKEND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), g_nextstep_settings_backend_get_type (), GNextstepSettingsBackend))
+
+typedef struct _GNextstepSettingsBackend GNextstepSettingsBackend;
+typedef GSettingsBackendClass            GNextstepSettingsBackendClass;
+
+struct _GNextstepSettingsBackend
+{
+  GSettingsBackend  parent_instance;
+
+  /*< private >*/
+  NSUserDefaults   *user_defaults;
+  GMutex            mutex;
+};
+
+G_DEFINE_TYPE_WITH_CODE (GNextstepSettingsBackend,
+                         g_nextstep_settings_backend,
+                         G_TYPE_SETTINGS_BACKEND,
+                         g_io_extension_point_implement (G_SETTINGS_BACKEND_EXTENSION_POINT_NAME,
+                                                         g_define_type_id, "nextstep", 90));
+
+static void          g_nextstep_settings_backend_finalize       (GObject            *backend);
+
+static GVariant *    g_nextstep_settings_backend_read           (GSettingsBackend   *backend,
+                                                                 const gchar        *key,
+                                                                 const GVariantType *expected_type,
+                                                                 gboolean            default_value);
+
+static gboolean      g_nextstep_settings_backend_get_writable   (GSettingsBackend   *backend,
+                                                                 const gchar        *key);
+
+static gboolean      g_nextstep_settings_backend_write          (GSettingsBackend   *backend,
+                                                                 const gchar        *key,
+                                                                 GVariant           *value,
+                                                                 gpointer            origin_tag);
+
+static gboolean      g_nextstep_settings_backend_write_tree     (GSettingsBackend   *backend,
+                                                                 GTree              *tree,
+                                                                 gpointer            origin_tag);
+
+static void          g_nextstep_settings_backend_reset          (GSettingsBackend   *backend,
+                                                                 const gchar        *key,
+                                                                 gpointer            origin_tag);
+
+static void          g_nextstep_settings_backend_subscribe      (GSettingsBackend   *backend,
+                                                                 const gchar        *name);
+
+static void          g_nextstep_settings_backend_unsubscribe    (GSettingsBackend   *backend,
+                                                                 const gchar        *name);
+
+static void          g_nextstep_settings_backend_sync           (GSettingsBackend   *backend);
+
+static GPermission * g_nextstep_settings_backend_get_permission (GSettingsBackend   *backend,
+                                                                 const gchar        *path);
+
+static gboolean      g_nextstep_settings_backend_write_pair     (gpointer            name,
+                                                                 gpointer            value,
+                                                                 gpointer            data);
+
+static GVariant *    g_nextstep_settings_backend_get_g_variant  (id                  object,
+                                                                 const GVariantType *type);
+
+static id            g_nextstep_settings_backend_get_ns_object  (GVariant           *variant);
+
+static void
+g_nextstep_settings_backend_class_init (GNextstepSettingsBackendClass *class)
+{
+  G_OBJECT_CLASS (class)->finalize = g_nextstep_settings_backend_finalize;
+  class->read = g_nextstep_settings_backend_read;
+  class->get_writable = g_nextstep_settings_backend_get_writable;
+  class->write = g_nextstep_settings_backend_write;
+  class->write_tree = g_nextstep_settings_backend_write_tree;
+  class->reset = g_nextstep_settings_backend_reset;
+  class->subscribe = g_nextstep_settings_backend_subscribe;
+  class->unsubscribe = g_nextstep_settings_backend_unsubscribe;
+  class->sync = g_nextstep_settings_backend_sync;
+  class->get_permission = g_nextstep_settings_backend_get_permission;
+}
+
+static void
+g_nextstep_settings_backend_init (GNextstepSettingsBackend *self)
+{
+  NSAutoreleasePool *pool;
+
+  pool = [[NSAutoreleasePool alloc] init];
+
+  self->user_defaults = [[NSUserDefaults standardUserDefaults] retain];
+
+  g_mutex_init (&self->mutex);
+
+  [pool drain];
+}
+
+static void
+g_nextstep_settings_backend_finalize (GObject *self)
+{
+  GNextstepSettingsBackend *backend = G_NEXTSTEP_SETTINGS_BACKEND (self);
+  NSAutoreleasePool *pool;
+
+  pool = [[NSAutoreleasePool alloc] init];
+
+  g_mutex_clear (&backend->mutex);
+
+  [backend->user_defaults release];
+
+  [pool drain];
+
+  G_OBJECT_CLASS (g_nextstep_settings_backend_parent_class)->finalize (self);
+}
+
+static GVariant *
+g_nextstep_settings_backend_read (GSettingsBackend   *backend,
+                                  const gchar        *key,
+                                  const GVariantType *expected_type,
+                                  gboolean            default_value)
+{
+  GNextstepSettingsBackend *self = G_NEXTSTEP_SETTINGS_BACKEND (backend);
+  NSAutoreleasePool *pool;
+  NSString *name;
+  id value;
+  GVariant *variant;
+
+  if (default_value)
+    return NULL;
+
+  pool = [[NSAutoreleasePool alloc] init];
+  name = [NSString stringWithUTF8String:key];
+
+  g_mutex_lock (&self->mutex);
+  value = [self->user_defaults objectForKey:name];
+  g_mutex_unlock (&self->mutex);
+
+  variant = g_nextstep_settings_backend_get_g_variant (value, expected_type);
+
+  [pool drain];
+
+  return variant;
+}
+
+static gboolean
+g_nextstep_settings_backend_get_writable (GSettingsBackend *backend,
+                                          const gchar      *key)
+{
+  return TRUE;
+}
+
+static gboolean
+g_nextstep_settings_backend_write (GSettingsBackend *backend,
+                                   const gchar      *key,
+                                   GVariant         *value,
+                                   gpointer          origin_tag)
+{
+  GNextstepSettingsBackend *self = G_NEXTSTEP_SETTINGS_BACKEND (backend);
+  NSAutoreleasePool *pool;
+
+  pool = [[NSAutoreleasePool alloc] init];
+
+  g_mutex_lock (&self->mutex);
+  g_nextstep_settings_backend_write_pair ((gpointer) key, value, self);
+  g_mutex_unlock (&self->mutex);
+
+  g_settings_backend_changed (backend, key, origin_tag);
+
+  [pool drain];
+
+  return TRUE;
+}
+
+static gboolean
+g_nextstep_settings_backend_write_tree (GSettingsBackend *backend,
+                                        GTree            *tree,
+                                        gpointer          origin_tag)
+{
+  GNextstepSettingsBackend *self = G_NEXTSTEP_SETTINGS_BACKEND (backend);
+  NSAutoreleasePool *pool;
+
+  pool = [[NSAutoreleasePool alloc] init];
+
+  g_mutex_lock (&self->mutex);
+  g_tree_foreach (tree, g_nextstep_settings_backend_write_pair, self);
+  g_mutex_unlock (&self->mutex);
+  g_settings_backend_changed_tree (backend, tree, origin_tag);
+
+  [pool drain];
+
+  return TRUE;
+}
+
+static void
+g_nextstep_settings_backend_reset (GSettingsBackend *backend,
+                                   const gchar      *key,
+                                   gpointer          origin_tag)
+{
+  GNextstepSettingsBackend *self = G_NEXTSTEP_SETTINGS_BACKEND (backend);
+  NSAutoreleasePool *pool;
+  NSString *name;
+
+  pool = [[NSAutoreleasePool alloc] init];
+  name = [NSString stringWithUTF8String:key];
+
+  g_mutex_lock (&self->mutex);
+  [self->user_defaults removeObjectForKey:name];
+  g_mutex_unlock (&self->mutex);
+
+  g_settings_backend_changed (backend, key, origin_tag);
+
+  [pool drain];
+}
+
+static void
+g_nextstep_settings_backend_subscribe (GSettingsBackend *backend,
+                                       const gchar      *name)
+{
+}
+
+static void
+g_nextstep_settings_backend_unsubscribe (GSettingsBackend *backend,
+                                         const gchar      *name)
+{
+}
+
+static void
+g_nextstep_settings_backend_sync (GSettingsBackend *backend)
+{
+  GNextstepSettingsBackend *self = G_NEXTSTEP_SETTINGS_BACKEND (backend);
+  NSAutoreleasePool *pool;
+
+  pool = [[NSAutoreleasePool alloc] init];
+
+  g_mutex_lock (&self->mutex);
+  [self->user_defaults synchronize];
+  g_mutex_unlock (&self->mutex);
+
+  [pool drain];
+}
+
+static GPermission *
+g_nextstep_settings_backend_get_permission (GSettingsBackend *backend,
+                                            const gchar      *path)
+{
+  return g_simple_permission_new (TRUE);
+}
+
+static gboolean
+g_nextstep_settings_backend_write_pair (gpointer name,
+                                        gpointer value,
+                                        gpointer data)
+{
+  GNextstepSettingsBackend *backend = G_NEXTSTEP_SETTINGS_BACKEND (data);
+  NSString *key;
+  id object;
+
+  key = [NSString stringWithUTF8String:name];
+  object = g_nextstep_settings_backend_get_ns_object (value);
+
+  [backend->user_defaults setObject:object forKey:key];
+
+  return FALSE;
+}
+
+static GVariant *
+g_nextstep_settings_backend_get_g_variant (id                  object,
+                                           const GVariantType *type)
+{
+  if ([object isKindOfClass:[NSData class]])
+    return g_variant_parse (type, [[[[NSString alloc] initWithData:object encoding:NSUTF8StringEncoding] autorelease] UTF8String], NULL, NULL, NULL);
+  else if ([object isKindOfClass:[NSNumber class]])
+    {
+      if (g_variant_type_equal (type, G_VARIANT_TYPE_BOOLEAN))
+        return g_variant_new_boolean ([object boolValue]);
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_BYTE))
+        return g_variant_new_byte ([object unsignedCharValue]);
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_INT16))
+        return g_variant_new_int16 ([object shortValue]);
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_UINT16))
+        return g_variant_new_uint16 ([object unsignedShortValue]);
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_INT32))
+        return g_variant_new_int32 ([object longValue]);
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_UINT32))
+        return g_variant_new_uint32 ([object unsignedLongValue]);
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_INT64))
+        return g_variant_new_int64 ([object longLongValue]);
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_UINT64))
+        return g_variant_new_uint64 ([object unsignedLongLongValue]);
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_HANDLE))
+        return g_variant_new_handle ([object longValue]);
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_DOUBLE))
+        return g_variant_new_double ([object doubleValue]);
+    }
+  else if ([object isKindOfClass:[NSString class]])
+    {
+      const char *string;
+
+      string = [object UTF8String];
+
+      if (g_variant_type_equal (type, G_VARIANT_TYPE_STRING))
+        return g_variant_new_string (string);
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_OBJECT_PATH))
+        return g_variant_is_object_path (string) ?
+               g_variant_new_object_path (string) : NULL;
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_SIGNATURE))
+        return g_variant_is_signature (string) ?
+               g_variant_new_signature (string) : NULL;
+    }
+  else if ([object isKindOfClass:[NSDictionary class]])
+    {
+      if (g_variant_type_is_subtype_of (type, G_VARIANT_TYPE ("a{s*}")))
+        {
+          const GVariantType *value_type;
+          GVariantBuilder builder;
+          NSString *key;
+
+          value_type = g_variant_type_value (g_variant_type_element (type));
+
+          g_variant_builder_init (&builder, type);
+
+          for (key in object)
+            {
+              GVariant *name;
+              id value;
+              GVariant *variant;
+              GVariant *entry;
+
+              name = g_variant_new_string ([key UTF8String]);
+              value = [object objectForKey:key];
+              variant = g_nextstep_settings_backend_get_g_variant (value, value_type);
+
+              if (variant == NULL)
+                {
+                  g_variant_builder_clear (&builder);
+
+                  return NULL;
+                }
+
+              entry = g_variant_new_dict_entry (name, variant);
+              g_variant_builder_add_value (&builder, entry);
+            }
+
+          return g_variant_builder_end (&builder);
+        }
+    }
+  else if ([object isKindOfClass:[NSArray class]])
+    {
+      if (g_variant_type_is_subtype_of (type, G_VARIANT_TYPE_ARRAY))
+        {
+          const GVariantType *value_type;
+          GVariantBuilder builder;
+          id value;
+
+          value_type = g_variant_type_element (type);
+          g_variant_builder_init (&builder, type);
+
+          for (value in object)
+            {
+              GVariant *variant = g_nextstep_settings_backend_get_g_variant (value, value_type);
+
+              if (variant == NULL)
+                {
+                  g_variant_builder_clear (&builder);
+
+                  return NULL;
+                }
+
+              g_variant_builder_add_value (&builder, variant);
+            }
+
+          return g_variant_builder_end (&builder);
+        }
+    }
+
+  return NULL;
+}
+
+static id
+g_nextstep_settings_backend_get_ns_object (GVariant *variant)
+{
+  if (variant == NULL)
+    return nil;
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_BOOLEAN))
+    return [NSNumber numberWithBool:g_variant_get_boolean (variant)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_BYTE))
+    return [NSNumber numberWithUnsignedChar:g_variant_get_byte (variant)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_INT16))
+    return [NSNumber numberWithShort:g_variant_get_int16 (variant)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_UINT16))
+    return [NSNumber numberWithUnsignedShort:g_variant_get_uint16 (variant)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_INT32))
+    return [NSNumber numberWithLong:g_variant_get_int32 (variant)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_UINT32))
+    return [NSNumber numberWithUnsignedLong:g_variant_get_uint32 (variant)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_INT64))
+    return [NSNumber numberWithLongLong:g_variant_get_int64 (variant)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_UINT64))
+    return [NSNumber numberWithUnsignedLongLong:g_variant_get_uint64 (variant)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_HANDLE))
+    return [NSNumber numberWithLong:g_variant_get_handle (variant)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_DOUBLE))
+    return [NSNumber numberWithDouble:g_variant_get_double (variant)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_STRING))
+    return [NSString stringWithUTF8String:g_variant_get_string (variant, NULL)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_OBJECT_PATH))
+    return [NSString stringWithUTF8String:g_variant_get_string (variant, NULL)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_SIGNATURE))
+    return [NSString stringWithUTF8String:g_variant_get_string (variant, NULL)];
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE ("a{s*}")))
+    {
+      NSMutableDictionary *dictionary;
+      GVariantIter iter;
+      GVariant *name;
+      GVariant *value;
+
+      dictionary = [NSMutableDictionary dictionaryWithCapacity:g_variant_iter_init (&iter, variant)];
+
+      while (g_variant_iter_loop (&iter, "{s*}", &name, &value))
+        {
+          NSString *key;
+          id object;
+
+          key = [NSString stringWithUTF8String:g_variant_get_string (name, NULL)];
+          object = g_nextstep_settings_backend_get_ns_object (value);
+
+          [dictionary setObject:object forKey:key];
+        }
+
+      return dictionary;
+    }
+  else if (g_variant_is_of_type (variant, G_VARIANT_TYPE_ARRAY))
+    {
+      NSMutableArray *array;
+      GVariantIter iter;
+      GVariant *value;
+
+      array = [NSMutableArray arrayWithCapacity:g_variant_iter_init (&iter, variant)];
+
+      while ((value = g_variant_iter_next_value (&iter)) != NULL)
+        [array addObject:g_nextstep_settings_backend_get_ns_object (value)];
+
+      return array;
+    }
+  else
+    return [[NSString stringWithUTF8String:g_variant_print (variant, TRUE)] dataUsingEncoding:NSUTF8StringEncoding];
+}
diff --git a/gio/gsettingsbackend.c b/gio/gsettingsbackend.c
index 6ea88d2..6075d7f 100644
--- a/gio/gsettingsbackend.c
+++ b/gio/gsettingsbackend.c
@@ -733,6 +733,9 @@ g_settings_backend_read (GSettingsBackend   *backend,
   value = G_SETTINGS_BACKEND_GET_CLASS (backend)
     ->read (backend, key, expected_type, default_value);
 
+  if (value != NULL)
+    value = g_variant_take_ref (value);
+
   if G_UNLIKELY (value && !g_variant_is_of_type (value, expected_type))
     {
       g_variant_unref (value);
diff --git a/gio/gsettingsbackendinternal.h b/gio/gsettingsbackendinternal.h
index e009b31..5837dcc 100644
--- a/gio/gsettingsbackendinternal.h
+++ b/gio/gsettingsbackendinternal.h
@@ -100,4 +100,9 @@ GType                   g_null_settings_backend_get_type                (void);
 G_GNUC_INTERNAL
 GType                   g_memory_settings_backend_get_type              (void);
 
+#ifdef G_OS_CARBON
+G_GNUC_INTERNAL
+GType                   g_nextstep_settings_backend_get_type            (void);
+#endif
+
 #endif  /* __G_SETTINGS_BACKEND_INTERNAL_H__ */
diff --git a/gio/gsimpleaction.c b/gio/gsimpleaction.c
index d05644d..64dacfd 100644
--- a/gio/gsimpleaction.c
+++ b/gio/gsimpleaction.c
@@ -220,7 +220,7 @@ g_simple_action_set_property (GObject    *object,
     case PROP_NAME:
       action->name = g_strdup (g_value_get_string (value));
       break;
-      
+
     case PROP_PARAMETER_TYPE:
       action->parameter_type = g_value_dup_boxed (value);
       break;
@@ -401,7 +401,7 @@ g_simple_action_class_init (GSimpleActionClass *class)
                                                         P_("The name used to invoke the action"),
                                                         NULL,
                                                         G_PARAM_READWRITE |
-							G_PARAM_CONSTRUCT_ONLY |
+                                                        G_PARAM_CONSTRUCT_ONLY |
                                                         G_PARAM_STATIC_STRINGS));
 
   /**
@@ -418,7 +418,7 @@ g_simple_action_class_init (GSimpleActionClass *class)
                                                        P_("The type of GVariant passed to activate()"),
                                                        G_TYPE_VARIANT_TYPE,
                                                        G_PARAM_READWRITE |
-						       G_PARAM_CONSTRUCT_ONLY |
+                                                       G_PARAM_CONSTRUCT_ONLY |
                                                        G_PARAM_STATIC_STRINGS));
 
   /**
@@ -436,8 +436,7 @@ g_simple_action_class_init (GSimpleActionClass *class)
                                                          P_("Enabled"),
                                                          P_("If the action can be activated"),
                                                          TRUE,
-							 G_PARAM_READWRITE |
-							 G_PARAM_CONSTRUCT_ONLY |
+                                                         G_PARAM_READWRITE |
                                                          G_PARAM_STATIC_STRINGS));
 
   /**
@@ -469,8 +468,7 @@ g_simple_action_class_init (GSimpleActionClass *class)
                                                          P_("The state the action is in"),
                                                          G_VARIANT_TYPE_ANY,
                                                          NULL,
-							 G_PARAM_READWRITE |
-							 G_PARAM_CONSTRUCT_ONLY |
+                                                         G_PARAM_READWRITE |
                                                          G_PARAM_STATIC_STRINGS));
 }
 
@@ -520,10 +518,10 @@ GSimpleAction *
 g_simple_action_new (const gchar        *name,
                      const GVariantType *parameter_type)
 {
-  return (GSimpleAction*) g_object_new (G_TYPE_SIMPLE_ACTION,
-					"name", name,
-					"parameter-type", parameter_type,
-					NULL);
+  return g_object_new (G_TYPE_SIMPLE_ACTION,
+                       "name", name,
+                       "parameter-type", parameter_type,
+                       NULL);
 }
 
 /**
@@ -548,9 +546,9 @@ g_simple_action_new_stateful (const gchar        *name,
                               const GVariantType *parameter_type,
                               GVariant           *state)
 {
-  return (GSimpleAction*) g_object_new (G_TYPE_SIMPLE_ACTION,
-					"name", name,
-					"parameter-type", parameter_type,
-					"state", state,
-					NULL);
+  return g_object_new (G_TYPE_SIMPLE_ACTION,
+                       "name", name,
+                       "parameter-type", parameter_type,
+                       "state", state,
+                       NULL);
 }
diff --git a/gio/gsocket.c b/gio/gsocket.c
index 661a91b..1679280 100644
--- a/gio/gsocket.c
+++ b/gio/gsocket.c
@@ -1727,6 +1727,8 @@ g_socket_check_connect_result (GSocket  *socket,
   guint optlen;
   int value;
 
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
   if (!check_socket (socket, error))
     return FALSE;
 
@@ -1835,7 +1837,7 @@ g_socket_receive_with_blocking (GSocket       *socket,
 {
   gssize ret;
 
-  g_return_val_if_fail (G_IS_SOCKET (socket) && buffer != NULL, FALSE);
+  g_return_val_if_fail (G_IS_SOCKET (socket) && buffer != NULL, -1);
 
   if (!check_socket (socket, error))
     return -1;
@@ -2007,7 +2009,7 @@ g_socket_send_with_blocking (GSocket       *socket,
 {
   gssize ret;
 
-  g_return_val_if_fail (G_IS_SOCKET (socket) && buffer != NULL, FALSE);
+  g_return_val_if_fail (G_IS_SOCKET (socket) && buffer != NULL, -1);
 
   if (!check_socket (socket, error))
     return -1;
@@ -2692,6 +2694,8 @@ GIOCondition
 g_socket_condition_check (GSocket      *socket,
 			  GIOCondition  condition)
 {
+  g_return_val_if_fail (G_IS_SOCKET (socket), 0);
+
   if (!check_socket (socket, NULL))
     return 0;
 
@@ -2748,6 +2752,8 @@ g_socket_condition_wait (GSocket       *socket,
 			 GCancellable  *cancellable,
 			 GError       **error)
 {
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
   if (!check_socket (socket, error))
     return FALSE;
 
@@ -2919,6 +2925,8 @@ g_socket_send_message (GSocket                *socket,
   GOutputVector one_vector;
   char zero;
 
+  g_return_val_if_fail (G_IS_SOCKET (socket), -1);
+
   if (!check_socket (socket, error))
     return -1;
 
@@ -3238,6 +3246,8 @@ g_socket_receive_message (GSocket                 *socket,
   GInputVector one_vector;
   char one_byte;
 
+  g_return_val_if_fail (G_IS_SOCKET (socket), -1);
+
   if (!check_socket (socket, error))
     return -1;
 
diff --git a/gio/gsocketclient.c b/gio/gsocketclient.c
index da534e7..1a86bf5 100644
--- a/gio/gsocketclient.c
+++ b/gio/gsocketclient.c
@@ -75,6 +75,14 @@ G_DEFINE_TYPE (GSocketClient, g_socket_client, G_TYPE_OBJECT);
 
 enum
 {
+  EVENT,
+  LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+enum
+{
   PROP_NONE,
   PROP_FAMILY,
   PROP_TYPE,
@@ -615,6 +623,14 @@ g_socket_client_get_tls (GSocketClient *client)
  * g_tcp_wrapper_connection_get_base_io_stream() on the return value
  * to extract the #GTlsClientConnection.
  *
+ * If you need to modify the behavior of the TLS handshake (eg, by
+ * setting a client-side certificate to use, or connecting to the
+ * #GTlsConnection::accept-certificate signal), you can connect to
+ * @client's #GSocketClient::event signal and wait for it to be
+ * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you
+ * a chance to see the #GTlsClientConnection before the handshake
+ * starts.
+ *
  * Since: 2.28
  */
 void
@@ -678,6 +694,116 @@ g_socket_client_class_init (GSocketClientClass *class)
   gobject_class->set_property = g_socket_client_set_property;
   gobject_class->get_property = g_socket_client_get_property;
 
+  /**
+   * GSocketClient::event:
+   * @client: the #GSocketClient
+   * @event: the event that is occurring
+   * @connectable: the #GSocketConnectable that @event is occurring on
+   * @connection: the current representation of the connection
+   *
+   * Emitted when @client's activity on @connectable changes state.
+   * Among other things, this can be used to provide progress
+   * information about a network connection in the UI. The meanings of
+   * the different @event values are as follows:
+   *
+   * <variablelist>
+   *   <varlistentry>
+   *     <term>%G_SOCKET_CLIENT_RESOLVING:</term>
+   *     <listitem><para>
+   *       @client is about to look up @connectable in DNS.
+   *       @connection will be %NULL.
+   *     </para></listitem>
+   *   </varlistentry>
+   *   <varlistentry>
+   *     <term>%G_SOCKET_CLIENT_RESOLVED:</term>
+   *     <listitem><para>
+   *       @client has successfully resolved @connectable in DNS.
+   *       @connection will be %NULL.
+   *     </para></listitem>
+   *   </varlistentry>
+   *   <varlistentry>
+   *     <term>%G_SOCKET_CLIENT_CONNECTING:</term>
+   *     <listitem><para>
+   *       @client is about to make a connection to a remote host;
+   *       either a proxy server or the destination server itself.
+   *       @connection is the #GSocketConnection, which is not yet
+   *       connected.
+   *     </para></listitem>
+   *   </varlistentry>
+   *   <varlistentry>
+   *     <term>%G_SOCKET_CLIENT_CONNECTED:</term>
+   *     <listitem><para>
+   *       @client has successfully connected to a remote host.
+   *       @connection is the connected #GSocketConnection.
+   *     </para></listitem>
+   *   </varlistentry>
+   *   <varlistentry>
+   *     <term>%G_SOCKET_CLIENT_PROXY_NEGOTIATING:</term>
+   *     <listitem><para>
+   *       @client is about to negotiate with a proxy to get it to
+   *       connect to @connectable. @connection is the
+   *       #GSocketConnection to the proxy server.
+   *     </para></listitem>
+   *   </varlistentry>
+   *   <varlistentry>
+   *     <term>%G_SOCKET_CLIENT_PROXY_NEGOTIATED:</term>
+   *     <listitem><para>
+   *       @client has negotiated a connection to @connectable through
+   *       a proxy server. @connection is the stream returned from
+   *       g_proxy_connect(), which may or may not be a
+   *       #GSocketConnection.
+   *     </para></listitem>
+   *   </varlistentry>
+   *   <varlistentry>
+   *     <term>%G_SOCKET_CLIENT_TLS_HANDSHAKING:</term>
+   *     <listitem><para>
+   *       @client is about to begin a TLS handshake. @connection is a
+   *       #GTlsClientConnection.
+   *     </para></listitem>
+   *   </varlistentry>
+   *   <varlistentry>
+   *     <term>%G_SOCKET_CLIENT_TLS_HANDSHAKED:</term>
+   *     <listitem><para>
+   *       @client has successfully completed the TLS handshake.
+   *       @connection is a #GTlsClientConnection.
+   *     </para></listitem>
+   *   </varlistentry>
+   *   <varlistentry>
+   *     <term>%G_SOCKET_CLIENT_COMPLETE:</term>
+   *     <listitem><para>
+   *       @client has either successfully connected to @connectable
+   *       (in which case @connection is the #GSocketConnection that
+   *       it will be returning to the caller) or has failed (in which
+   *       case @connection is %NULL and the client is about to return
+   *       an error).
+   *     </para></listitem>
+   *   </varlistentry>
+   * </variablelist>
+   *
+   * Each event except %G_SOCKET_CLIENT_COMPLETE may be emitted
+   * multiple times (or not at all) for a given connectable (in
+   * particular, if @client ends up attempting to connect to more than
+   * one address). However, if @client emits the #GSocketClient:event
+   * signal at all for a given connectable, that it will always emit
+   * it with %G_SOCKET_CLIENT_COMPLETE when it is done.
+   *
+   * Note that there may be additional #GSocketClientEvent values in
+   * the future; unrecognized @event values should be ignored.
+   *
+   * Since: 2.32
+   */
+  signals[EVENT] =
+    g_signal_new (I_("event"),
+		  G_TYPE_FROM_CLASS (gobject_class),
+		  G_SIGNAL_RUN_LAST,
+		  G_STRUCT_OFFSET (GSocketClientClass, event),
+		  NULL, NULL,
+		  NULL,
+		  G_TYPE_NONE, 3,
+		  G_TYPE_SOCKET_CLIENT_EVENT,
+		  G_TYPE_SOCKET_CONNECTABLE,
+		  G_TYPE_IO_STREAM);
+
   g_object_class_install_property (gobject_class, PROP_FAMILY,
 				   g_param_spec_enum ("family",
 						      P_("Socket family"),
@@ -754,6 +880,16 @@ g_socket_client_class_init (GSocketClientClass *class)
 						       G_PARAM_STATIC_STRINGS));
 }
 
+static void
+g_socket_client_emit_event (GSocketClient       *client,
+			    GSocketClientEvent  event,
+			    GSocketConnectable  *connectable,
+			    GIOStream           *connection)
+{
+  g_signal_emit (client, signals[EVENT], 0,
+		 event, connectable, connection);
+}
+
 /**
  * g_socket_client_connect:
  * @client: a #GSocketClient.
@@ -806,6 +942,7 @@ g_socket_client_connect (GSocketClient       *client,
       GSocketAddress *address = NULL;
       gboolean application_proxy = FALSE;
       GSocket *socket;
+      gboolean using_proxy;
 
       if (g_cancellable_is_cancelled (cancellable))
 	{
@@ -815,6 +952,8 @@ g_socket_client_connect (GSocketClient       *client,
 	}
 
       tmp_error = NULL;
+      g_socket_client_emit_event (client, G_SOCKET_CLIENT_RESOLVING,
+				  connectable, NULL);
       address = g_socket_address_enumerator_next (enumerator, cancellable,
 	      					  &tmp_error);
 
@@ -834,6 +973,11 @@ g_socket_client_connect (GSocketClient       *client,
                                  _("Unknown error on connect"));
 	  break;
 	}
+      g_socket_client_emit_event (client, G_SOCKET_CLIENT_RESOLVED,
+				  connectable, NULL);
+
+      using_proxy = (G_IS_PROXY_ADDRESS (address) &&
+		     client->priv->enable_proxy);
 
       /* clear error from previous attempt */
       g_clear_error (&last_error);
@@ -845,14 +989,22 @@ g_socket_client_connect (GSocketClient       *client,
 	  continue;
 	}
 
-      if (g_socket_connect (socket, address, cancellable, &last_error))
-	connection = (GIOStream *)g_socket_connection_factory_create_connection (socket);
+      connection = (GIOStream *)g_socket_connection_factory_create_connection (socket);
+      g_socket_client_emit_event (client, G_SOCKET_CLIENT_CONNECTING, connectable, connection);
+
+      if (g_socket_connection_connect (G_SOCKET_CONNECTION (connection),
+				       address, cancellable, &last_error))
+	{
+	  g_socket_client_emit_event (client, G_SOCKET_CLIENT_CONNECTED, connectable, connection);
+	}
       else
-	clarify_connect_error (last_error, connectable, address);
+	{
+	  clarify_connect_error (last_error, connectable, address);
+	  g_object_unref (connection);
+	  connection = NULL;
+	}
 
-      if (connection &&
-	  G_IS_PROXY_ADDRESS (address) &&
-	  client->priv->enable_proxy)
+      if (connection && using_proxy)
 	{
 	  GProxyAddress *proxy_addr = G_PROXY_ADDRESS (address);
 	  const gchar *protocol;
@@ -878,8 +1030,9 @@ g_socket_client_connect (GSocketClient       *client,
             }
           else if (proxy)
 	    {
-              GIOStream *proxy_connection;
+	      GIOStream *proxy_connection;
 
+	      g_socket_client_emit_event (client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, connectable, connection);
 	      proxy_connection = g_proxy_connect (proxy,
 						  connection,
 						  proxy_addr,
@@ -888,6 +1041,9 @@ g_socket_client_connect (GSocketClient       *client,
 	      g_object_unref (connection);
 	      connection = proxy_connection;
 	      g_object_unref (proxy);
+
+	      if (connection)
+		g_socket_client_emit_event (client, G_SOCKET_CLIENT_PROXY_NEGOTIATED, connectable, connection);
 	    }
 	  else if (!g_hash_table_lookup_extended (client->priv->app_proxies,
 						  protocol, NULL, NULL))
@@ -916,8 +1072,13 @@ g_socket_client_connect (GSocketClient       *client,
 	    {
 	      g_tls_client_connection_set_validation_flags (G_TLS_CLIENT_CONNECTION (tlsconn),
                                                             client->priv->tls_validation_flags);
-	      if (!g_tls_connection_handshake (G_TLS_CONNECTION (tlsconn),
-					       cancellable, &last_error))
+	      g_socket_client_emit_event (client, G_SOCKET_CLIENT_TLS_HANDSHAKING, connectable, connection);
+	      if (g_tls_connection_handshake (G_TLS_CONNECTION (tlsconn),
+					      cancellable, &last_error))
+		{
+		  g_socket_client_emit_event (client, G_SOCKET_CLIENT_TLS_HANDSHAKED, connectable, connection);
+		}
+	      else
 		{
 		  g_object_unref (tlsconn);
 		  connection = NULL;
@@ -939,6 +1100,7 @@ g_socket_client_connect (GSocketClient       *client,
     }
   g_object_unref (enumerator);
 
+  g_socket_client_emit_event (client, G_SOCKET_CLIENT_COMPLETE, connectable, connection);
   return G_SOCKET_CONNECTION (connection);
 }
 
@@ -1123,6 +1285,8 @@ typedef struct
 static void
 g_socket_client_async_connect_complete (GSocketClientAsyncConnectData *data)
 {
+  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_COMPLETE, data->connectable, data->connection);
+
   if (data->last_error)
     {
       g_simple_async_result_take_error (data->result, data->last_error);
@@ -1184,6 +1348,7 @@ enumerator_next_async (GSocketClientAsyncConnectData *data)
   g_clear_object (&data->proxy_addr);
   g_clear_object (&data->connection);
 
+  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_RESOLVING, data->connectable, NULL);
   g_socket_address_enumerator_next_async (data->enumerator,
 					  data->cancellable,
 					  g_socket_client_enumerator_callback,
@@ -1204,6 +1369,7 @@ g_socket_client_tls_handshake_callback (GObject      *object,
       g_object_unref (data->connection);
       data->connection = G_IO_STREAM (object);
 
+      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_TLS_HANDSHAKED, data->connectable, data->connection);
       g_socket_client_async_connect_complete (data);
     }
   else
@@ -1231,6 +1397,7 @@ g_socket_client_tls_handshake (GSocketClientAsyncConnectData *data)
     {
       g_tls_client_connection_set_validation_flags (G_TLS_CLIENT_CONNECTION (tlsconn),
                                                     data->client->priv->tls_validation_flags);
+      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_TLS_HANDSHAKING, data->connectable, G_IO_STREAM (tlsconn));
       g_tls_connection_handshake_async (G_TLS_CONNECTION (tlsconn),
 					G_PRIORITY_DEFAULT,
 					data->cancellable,
@@ -1254,7 +1421,11 @@ g_socket_client_proxy_connect_callback (GObject      *object,
   data->connection = g_proxy_connect_finish (G_PROXY (object),
 					     result,
 					     &data->last_error);
-  if (!data->connection)
+  if (data->connection)
+    {
+      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATED, data->connectable, data->connection);
+    }
+  else
     {
       enumerator_next_async (data);
       return;
@@ -1264,21 +1435,42 @@ g_socket_client_proxy_connect_callback (GObject      *object,
 }
 
 static void
-g_socket_client_proxy_connect (GSocketClientAsyncConnectData *data)
+g_socket_client_connected_callback (GObject      *source,
+				    GAsyncResult *result,
+				    gpointer      user_data)
 {
+  GSocketClientAsyncConnectData *data = user_data;
+  GError *error = NULL;
   GProxy *proxy;
   const gchar *protocol;
 
+  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),
+					   result, &error))
+    {
+      clarify_connect_error (error, data->connectable,
+			     data->current_addr);
+      set_last_error (data, error);
+
+      /* try next one */
+      enumerator_next_async (data);
+      return;
+    }
+
+  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);
+
+  /* wrong, but backward compatible */
+  g_socket_set_blocking (data->current_socket, TRUE);
+
   if (!data->proxy_addr)
     {
       g_socket_client_tls_handshake (data);
       return;
     }
 
-  protocol  = g_proxy_address_get_protocol (data->proxy_addr);
+  protocol = g_proxy_address_get_protocol (data->proxy_addr);
   proxy = g_proxy_get_default_for_protocol (protocol);
 
-  /* The connection should not be anything else then TCP Connection,
+  /* The connection should not be anything other than TCP,
    * but let's put a safety guard in case
    */
   if (!G_IS_TCP_CONNECTION (data->connection))
@@ -1294,6 +1486,7 @@ g_socket_client_proxy_connect (GSocketClientAsyncConnectData *data)
     }
   else if (proxy)
     {
+      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);
       g_proxy_connect_async (proxy,
                              data->connection,
                              data->proxy_addr,
@@ -1322,54 +1515,6 @@ g_socket_client_proxy_connect (GSocketClientAsyncConnectData *data)
 }
 
 static void
-g_socket_client_socket_connected (GSocketClientAsyncConnectData *data)
-{
-  g_socket_set_blocking (data->current_socket, TRUE);
-
-  data->connection = (GIOStream *)
-    g_socket_connection_factory_create_connection (data->current_socket);
-
-  g_socket_client_proxy_connect (data);
-}
-
-static gboolean
-g_socket_client_socket_callback (GSocket *socket,
-				 GIOCondition condition,
-				 GSocketClientAsyncConnectData *data)
-{
-  GError *error = NULL;
-
-  if (g_cancellable_is_cancelled (data->cancellable))
-    {
-      /* Cancelled, return done with last error being cancelled */
-      g_clear_error (&data->last_error);
-      g_cancellable_set_error_if_cancelled (data->cancellable,
-					    &data->last_error);
-
-      g_socket_client_async_connect_complete (data);
-      return FALSE;
-    }
-  else
-    {
-      /* socket is ready for writing means connect done, did it succeed? */
-      if (!g_socket_check_connect_result (data->current_socket, &error))
-	{
-	  clarify_connect_error (error, data->connectable,
-				 data->current_addr);
-	  set_last_error (data, error);
-
-	  /* try next one */
-	  enumerator_next_async (data);
-
-	  return FALSE;
-	}
-    }
-
-  g_socket_client_socket_connected (data);
-  return FALSE;
-}
-
-static void
 g_socket_client_enumerator_callback (GObject      *object,
 				     GAsyncResult *result,
 				     gpointer      user_data)
@@ -1402,6 +1547,9 @@ g_socket_client_enumerator_callback (GObject      *object,
       return;
     }
 
+  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_RESOLVED,
+			      data->connectable, NULL);
+
   if (G_IS_PROXY_ADDRESS (address) &&
       data->client->priv->enable_proxy)
     data->proxy_addr = g_object_ref (G_PROXY_ADDRESS (address));
@@ -1409,44 +1557,21 @@ g_socket_client_enumerator_callback (GObject      *object,
   g_clear_error (&data->last_error);
 
   socket = create_socket (data->client, address, &data->last_error);
-  if (socket != NULL)
+  if (socket == NULL)
     {
-      g_socket_set_blocking (socket, FALSE);
-      if (g_socket_connect (socket, address, data->cancellable, &tmp_error))
-	{
-	  data->current_socket = socket;
-	  g_socket_client_socket_connected (data);
-
-	  g_object_unref (address);
-	  return;
-	}
-      else if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_PENDING))
-	{
-	  GSource *source;
-
-	  data->current_socket = socket;
-	  data->current_addr = address;
-	  g_error_free (tmp_error);
-
-	  source = g_socket_create_source (socket, G_IO_OUT,
-					   data->cancellable);
-	  g_source_set_callback (source,
-				 (GSourceFunc) g_socket_client_socket_callback,
-				 data, NULL);
-	  g_source_attach (source, g_main_context_get_thread_default ());
-	  g_source_unref (source);
-	  return;
-	}
-      else
-	{
-	  clarify_connect_error (tmp_error, data->connectable, address);
-	  data->last_error = tmp_error;
-	  g_object_unref (socket);
-	}
+      g_object_unref (address);
+      enumerator_next_async (data);
+      return;
     }
 
-  g_object_unref (address);
-  enumerator_next_async (data);
+  data->current_socket = socket;
+  data->current_addr = address;
+  data->connection = (GIOStream *) g_socket_connection_factory_create_connection (socket);
+
+  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTING, data->connectable, data->connection);
+  g_socket_connection_connect_async (G_SOCKET_CONNECTION (data->connection),
+				     address, data->cancellable,
+				     g_socket_client_connected_callback, data);
 }
 
 /**
diff --git a/gio/gsocketclient.h b/gio/gsocketclient.h
index 180bedd..216310b 100644
--- a/gio/gsocketclient.h
+++ b/gio/gsocketclient.h
@@ -52,12 +52,16 @@ struct _GSocketClientClass
 {
   GObjectClass parent_class;
 
+  void (* event) (GSocketClient       *client,
+		  GSocketClientEvent  event,
+		  GSocketConnectable  *connectable,
+		  GIOStream           *connection);
+
   /* Padding for future expansion */
   void (*_g_reserved1) (void);
   void (*_g_reserved2) (void);
   void (*_g_reserved3) (void);
   void (*_g_reserved4) (void);
-  void (*_g_reserved5) (void);
 };
 
 struct _GSocketClient
diff --git a/gio/gsocketconnection.c b/gio/gsocketconnection.c
index 6f2f102..ee391ab 100644
--- a/gio/gsocketconnection.c
+++ b/gio/gsocketconnection.c
@@ -114,6 +114,165 @@ g_socket_connection_get_output_stream (GIOStream *io_stream)
 }
 
 /**
+ * g_socket_connection_is_connected:
+ * @connection: a #GSocketConnection
+ *
+ * Checks if @connection is connected. This is equivalent to calling
+ * g_socket_is_connected() on @connection's underlying #GSocket.
+ *
+ * Returns: whether @connection is connected
+ *
+ * Since: 2.32
+ */
+gboolean
+g_socket_connection_is_connected (GSocketConnection  *connection)
+{
+  return g_socket_is_connected (connection->priv->socket);
+}
+
+/**
+ * g_socket_connection_connect:
+ * @connection: a #GSocketConnection
+ * @address: a #GSocketAddress specifying the remote address.
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Connect @connection to the specified remote address.
+ *
+ * Returns: %TRUE if the connection succeeded, %FALSE on error
+ *
+ * Since: 2.32
+ */
+gboolean
+g_socket_connection_connect (GSocketConnection  *connection,
+			     GSocketAddress     *address,
+			     GCancellable       *cancellable,
+			     GError            **error)
+{
+  g_return_val_if_fail (G_IS_SOCKET_CONNECTION (connection), FALSE);
+  g_return_val_if_fail (G_IS_SOCKET_ADDRESS (address), FALSE);
+
+  return g_socket_connect (connection->priv->socket, address,
+			   cancellable, error);
+}
+
+static gboolean g_socket_connection_connect_callback (GSocket      *socket,
+						      GIOCondition  condition,
+						      gpointer      user_data);
+
+/**
+ * g_socket_connection_connect_async:
+ * @connection: a #GSocketConnection
+ * @address: a #GSocketAddress specifying the remote address.
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @callback: (scope async): a #GAsyncReadyCallback
+ * @user_data: (closure): user data for the callback
+ *
+ * Asynchronously connect @connection to the specified remote address.
+ *
+ * This clears the #GSocket:blocking flag on @connection's underlying
+ * socket if it is currently set.
+ *
+ * Use g_socket_connection_connect_finish() to retrieve the result.
+ *
+ * Since: 2.32
+ */
+void
+g_socket_connection_connect_async (GSocketConnection   *connection,
+				   GSocketAddress      *address,
+				   GCancellable        *cancellable,
+				   GAsyncReadyCallback  callback,
+				   gpointer             user_data)
+{
+  GSimpleAsyncResult *simple;
+  GError *tmp_error = NULL;
+
+  g_return_if_fail (G_IS_SOCKET_CONNECTION (connection));
+  g_return_if_fail (G_IS_SOCKET_ADDRESS (address));
+
+  simple = g_simple_async_result_new (G_OBJECT (connection),
+				      callback, user_data,
+				      g_socket_connection_connect_async);
+
+  g_socket_set_blocking (connection->priv->socket, FALSE);
+
+  if (g_socket_connect (connection->priv->socket, address,
+			cancellable, &tmp_error))
+    {
+      g_simple_async_result_set_op_res_gboolean (simple, TRUE);
+      g_simple_async_result_complete_in_idle (simple);
+    }
+  else if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_PENDING))
+    {
+      GSource *source;
+
+      g_error_free (tmp_error);
+      source = g_socket_create_source (connection->priv->socket,
+				       G_IO_OUT, cancellable);
+      g_source_set_callback (source,
+			     (GSourceFunc) g_socket_connection_connect_callback,
+			     simple, NULL);
+      g_source_attach (source, g_main_context_get_thread_default ());
+      g_source_unref (source);
+    }
+  else
+    {
+      g_simple_async_result_take_error (simple, tmp_error);
+      g_simple_async_result_complete_in_idle (simple);
+    }
+}
+
+static gboolean
+g_socket_connection_connect_callback (GSocket      *socket,
+				      GIOCondition  condition,
+				      gpointer      user_data)
+{
+  GSimpleAsyncResult *simple = user_data;
+  GSocketConnection *connection;
+  GError *error = NULL;
+
+  connection = G_SOCKET_CONNECTION (g_async_result_get_source_object (G_ASYNC_RESULT (simple)));
+  g_object_unref (connection);
+
+  if (g_socket_check_connect_result (connection->priv->socket, &error))
+    g_simple_async_result_set_op_res_gboolean (simple, TRUE);
+  else
+    g_simple_async_result_take_error (simple, error);
+
+  g_simple_async_result_complete (simple);
+  g_object_unref (simple);
+  return FALSE;
+}
+
+/**
+ * g_socket_connection_connect_finish:
+ * @connection: a #GSocketConnection
+ * @result: the #GAsyncResult
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Gets the result of a g_socket_connection_connect_async() call.
+ *
+ * Returns: %TRUE if the connection succeeded, %FALSE on error
+ *
+ * Since: 2.32
+ */
+gboolean
+g_socket_connection_connect_finish (GSocketConnection  *connection,
+				    GAsyncResult       *result,
+				    GError            **error)
+{
+  GSimpleAsyncResult *simple;
+
+  g_return_val_if_fail (G_IS_SOCKET_CONNECTION (connection), FALSE);
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (connection), g_socket_connection_connect_async), FALSE);
+
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+  if (g_simple_async_result_propagate_error (simple, error))
+    return FALSE;
+  return TRUE;
+}
+
+/**
  * g_socket_connection_get_socket:
  * @connection: a #GSocketConnection
  *
diff --git a/gio/gsocketconnection.h b/gio/gsocketconnection.h
index 1edc2f4..34a0cb1 100644
--- a/gio/gsocketconnection.h
+++ b/gio/gsocketconnection.h
@@ -72,11 +72,26 @@ struct _GSocketConnection
 
 GType              g_socket_connection_get_type                  (void) G_GNUC_CONST;
 
+gboolean           g_socket_connection_is_connected              (GSocketConnection  *connection);
+gboolean           g_socket_connection_connect                   (GSocketConnection  *connection,
+								  GSocketAddress     *address,
+								  GCancellable       *cancellable,
+								  GError            **error);
+void               g_socket_connection_connect_async             (GSocketConnection  *connection,
+								  GSocketAddress     *address,
+								  GCancellable       *cancellable,
+								  GAsyncReadyCallback callback,
+								  gpointer            user_data);
+gboolean           g_socket_connection_connect_finish            (GSocketConnection  *connection,
+								  GAsyncResult       *result,
+								  GError            **error);
+
 GSocket           *g_socket_connection_get_socket                (GSocketConnection  *connection);
 GSocketAddress    *g_socket_connection_get_local_address         (GSocketConnection  *connection,
 								  GError            **error);
 GSocketAddress    *g_socket_connection_get_remote_address        (GSocketConnection  *connection,
 								  GError            **error);
+
 void               g_socket_connection_factory_register_type     (GType               g_type,
 								  GSocketFamily       family,
 								  GSocketType         type,
diff --git a/gio/gunixvolumemonitor.c b/gio/gunixvolumemonitor.c
index 76a9840..26ec483 100644
--- a/gio/gunixvolumemonitor.c
+++ b/gio/gunixvolumemonitor.c
@@ -76,15 +76,11 @@ g_unix_volume_monitor_finalize (GObject *object)
 					
   g_object_unref (monitor->mount_monitor);
 
-  g_list_foreach (monitor->last_mountpoints, (GFunc)g_unix_mount_point_free, NULL);
-  g_list_free (monitor->last_mountpoints);
-  g_list_foreach (monitor->last_mounts, (GFunc)g_unix_mount_free, NULL);
-  g_list_free (monitor->last_mounts);
+  g_list_free_full (monitor->last_mountpoints, (GDestroyNotify) g_unix_mount_point_free);
+  g_list_free_full (monitor->last_mounts, (GDestroyNotify) g_unix_mount_free);
 
-  g_list_foreach (monitor->volumes, (GFunc)g_object_unref, NULL);
-  g_list_free (monitor->volumes);
-  g_list_foreach (monitor->mounts, (GFunc)g_object_unref, NULL);
-  g_list_free (monitor->mounts);
+  g_list_free_full (monitor->volumes, g_object_unref);
+  g_list_free_full (monitor->mounts, g_object_unref);
 
   G_OBJECT_CLASS (g_unix_volume_monitor_parent_class)->finalize (object);
 }
@@ -95,12 +91,11 @@ g_unix_volume_monitor_dispose (GObject *object)
   GUnixVolumeMonitor *monitor;
 
   monitor = G_UNIX_VOLUME_MONITOR (object);
-  g_list_foreach (monitor->volumes, (GFunc)g_object_unref, NULL);
-  g_list_free (monitor->volumes);
+
+  g_list_free_full (monitor->volumes, g_object_unref);
   monitor->volumes = NULL;
   
-  g_list_foreach (monitor->mounts, (GFunc)g_object_unref, NULL);
-  g_list_free (monitor->mounts);
+  g_list_free_full (monitor->mounts, g_object_unref);
   monitor->mounts = NULL;
   
   G_OBJECT_CLASS (g_unix_volume_monitor_parent_class)->dispose (object);
@@ -372,9 +367,7 @@ update_volumes (GUnixVolumeMonitor *monitor)
   
   g_list_free (added);
   g_list_free (removed);
-  g_list_foreach (monitor->last_mountpoints,
-		  (GFunc)g_unix_mount_point_free, NULL);
-  g_list_free (monitor->last_mountpoints);
+  g_list_free_full (monitor->last_mountpoints, (GDestroyNotify) g_unix_mount_point_free);
   monitor->last_mountpoints = new_mountpoints;
 }
 
@@ -428,8 +421,6 @@ update_mounts (GUnixVolumeMonitor *monitor)
   
   g_list_free (added);
   g_list_free (removed);
-  g_list_foreach (monitor->last_mounts,
-		  (GFunc)g_unix_mount_free, NULL);
-  g_list_free (monitor->last_mounts);
+  g_list_free_full (monitor->last_mounts, (GDestroyNotify) g_unix_mount_free);
   monitor->last_mounts = new_mounts;
 }
diff --git a/gio/tests/actions.c b/gio/tests/actions.c
index 57fec75..53a3a8d 100644
--- a/gio/tests/actions.c
+++ b/gio/tests/actions.c
@@ -62,12 +62,15 @@ test_basic (void)
   g_action_activate (G_ACTION (action), NULL);
   g_assert (!a.did_run);
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      g_action_activate (G_ACTION (action), g_variant_new_string ("xxx"));
-      exit (0);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_action_activate (G_ACTION (action), g_variant_new_string ("xxx"));
+          exit (0);
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   g_object_unref (action);
   g_assert (!a.did_run);
@@ -87,13 +90,16 @@ test_basic (void)
   g_variant_unref (a.params);
   a.did_run = FALSE;
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      g_action_activate (G_ACTION (action), NULL);
-      exit (0);
-    }
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_action_activate (G_ACTION (action), NULL);
+          exit (0);
+        }
 
-  g_test_trap_assert_failed ();
+      g_test_trap_assert_failed ();
+    }
 
   g_object_unref (action);
   g_assert (!a.did_run);
@@ -250,12 +256,15 @@ test_stateful (void)
   g_assert_cmpstr (g_variant_get_string (state, NULL), ==, "hihi");
   g_variant_unref (state);
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      g_simple_action_set_state (action, g_variant_new_int32 (123));
-      exit (0);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_simple_action_set_state (action, g_variant_new_int32 (123));
+          exit (0);
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   g_simple_action_set_state (action, g_variant_new_string ("hello"));
   state = g_action_get_state (G_ACTION (action));
@@ -265,12 +274,17 @@ test_stateful (void)
   g_object_unref (action);
 
   action = g_simple_action_new ("foo", NULL);
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+
+  if (g_test_undefined ())
     {
-      g_simple_action_set_state (action, g_variant_new_int32 (123));
-      exit (0);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_simple_action_set_state (action, g_variant_new_int32 (123));
+          exit (0);
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
+
   g_object_unref (action);
 }
 
@@ -339,27 +353,30 @@ test_entries (void)
   g_assert (bar_activated);
   g_assert (!foo_activated);
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      const GActionEntry bad_type = {
-        "bad-type", NULL, "ss"
-      };
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          const GActionEntry bad_type = {
+            "bad-type", NULL, "ss"
+          };
 
-      g_simple_action_group_add_entries (actions, &bad_type, 1, NULL);
-      exit (0);
-    }
-  g_test_trap_assert_failed ();
+          g_simple_action_group_add_entries (actions, &bad_type, 1, NULL);
+          exit (0);
+        }
+      g_test_trap_assert_failed ();
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
-    {
-      const GActionEntry bad_state = {
-        "bad-state", NULL, NULL, "flse"
-      };
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          const GActionEntry bad_state = {
+            "bad-state", NULL, NULL, "flse"
+          };
 
-      g_simple_action_group_add_entries (actions, &bad_state, 1, NULL);
-      exit (0);
+          g_simple_action_group_add_entries (actions, &bad_state, 1, NULL);
+          exit (0);
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   state = g_action_group_get_action_state (G_ACTION_GROUP (actions), "volume");
   g_assert_cmpint (g_variant_get_int32 (state), ==, 0);
diff --git a/gio/tests/contenttype.c b/gio/tests/contenttype.c
index db31ba1..ca5dfe8 100644
--- a/gio/tests/contenttype.c
+++ b/gio/tests/contenttype.c
@@ -75,8 +75,7 @@ test_list (void)
   g_assert (g_list_find_custom (types, plain, find_mime) != NULL);
   g_assert (g_list_find_custom (types, xml, find_mime) != NULL);
 
-  g_list_foreach (types, (GFunc)g_free, NULL);
-  g_list_free (types);
+  g_list_free_full (types, g_free);
 
   g_free (plain);
   g_free (xml);
diff --git a/gio/tests/desktop-app-info.c b/gio/tests/desktop-app-info.c
index 6c6e313..787d217 100644
--- a/gio/tests/desktop-app-info.c
+++ b/gio/tests/desktop-app-info.c
@@ -120,8 +120,7 @@ test_default (void)
   info = (GAppInfo *)list->next->data;
   g_assert (g_strcmp0 (g_app_info_get_id (info), g_app_info_get_id (info1)) == 0);
 
-  g_list_foreach (list, (GFunc)g_object_unref, NULL);
-  g_list_free (list);
+  g_list_free_full (list, g_object_unref);
 
   /* now try adding something at the end */
   g_app_info_add_supports_type (info3, "application/x-test", &error);
@@ -140,8 +139,7 @@ test_default (void)
   info = (GAppInfo *)list->next->next->data;
   g_assert (g_strcmp0 (g_app_info_get_id (info), g_app_info_get_id (info3)) == 0);
 
-  g_list_foreach (list, (GFunc)g_object_unref, NULL);
-  g_list_free (list);
+  g_list_free_full (list, g_object_unref);
 
   /* now remove info1 again */
   g_app_info_remove_supports_type (info1, "application/x-test", &error);
@@ -157,8 +155,7 @@ test_default (void)
   info = (GAppInfo *)list->next->data;
   g_assert (g_strcmp0 (g_app_info_get_id (info), g_app_info_get_id (info3)) == 0);
 
-  g_list_foreach (list, (GFunc)g_object_unref, NULL);
-  g_list_free (list);
+  g_list_free_full (list, g_object_unref);
 
   /* now clean it all up */
   g_app_info_reset_type_associations ("application/x-test");
diff --git a/gio/tests/gdbus-example-objectmanager-client.c b/gio/tests/gdbus-example-objectmanager-client.c
index b413890..3d9242d 100644
--- a/gio/tests/gdbus-example-objectmanager-client.c
+++ b/gio/tests/gdbus-example-objectmanager-client.c
@@ -42,11 +42,9 @@ print_objects (GDBusObjectManager *manager)
            * can be used to get the value of the :Mood property.
            */
         }
-      g_list_foreach (interfaces, (GFunc) g_object_unref, NULL);
-      g_list_free (interfaces);
+      g_list_free_full (interfaces, g_object_unref);
     }
-  g_list_foreach (objects, (GFunc) g_object_unref, NULL);
-  g_list_free (objects);
+  g_list_free_full (objects, g_object_unref);
 }
 
 static void
diff --git a/gio/tests/gdbus-peer.c b/gio/tests/gdbus-peer.c
index 9ee0b08..ca1cf13 100644
--- a/gio/tests/gdbus-peer.c
+++ b/gio/tests/gdbus-peer.c
@@ -926,8 +926,7 @@ dmp_data_free (DmpData *data)
   g_main_loop_unref (data->loop);
   g_main_context_unref (data->context);
   g_object_unref (data->server);
-  g_list_foreach (data->connections, (GFunc) g_object_unref, NULL);
-  g_list_free (data->connections);
+  g_list_free_full (data->connections, g_object_unref);
   g_free (data);
 }
 
diff --git a/gio/tests/gdbus-proxy.c b/gio/tests/gdbus-proxy.c
index 2e280fc..0b2905c 100644
--- a/gio/tests/gdbus-proxy.c
+++ b/gio/tests/gdbus-proxy.c
@@ -572,26 +572,32 @@ test_expected_interface (GDBusProxy *proxy)
   test_bogus_property (proxy);
   */
 
-  /* Also check that we complain if setting a cached property of the wrong type */
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      g_dbus_proxy_set_cached_property (proxy, "y", g_variant_new_string ("error_me_out!"));
+      /* Also check that we complain if setting a cached property of the wrong type */
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_dbus_proxy_set_cached_property (proxy, "y", g_variant_new_string ("error_me_out!"));
+        }
+      g_test_trap_assert_stderr ("*Trying to set property y of type s but according to the expected interface the type is y*");
+      g_test_trap_assert_failed();
     }
-  g_test_trap_assert_stderr ("*Trying to set property y of type s but according to the expected interface the type is y*");
-  g_test_trap_assert_failed();
 
   /* this should work, however (since the type is correct) */
   g_dbus_proxy_set_cached_property (proxy, "y", g_variant_new_byte (42));
 
-  /* Try to get the value of a property where the type we expect is different from
-   * what we have in our cache (e.g. what the service returned)
-   */
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      value = g_dbus_proxy_get_cached_property (proxy, "i");
+      /* Try to get the value of a property where the type we expect is different from
+       * what we have in our cache (e.g. what the service returned)
+       */
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR))
+        {
+          value = g_dbus_proxy_get_cached_property (proxy, "i");
+        }
+      g_test_trap_assert_stderr ("*Trying to get property i with type i but according to the expected interface the type is u*");
+      g_test_trap_assert_failed();
     }
-  g_test_trap_assert_stderr ("*Trying to get property i with type i but according to the expected interface the type is u*");
-  g_test_trap_assert_failed();
 
   /* Even if a property does not exist in expected_interface, looking it
    * up, or setting it, should never fail. Because it could be that the
diff --git a/gio/tests/gdbus-test-codegen.c b/gio/tests/gdbus-test-codegen.c
index 3b4ac76..0dfd37d 100644
--- a/gio/tests/gdbus-test-codegen.c
+++ b/gio/tests/gdbus-test-codegen.c
@@ -2035,16 +2035,14 @@ check_object_manager (void)
    */
   object_proxies = g_dbus_object_manager_get_objects (pm);
   g_assert (g_list_length (object_proxies) == 2);
-  g_list_foreach (object_proxies, (GFunc) g_object_unref, NULL);
-  g_list_free (object_proxies);
+  g_list_free_full (object_proxies, g_object_unref);
   op = g_dbus_object_manager_get_object (pm, "/managed/first");
   g_assert (op != NULL);
   g_assert (FOO_IGEN_IS_OBJECT_PROXY (op));
   g_assert_cmpstr (g_dbus_object_get_object_path (op), ==, "/managed/first");
   proxies = g_dbus_object_get_interfaces (op);
   g_assert (g_list_length (proxies) == 1);
-  g_list_foreach (proxies, (GFunc) g_object_unref, NULL);
-  g_list_free (proxies);
+  g_list_free_full (proxies, g_object_unref);
   p = G_DBUS_PROXY (foo_igen_object_get_com_acme_coyote (FOO_IGEN_OBJECT (op)));
   g_assert (p != NULL);
   g_assert_cmpint (G_TYPE_FROM_INSTANCE (p), ==, FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY);
@@ -2060,8 +2058,7 @@ check_object_manager (void)
   g_assert_cmpstr (g_dbus_object_get_object_path (op), ==, "/managed/second");
   proxies = g_dbus_object_get_interfaces (op);
   g_assert (g_list_length (proxies) == 2);
-  g_list_foreach (proxies, (GFunc) g_object_unref, NULL);
-  g_list_free (proxies);
+  g_list_free_full (proxies, g_object_unref);
   p = G_DBUS_PROXY (foo_igen_object_get_bat (FOO_IGEN_OBJECT (op)));
   g_assert (p != NULL);
   g_assert_cmpint (G_TYPE_FROM_INSTANCE (p), ==, FOO_IGEN_TYPE_BAT_PROXY);
diff --git a/gio/tests/gdbus-threading.c b/gio/tests/gdbus-threading.c
index 1736e60..b46af0b 100644
--- a/gio/tests/gdbus-threading.c
+++ b/gio/tests/gdbus-threading.c
@@ -446,6 +446,133 @@ test_method_calls_in_thread (void)
   g_object_unref (connection);
 }
 
+#define SLEEP_MIN_USEC 1
+#define SLEEP_MAX_USEC 10
+
+/* Can run in any thread */
+static void
+ensure_connection_works (GDBusConnection *conn)
+{
+  GVariant *v;
+  GError *error = NULL;
+
+  v = g_dbus_connection_call_sync (conn, "org.freedesktop.DBus",
+      "/org/freedesktop/DBus", "org.freedesktop.DBus", "GetId", NULL, NULL, 0, -1,
+      NULL, &error);
+  g_assert_no_error (error);
+  g_assert (v != NULL);
+  g_assert (g_variant_is_of_type (v, G_VARIANT_TYPE ("(s)")));
+  g_variant_unref (v);
+}
+
+/*
+ * get_sync_in_thread:
+ * @data: (type guint): delay in microseconds
+ *
+ * Sleep for a short time, then get a session bus connection and call
+ * a method on it.
+ *
+ * Runs in a non-main thread.
+ *
+ * Returns: (transfer full): the connection
+ */
+static gpointer
+get_sync_in_thread (gpointer data)
+{
+  guint delay = GPOINTER_TO_UINT (data);
+  GError *error = NULL;
+  GDBusConnection *conn;
+
+  g_usleep (delay);
+
+  conn = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, &error);
+  g_assert_no_error (error);
+
+  ensure_connection_works (conn);
+
+  return conn;
+}
+
+static void
+test_threaded_singleton (void)
+{
+  guint i, n;
+  guint unref_wins = 0;
+  guint get_wins = 0;
+
+  if (g_test_thorough ())
+    n = 100000;
+  else
+    n = 5000;
+
+  for (i = 0; i < n; i++)
+    {
+      GThread *thread;
+      guint j;
+      guint unref_delay, get_delay;
+      GDBusConnection *new_conn;
+
+      /* We want to be the last ref, so let it finish setting up */
+      for (j = 0; j < 100; j++)
+        {
+          guint r = g_atomic_int_get (&G_OBJECT (c)->ref_count);
+
+          if (r == 1)
+            break;
+
+          g_debug ("run %u: refcount is %u, sleeping", i, r);
+          g_usleep (1000);
+        }
+
+      if (j == 100)
+        g_error ("connection had too many refs");
+
+      if (g_test_verbose () && (i % (n/50)) == 0)
+        g_print ("%u%%\n", ((i * 100) / n));
+
+      /* Delay for a random time on each side of the race, to perturb the
+       * timing. Ideally, we want each side to win half the races; these
+       * timings are about right on smcv's laptop.
+       */
+      unref_delay = g_random_int_range (SLEEP_MIN_USEC, SLEEP_MAX_USEC);
+      get_delay = g_random_int_range (SLEEP_MIN_USEC / 2, SLEEP_MAX_USEC / 2);
+
+      /* One half of the race is to call g_bus_get_sync... */
+      thread = g_thread_new ("get_sync_in_thread", get_sync_in_thread,
+          GUINT_TO_POINTER (get_delay));
+
+      /* ... and the other half is to unref the shared connection, which must
+       * have exactly one ref at this point
+       */
+      g_usleep (unref_delay);
+      g_object_unref (c);
+
+      /* Wait for the thread to run; see what it got */
+      new_conn = g_thread_join (thread);
+
+      /* If the thread won the race, it will have kept the same connection,
+       * and it'll have one ref
+       */
+      if (new_conn == c)
+        {
+          get_wins++;
+        }
+      else
+        {
+          unref_wins++;
+          /* c is invalid now, but new_conn is suitable for the
+           * next round
+           */
+          c = new_conn;
+        }
+
+      ensure_connection_works (c);
+    }
+
+  if (g_test_verbose ())
+    g_print ("Unref won %u races; Get won %u races\n", unref_wins, get_wins);
+}
+
 /* ---------------------------------------------------------------------------------------------------- */
 
 int
@@ -485,6 +612,7 @@ main (int   argc,
 
   g_test_add_func ("/gdbus/delivery-in-thread", test_delivery_in_thread);
   g_test_add_func ("/gdbus/method-calls-in-thread", test_method_calls_in_thread);
+  g_test_add_func ("/gdbus/threaded-singleton", test_threaded_singleton);
 
   ret = g_test_run();
 
diff --git a/gio/tests/gmenumodel.c b/gio/tests/gmenumodel.c
index 8a0cb2c..4253f99 100644
--- a/gio/tests/gmenumodel.c
+++ b/gio/tests/gmenumodel.c
@@ -932,6 +932,46 @@ test_markup_objects (void)
   g_hash_table_unref (objects);
 }
 
+const gchar menu_data2[] =
+  "<menu>"
+  "  <section>"
+  "    <item label='Redo' action='redo'/>"
+  "  </section>"
+  "  <section></section>\n"
+  "  <section label='Copy &amp; Paste'>"
+  "    <item label='Cut' action='cut'/>"
+  "  </section>"
+  "  <section id='section1'>"
+  "    <item label='Bold' action='bold'/>"
+  "    <submenu label='Language' id='submenu1'>"
+  "      <section id='section2'>"
+  "        <item label='Urdu'  action='lang' target='urdu'/>"
+  "      </section>"
+  "    </submenu>"
+  "  </section>"
+  "</menu>";
+static void
+test_markup_ids (void)
+{
+  GMenuModel *a, *b;
+  GHashTable *objects;
+  GError *error = NULL;
+
+  objects = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
+  a = parse_menu_string (menu_data2, objects, &error);
+  g_assert_no_error (error);
+  g_assert (G_IS_MENU_MODEL (a));
+  g_assert_cmpint (g_hash_table_size (objects), ==, 3);
+  b = g_hash_table_lookup (objects, "section1");
+  g_assert (G_IS_MENU_MODEL (b));
+  b = g_hash_table_lookup (objects, "section2");
+  g_assert (G_IS_MENU_MODEL (b));
+  b = g_hash_table_lookup (objects, "submenu1");
+  g_assert (G_IS_MENU_MODEL (b));
+  g_object_unref (a);
+  g_hash_table_unref (objects);
+}
+
 static void
 test_attributes (void)
 {
@@ -1119,6 +1159,7 @@ main (int argc, char **argv)
   g_test_add_func ("/gmenu/dbus/threaded", test_dbus_threaded);
   g_test_add_func ("/gmenu/markup/roundtrip", test_markup_roundtrip);
   g_test_add_func ("/gmenu/markup/objects", test_markup_objects);
+  g_test_add_func ("/gmenu/markup/ids", test_markup_ids);
   g_test_add_func ("/gmenu/attributes", test_attributes);
   g_test_add_func ("/gmenu/links", test_links);
   g_test_add_func ("/gmenu/mutable", test_mutable);
diff --git a/gio/tests/gsettings.c b/gio/tests/gsettings.c
index 645d487..3c42c90 100644
--- a/gio/tests/gsettings.c
+++ b/gio/tests/gsettings.c
@@ -53,7 +53,7 @@ test_basic (void)
   g_free (str);
   str = NULL;
 
-  if (!backend_set)
+  if (!backend_set && g_test_undefined ())
     {
       if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
         {
@@ -85,6 +85,9 @@ test_basic (void)
 static void
 test_unknown_key (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       GSettings *settings;
@@ -107,6 +110,9 @@ test_unknown_key (void)
 static void
 test_no_schema (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       GSettings *settings;
@@ -126,6 +132,9 @@ test_no_schema (void)
 static void
 test_wrong_type (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       GSettings *settings;
@@ -156,6 +165,9 @@ test_wrong_type (void)
 static void
 test_wrong_path (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       GSettings *settings G_GNUC_UNUSED;
@@ -170,6 +182,9 @@ test_wrong_path (void)
 static void
 test_no_path (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       GSettings *settings G_GNUC_UNUSED;
@@ -1233,6 +1248,9 @@ test_directional_binding (void)
 static void
 test_typesafe_binding (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       TestObject *obj;
@@ -1356,18 +1374,21 @@ test_no_change_binding (void)
 static void
 test_no_read_binding (void)
 {
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      TestObject *obj;
-      GSettings *settings;
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          TestObject *obj;
+          GSettings *settings;
 
-      settings = g_settings_new ("org.gtk.test.binding");
-      obj = test_object_new ();
+          settings = g_settings_new ("org.gtk.test.binding");
+          obj = test_object_new ();
 
-      g_settings_bind (settings, "string", obj, "no-read", 0);
+          g_settings_bind (settings, "string", obj, "no-read", 0);
+        }
+      g_test_trap_assert_failed ();
+      g_test_trap_assert_stderr ("*property*is not readable*");
     }
-  g_test_trap_assert_failed ();
-  g_test_trap_assert_stderr ("*property*is not readable*");
 
   if (g_test_trap_fork (0, 0))
     {
@@ -1390,18 +1411,21 @@ test_no_read_binding (void)
 static void
 test_no_write_binding (void)
 {
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      TestObject *obj;
-      GSettings *settings;
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          TestObject *obj;
+          GSettings *settings;
 
-      settings = g_settings_new ("org.gtk.test.binding");
-      obj = test_object_new ();
+          settings = g_settings_new ("org.gtk.test.binding");
+          obj = test_object_new ();
 
-      g_settings_bind (settings, "string", obj, "no-write", 0);
+          g_settings_bind (settings, "string", obj, "no-write", 0);
+        }
+      g_test_trap_assert_failed ();
+      g_test_trap_assert_stderr ("*property*is not writable*");
     }
-  g_test_trap_assert_failed ();
-  g_test_trap_assert_stderr ("*property*is not writable*");
 
   if (g_test_trap_fork (0, 0))
     {
@@ -1562,7 +1586,7 @@ test_enums (void)
   settings = g_settings_new ("org.gtk.test.enums");
   direct = g_settings_new ("org.gtk.test.enums.direct");
 
-  if (!backend_set)
+  if (g_test_undefined () && !backend_set)
     {
       if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
         g_settings_get_enum (direct, "test");
@@ -1620,7 +1644,7 @@ test_flags (void)
   settings = g_settings_new ("org.gtk.test.enums");
   direct = g_settings_new ("org.gtk.test.enums.direct");
 
-  if (!backend_set)
+  if (g_test_undefined () && !backend_set)
     {
       if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
         g_settings_get_flags (direct, "test");
@@ -1690,7 +1714,7 @@ test_range (void)
   settings = g_settings_new ("org.gtk.test.range");
   direct = g_settings_new ("org.gtk.test.range.direct");
 
-  if (!backend_set)
+  if (g_test_undefined () && !backend_set)
     {
       if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
         g_settings_set_int (settings, "val", 45);
diff --git a/gio/tests/send-data.c b/gio/tests/send-data.c
index 01a42b4..201e710 100644
--- a/gio/tests/send-data.c
+++ b/gio/tests/send-data.c
@@ -8,6 +8,7 @@ int cancel_timeout = 0;
 int io_timeout = 0;
 gboolean async = FALSE;
 gboolean graceful = FALSE;
+gboolean verbose = FALSE;
 static GOptionEntry cmd_entries[] = {
   {"cancel", 'c', 0, G_OPTION_ARG_INT, &cancel_timeout,
    "Cancel any op after the specified amount of seconds", NULL},
@@ -17,6 +18,8 @@ static GOptionEntry cmd_entries[] = {
    "Use graceful disconnect", NULL},
   {"timeout", 't', 0, G_OPTION_ARG_INT, &io_timeout,
    "Time out socket I/O after the specified number of seconds", NULL},
+  {"verbose", 'v', 0, G_OPTION_ARG_NONE, &verbose,
+   "Verbose debugging output", NULL},
   {NULL}
 };
 
@@ -56,6 +59,24 @@ async_cb (GObject *source_object,
   g_main_loop_quit (loop);
 }
 
+static void
+socket_client_event (GSocketClient *client,
+		     GSocketClientEvent event,
+		     GSocketConnectable *connectable,
+		     GSocketConnection *connection)
+{
+  static GEnumClass *event_class;
+  GTimeVal tv;
+
+  if (!event_class)
+    event_class = g_type_class_ref (G_TYPE_SOCKET_CLIENT_EVENT);
+
+  g_get_current_time (&tv);
+  printf ("% 12ld.%06ld GSocketClient => %s [%s]\n",
+	  tv.tv_sec, tv.tv_usec,
+	  g_enum_get_value (event_class, event)->value_nick,
+	  connection ? G_OBJECT_TYPE_NAME (connection) : "");
+}
 
 int
 main (int argc, char *argv[])
@@ -103,6 +124,8 @@ main (int argc, char *argv[])
   client = g_socket_client_new ();
   if (io_timeout)
     g_socket_client_set_timeout (client, io_timeout);
+  if (verbose)
+    g_signal_connect (client, "event", G_CALLBACK (socket_client_event), NULL);
 
   if (async)
     {
diff --git a/gio/tests/volumemonitor.c b/gio/tests/volumemonitor.c
index e3fdc3b..4891505 100644
--- a/gio/tests/volumemonitor.c
+++ b/gio/tests/volumemonitor.c
@@ -91,8 +91,7 @@ do_drive_tests (GDrive *drive)
       do_volume_tests (drive, volume);
     }
 
-  g_list_foreach (volumes, (GFunc)g_object_unref,  NULL);
-  g_list_free (volumes);
+  g_list_free_full (volumes, g_object_unref);
 }
 
 static void
@@ -109,8 +108,7 @@ test_connected_drives (void)
       do_drive_tests (drive);
     }
 
-  g_list_foreach (drives, (GFunc)g_object_unref,  NULL);
-  g_list_free (drives);
+  g_list_free_full (drives, g_object_unref);
 }
 
 static void
@@ -131,8 +129,7 @@ test_volumes (void)
         g_object_unref (drive);
     }
 
-  g_list_foreach (volumes, (GFunc)g_object_unref,  NULL);
-  g_list_free (volumes);
+  g_list_free_full (volumes, g_object_unref);
 }
 
 static void
@@ -158,8 +155,7 @@ test_mounts (void)
         g_object_unref (volume);
     }
 
-  g_list_foreach (mounts, (GFunc)g_object_unref,  NULL);
-  g_list_free (mounts);
+  g_list_free_full (mounts, g_object_unref);
 }
 int
 main (int argc, char *argv[])
diff --git a/glib/deprecated/gthread.h b/glib/deprecated/gthread.h
index ef605fa..a0d795d 100644
--- a/glib/deprecated/gthread.h
+++ b/glib/deprecated/gthread.h
@@ -162,7 +162,7 @@ struct _GStaticRecMutex
     pthread_t owner;
 #endif
     gdouble dummy;
-  };
+  } unused;
 };
 
 #define G_STATIC_REC_MUTEX_INIT { G_STATIC_MUTEX_INIT }
diff --git a/glib/gbitlock.c b/glib/gbitlock.c
index 7674f9a..7b879be 100644
--- a/glib/gbitlock.c
+++ b/glib/gbitlock.c
@@ -366,6 +366,12 @@ g_futex_int_address (const volatile void *address)
 {
   const volatile gint *int_address = address;
 
+  /* this implementation makes these (reasonable) assumptions: */
+  G_STATIC_ASSERT (G_BYTE_ORDER == G_LITTLE_ENDIAN ||
+      (G_BYTE_ORDER == G_BIG_ENDIAN &&
+       sizeof (int) == 4 &&
+       (sizeof (gpointer) == 4 || sizeof (gpointer) == 8)));
+
 #if G_BYTE_ORDER == G_BIG_ENDIAN && GLIB_SIZEOF_VOID_P == 8
   int_address++;
 #endif
diff --git a/glib/gbookmarkfile.c b/glib/gbookmarkfile.c
index 0306bc2..4709cdf 100644
--- a/glib/gbookmarkfile.c
+++ b/glib/gbookmarkfile.c
@@ -359,21 +359,8 @@ bookmark_metadata_free (BookmarkMetadata *metadata)
   
   g_free (metadata->mime_type);
     
-  if (metadata->groups)
-    {
-      g_list_foreach (metadata->groups,
-		      (GFunc) g_free,
-		      NULL);
-      g_list_free (metadata->groups);
-    }
-  
-  if (metadata->applications)
-    {
-      g_list_foreach (metadata->applications,
-		      (GFunc) bookmark_app_info_free,
-		      NULL);
-      g_list_free (metadata->applications);
-    }
+  g_list_free_full (metadata->groups, g_free);
+  g_list_free_full (metadata->applications, (GDestroyNotify) bookmark_app_info_free);
 
   g_hash_table_destroy (metadata->apps_by_name);
 
@@ -687,15 +674,8 @@ g_bookmark_file_clear (GBookmarkFile *bookmark)
   g_free (bookmark->title);
   g_free (bookmark->description);
 
-  if (bookmark->items)
-    {
-      g_list_foreach (bookmark->items,
-		      (GFunc) bookmark_item_free,
-		      NULL);
-      g_list_free (bookmark->items);
-      
-      bookmark->items = NULL;
-    }
+  g_list_free_full (bookmark->items, (GDestroyNotify) bookmark_item_free);
+  bookmark->items = NULL;
   
   if (bookmark->items_by_uri)
     {
@@ -2933,14 +2913,8 @@ g_bookmark_file_set_groups (GBookmarkFile  *bookmark,
   if (!item->metadata)
     item->metadata = bookmark_metadata_new ();
 
-  if (item->metadata->groups != NULL)
-    {
-      g_list_foreach (item->metadata->groups,
-		      (GFunc) g_free,
-		      NULL);
-      g_list_free (item->metadata->groups);
-      item->metadata->groups = NULL;
-    }
+  g_list_free_full (item->metadata->groups, g_free);
+  item->metadata->groups = NULL;
   
   if (groups)
     {
diff --git a/glib/gfileutils.c b/glib/gfileutils.c
index 9b603a5..cb306ef 100644
--- a/glib/gfileutils.c
+++ b/glib/gfileutils.c
@@ -1410,7 +1410,7 @@ wrap_mkdir (gchar *tmpl,
  *     to hold the directory name. In case of errors, %NULL is
  *     returned, and %errno will be set.
  *
- * Since: 2.26
+ * Since: 2.30
  */
 gchar *
 g_mkdtemp_full (gchar *tmpl,
@@ -1442,7 +1442,7 @@ g_mkdtemp_full (gchar *tmpl,
  *     to hold the directory name.  In case of errors, %NULL is
  *     returned and %errno will be set.
  *
- * Since: 2.26
+ * Since: 2.30
  */
 gchar *
 g_mkdtemp (gchar *tmpl)
diff --git a/glib/gkeyfile.c b/glib/gkeyfile.c
index 713721f..8de05a2 100644
--- a/glib/gkeyfile.c
+++ b/glib/gkeyfile.c
@@ -3197,14 +3197,8 @@ g_key_file_set_top_comment (GKeyFile     *key_file,
   /* Note all keys must be comments at the top of
    * the file, so we can just free it all.
    */
-  if (group->key_value_pairs != NULL)
-    {
-      g_list_foreach (group->key_value_pairs, 
-                      (GFunc) g_key_file_key_value_pair_free, 
-                      NULL);
-      g_list_free (group->key_value_pairs);
-      group->key_value_pairs = NULL;
-    }
+  g_list_free_full (group->key_value_pairs, (GDestroyNotify) g_key_file_key_value_pair_free);
+  group->key_value_pairs = NULL;
 
   if (comment == NULL)
      return TRUE;
diff --git a/glib/gmain.h b/glib/gmain.h
index e24d6f5..498e108 100644
--- a/glib/gmain.h
+++ b/glib/gmain.h
@@ -119,6 +119,9 @@ typedef struct _GSourceFuncs            GSourceFuncs;
  *
  * On UNIX, processes are identified by a process id (an integer),
  * while Windows uses process handles (which are pointers).
+ *
+ * GPid is used in GLib only for descendant processes spawned with
+ * the g_spawn functions.
  */
 
 /**
diff --git a/glib/goption.c b/glib/goption.c
index 799ea09..c65e84c 100644
--- a/glib/goption.c
+++ b/glib/goption.c
@@ -356,8 +356,7 @@ void g_option_context_free (GOptionContext *context)
 {
   g_return_if_fail (context != NULL);
 
-  g_list_foreach (context->groups, (GFunc)g_option_group_free, NULL);
-  g_list_free (context->groups);
+  g_list_free_full (context->groups, (GDestroyNotify) g_option_group_free);
 
   if (context->main_group)
     g_option_group_free (context->main_group);
diff --git a/glib/gregex.c b/glib/gregex.c
index f8b8701..ffffda7 100644
--- a/glib/gregex.c
+++ b/glib/gregex.c
@@ -835,8 +835,7 @@ g_match_info_expand_references (const GMatchInfo  *match_info,
   result = g_string_sized_new (strlen (string_to_expand));
   interpolate_replacement (match_info, result, list);
 
-  g_list_foreach (list, (GFunc)free_interpolation_data, NULL);
-  g_list_free (list);
+  g_list_free_full (list, (GDestroyNotify) free_interpolation_data);
 
   return g_string_free (result, FALSE);
 }
@@ -2062,8 +2061,7 @@ g_regex_split_full (const GRegex      *regex,
   if (tmp_error != NULL)
     {
       g_propagate_error (error, tmp_error);
-      g_list_foreach (list, (GFunc)g_free, NULL);
-      g_list_free (list);
+      g_list_free_full (list, g_free);
       match_info->pos = -1;
       return NULL;
     }
@@ -2385,8 +2383,7 @@ split_replacement (const gchar  *replacement,
           start = p = expand_escape (replacement, p, data, error);
           if (p == NULL)
             {
-              g_list_foreach (list, (GFunc)free_interpolation_data, NULL);
-              g_list_free (list);
+              g_list_free_full (list, (GDestroyNotify) free_interpolation_data);
               free_interpolation_data (data);
 
               return NULL;
@@ -2617,8 +2614,7 @@ g_regex_replace (const GRegex      *regex,
   if (tmp_error != NULL)
     g_propagate_error (error, tmp_error);
 
-  g_list_foreach (list, (GFunc)free_interpolation_data, NULL);
-  g_list_free (list);
+  g_list_free_full (list, (GDestroyNotify) free_interpolation_data);
 
   return result;
 }
@@ -2827,8 +2823,7 @@ g_regex_check_replacement (const gchar  *replacement,
   if (has_references)
     *has_references = interpolation_list_needs_match (list);
 
-  g_list_foreach (list, (GFunc) free_interpolation_data, NULL);
-  g_list_free (list);
+  g_list_free_full (list, (GDestroyNotify) free_interpolation_data);
 
   return TRUE;
 }
diff --git a/glib/gshell.c b/glib/gshell.c
index 315f502..205519e 100644
--- a/glib/gshell.c
+++ b/glib/gshell.c
@@ -587,12 +587,8 @@ tokenize_command_line (const gchar *command_line,
 
  error:
   g_assert (error == NULL || *error != NULL);
-  
-  if (retval)
-    {
-      g_slist_foreach (retval, (GFunc)g_free, NULL);
-      g_slist_free (retval);
-    }
+
+  g_slist_free_full (retval, g_free);
 
   return NULL;
 }
@@ -667,8 +663,7 @@ g_shell_parse_argv (const gchar *command_line,
       ++i;
     }
   
-  g_slist_foreach (tokens, (GFunc)g_free, NULL);
-  g_slist_free (tokens);
+  g_slist_free_full (tokens, g_free);
   
   if (argcp)
     *argcp = argc;
@@ -684,8 +679,7 @@ g_shell_parse_argv (const gchar *command_line,
 
   g_assert (error == NULL || *error != NULL);
   g_strfreev (argv);
-  g_slist_foreach (tokens, (GFunc) g_free, NULL);
-  g_slist_free (tokens);
+  g_slist_free_full (tokens, g_free);
   
   return FALSE;
 }
diff --git a/glib/gstrfuncs.c b/glib/gstrfuncs.c
index 63e1be9..19365b2 100644
--- a/glib/gstrfuncs.c
+++ b/glib/gstrfuncs.c
@@ -2022,6 +2022,9 @@ g_strcompress (const gchar *source)
             case 't':
               *q++ = '\t';
               break;
+            case 'v':
+              *q++ = '\v';
+              break;
             default:            /* Also handles \" and \\ */
               *q++ = *p;
               break;
@@ -2042,7 +2045,7 @@ out:
  * @source: a string to escape
  * @exceptions: a string of characters not to escape in @source
  *
- * Escapes the special characters '\b', '\f', '\n', '\r', '\t', '\'
+ * Escapes the special characters '\b', '\f', '\n', '\r', '\t', '\v', '\'
  * and '&quot;' in the string @source by inserting a '\' before
  * them. Additionally all characters in the range 0x01-0x1F (everything
  * below SPACE) and in the range 0x7F-0xFF (all non-ASCII chars) are
@@ -2109,6 +2112,10 @@ g_strescape (const gchar *source,
               *q++ = '\\';
               *q++ = 't';
               break;
+            case '\v':
+              *q++ = '\\';
+              *q++ = 'v';
+              break;
             case '\\':
               *q++ = '\\';
               *q++ = '\\';
diff --git a/glib/gtester.c b/glib/gtester.c
index df9d665..e9d695f 100644
--- a/glib/gtester.c
+++ b/glib/gtester.c
@@ -50,6 +50,7 @@ static gboolean     subtest_verbose = FALSE;
 static gboolean     subtest_mode_fatal = TRUE;
 static gboolean     subtest_mode_perf = FALSE;
 static gboolean     subtest_mode_quick = TRUE;
+static gboolean     subtest_mode_undefined = TRUE;
 static const gchar *subtest_seedstr = NULL;
 static gchar       *subtest_last_seed = NULL;
 static GSList      *subtest_paths = NULL;
@@ -307,6 +308,8 @@ launch_test_binary (const char *binary,
     argc++;
   if (subtest_mode_perf)
     argc++;
+  if (!subtest_mode_undefined)
+    argc++;
   if (gtester_list_tests)
     argc++;
   if (subtest_seedstr)
@@ -337,6 +340,8 @@ launch_test_binary (const char *binary,
     argv[i++] = "-m=slow";
   if (subtest_mode_perf)
     argv[i++] = "-m=perf";
+  if (!subtest_mode_undefined)
+    argv[i++] = "-m=no-undefined";
   if (gtester_list_tests)
     argv[i++] = "-l";
   if (subtest_seedstr)
@@ -479,6 +484,7 @@ usage (gboolean just_version)
   g_print ("  -l                          list paths of available test cases\n");
   g_print ("  -m=perf, -m=slow, -m=quick -m=thorough\n");
   g_print ("                              run test cases in mode perf, slow/thorough or quick (default)\n");
+  g_print ("  -m=no-undefined             don't run test cases that provoke assertions\n");
   g_print ("  -p=TESTPATH                 only start test cases matching TESTPATH\n");
   g_print ("  -s=TESTPATH                 skip test cases matching TESTPATH\n");
   g_print ("  --seed=SEEDSTRING           start all tests with random number seed SEEDSTRING\n");
@@ -596,6 +602,10 @@ parse_args (gint    *argc_p,
               subtest_mode_quick = TRUE;
               subtest_mode_perf = FALSE;
             }
+          else if (strcmp (mode, "undefined") == 0)
+            subtest_mode_undefined = TRUE;
+          else if (strcmp (mode, "no-undefined") == 0)
+            subtest_mode_undefined = FALSE;
           else
             g_error ("unknown test mode: -m %s", mode);
           argv[i] = NULL;
diff --git a/glib/gtestutils.c b/glib/gtestutils.c
index ddc880a..3406d43 100644
--- a/glib/gtestutils.c
+++ b/glib/gtestutils.c
@@ -107,6 +107,8 @@
  * g_test_quick:
  *
  * Returns %TRUE if tests are run in quick mode.
+ * Exactly one of g_test_quick() and g_test_slow() is active in any run;
+ * there is no "medium speed".
  *
  * Returns: %TRUE if in quick mode
  */
@@ -115,16 +117,19 @@
  * g_test_slow:
  *
  * Returns %TRUE if tests are run in slow mode.
+ * Exactly one of g_test_quick() and g_test_slow() is active in any run;
+ * there is no "medium speed".
  *
- * Returns: %TRUE if in slow mode
+ * Returns: the opposite of g_test_quick()
  */
 
 /**
  * g_test_thorough:
  *
- * Returns %TRUE if tests are run in thorough mode.
+ * Returns %TRUE if tests are run in thorough mode, equivalent to
+ * g_test_slow().
  *
- * Returns: %TRUE if in thorough mode
+ * Returns: the same thing as g_test_slow()
  */
 
 /**
@@ -136,9 +141,21 @@
  */
 
 /**
+ * g_test_undefined:
+ *
+ * Returns %TRUE if tests may provoke assertions and other formally-undefined
+ * behaviour under g_test_trap_fork(), to verify that appropriate warnings
+ * are given. It can be useful to turn this off if running tests under
+ * valgrind.
+ *
+ * Returns: %TRUE if tests may provoke programming errors
+ */
+
+/**
  * g_test_verbose:
  *
  * Returns %TRUE if tests are run in verbose mode.
+ * The default is neither g_test_verbose() nor g_test_quiet().
  *
  * Returns: %TRUE if in verbose mode
  */
@@ -147,8 +164,9 @@
  * g_test_quiet:
  *
  * Returns %TRUE if tests are run in quiet mode.
+ * The default is neither g_test_verbose() nor g_test_quiet().
  *
- * Returns: %TRUE if in quied mode
+ * Returns: %TRUE if in quiet mode
  */
 
 /**
@@ -489,6 +507,7 @@ static GTestConfig mutable_test_config_vars = {
   FALSE,        /* test_perf */
   FALSE,        /* test_verbose */
   FALSE,        /* test_quiet */
+  TRUE,         /* test_undefined */
 };
 const GTestConfig * const g_test_config_vars = &mutable_test_config_vars;
 
@@ -715,6 +734,10 @@ parse_args (gint    *argc_p,
               mutable_test_config_vars.test_quick = TRUE;
               mutable_test_config_vars.test_perf = FALSE;
             }
+          else if (strcmp (mode, "undefined") == 0)
+            mutable_test_config_vars.test_undefined = TRUE;
+          else if (strcmp (mode, "no-undefined") == 0)
+            mutable_test_config_vars.test_undefined = FALSE;
           else
             g_error ("unknown test mode: -m %s", mode);
           argv[i] = NULL;
@@ -763,6 +786,7 @@ parse_args (gint    *argc_p,
                   "  -p TESTPATH                    execute all tests matching TESTPATH\n"
                   "  -s TESTPATH                    skip all tests matching TESTPATH\n"
                   "  -m {perf|slow|thorough|quick}  Execute tests according modes\n"
+                  "  -m {undefined|no-undefined}    Execute tests according modes\n"
                   "  --debug-log                    debug test logging output\n"
                   "  -k, --keep-going               gtester-specific argument\n"
                   "  --GTestLogFD=N                 gtester-specific argument\n"
@@ -823,7 +847,7 @@ parse_args (gint    *argc_p,
  *       </para></listitem>
  *     </varlistentry>
  *     <varlistentry>
- *       <term><option>-m {perf|slow|thorough|quick}</option></term>
+ *       <term><option>-m {perf|slow|thorough|quick|undefined|no-undefined}</option></term>
  *       <listitem><para>
  *         execute tests according to these test modes:
  *         <variablelist>
@@ -846,6 +870,20 @@ parse_args (gint    *argc_p,
  *               quick tests, should run really quickly and give good coverage.
  *             </para></listitem>
  *           </varlistentry>
+ *           <varlistentry>
+ *             <term>undefined</term>
+ *             <listitem><para>
+ *               tests for undefined behaviour, may provoke programming errors
+ *               under g_test_trap_fork() to check that appropriate assertions
+ *               or warnings are given
+ *             </para></listitem>
+ *           </varlistentry>
+ *           <varlistentry>
+ *             <term>no-undefined</term>
+ *             <listitem><para>
+ *               avoid tests for undefined behaviour
+ *             </para></listitem>
+ *           </varlistentry>
  *         </variablelist>
  *       </para></listitem>
  *     </varlistentry>
diff --git a/glib/gtestutils.h b/glib/gtestutils.h
index 0184c7c..3cd173c 100644
--- a/glib/gtestutils.h
+++ b/glib/gtestutils.h
@@ -98,6 +98,7 @@ void    g_test_init                     (int            *argc,
 #define g_test_perf()                   (g_test_config_vars->test_perf)
 #define g_test_verbose()                (g_test_config_vars->test_verbose)
 #define g_test_quiet()                  (g_test_config_vars->test_quiet)
+#define g_test_undefined()              (g_test_config_vars->test_undefined)
 /* run all tests under toplevel suite (path: /) */
 int     g_test_run                      (void);
 /* hook up a test functions under test path */
@@ -234,6 +235,7 @@ typedef struct {
   gboolean      test_perf;      /* run performance tests */
   gboolean      test_verbose;   /* extra info */
   gboolean      test_quiet;     /* reduce output */
+  gboolean      test_undefined; /* run tests that are meant to assert */
 } GTestConfig;
 GLIB_VAR const GTestConfig * const g_test_config_vars;
 
diff --git a/glib/gthread-win32.c b/glib/gthread-win32.c
index 29065b5..94a56e2 100644
--- a/glib/gthread-win32.c
+++ b/glib/gthread-win32.c
@@ -520,8 +520,9 @@ static DWORD            g_thread_xp_waiter_tls;
 typedef struct _GThreadXpWaiter GThreadXpWaiter;
 struct _GThreadXpWaiter
 {
-  HANDLE                    event;
-  volatile GThreadXpWaiter *next;
+  HANDLE                     event;
+  volatile GThreadXpWaiter  *next;
+  volatile GThreadXpWaiter **my_owner;
 };
 
 static GThreadXpWaiter *
@@ -539,6 +540,7 @@ g_thread_xp_waiter_get (void)
       waiter->event = CreateEvent (0, FALSE, FALSE, NULL);
       if (waiter->event == NULL)
         g_thread_abort (GetLastError (), "CreateEvent");
+      waiter->my_owner = NULL;
 
       TlsSetValue (g_thread_xp_waiter_tls, waiter);
     }
@@ -848,6 +850,7 @@ g_thread_xp_SleepConditionVariableSRW (gpointer cond,
   waiter->next = NULL;
 
   EnterCriticalSection (&g_thread_xp_lock);
+  waiter->my_owner = cv->last_ptr;
   *cv->last_ptr = waiter;
   cv->last_ptr = &waiter->next;
   LeaveCriticalSection (&g_thread_xp_lock);
@@ -857,9 +860,23 @@ g_thread_xp_SleepConditionVariableSRW (gpointer cond,
 
   if (status != WAIT_TIMEOUT && status != WAIT_OBJECT_0)
     g_thread_abort (GetLastError (), "WaitForSingleObject");
-
   g_mutex_lock (mutex);
 
+  if (status == WAIT_TIMEOUT)
+    {
+      EnterCriticalSection (&g_thread_xp_lock);
+      if (waiter->my_owner)
+        {
+          if (waiter->next)
+            waiter->next->my_owner = waiter->my_owner;
+          else
+            cv->last_ptr = waiter->my_owner;
+          *waiter->my_owner = waiter->next;
+          waiter->my_owner = NULL;
+        }
+      LeaveCriticalSection (&g_thread_xp_lock);
+    }
+
   return status == WAIT_OBJECT_0;
 }
 
@@ -870,17 +887,22 @@ g_thread_xp_WakeConditionVariable (gpointer cond)
   volatile GThreadXpWaiter *waiter;
 
   EnterCriticalSection (&g_thread_xp_lock);
+
   waiter = cv->first;
   if (waiter != NULL)
     {
+      waiter->my_owner = NULL;
       cv->first = waiter->next;
-      if (cv->first == NULL)
+      if (cv->first != NULL)
+        cv->first->my_owner = &cv->first;
+      else
         cv->last_ptr = &cv->first;
     }
-  LeaveCriticalSection (&g_thread_xp_lock);
 
   if (waiter != NULL)
     SetEvent (waiter->event);
+
+  LeaveCriticalSection (&g_thread_xp_lock);
 }
 
 static void __stdcall
@@ -890,10 +912,10 @@ g_thread_xp_WakeAllConditionVariable (gpointer cond)
   volatile GThreadXpWaiter *waiter;
 
   EnterCriticalSection (&g_thread_xp_lock);
+
   waiter = cv->first;
   cv->first = NULL;
   cv->last_ptr = &cv->first;
-  LeaveCriticalSection (&g_thread_xp_lock);
 
   while (waiter != NULL)
     {
@@ -901,8 +923,11 @@ g_thread_xp_WakeAllConditionVariable (gpointer cond)
 
       next = waiter->next;
       SetEvent (waiter->event);
+      waiter->my_owner = NULL;
       waiter = next;
     }
+
+  LeaveCriticalSection (&g_thread_xp_lock);
 }
 
 /* {{{2 XP Setup */
diff --git a/glib/gutf8.c b/glib/gutf8.c
index a7bc343..e1e0003 100644
--- a/glib/gutf8.c
+++ b/glib/gutf8.c
@@ -220,10 +220,12 @@ g_utf8_prev_char (const gchar *p)
  * @max: the maximum number of bytes to examine. If @max
  *       is less than 0, then the string is assumed to be
  *       nul-terminated. If @max is 0, @p will not be examined and
- *       may be %NULL.
+ *       may be %NULL. If @max is greater than 0, up to @max
+ *       bytes are examined
  *
  * Computes the length of the string in characters, not including
- * the terminating nul character.
+ * the terminating nul character. If the @max'th byte falls in the
+ * middle of a character, the last (partial) character is not counted.
  *
  * Return value: the length of the string in characters
  **/
@@ -1606,7 +1608,7 @@ fast_validate_len (const char *str,
  * being validated otherwise).
  *
  * Note that g_utf8_validate() returns %FALSE if @max_len is 
- * positive and NUL is met before @max_len bytes have been read.
+ * positive and any of the @max_len bytes are NUL.
  *
  * Returns %TRUE if all of @str was valid. Many GLib and GTK+
  * routines <emphasis>require</emphasis> valid UTF-8 as input;
diff --git a/glib/gutils.c b/glib/gutils.c
index 4b77dbc..4992ecc 100644
--- a/glib/gutils.c
+++ b/glib/gutils.c
@@ -252,8 +252,7 @@ g_memmove (gpointer      dest,
  * calling g_atexit() (or atexit()) except in the main executable of a
  * program.
  *
- * Deprecated:2.32: It is best to avoid g_atexit(), for the reasons
- *     outlined above.
+ * Deprecated:2.32: It is best to avoid g_atexit().
  */
 void
 g_atexit (GVoidFunc func)
diff --git a/glib/gvariant.c b/glib/gvariant.c
index 5a4d43b..22341ff 100644
--- a/glib/gvariant.c
+++ b/glib/gvariant.c
@@ -4872,6 +4872,10 @@ g_variant_iter_next (GVariantIter *iter,
  * function and g_variant_iter_next() or g_variant_iter_next_value() on
  * the same iterator causes undefined behavior.
  *
+ * If you break out of a such a while loop using g_variant_iter_loop() then
+ * you must free or unreference all the unpacked values as you would with
+ * g_variant_get(). Failure to do so will cause a memory leak.
+ *
  * See the section on <link linkend='gvariant-format-strings'>GVariant
  * Format Strings</link>.
  *
@@ -4893,6 +4897,7 @@ g_variant_iter_next (GVariantIter *iter,
  *                  g_variant_get_type_string (value));
  *
  *         /<!-- -->* no need to free 'key' and 'value' here *<!-- -->/
+ *         /<!-- -->* unless breaking out of this loop *<!-- -->/
  *       }
  *   }
  *  </programlisting>
diff --git a/glib/tests/error.c b/glib/tests/error.c
index f483092..66ec6e0 100644
--- a/glib/tests/error.c
+++ b/glib/tests/error.c
@@ -3,6 +3,9 @@
 static void
 test_overwrite (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       GError *error;
diff --git a/glib/tests/gvariant.c b/glib/tests/gvariant.c
index 18fe2fe..c328aa8 100644
--- a/glib/tests/gvariant.c
+++ b/glib/tests/gvariant.c
@@ -2831,6 +2831,9 @@ do_failed_test (const gchar *pattern)
 static void
 test_invalid_varargs (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (do_failed_test ("*GVariant format string*"))
     {
       g_variant_new ("z");
@@ -3871,22 +3874,25 @@ test_parse_positional (void)
   check_and_free (value, "[('one', 1), ('two', 2), ('three', 3)]");
   check_and_free (g_variant_new_parsed ("{%s:%i}", "one", 1), "{'one': 1}");
 
-  if (do_failed_test ("*GVariant format string*"))
+  if (g_test_undefined ())
     {
-      g_variant_new_parsed ("%z");
-      abort ();
-    }
+      if (do_failed_test ("*GVariant format string*"))
+        {
+          g_variant_new_parsed ("%z");
+          abort ();
+        }
 
-  if (do_failed_test ("*can not parse as*"))
-    {
-      g_variant_new_parsed ("uint32 %i", 2);
-      abort ();
-    }
+      if (do_failed_test ("*can not parse as*"))
+        {
+          g_variant_new_parsed ("uint32 %i", 2);
+          abort ();
+        }
 
-  if (do_failed_test ("*expected GVariant of type `i'*"))
-    {
-      g_variant_new_parsed ("%@i", g_variant_new_uint32 (2));
-      abort ();
+      if (do_failed_test ("*expected GVariant of type `i'*"))
+        {
+          g_variant_new_parsed ("%@i", g_variant_new_uint32 (2));
+          abort ();
+        }
     }
 }
 
diff --git a/glib/tests/hash.c b/glib/tests/hash.c
index 716bfa2..492e89f 100644
--- a/glib/tests/hash.c
+++ b/glib/tests/hash.c
@@ -32,11 +32,9 @@
 #  include <config.h>
 #endif
 
-#if STDC_HEADERS
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
-#endif
 
 #include <glib.h>
 
diff --git a/glib/tests/logging.c b/glib/tests/logging.c
index 9d69e6a..aece490 100644
--- a/glib/tests/logging.c
+++ b/glib/tests/logging.c
@@ -5,6 +5,9 @@
 static void
 test_warnings (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       g_warn_if_reached ();
@@ -62,29 +65,32 @@ test_set_handler (void)
 static void
 test_default_handler (void)
 {
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
-    {
-      g_error ("message1");
-      exit (0);
-    }
-  g_test_trap_assert_failed ();
-  g_test_trap_assert_stderr ("*ERROR*message1*");
-
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
-    {
-      g_critical ("message2");
-      exit (0);
-    }
-  g_test_trap_assert_failed ();
-  g_test_trap_assert_stderr ("*CRITICAL*message2*");
-
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      g_warning ("message3");
-      exit (0);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_error ("message1");
+          exit (0);
+        }
+      g_test_trap_assert_failed ();
+      g_test_trap_assert_stderr ("*ERROR*message1*");
+
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_critical ("message2");
+          exit (0);
+        }
+      g_test_trap_assert_failed ();
+      g_test_trap_assert_stderr ("*CRITICAL*message2*");
+
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_warning ("message3");
+          exit (0);
+        }
+      g_test_trap_assert_failed ();
+      g_test_trap_assert_stderr ("*WARNING*message3*");
     }
-  g_test_trap_assert_failed ();
-  g_test_trap_assert_stderr ("*WARNING*message3*");
 
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
@@ -146,6 +152,9 @@ test_fatal_log_mask (void)
 {
   GLogLevelFlags flags;
 
+  if (!g_test_undefined ())
+    return;
+
   flags = g_log_set_fatal_mask ("bu", G_LOG_LEVEL_INFO);
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT))
     g_log ("bu", G_LOG_LEVEL_INFO, "fatal");
@@ -233,6 +242,9 @@ test_handler (const gchar    *log_domain,
 static void
 bug653052 (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   g_test_bug ("653052");
 
   g_test_log_set_fatal_handler (good_failure_handler, fail_str);
diff --git a/glib/tests/markup-collect.c b/glib/tests/markup-collect.c
index 74ce2bf..3b2e2bd 100644
--- a/glib/tests/markup-collect.c
+++ b/glib/tests/markup-collect.c
@@ -197,6 +197,9 @@ static GMarkupParser cleanup_parser = {
 static void
 test_cleanup (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       GMarkupParseContext *context;
diff --git a/glib/tests/mem-overflow.c b/glib/tests/mem-overflow.c
index 0d483fb..c7ea218 100644
--- a/glib/tests/mem-overflow.c
+++ b/glib/tests/mem-overflow.c
@@ -73,7 +73,18 @@ mem_overflow (void)
 #undef CHECK_FAIL
 #undef CHECK_PASS
 
-#define CHECK_FAIL(P)	if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR)) { p = (P); exit (0); } g_test_trap_assert_failed();
+#define CHECK_FAIL(P)	do { \
+      if (g_test_undefined ()) \
+        { \
+          if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR)) \
+            { \
+              p = (P); \
+              exit (0); \
+            } \
+          \
+          g_test_trap_assert_failed(); \
+        } \
+    } while (0)
 
 #define CHECK_PASS(P)	do { \
       if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR)) \
diff --git a/glib/tests/option-context.c b/glib/tests/option-context.c
index 20b1ee3..ba8fcf1 100644
--- a/glib/tests/option-context.c
+++ b/glib/tests/option-context.c
@@ -2077,6 +2077,9 @@ test_error_hook (void)
 static void
 flag_reverse_string (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       GOptionContext *context;
@@ -2108,6 +2111,9 @@ flag_reverse_string (void)
 static void
 flag_optional_int (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       GOptionContext *context;
diff --git a/glib/tests/private.c b/glib/tests/private.c
index c21aacf..cacf3f5 100644
--- a/glib/tests/private.c
+++ b/glib/tests/private.c
@@ -114,6 +114,7 @@ private3_free (gpointer data)
 
 #ifdef G_OS_WIN32
 #include <windows.h>
+#include <process.h>
 
 static guint __stdcall
 #else
@@ -139,7 +140,7 @@ test_private3 (void)
   {
     HANDLE thread;
     guint ignore;
-    thread = _beginthreadex (NULL, 0, private3_func, NULL, 0, &ignore);
+    thread = (HANDLE) _beginthreadex (NULL, 0, private3_func, NULL, 0, &ignore);
     WaitForSingleObject (thread, INFINITE);
     CloseHandle (thread);
   }
diff --git a/glib/tests/regex.c b/glib/tests/regex.c
index 7f7cc65..b256cb4 100644
--- a/glib/tests/regex.c
+++ b/glib/tests/regex.c
@@ -268,8 +268,7 @@ test_match_next (gconstpointer d)
     }
 
   g_regex_unref (regex);
-  g_slist_foreach (matches, free_match, NULL);
-  g_slist_free (matches);
+  g_slist_free_full (matches, free_match);
 }
 
 #define TEST_MATCH_NEXT0(_pattern, _string, _string_len, _start_position) { \
@@ -2298,6 +2297,9 @@ main (int argc, char *argv[])
   TEST_MATCH("a#\nb", G_REGEX_EXTENDED, G_REGEX_MATCH_NEWLINE_CR, "a", -1, 0, 0, FALSE);
   TEST_MATCH("a#\nb", G_REGEX_EXTENDED | G_REGEX_NEWLINE_CR, 0, "a", -1, 0, 0, TRUE);
 
+  /* This failed with PCRE 7.2 (gnome bug #455640) */
+  TEST_MATCH(".*$", 0, 0, "\xe1\xbb\x85", -1, 0, 0, TRUE);
+
   /* TEST_MATCH_NEXT#(pattern, string, string_len, start_position, ...) */
   TEST_MATCH_NEXT0("a", "x", -1, 0);
   TEST_MATCH_NEXT0("a", "ax", -1, 1);
diff --git a/glib/tests/slice.c b/glib/tests/slice.c
index 9f4670c..7976e51 100644
--- a/glib/tests/slice.c
+++ b/glib/tests/slice.c
@@ -3,6 +3,9 @@
 static void
 test_slice_config (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (1000000, G_TEST_TRAP_SILENCE_STDERR))
     g_slice_set_config (G_SLICE_CONFIG_ALWAYS_MALLOC, TRUE);
 
diff --git a/glib/tests/strfuncs.c b/glib/tests/strfuncs.c
index d5e4f4c..358bc58 100644
--- a/glib/tests/strfuncs.c
+++ b/glib/tests/strfuncs.c
@@ -327,19 +327,22 @@ test_strcanon (void)
 {
   gchar *str;
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      str = g_strcanon (NULL, "ab", 'y');
-    }
-  g_test_trap_assert_failed ();
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          str = g_strcanon (NULL, "ab", 'y');
+        }
+      g_test_trap_assert_failed ();
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
-    {
-      str = g_strdup ("abxabxab");
-      str = g_strcanon (str, NULL, 'y');
-      g_free (str);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          str = g_strdup ("abxabxab");
+          str = g_strcanon (str, NULL, 'y');
+          g_free (str);
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   str = g_strdup ("abxabxab");
   str = g_strcanon (str, "ab", 'y');
@@ -355,47 +358,53 @@ test_strcompress_strescape (void)
   gchar *tmp;
 
   /* test compress */
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      str = g_strcompress (NULL);
-    }
-  g_test_trap_assert_failed ();
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          str = g_strcompress (NULL);
+        }
+      g_test_trap_assert_failed ();
 
-  /* trailing slashes are not allowed */
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
-    {
-      str = g_strcompress ("abc\\");
+      /* trailing slashes are not allowed */
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          str = g_strcompress ("abc\\");
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
-  str = g_strcompress ("abc\\\\\\\"\\b\\f\\n\\r\\t\\003\\177\\234\\313\\12345z");
+  str = g_strcompress ("abc\\\\\\\"\\b\\f\\n\\r\\t\\v\\003\\177\\234\\313\\12345z");
   g_assert (str != NULL);
-  g_assert_cmpstr (str, ==, "abc\\\"\b\f\n\r\t\003\177\234\313\12345z");
+  g_assert_cmpstr (str, ==, "abc\\\"\b\f\n\r\t\v\003\177\234\313\12345z");
   g_free (str);
 
   /* test escape */
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      str = g_strescape (NULL, NULL);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          str = g_strescape (NULL, NULL);
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
-  str = g_strescape ("abc\\\"\b\f\n\r\t\003\177\234\313", NULL);
+  str = g_strescape ("abc\\\"\b\f\n\r\t\v\003\177\234\313", NULL);
   g_assert (str != NULL);
-  g_assert_cmpstr (str, ==, "abc\\\\\\\"\\b\\f\\n\\r\\t\\003\\177\\234\\313");
+  g_assert_cmpstr (str, ==, "abc\\\\\\\"\\b\\f\\n\\r\\t\\v\\003\\177\\234\\313");
   g_free (str);
 
-  str = g_strescape ("abc\\\"\b\f\n\r\t\003\177\234\313",
+  str = g_strescape ("abc\\\"\b\f\n\r\t\v\003\177\234\313",
 		     "\b\f\001\002\003\004");
   g_assert (str != NULL);
-  g_assert_cmpstr (str, ==, "abc\\\\\\\"\b\f\\n\\r\\t\003\\177\\234\\313");
+  g_assert_cmpstr (str, ==, "abc\\\\\\\"\b\f\\n\\r\\t\\v\003\\177\\234\\313");
   g_free (str);
 
   /* round trip */
-  tmp = g_strescape ("abc\\\"\b\f\n\r\t\003\177\234\313", NULL);
+  tmp = g_strescape ("abc\\\"\b\f\n\r\t\v\003\177\234\313", NULL);
   str = g_strcompress (tmp);
   g_assert (str != NULL); 
-  g_assert_cmpstr (str, ==, "abc\\\"\b\f\n\r\t\003\177\234\313");
+  g_assert_cmpstr (str, ==, "abc\\\"\b\f\n\r\t\v\003\177\234\313");
   g_free (str);
   g_free (tmp);
 }
@@ -405,17 +414,20 @@ test_ascii_strcasecmp (void)
 {
   gboolean res;
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      res = g_ascii_strcasecmp ("foo", NULL);
-    }
-  g_test_trap_assert_failed ();
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          res = g_ascii_strcasecmp ("foo", NULL);
+        }
+      g_test_trap_assert_failed ();
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
-    {
-      res = g_ascii_strcasecmp (NULL, "foo");
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          res = g_ascii_strcasecmp (NULL, "foo");
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   res = g_ascii_strcasecmp ("FroboZZ", "frobozz");
   g_assert_cmpint (res, ==, 0);
@@ -478,11 +490,14 @@ do_test_strchug (const gchar *str, const gchar *expected)
 static void
 test_strchug (void)
 {
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      g_strchug (NULL);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_strchug (NULL);
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   do_test_strchug ("", "");
   do_test_strchug (" ", "");
@@ -511,11 +526,14 @@ do_test_strchomp (const gchar *str, const gchar *expected)
 static void
 test_strchomp (void)
 {
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      g_strchomp (NULL);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_strchomp (NULL);
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   do_test_strchomp ("", "");
   do_test_strchomp (" ", "");
@@ -532,11 +550,14 @@ test_strreverse (void)
   gchar *str;
   gchar *p;
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      str = g_strreverse (NULL);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          str = g_strreverse (NULL);
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   str = p = g_strdup ("abcde");
   str = g_strreverse (str);
@@ -626,17 +647,20 @@ test_has_prefix (void)
 {
   gboolean res;
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      res = g_str_has_prefix ("foo", NULL);
-    }
-  g_test_trap_assert_failed ();
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          res = g_str_has_prefix ("foo", NULL);
+        }
+      g_test_trap_assert_failed ();
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
-    {
-      res = g_str_has_prefix (NULL, "foo");
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          res = g_str_has_prefix (NULL, "foo");
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   res = g_str_has_prefix ("foo", "bar");
   g_assert_cmpint (res, ==, FALSE);
@@ -665,17 +689,20 @@ test_has_suffix (void)
 {
   gboolean res;
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      res = g_str_has_suffix ("foo", NULL);
-    }
-  g_test_trap_assert_failed ();
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          res = g_str_has_suffix ("foo", NULL);
+        }
+      g_test_trap_assert_failed ();
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
-    {
-      res = g_str_has_suffix (NULL, "foo");
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          res = g_str_has_suffix (NULL, "foo");
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   res = g_str_has_suffix ("foo", "bar");
   g_assert_cmpint (res, ==, FALSE);
@@ -844,11 +871,14 @@ test_strv_length (void)
   gchar **strv;
   guint l;
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      l = g_strv_length (NULL);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          l = g_strv_length (NULL);
+        }
+      g_test_trap_assert_failed ();
     }
-  g_test_trap_assert_failed ();
 
   strv = g_strsplit ("1,2,3,4", ",", -1);
   l = g_strv_length (strv);
diff --git a/glib/tests/testing.c b/glib/tests/testing.c
index 2b257f2..d6e39ba 100644
--- a/glib/tests/testing.c
+++ b/glib/tests/testing.c
@@ -46,19 +46,22 @@ test_assertions (void)
   g_assert_cmpstr ("fzz", >, "faa");
   g_assert_cmpstr ("fzz", ==, "fzz");
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+  if (g_test_undefined ())
     {
-      g_assert_cmpstr ("fzz", !=, "fzz");
-    }
-  g_test_trap_assert_failed ();
-  g_test_trap_assert_stderr ("*assertion failed*");
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_assert_cmpstr ("fzz", !=, "fzz");
+        }
+      g_test_trap_assert_failed ();
+      g_test_trap_assert_stderr ("*assertion failed*");
 
-  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
-    {
-      g_assert_cmpint (4, !=, 4);
+      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
+        {
+          g_assert_cmpint (4, !=, 4);
+        }
+      g_test_trap_assert_failed ();
+      g_test_trap_assert_stderr ("*assertion failed*");
     }
-  g_test_trap_assert_failed ();
-  g_test_trap_assert_stderr ("*assertion failed*");
 }
 
 /* test g_test_timer* API */
@@ -80,6 +83,9 @@ test_timer (void)
 static void
 test_fork_fail (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
       g_assert_not_reached();
@@ -107,6 +113,9 @@ test_fork_patterns (void)
 static void
 test_fork_timeout (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   /* allow child to run for only a fraction of a second */
   if (g_test_trap_fork (0.11 * 1000000, 0))
     {
@@ -217,6 +226,9 @@ fatal_handler (const gchar    *log_domain,
 static void
 test_fatal_log_handler (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   g_test_log_set_fatal_handler (fatal_handler, NULL);
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDERR))
     {
diff --git a/gobject/gobject.c b/gobject/gobject.c
index 166faac..88fb7ef 100644
--- a/gobject/gobject.c
+++ b/gobject/gobject.c
@@ -200,6 +200,9 @@ static gulong	            gobject_signals[LAST_SIGNAL] = { 0, };
 static guint (*floating_flag_handler) (GObject*, gint) = object_floating_flag_handler;
 G_LOCK_DEFINE_STATIC (construction_mutex);
 static GSList *construction_objects = NULL;
+/* qdata pointing to GSList<GWeakRef *>, protected by weak_locations_lock */
+static GQuark	            quark_weak_locations = 0;
+static GRWLock              weak_locations_lock;
 
 G_LOCK_DEFINE_STATIC(notify_lock);
 
@@ -434,6 +437,7 @@ g_object_do_class_init (GObjectClass *class)
   quark_closure_array = g_quark_from_static_string ("GObject-closure-array");
 
   quark_weak_refs = g_quark_from_static_string ("GObject-weak-references");
+  quark_weak_locations = g_quark_from_static_string ("GObject-weak-locations");
   quark_toggle_refs = g_quark_from_static_string ("GObject-toggle-references");
   quark_notify_queue = g_quark_from_static_string ("GObject-notify-queue");
   pspec_pool = g_param_spec_pool_new (TRUE);
@@ -530,6 +534,7 @@ g_object_class_install_property (GObjectClass *class,
 
   class->flags |= CLASS_HAS_PROPS_FLAG;
 
+  g_return_if_fail (pspec->flags & (G_PARAM_READABLE | G_PARAM_WRITABLE));
   if (pspec->flags & G_PARAM_WRITABLE)
     g_return_if_fail (class->set_property != NULL);
   if (pspec->flags & G_PARAM_READABLE)
@@ -705,7 +710,13 @@ g_object_interface_install_property (gpointer      g_iface,
   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
   g_return_if_fail (!G_IS_PARAM_SPEC_OVERRIDE (pspec)); /* paranoid */
   g_return_if_fail (PARAM_SPEC_PARAM_ID (pspec) == 0);	/* paranoid */
-		    
+
+  g_return_if_fail (pspec->flags & (G_PARAM_READABLE | G_PARAM_WRITABLE));
+  if (pspec->flags & G_PARAM_CONSTRUCT)
+    g_return_if_fail ((pspec->flags & G_PARAM_CONSTRUCT_ONLY) == 0);
+  if (pspec->flags & (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY))
+    g_return_if_fail (pspec->flags & G_PARAM_WRITABLE);
+
   install_property_internal (iface_class->g_type, 0, pspec);
 }
 
@@ -1373,49 +1384,112 @@ object_interface_check_properties (gpointer func_data,
 	  continue;
 	}
 
-      /* The implementation paramspec must have a less restrictive
-       * type than the interface parameter spec for set() and a
-       * more restrictive type for get(). We just require equality,
-       * rather than doing something more complicated checking
-       * the READABLE and WRITABLE flags. We also simplify here
-       * by only checking the value type, not the G_PARAM_SPEC_TYPE.
+      /* We do a number of checks on the properties of an interface to
+       * make sure that all classes implementing the interface are
+       * overriding the properties in a sane way.
+       *
+       * We do the checks in order of importance so that we can give
+       * more useful error messages first.
+       *
+       * First, we check that the implementation doesn't remove the
+       * basic functionality (readability, writability) advertised by
+       * the interface.  Next, we check that it doesn't introduce
+       * additional restrictions (such as construct-only).  Finally, we
+       * make sure the types are compatible.
        */
-      if (class_pspec &&
-	  !g_type_is_a (pspecs[n]->value_type,
-			class_pspec->value_type))
-	{
-	  g_critical ("Property '%s' on class '%s' has type '%s' "
-		      "which is different from the type '%s', "
-		      "of the property on interface '%s'\n",
-		      pspecs[n]->name,
-		      g_type_name (G_OBJECT_CLASS_TYPE (class)),
-		      g_type_name (G_PARAM_SPEC_VALUE_TYPE (class_pspec)),
-		      g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspecs[n])),
-		      g_type_name (iface_type));
-	}
 
 #define SUBSET(a,b,mask) (((a) & ~(b) & (mask)) == 0)
+      /* If the property on the interface is readable then the
+       * implementation must be readable.  If the interface is writable
+       * then the implementation must be writable.
+       */
+      if (!SUBSET (pspecs[n]->flags, class_pspec->flags, G_PARAM_READABLE | G_PARAM_WRITABLE))
+        {
+          g_critical ("Flags for property '%s' on class '%s' remove functionality compared with the "
+                      "property on interface '%s'\n", pspecs[n]->name,
+                      g_type_name (G_OBJECT_CLASS_TYPE (class)), g_type_name (iface_type));
+          continue;
+        }
 
-      /* CONSTRUCT and CONSTRUCT_ONLY add restrictions.
-       * READABLE and WRITABLE remove restrictions. The implementation
-       * paramspec must have less restrictive flags.
+      /* If the property on the interface is writable then we need to
+       * make sure the implementation doesn't introduce new restrictions
+       * on that writability (ie: construct-only).
+       *
+       * If the interface was not writable to begin with then we don't
+       * really have any problems here because "writable at construct
+       * type only" is still more permissive than "read only".
        */
-      if (class_pspec &&
-	  (!SUBSET (class_pspec->flags,
-		    pspecs[n]->flags,
-		    G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY) ||
-	   !SUBSET (pspecs[n]->flags,
-		    class_pspec->flags,
-		    G_PARAM_READABLE | G_PARAM_WRITABLE)))
-	{
-	  g_critical ("Flags for property '%s' on class '%s' "
-		      "are not compatible with the property on"
-		      "interface '%s'\n",
-		      pspecs[n]->name,
-		      g_type_name (G_OBJECT_CLASS_TYPE (class)),
-		      g_type_name (iface_type));
-	}
+      if (pspecs[n]->flags & G_PARAM_WRITABLE)
+        {
+          if (!SUBSET (class_pspec->flags, pspecs[n]->flags, G_PARAM_CONSTRUCT_ONLY))
+            {
+              g_critical ("Flags for property '%s' on class '%s' introduce additional restrictions on "
+                          "writability compared with the property on interface '%s'\n", pspecs[n]->name,
+                          g_type_name (G_OBJECT_CLASS_TYPE (class)), g_type_name (iface_type));
+              continue;
+            }
+        }
 #undef SUBSET
+
+      /* If the property on the interface is readable then we are
+       * effectively advertising that reading the property will return a
+       * value of a specific type.  All implementations of the interface
+       * need to return items of this type -- but may be more
+       * restrictive.  For example, it is legal to have:
+       *
+       *   GtkWidget *get_item();
+       *
+       * that is implemented by a function that always returns a
+       * GtkEntry.  In short: readability implies that the
+       * implementation  value type must be equal or more restrictive.
+       *
+       * Similarly, if the property on the interface is writable then
+       * must be able to accept the property being set to any value of
+       * that type, including subclasses.  In this case, we may also be
+       * less restrictive.  For example, it is legal to have:
+       *
+       *   set_item (GtkEntry *);
+       *
+       * that is implemented by a function that will actually work with
+       * any GtkWidget.  In short: writability implies that the
+       * implementation value type must be equal or less restrictive.
+       *
+       * In the case that the property is both readable and writable
+       * then the only way that both of the above can be satisfied is
+       * with a type that is exactly equal.
+       */
+      switch (pspecs[n]->flags & (G_PARAM_READABLE | G_PARAM_WRITABLE))
+        {
+        case G_PARAM_READABLE | G_PARAM_WRITABLE:
+          /* class pspec value type must have exact equality with interface */
+          if (pspecs[n]->value_type != class_pspec->value_type)
+            g_critical ("Read/writable property '%s' on class '%s' has type '%s' which is not exactly equal to the "
+                        "type '%s' of the property on the interface '%s'\n", pspecs[n]->name,
+                        g_type_name (G_OBJECT_CLASS_TYPE (class)), g_type_name (G_PARAM_SPEC_VALUE_TYPE (class_pspec)),
+                        g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspecs[n])), g_type_name (iface_type));
+          break;
+
+        case G_PARAM_READABLE:
+          /* class pspec value type equal or more restrictive than interface */
+          if (!g_type_is_a (class_pspec->value_type, pspecs[n]->value_type))
+            g_critical ("Read-only property '%s' on class '%s' has type '%s' which is not equal to or more "
+                        "restrictive than the type '%s' of the property on the interface '%s'\n", pspecs[n]->name,
+                        g_type_name (G_OBJECT_CLASS_TYPE (class)), g_type_name (G_PARAM_SPEC_VALUE_TYPE (class_pspec)),
+                        g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspecs[n])), g_type_name (iface_type));
+          break;
+
+        case G_PARAM_WRITABLE:
+          /* class pspec value type equal or less restrictive than interface */
+          if (!g_type_is_a (pspecs[n]->value_type, class_pspec->value_type))
+            g_critical ("Write-only property '%s' on class '%s' has type '%s' which is not equal to or less "
+                        "restrictive than the type '%s' of the property on the interface '%s' \n", pspecs[n]->name,
+                        g_type_name (G_OBJECT_CLASS_TYPE (class)), g_type_name (G_PARAM_SPEC_VALUE_TYPE (class_pspec)),
+                        g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspecs[n])), g_type_name (iface_type));
+          break;
+
+        default:
+          g_assert_not_reached ();
+        }
     }
 
   g_free (pspecs);
@@ -2392,6 +2466,11 @@ weak_refs_notify (gpointer data)
  * "weak references" because they allow you to safely hold a pointer
  * to an object without calling g_object_ref() (g_object_ref() adds a
  * strong reference, that is, forces the object to stay alive).
+ *
+ * Note that the weak references created by this method are not
+ * thread-safe: they cannot safely be used in one thread if the
+ * object's last g_object_unref() might happen in another thread.
+ * Use #GWeakRef if thread-safety is required.
  */
 void
 g_object_weak_ref (GObject    *object,
@@ -2476,6 +2555,11 @@ g_object_weak_unref (GObject    *object,
  * the pointer located at @weak_pointer_location is only valid during
  * the lifetime of @object. When the @object is finalized,
  * @weak_pointer will be set to %NULL.
+ *
+ * Note that as with g_object_weak_ref(), the weak references created by
+ * this method are not thread-safe: they cannot safely be used in one
+ * thread if the object's last g_object_unref() might happen in another
+ * thread. Use #GWeakRef if thread-safety is required.
  */
 void
 g_object_add_weak_pointer (GObject  *object, 
@@ -2840,7 +2924,49 @@ g_object_unref (gpointer _object)
     }
   else
     {
-      /* we are about tp remove the last reference */
+      GSList **weak_locations;
+
+      /* The only way that this object can live at this point is if
+       * there are outstanding weak references already established
+       * before we got here.
+       *
+       * If there were not already weak references then no more can be
+       * established at this time, because the other thread would have
+       * to hold a strong ref in order to call
+       * g_object_add_weak_pointer() and then we wouldn't be here.
+       */
+      weak_locations = g_datalist_id_get_data (&object->qdata, quark_weak_locations);
+
+      if (weak_locations != NULL)
+        {
+          g_rw_lock_writer_lock (&weak_locations_lock);
+
+          /* It is possible that one of the weak references beat us to
+           * the lock. Make sure the refcount is still what we expected
+           * it to be.
+           */
+          old_ref = g_atomic_int_get (&object->ref_count);
+          if (old_ref != 1)
+            {
+              g_rw_lock_writer_unlock (&weak_locations_lock);
+              goto retry_atomic_decrement1;
+            }
+
+          /* We got the lock first, so the object will definitely die
+           * now. Clear out all the weak references.
+           */
+          while (*weak_locations)
+            {
+              GWeakRef *weak_ref_location = (*weak_locations)->data;
+
+              weak_ref_location->priv.p = NULL;
+              *weak_locations = g_slist_delete_link (*weak_locations, *weak_locations);
+            }
+
+          g_rw_lock_writer_unlock (&weak_locations_lock);
+        }
+
+      /* we are about to remove the last reference */
       TRACE (GOBJECT_OBJECT_DISPOSE(object,G_TYPE_FROM_INSTANCE(object), 1));
       G_OBJECT_GET_CLASS (object)->dispose (object);
       TRACE (GOBJECT_OBJECT_DISPOSE_END(object,G_TYPE_FROM_INSTANCE(object), 1));
@@ -3668,3 +3794,191 @@ static void
 g_initially_unowned_class_init (GInitiallyUnownedClass *klass)
 {
 }
+
+/**
+ * GWeakRef:
+ *
+ * A structure containing a weak reference to a #GObject.  It can either
+ * be empty (i.e. point to %NULL), or point to an object for as long as
+ * at least one "strong" reference to that object exists. Before the
+ * object's #GObjectClass.dispose method is called, every #GWeakRef
+ * associated with becomes empty (i.e. points to %NULL).
+ *
+ * Like #GValue, #GWeakRef can be statically allocated, stack- or
+ * heap-allocated, or embedded in larger structures.
+ *
+ * Unlike g_object_weak_ref() and g_object_add_weak_pointer(), this weak
+ * reference is thread-safe: converting a weak pointer to a reference is
+ * atomic with respect to invalidation of weak pointers to destroyed
+ * objects.
+ *
+ * If the object's #GObjectClass.dispose method results in additional
+ * references to the object being held, any #GWeakRef<!-- -->s taken
+ * before it was disposed will continue to point to %NULL.  If
+ * #GWeakRef<!-- -->s are taken after the object is disposed and
+ * re-referenced, they will continue to point to it until its refcount
+ * goes back to zero, at which point they too will be invalidated.
+ */
+
+/**
+ * g_weak_ref_init: (skip)
+ * @weak_ref: (inout): uninitialized or empty location for a weak
+ *    reference
+ * @object: (allow-none): a #GObject or %NULL
+ *
+ * Initialise a non-statically-allocated #GWeakRef.
+ *
+ * This function also calls g_weak_ref_set() with @object on the
+ * freshly-initialised weak reference.
+ *
+ * This function should always be matched with a call to
+ * g_weak_ref_clear().  It is not necessary to use this function for a
+ * #GWeakRef in static storage because it will already be
+ * properly initialised.  Just use g_weak_ref_set() directly.
+ *
+ * Since: 2.32
+ */
+void
+g_weak_ref_init (GWeakRef *weak_ref,
+                 gpointer  object)
+{
+  weak_ref->priv.p = NULL;
+
+  g_weak_ref_set (weak_ref, object);
+}
+
+/**
+ * g_weak_ref_clear: (skip)
+ * @weak_ref: (inout): location of a weak reference, which
+ *  may be empty
+ *
+ * Frees resources associated with a non-statically-allocated #GWeakRef.
+ * After this call, the #GWeakRef is left in an undefined state.
+ *
+ * You should only call this on a #GWeakRef that previously had
+ * g_weak_ref_init() called on it.
+ *
+ * Since: 2.32
+ */
+void
+g_weak_ref_clear (GWeakRef *weak_ref)
+{
+  g_weak_ref_set (weak_ref, NULL);
+
+  /* be unkind */
+  weak_ref->priv.p = (void *) 0xccccccccu;
+}
+
+/**
+ * g_weak_ref_get: (skip)
+ * @weak_ref: (inout): location of a weak reference to a #GObject
+ *
+ * If @weak_ref is not empty, atomically acquire a strong
+ * reference to the object it points to, and return that reference.
+ *
+ * This function is needed because of the potential race between taking
+ * the pointer value and g_object_ref() on it, if the object was losing
+ * its last reference at the same time in a different thread.
+ *
+ * The caller should release the resulting reference in the usual way,
+ * by using g_object_unref().
+ *
+ * Returns: (transfer full) (type GObject.Object): the object pointed to
+ *     by @weak_ref, or %NULL if it was empty
+ *
+ * Since: 2.32
+ */
+gpointer
+g_weak_ref_get (GWeakRef *weak_ref)
+{
+  gpointer object_or_null;
+
+  g_return_val_if_fail (weak_ref!= NULL, NULL);
+
+  g_rw_lock_reader_lock (&weak_locations_lock);
+
+  object_or_null = weak_ref->priv.p;
+
+  if (object_or_null != NULL)
+    g_object_ref (object_or_null);
+
+  g_rw_lock_reader_unlock (&weak_locations_lock);
+
+  return object_or_null;
+}
+
+/**
+ * g_weak_ref_set: (skip)
+ * @weak_ref: location for a weak reference
+ * @object: (allow-none): a #GObject or %NULL
+ *
+ * Change the object to which @weak_ref points, or set it to
+ * %NULL.
+ *
+ * You must own a strong reference on @object while calling this
+ * function.
+ *
+ * Since: 2.32
+ */
+void
+g_weak_ref_set (GWeakRef *weak_ref,
+                gpointer  object)
+{
+  GSList **weak_locations;
+  GObject *new_object;
+  GObject *old_object;
+
+  g_return_if_fail (weak_ref != NULL);
+  g_return_if_fail (object == NULL || G_IS_OBJECT (object));
+
+  new_object = object;
+
+  g_rw_lock_writer_lock (&weak_locations_lock);
+
+  /* We use the extra level of indirection here so that if we have ever
+   * had a weak pointer installed at any point in time on this object,
+   * we can see that there is a non-NULL value associated with the
+   * weak-pointer quark and know that this value will not change at any
+   * point in the object's lifetime.
+   *
+   * Both properties are important for reducing the amount of times we
+   * need to acquire locks and for decreasing the duration of time the
+   * lock is held while avoiding some rather tricky races.
+   *
+   * Specifically: we can avoid having to do an extra unconditional lock
+   * in g_object_unref() without worrying about some extremely tricky
+   * races.
+   */
+
+  old_object = weak_ref->priv.p;
+  if (new_object != old_object)
+    {
+      weak_ref->priv.p = new_object;
+
+      /* Remove the weak ref from the old object */
+      if (old_object != NULL)
+        {
+          weak_locations = g_datalist_id_get_data (&old_object->qdata, quark_weak_locations);
+          /* for it to point to an object, the object must have had it added once */
+          g_assert (weak_locations != NULL);
+
+          *weak_locations = g_slist_remove (*weak_locations, weak_ref);
+        }
+
+      /* Add the weak ref to the new object */
+      if (new_object != NULL)
+        {
+          weak_locations = g_datalist_id_get_data (&new_object->qdata, quark_weak_locations);
+
+          if (weak_locations == NULL)
+            {
+              weak_locations = g_new0 (GSList *, 1);
+              g_datalist_id_set_data_full (&new_object->qdata, quark_weak_locations, weak_locations, g_free);
+            }
+
+          *weak_locations = g_slist_prepend (*weak_locations, weak_ref);
+        }
+    }
+
+  g_rw_lock_writer_unlock (&weak_locations_lock);
+}
diff --git a/gobject/gobject.h b/gobject/gobject.h
index ea3b048..3572736 100644
--- a/gobject/gobject.h
+++ b/gobject/gobject.h
@@ -575,6 +575,18 @@ void    g_clear_object (volatile GObject **object_ptr);
       g_object_unref (_o);                                                   \
   } G_STMT_END
 
+typedef struct {
+    /*<private>*/
+    union { gpointer p; } priv;
+} GWeakRef;
+
+void     g_weak_ref_init       (GWeakRef *weak_ref,
+                                gpointer  object);
+void     g_weak_ref_clear      (GWeakRef *weak_ref);
+gpointer g_weak_ref_get        (GWeakRef *weak_ref);
+void     g_weak_ref_set        (GWeakRef *weak_ref,
+                                gpointer  object);
+
 G_END_DECLS
 
 #endif /* __G_OBJECT_H__ */
diff --git a/gobject/gobject.symbols b/gobject/gobject.symbols
index dda51d0..1a7bd57 100644
--- a/gobject/gobject.symbols
+++ b/gobject/gobject.symbols
@@ -385,3 +385,7 @@ g_param_spec_types
 g_slist_remove_all PRIVATE
 g_unichar_validate PRIVATE
 #endif
+g_weak_ref_init
+g_weak_ref_clear
+g_weak_ref_get
+g_weak_ref_set
diff --git a/gobject/tests/ifaceproperties.c b/gobject/tests/ifaceproperties.c
index 5e3d220..f7a260c 100644
--- a/gobject/tests/ifaceproperties.c
+++ b/gobject/tests/ifaceproperties.c
@@ -615,6 +615,9 @@ base2_object_init (Base2Object *object)
 static void
 test_not_overridden (void)
 {
+  if (!g_test_undefined ())
+    return;
+
   g_test_bug ("637738");
 
   if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT|G_TEST_TRAP_SILENCE_STDERR))
diff --git a/gobject/tests/param.c b/gobject/tests/param.c
index e048ebc..7e7721b 100644
--- a/gobject/tests/param.c
+++ b/gobject/tests/param.c
@@ -1,5 +1,6 @@
 #define GLIB_DISABLE_DEPRECATION_WARNINGS
 #include <glib-object.h>
+#include <stdlib.h>
 
 static void
 test_param_value (void)
@@ -394,6 +395,384 @@ test_value_transform (void)
   g_value_unset (&dest);
 }
 
+
+/* We create some dummy objects with a simple relationship:
+ *
+ *           GObject
+ *          /       \
+ * TestObjectA     TestObjectC
+ *      |
+ * TestObjectB
+ *
+ * ie: TestObjectB is a subclass of TestObjectA and TestObjectC is
+ * related to neither.
+ */
+
+static GType test_object_a_get_type (void);
+typedef GObject TestObjectA; typedef GObjectClass TestObjectAClass;
+G_DEFINE_TYPE (TestObjectA, test_object_a, G_TYPE_OBJECT);
+static void test_object_a_class_init (TestObjectAClass *class) { }
+static void test_object_a_init (TestObjectA *a) { }
+
+static GType test_object_b_get_type (void);
+typedef GObject TestObjectB; typedef GObjectClass TestObjectBClass;
+G_DEFINE_TYPE (TestObjectB, test_object_b, test_object_a_get_type ());
+static void test_object_b_class_init (TestObjectBClass *class) { }
+static void test_object_b_init (TestObjectB *b) { }
+
+static GType test_object_c_get_type (void);
+typedef GObject TestObjectC; typedef GObjectClass TestObjectCClass;
+G_DEFINE_TYPE (TestObjectC, test_object_c, G_TYPE_OBJECT);
+static void test_object_c_class_init (TestObjectCClass *class) { }
+static void test_object_c_init (TestObjectC *c) { }
+
+/* We create an interface and programmatically populate it with
+ * properties of each of the above type, with various flag combinations.
+ *
+ * Properties are named like "type-perm" where type is 'a', 'b' or 'c'
+ * and perm is a series of characters, indicating the permissions:
+ *
+ *   - 'r': readable
+ *   - 'w': writable
+ *   - 'c': construct
+ *   - 'C': construct-only
+ *
+ * It doesn't make sense to have a property that is neither readable nor
+ * writable.  It is also not valid to have construct or construct-only
+ * on read-only params.  Finally, it is invalid to have both construct
+ * and construct-only specified, so we do not consider those cases.
+ * That gives us 7 possible permissions:
+ *
+ *     'r', 'w', 'rw', 'wc', 'rwc', 'wC', 'rwC'
+ *
+ * And 9 impossible ones:
+ *
+ *     '', 'c', 'rc', 'C', 'rC', 'cC', 'rcC', 'wcC', rwcC'
+ *
+ * For a total of 16 combinations.
+ *
+ * That gives a total of 48 (16 * 3) possible flag/type combinations, of
+ * which 27 (9 * 3) are impossible to install.
+ *
+ * That gives 21 (7 * 3) properties that will be installed.
+ */
+typedef GTypeInterface TestInterfaceInterface;
+//typedef struct _TestInterface TestInterface;
+G_DEFINE_INTERFACE (TestInterface, test_interface, G_TYPE_OBJECT)
+static void
+test_interface_default_init (TestInterfaceInterface *iface)
+{
+  const gchar *names[] = { "a", "b", "c" };
+  const gchar *perms[] = { NULL, "r",  "w",  "rw",
+                           NULL, NULL, "wc", "rwc",
+                           NULL, NULL, "wC", "rwC",
+                           NULL, NULL, NULL, NULL };
+  const GType types[] = { test_object_a_get_type (), test_object_b_get_type (), test_object_c_get_type () };
+  guint i, j;
+
+  for (i = 0; i < G_N_ELEMENTS (types); i++)
+    for (j = 0; j < G_N_ELEMENTS (perms); j++)
+      {
+        gchar prop_name[10];
+        GParamSpec *pspec;
+
+        if (perms[j] == NULL)
+          {
+            /* we think that this is impossible.  make sure. */
+            if (g_test_trap_fork (G_TIME_SPAN_SECOND, G_TEST_TRAP_SILENCE_STDERR))
+              {
+                GParamSpec *pspec;
+
+                pspec = g_param_spec_object ("xyz", "xyz", "xyz", types[i], j);
+                g_object_interface_install_property (iface, pspec);
+                exit (0);
+              }
+            g_test_trap_assert_failed ();
+            continue;
+          }
+
+        /* install the property */
+        g_snprintf (prop_name, sizeof prop_name, "%s-%s", names[i], perms[j]);
+        pspec = g_param_spec_object (prop_name, prop_name, prop_name, types[i], j);
+        g_object_interface_install_property (iface, pspec);
+      }
+}
+
+/* We now have 21 properties.  Each property may be correctly
+ * implemented with the following types:
+ *
+ *   Properties         Valid Types       Reason
+ *
+ *   a-r                a, b              Read only can provide subclasses
+ *   a-w, wc, wC        a, GObject        Write only can accept superclasses
+ *   a-rw, rwc, rwC     a                 Read-write must be exactly equal
+ *
+ *   b-r                b                 (as above)
+ *   b-w, wc, wC        b, a, GObject
+ *   b-rw, rwc, rwC     b
+ *
+ *   c-r                c                 (as above)
+ *   c-wo, wc, wC       c, GObject
+ *   c-rw, rwc, rwC     c
+ *
+ * We can express this in a 48-by-4 table where each row represents an
+ * installed property and each column represents a type.  The value in
+ * the table represents if it is valid to subclass the row's property
+ * with the type of the column:
+ *
+ *   - 0:   invalid because the interface property doesn't exist (invalid flags)
+ *   - 'v': valid
+ *   - '=': invalid because of the type not being exactly equal
+ *   - '<': invalid because of the type not being a subclass
+ *   - '>': invalid because of the type not being a superclass
+ *
+ * We organise the table by interface property type ('a', 'b', 'c') then
+ * by interface property flags.
+ */
+
+static gint valid_impl_types[48][4] = {
+                    /* a    b    c    GObject */
+    /* 'a-' */       { },
+    /* 'a-r' */      { 'v', 'v', '<', '<' },
+    /* 'a-w' */      { 'v', '>', '>', 'v' },
+    /* 'a-rw' */     { 'v', '=', '=', '=' },
+    /* 'a-c */       { },
+    /* 'a-rc' */     { },
+    /* 'a-wc' */     { 'v', '>', '>', 'v' },
+    /* 'a-rwc' */    { 'v', '=', '=', '=' },
+    /* 'a-C */       { },
+    /* 'a-rC' */     { },
+    /* 'a-wC' */     { 'v', '>', '>', 'v' },
+    /* 'a-rwC' */    { 'v', '=', '=', '=' },
+    /* 'a-cC */      { },
+    /* 'a-rcC' */    { },
+    /* 'a-wcC' */    { },
+    /* 'a-rwcC' */   { },
+
+    /* 'b-' */       { },
+    /* 'b-r' */      { '<', 'v', '<', '<' },
+    /* 'b-w' */      { 'v', 'v', '>', 'v' },
+    /* 'b-rw' */     { '=', 'v', '=', '=' },
+    /* 'b-c */       { },
+    /* 'b-rc' */     { },
+    /* 'b-wc' */     { 'v', 'v', '>', 'v' },
+    /* 'b-rwc' */    { '=', 'v', '=', '=' },
+    /* 'b-C */       { },
+    /* 'b-rC' */     { },
+    /* 'b-wC' */     { 'v', 'v', '>', 'v' },
+    /* 'b-rwC' */    { '=', 'v', '=', '=' },
+    /* 'b-cC */      { },
+    /* 'b-rcC' */    { },
+    /* 'b-wcC' */    { },
+    /* 'b-rwcC' */   { },
+
+    /* 'c-' */       { },
+    /* 'c-r' */      { '<', '<', 'v', '<' },
+    /* 'c-w' */      { '>', '>', 'v', 'v' },
+    /* 'c-rw' */     { '=', '=', 'v', '=' },
+    /* 'c-c */       { },
+    /* 'c-rc' */     { },
+    /* 'c-wc' */     { '>', '>', 'v', 'v' },
+    /* 'c-rwc' */    { '=', '=', 'v', '=' },
+    /* 'c-C */       { },
+    /* 'c-rC' */     { },
+    /* 'c-wC' */     { '>', '>', 'v', 'v' },
+    /* 'c-rwC' */    { '=', '=', 'v', '=' },
+    /* 'c-cC */      { },
+    /* 'c-rcC' */    { },
+    /* 'c-wcC' */    { },
+    /* 'c-rwcC' */   { }
+};
+
+/* We also try to change the flags.  We must ensure that all
+ * implementations provide all functionality promised by the interface.
+ * We must therefore never remove readability or writability (but we can
+ * add them).  Construct-only is a restrictions that applies to
+ * writability, so we can never add it unless writability was never
+ * present in the first place, in which case "writable at construct
+ * only" is still better than "not writable".
+ *
+ * The 'construct' flag is of interest only to the implementation.  It
+ * may be changed at any time.
+ *
+ *   Properties         Valid Access      Reason
+ *
+ *   *-r                r, rw, rwc, rwC   Must keep readable, but can restrict newly-added writable
+ *   *-w                w, rw, rwc        Must keep writable unrestricted
+ *   *-rw               rw, rwc           Must not add any restrictions
+ *   *-rwc              rw, rwc           Must not add any restrictions
+ *   *-rwC              rw, rwc, rwC      Can remove 'construct-only' restriction
+ *   *-wc               rwc, rw, w, wc    Can add readability
+ *   *-wC               rwC, rw, w, wC    Can add readability or remove 'construct only' restriction
+ *                        rwc, wc
+ *
+ * We can represent this with a 16-by-16 table.  The rows represent the
+ * flags of the property on the interface.  The columns is the flags to
+ * try to use when overriding the property.  The cell contents are:
+ *
+ *   - 0:   invalid because the interface property doesn't exist (invalid flags)
+ *   - 'v': valid
+ *   - 'i': invalid because the implementation flags are invalid
+ *   - 'f': invalid because of the removal of functionality
+ *   - 'r': invalid because of the addition of restrictions (ie: construct-only)
+ *
+ * We also ensure that removal of functionality is reported before
+ * addition of restrictions, since this is a more basic problem.
+ */
+static gint valid_impl_flags[16][16] = {
+                 /* ''   r    w    rw   c    rc   wc   rwc  C    rC   wC   rwC  cC   rcC  wcC  rwcC */
+    /* '*-' */    { },
+    /* '*-r' */   { 'i', 'v', 'f', 'v', 'i', 'i', 'f', 'v', 'i', 'i', 'f', 'v', 'i', 'i', 'i', 'i' },
+    /* '*-w' */   { 'i', 'f', 'v', 'v', 'i', 'i', 'v', 'v', 'i', 'i', 'r', 'r', 'i', 'i', 'i', 'i' },
+    /* '*-rw' */  { 'i', 'f', 'f', 'v', 'i', 'i', 'f', 'v', 'i', 'i', 'f', 'r', 'i', 'i', 'i', 'i' },
+    /* '*-c */    { },
+    /* '*-rc' */  { },
+    /* '*-wc' */  { 'i', 'f', 'v', 'v', 'i', 'i', 'v', 'v', 'i', 'i', 'r', 'r', 'i', 'i', 'i', 'i' },
+    /* '*-rwc' */ { 'i', 'f', 'f', 'v', 'i', 'i', 'f', 'v', 'i', 'i', 'f', 'r', 'i', 'i', 'i', 'i' },
+    /* '*-C */    { },
+    /* '*-rC' */  { },
+    /* '*-wC' */  { 'i', 'f', 'v', 'v', 'i', 'i', 'v', 'v', 'i', 'i', 'v', 'v', 'i', 'i', 'i', 'i' },
+    /* '*-rwC' */ { 'i', 'f', 'f', 'v', 'i', 'i', 'f', 'v', 'i', 'i', 'f', 'v', 'i', 'i', 'i', 'i' },
+};
+
+static guint change_this_flag;
+static guint change_this_type;
+static guint use_this_flag;
+static guint use_this_type;
+
+typedef GObjectClass TestImplementationClass;
+typedef GObject TestImplementation;
+
+static void test_implementation_init (TestImplementation *impl) { }
+static void test_implementation_iface_init (TestInterfaceInterface *iface) { }
+
+static GType test_implementation_get_type (void);
+G_DEFINE_TYPE_WITH_CODE (TestImplementation, test_implementation, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (test_interface_get_type (), test_implementation_iface_init))
+
+static void test_implementation_class_init (TestImplementationClass *class)
+{
+  const gchar *names[] = { "a", "b", "c" };
+  const gchar *perms[] = { NULL, "r",  "w",  "rw",
+                           NULL, NULL, "wc", "rwc",
+                           NULL, NULL, "wC", "rwC",
+                           NULL, NULL, NULL, NULL };
+  const GType types[] = { test_object_a_get_type (), test_object_b_get_type (),
+                          test_object_c_get_type (), G_TYPE_OBJECT };
+  gchar prop_name[10];
+  GParamSpec *pspec;
+  guint i, j;
+
+  class->get_property = GINT_TO_POINTER (1);
+  class->set_property = GINT_TO_POINTER (1);
+
+  /* Install all of the non-modified properties or else GObject will
+   * complain about non-implemented properties.
+   */
+  for (i = 0; i < 3; i++)
+    for (j = 0; j < G_N_ELEMENTS (perms); j++)
+      {
+        if (i == change_this_type && j == change_this_flag)
+          continue;
+
+        if (perms[j] != NULL)
+          {
+            /* override the property without making changes */
+            g_snprintf (prop_name, sizeof prop_name, "%s-%s", names[i], perms[j]);
+            g_object_class_override_property (class, 1, prop_name);
+          }
+      }
+
+  /* Now try installing our modified property */
+  if (perms[change_this_flag] == NULL)
+    g_error ("Interface property does not exist");
+
+  g_snprintf (prop_name, sizeof prop_name, "%s-%s", names[change_this_type], perms[change_this_flag]);
+  pspec = g_param_spec_object (prop_name, prop_name, prop_name, types[use_this_type], use_this_flag);
+  g_object_class_install_property (class, 1, pspec);
+}
+
+static void
+test_param_implement (void)
+{
+  /* GObject oddity: GObjectClass must be initialised before we can
+   * initialise a GTypeInterface.
+   */
+  g_type_class_ref (G_TYPE_OBJECT);
+
+  /* Bring up the interface first. */
+  g_type_default_interface_ref (test_interface_get_type ());
+
+  for (change_this_flag = 0; change_this_flag < 16; change_this_flag++)
+    for (change_this_type = 0; change_this_type < 3; change_this_type++)
+      for (use_this_flag = 0; use_this_flag < 16; use_this_flag++)
+        for (use_this_type = 0; use_this_type < 4; use_this_type++)
+          {
+            if (g_test_trap_fork (G_TIME_SPAN_SECOND, G_TEST_TRAP_SILENCE_STDERR))
+              {
+                g_type_class_ref (test_implementation_get_type ());
+                exit (0);
+              }
+
+            /* We want to ensure that any flags mismatch problems are reported first. */
+            switch (valid_impl_flags[change_this_flag][use_this_flag])
+              {
+              case 0:
+                /* make sure the other table agrees */
+                g_assert (valid_impl_types[change_this_type * 16 + change_this_flag][use_this_type] == 0);
+                g_test_trap_assert_failed ();
+                g_test_trap_assert_stderr ("*Interface property does not exist*");
+                continue;
+
+              case 'i':
+                g_test_trap_assert_failed ();
+                g_test_trap_assert_stderr ("*g_object_class_install_property*");
+                continue;
+
+              case 'f':
+                g_test_trap_assert_failed ();
+                g_test_trap_assert_stderr ("*remove functionality*");
+                continue;
+
+              case 'r':
+                g_test_trap_assert_failed ();
+                g_test_trap_assert_stderr ("*introduce additional restrictions*");
+                continue;
+
+              case 'v':
+                break;
+              }
+
+            /* Next, we check if there should have been a type error. */
+            switch (valid_impl_types[change_this_type * 16 + change_this_flag][use_this_type])
+              {
+              case 0:
+                /* this should have been caught above */
+                g_assert_not_reached ();
+
+              case '=':
+                g_test_trap_assert_failed ();
+                g_test_trap_assert_stderr ("*exactly equal*");
+                continue;
+
+              case '<':
+                g_test_trap_assert_failed ();
+                g_test_trap_assert_stderr ("*equal to or more restrictive*");
+                continue;
+
+              case '>':
+                g_test_trap_assert_failed ();
+                g_test_trap_assert_stderr ("*equal to or less restrictive*");
+                continue;
+
+              case 'v':
+                break;
+              }
+
+            g_test_trap_assert_passed ();
+          }
+}
+
 int
 main (int argc, char *argv[])
 {
@@ -405,6 +784,7 @@ main (int argc, char *argv[])
   g_test_add_func ("/param/qdata", test_param_qdata);
   g_test_add_func ("/param/validate", test_param_validate);
   g_test_add_func ("/param/convert", test_param_convert);
+  g_test_add_func ("/param/implement", test_param_implement);
   g_test_add_func ("/value/transform", test_value_transform);
 
   return g_test_run ();
diff --git a/gobject/tests/reference.c b/gobject/tests/reference.c
index 5a396be..39146c5 100644
--- a/gobject/tests/reference.c
+++ b/gobject/tests/reference.c
@@ -228,6 +228,106 @@ test_weak_pointer (void)
   g_assert (weak2 == obj);
 }
 
+/* See gobject/tests/threadtests.c for the threaded version */
+static void
+test_weak_ref (void)
+{
+  GObject *obj;
+  GObject *obj2;
+  GObject *tmp;
+  GWeakRef weak = { { GUINT_TO_POINTER (0xDEADBEEFU) } };
+  GWeakRef weak2 = { { GUINT_TO_POINTER (0xDEADBEEFU) } };
+  GWeakRef weak3 = { { GUINT_TO_POINTER (0xDEADBEEFU) } };
+  GWeakRef *dynamic_weak = g_new (GWeakRef, 1);
+
+  /* you can initialize to empty like this... */
+  g_weak_ref_init (&weak2, NULL);
+  g_assert (g_weak_ref_get (&weak2) == NULL);
+
+  /* ... or via an initializer */
+  g_weak_ref_init (&weak3, NULL);
+  g_assert (g_weak_ref_get (&weak3) == NULL);
+
+  obj = g_object_new (G_TYPE_OBJECT, NULL);
+  g_assert_cmpint (obj->ref_count, ==, 1);
+
+  obj2 = g_object_new (G_TYPE_OBJECT, NULL);
+  g_assert_cmpint (obj2->ref_count, ==, 1);
+
+  /* you can init with an object (even if uninitialized) */
+  g_weak_ref_init (&weak, obj);
+  g_weak_ref_init (dynamic_weak, obj);
+  /* or set to point at an object, if initialized (maybe to 0) */
+  g_weak_ref_set (&weak2, obj);
+  g_weak_ref_set (&weak3, obj);
+  /* none of this affects its refcount */
+  g_assert_cmpint (obj->ref_count, ==, 1);
+
+  /* getting the value takes a ref */
+  tmp = g_weak_ref_get (&weak);
+  g_assert (tmp == obj);
+  g_assert_cmpint (obj->ref_count, ==, 2);
+  g_object_unref (tmp);
+  g_assert_cmpint (obj->ref_count, ==, 1);
+
+  tmp = g_weak_ref_get (&weak2);
+  g_assert (tmp == obj);
+  g_assert_cmpint (obj->ref_count, ==, 2);
+  g_object_unref (tmp);
+  g_assert_cmpint (obj->ref_count, ==, 1);
+
+  tmp = g_weak_ref_get (&weak3);
+  g_assert (tmp == obj);
+  g_assert_cmpint (obj->ref_count, ==, 2);
+  g_object_unref (tmp);
+  g_assert_cmpint (obj->ref_count, ==, 1);
+
+  tmp = g_weak_ref_get (dynamic_weak);
+  g_assert (tmp == obj);
+  g_assert_cmpint (obj->ref_count, ==, 2);
+  g_object_unref (tmp);
+  g_assert_cmpint (obj->ref_count, ==, 1);
+
+  /* clearing a weak ref stops tracking */
+  g_weak_ref_clear (&weak);
+
+  /* setting a weak ref to NULL stops tracking too */
+  g_weak_ref_set (&weak2, NULL);
+  g_assert (g_weak_ref_get (&weak2) == NULL);
+  g_weak_ref_clear (&weak2);
+
+  /* setting a weak ref to a new object stops tracking the old one */
+  g_weak_ref_set (dynamic_weak, obj2);
+  tmp = g_weak_ref_get (dynamic_weak);
+  g_assert (tmp == obj2);
+  g_assert_cmpint (obj2->ref_count, ==, 2);
+  g_object_unref (tmp);
+  g_assert_cmpint (obj2->ref_count, ==, 1);
+
+  g_assert_cmpint (obj->ref_count, ==, 1);
+
+  /* free the object: weak3 is the only one left pointing there */
+  g_object_unref (obj);
+  g_assert (g_weak_ref_get (&weak3) == NULL);
+
+  /* setting a weak ref to a new object stops tracking the old one */
+  g_weak_ref_set (dynamic_weak, obj2);
+  tmp = g_weak_ref_get (dynamic_weak);
+  g_assert (tmp == obj2);
+  g_assert_cmpint (obj2->ref_count, ==, 2);
+  g_object_unref (tmp);
+  g_assert_cmpint (obj2->ref_count, ==, 1);
+
+  g_weak_ref_clear (&weak3);
+
+  /* clear and free dynamic_weak... */
+  g_weak_ref_clear (dynamic_weak);
+
+  /* ... to prove that doing so stops this from being a use-after-free */
+  g_object_unref (obj2);
+  g_free (dynamic_weak);
+}
+
 int
 main (int argc, char **argv)
 {
@@ -244,6 +344,7 @@ main (int argc, char **argv)
   g_test_add_func ("/object/value", test_object_value);
   g_test_add_func ("/object/initially-unowned", test_initially_unowned);
   g_test_add_func ("/object/weak-pointer", test_weak_pointer);
+  g_test_add_func ("/object/weak-ref", test_weak_ref);
 
   return g_test_run ();
 }
diff --git a/gobject/tests/threadtests.c b/gobject/tests/threadtests.c
index 72392b4..c14997c 100644
--- a/gobject/tests/threadtests.c
+++ b/gobject/tests/threadtests.c
@@ -204,6 +204,126 @@ test_threaded_object_init (void)
   g_thread_join (creator);
 }
 
+typedef struct {
+    MyTester0 *strong;
+    guint unref_delay;
+} UnrefInThreadData;
+
+static gpointer
+unref_in_thread (gpointer p)
+{
+  UnrefInThreadData *data = p;
+
+  g_usleep (data->unref_delay);
+  g_object_unref (data->strong);
+
+  return NULL;
+}
+
+/* undefine to see this test fail without GWeakRef */
+#define HAVE_G_WEAK_REF
+
+#define SLEEP_MIN_USEC 1
+#define SLEEP_MAX_USEC 10
+
+static void
+test_threaded_weak_ref (void)
+{
+  guint i;
+  guint get_wins = 0, unref_wins = 0;
+  guint n;
+
+  if (g_test_thorough ())
+    n = NUM_COUNTER_INCREMENTS;
+  else
+    n = NUM_COUNTER_INCREMENTS / 20;
+
+  for (i = 0; i < n; i++)
+    {
+      UnrefInThreadData data;
+#ifdef HAVE_G_WEAK_REF
+      /* GWeakRef<MyTester0> in C++ terms */
+      GWeakRef weak;
+#else
+      gpointer weak;
+#endif
+      MyTester0 *strengthened;
+      guint get_delay;
+      GThread *thread;
+      GError *error = NULL;
+
+      if (g_test_verbose () && (i % (n/20)) == 0)
+        g_print ("%u%%\n", ((i * 100) / n));
+
+      /* Have an object and a weak ref to it */
+      data.strong = g_object_new (my_tester0_get_type (), NULL);
+
+#ifdef HAVE_G_WEAK_REF
+      g_weak_ref_init (&weak, data.strong);
+#else
+      weak = data.strong;
+      g_object_add_weak_pointer ((GObject *) weak, &weak);
+#endif
+
+      /* Delay for a random time on each side of the race, to perturb the
+       * timing. Ideally, we want each side to win half the races; on
+       * smcv's laptop, these timings are about right.
+       */
+      data.unref_delay = g_random_int_range (SLEEP_MIN_USEC / 2, SLEEP_MAX_USEC / 2);
+      get_delay = g_random_int_range (SLEEP_MIN_USEC, SLEEP_MAX_USEC);
+
+      /* One half of the race is to unref the shared object */
+      thread = g_thread_create (unref_in_thread, &data, TRUE, &error);
+      g_assert_no_error (error);
+
+      /* The other half of the race is to get the object from the "global
+       * singleton"
+       */
+      g_usleep (get_delay);
+
+#ifdef HAVE_G_WEAK_REF
+      strengthened = g_weak_ref_get (&weak);
+#else
+      /* Spot the unsafe pointer access! In GDBusConnection this is rather
+       * better-hidden, but ends up with essentially the same thing, albeit
+       * cleared in dispose() rather than by a traditional weak pointer
+       */
+      strengthened = weak;
+
+      if (strengthened != NULL)
+        g_object_ref (strengthened);
+#endif
+
+      if (strengthened != NULL)
+        g_assert (G_IS_OBJECT (strengthened));
+
+      /* Wait for the thread to run */
+      g_thread_join (thread);
+
+      if (strengthened != NULL)
+        {
+          get_wins++;
+          g_assert (G_IS_OBJECT (strengthened));
+          g_object_unref (strengthened);
+        }
+      else
+        {
+          unref_wins++;
+        }
+
+#ifdef HAVE_G_WEAK_REF
+      g_weak_ref_clear (&weak);
+#else
+      if (weak != NULL)
+        g_object_remove_weak_pointer (weak, &weak);
+#endif
+    }
+
+  if (g_test_verbose ())
+    g_print ("Race won by get %u times, unref %u times\n",
+             get_wins, unref_wins);
+}
+
 int
 main (int   argc,
       char *argv[])
@@ -213,6 +333,7 @@ main (int   argc,
 
   g_test_add_func ("/GObject/threaded-class-init", test_threaded_class_init);
   g_test_add_func ("/GObject/threaded-object-init", test_threaded_object_init);
+  g_test_add_func ("/GObject/threaded-weak-ref", test_threaded_weak_ref);
 
   return g_test_run();
 }
diff --git a/po/he.po b/po/he.po
index 9c6c3c4..2f90f5c 100644
--- a/po/he.po
+++ b/po/he.po
@@ -12,8 +12,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: glib.HEAD.he\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2011-12-10 11:01+0200\n"
-"PO-Revision-Date: 2011-12-10 11:02+0200\n"
+"POT-Creation-Date: 2011-12-30 10:47+0200\n"
+"PO-Revision-Date: 2011-12-30 10:47+0200\n"
 "Last-Translator: Yaron Shahrabani <sh.yaron@gmail.com>\n"
 "Language-Team: Gezer (Hebrew)\n"
 "Language: he\n"
@@ -984,9 +984,9 @@ msgstr "Expected a GEmblem for GEmblemedIcon"
 #: ../gio/gfile.c:5048
 #: ../gio/gfile.c:5315
 #: ../gio/gfile.c:5380
-#: ../gio/gfile.c:7006
-#: ../gio/gfile.c:7096
-#: ../gio/gfile.c:7182
+#: ../gio/gfile.c:7008
+#: ../gio/gfile.c:7098
+#: ../gio/gfile.c:7184
 #: ../gio/win32/gwinhttpfile.c:439
 msgid "Operation not supported"
 msgstr "Operation not supported"
@@ -1050,12 +1050,12 @@ msgstr "Trash not supported"
 msgid "File names cannot contain '%c'"
 msgstr "File names cannot contain '%c'"
 
-#: ../gio/gfile.c:6065
+#: ../gio/gfile.c:6067
 #: ../gio/gvolume.c:332
 msgid "volume doesn't implement mount"
 msgstr "volume doesn't implement mount"
 
-#: ../gio/gfile.c:6176
+#: ../gio/gfile.c:6178
 msgid "No application is registered as handling this file"
 msgstr "No application is registered as handling this file"
 
@@ -1313,19 +1313,19 @@ msgid "<%s id='%s'> already specified"
 msgstr "<%s id='%s'> already specified"
 
 #: ../gio/glib-compile-schemas.c:1416
-#: ../gio/gmenumarkup.c:291
+#: ../gio/gmenumarkup.c:299
 #, c-format
 msgid "Element <%s> not allowed inside <%s>"
 msgstr "Element <%s> not allowed inside <%s>"
 
 #: ../gio/glib-compile-schemas.c:1420
-#: ../gio/gmenumarkup.c:296
+#: ../gio/gmenumarkup.c:304
 #, c-format
 msgid "Element <%s> not allowed at toplevel"
 msgstr "Element <%s> not allowed at toplevel"
 
 #: ../gio/glib-compile-schemas.c:1511
-#: ../gio/gmenumarkup.c:375
+#: ../gio/gmenumarkup.c:383
 #, c-format
 msgid "text may not appear inside <%s>"
 msgstr "text may not appear inside <%s>"
@@ -1847,18 +1847,18 @@ msgstr "Network unreachable"
 msgid "Host unreachable"
 msgstr "Host unreachable"
 
-#: ../gio/gnetworkmonitornetlink.c:94
-#: ../gio/gnetworkmonitornetlink.c:106
-#: ../gio/gnetworkmonitornetlink.c:117
+#: ../gio/gnetworkmonitornetlink.c:97
+#: ../gio/gnetworkmonitornetlink.c:109
+#: ../gio/gnetworkmonitornetlink.c:120
 #, c-format
 msgid "Could not create network monitor: %s"
 msgstr "Could not create network monitor: %s"
 
-#: ../gio/gnetworkmonitornetlink.c:126
+#: ../gio/gnetworkmonitornetlink.c:129
 msgid "Could not create network monitor: "
 msgstr "Could not create network monitor: "
 
-#: ../gio/gnetworkmonitornetlink.c:174
+#: ../gio/gnetworkmonitornetlink.c:177
 msgid "Could not get network status: "
 msgstr "Could not get network status: "
 
@@ -1900,79 +1900,79 @@ msgstr "Temporarily unable to resolve '%s'"
 msgid "Error resolving '%s'"
 msgstr "Error resolving '%s'"
 
-#: ../gio/gsettings-tool.c:60
-#, c-format
-msgid "Schema '%s' is not relocatable (path must not be specified)\n"
-msgstr "Schema '%s' is not relocatable (path must not be specified)\n"
-
-#: ../gio/gsettings-tool.c:65
-#: ../gio/gsettings-tool.c:82
+#: ../gio/gsettings-tool.c:53
+#: ../gio/gsettings-tool.c:74
 #, c-format
 msgid "No such schema '%s'\n"
 msgstr "No such schema '%s'\n"
 
-#: ../gio/gsettings-tool.c:77
+#: ../gio/gsettings-tool.c:59
+#, c-format
+msgid "Schema '%s' is not relocatable (path must not be specified)\n"
+msgstr "Schema '%s' is not relocatable (path must not be specified)\n"
+
+#: ../gio/gsettings-tool.c:80
 #, c-format
 msgid "Schema '%s' is relocatable (path must be specified)\n"
 msgstr "Schema '%s' is relocatable (path must be specified)\n"
 
-#: ../gio/gsettings-tool.c:92
+#: ../gio/gsettings-tool.c:94
 #, c-format
 msgid "Empty path given.\n"
 msgstr "Empty path given.\n"
 
-#: ../gio/gsettings-tool.c:98
+#: ../gio/gsettings-tool.c:100
 #, c-format
 msgid "Path must begin with a slash (/)\n"
 msgstr "Path must begin with a slash (/)\n"
 
-#: ../gio/gsettings-tool.c:104
+#: ../gio/gsettings-tool.c:106
 #, c-format
 msgid "Path must end with a slash (/)\n"
 msgstr "Path must end with a slash (/)\n"
 
-#: ../gio/gsettings-tool.c:110
+#: ../gio/gsettings-tool.c:112
 #, c-format
 msgid "Path must not contain two adjacent slashes (//)\n"
 msgstr "Path must not contain two adjacent slashes (//)\n"
 
-#: ../gio/gsettings-tool.c:131
+#: ../gio/gsettings-tool.c:133
 #, c-format
 msgid "No such key '%s'\n"
 msgstr "No such key '%s'\n"
 
-#: ../gio/gsettings-tool.c:504
+#: ../gio/gsettings-tool.c:500
 #, c-format
 msgid "The provided value is outside of the valid range\n"
 msgstr "The provided value is outside of the valid range\n"
 
-#: ../gio/gsettings-tool.c:533
+#: ../gio/gsettings-tool.c:529
 msgid "Print help"
 msgstr "Print help"
 
-#: ../gio/gsettings-tool.c:539
+#: ../gio/gsettings-tool.c:535
 msgid "List the installed (non-relocatable) schemas"
 msgstr "List the installed (non-relocatable) schemas"
 
-#: ../gio/gsettings-tool.c:545
+#: ../gio/gsettings-tool.c:541
 msgid "List the installed relocatable schemas"
 msgstr "List the installed relocatable schemas"
 
-#: ../gio/gsettings-tool.c:551
+#: ../gio/gsettings-tool.c:547
 msgid "List the keys in SCHEMA"
 msgstr "List the keys in SCHEMA"
 
-#: ../gio/gsettings-tool.c:552
-#: ../gio/gsettings-tool.c:558
-#: ../gio/gsettings-tool.c:595
+#: ../gio/gsettings-tool.c:548
+#: ../gio/gsettings-tool.c:554
+#: ../gio/gsettings-tool.c:591
 msgid "SCHEMA[:PATH]"
 msgstr "SCHEMA[:PATH]"
 
-#: ../gio/gsettings-tool.c:557
+#: ../gio/gsettings-tool.c:553
 msgid "List the children of SCHEMA"
 msgstr "List the children of SCHEMA"
 
-#: ../gio/gsettings-tool.c:563
+#: ../gio/gsettings-tool.c:559
 msgid ""
 "List keys and values, recursively\n"
 "If no SCHEMA is given, list all keys\n"
@@ -1980,46 +1980,46 @@ msgstr ""
 "List keys and values, recursively\n"
 "If no SCHEMA is given, list all keys\n"
 
-#: ../gio/gsettings-tool.c:565
+#: ../gio/gsettings-tool.c:561
 msgid "[SCHEMA[:PATH]]"
 msgstr "[SCHEMA[:PATH]]"
 
-#: ../gio/gsettings-tool.c:570
+#: ../gio/gsettings-tool.c:566
 msgid "Get the value of KEY"
 msgstr "Get the value of KEY"
 
-#: ../gio/gsettings-tool.c:571
-#: ../gio/gsettings-tool.c:577
-#: ../gio/gsettings-tool.c:589
-#: ../gio/gsettings-tool.c:601
+#: ../gio/gsettings-tool.c:567
+#: ../gio/gsettings-tool.c:573
+#: ../gio/gsettings-tool.c:585
+#: ../gio/gsettings-tool.c:597
 msgid "SCHEMA[:PATH] KEY"
 msgstr "SCHEMA[:PATH] KEY"
 
-#: ../gio/gsettings-tool.c:576
+#: ../gio/gsettings-tool.c:572
 msgid "Query the range of valid values for KEY"
 msgstr "Query the range of valid values for KEY"
 
-#: ../gio/gsettings-tool.c:582
+#: ../gio/gsettings-tool.c:578
 msgid "Set the value of KEY to VALUE"
 msgstr "Set the value of KEY to VALUE"
 
-#: ../gio/gsettings-tool.c:583
+#: ../gio/gsettings-tool.c:579
 msgid "SCHEMA[:PATH] KEY VALUE"
 msgstr "SCHEMA[:PATH] KEY VALUE"
 
-#: ../gio/gsettings-tool.c:588
+#: ../gio/gsettings-tool.c:584
 msgid "Reset KEY to its default value"
 msgstr "Reset KEY to its default value"
 
-#: ../gio/gsettings-tool.c:594
+#: ../gio/gsettings-tool.c:590
 msgid "Reset all keys in SCHEMA to their defaults"
 msgstr "Reset all keys in SCHEMA to their defaults"
 
-#: ../gio/gsettings-tool.c:600
+#: ../gio/gsettings-tool.c:596
 msgid "Check if KEY is writable"
 msgstr "Check if KEY is writable"
 
-#: ../gio/gsettings-tool.c:606
+#: ../gio/gsettings-tool.c:602
 msgid ""
 "Monitor KEY for changes.\n"
 "If no KEY is specified, monitor all keys in SCHEMA.\n"
@@ -2029,11 +2029,11 @@ msgstr ""
 "If no KEY is specified, monitor all keys in SCHEMA.\n"
 "Use ^C to stop monitoring.\n"
 
-#: ../gio/gsettings-tool.c:609
+#: ../gio/gsettings-tool.c:605
 msgid "SCHEMA[:PATH] [KEY]"
 msgstr "SCHEMA[:PATH] [KEY]"
 
-#: ../gio/gsettings-tool.c:613
+#: ../gio/gsettings-tool.c:609
 #, c-format
 msgid ""
 "Unknown command %s\n"
@@ -2042,10 +2042,10 @@ msgstr ""
 "Unknown command %s\n"
 "\n"
 
-#: ../gio/gsettings-tool.c:621
+#: ../gio/gsettings-tool.c:617
 msgid ""
 "Usage:\n"
-"  gsettings COMMAND [ARGS...]\n"
+"  gsettings [--schemadir SCHEMADIR] COMMAND [ARGS...]\n"
 "\n"
 "Commands:\n"
 "  help                      Show this information\n"
@@ -2066,7 +2066,7 @@ msgid ""
 "\n"
 msgstr ""
 "Usage:\n"
-"  gsettings COMMAND [ARGS...]\n"
+"  gsettings [--schemadir SCHEMADIR] COMMAND [ARGS...]\n"
 "\n"
 "Commands:\n"
 "  help                      Show this information\n"
@@ -2086,30 +2086,34 @@ msgstr ""
 "Use 'gsettings help COMMAND' to get detailed help.\n"
 "\n"
 
-#: ../gio/gsettings-tool.c:643
+#: ../gio/gsettings-tool.c:639
 #, c-format
 msgid ""
 "Usage:\n"
-"  gsettings %s %s\n"
+"  gsettings [--schemadir SCHEMADIR] %s %s\n"
 "\n"
 "%s\n"
 "\n"
 msgstr ""
 "Usage:\n"
-"  gsettings %s %s\n"
+"  gsettings [--schemadir SCHEMADIR] %s %s\n"
 "\n"
 "%s\n"
 "\n"
 
-#: ../gio/gsettings-tool.c:648
+#: ../gio/gsettings-tool.c:642
 msgid "Arguments:\n"
 msgstr "Arguments:\n"
 
-#: ../gio/gsettings-tool.c:652
+#: ../gio/gsettings-tool.c:645
+msgid "  SCHEMADIR A directory to search for additional schemas\n"
+msgstr "  SCHEMADIR A directory to search for additional schemas\n"
+
+#: ../gio/gsettings-tool.c:649
 msgid "  COMMAND   The (optional) command to explain\n"
 msgstr "  COMMAND   The (optional) command to explain\n"
 
-#: ../gio/gsettings-tool.c:656
+#: ../gio/gsettings-tool.c:653
 msgid ""
 "  SCHEMA    The name of the schema\n"
 "  PATH      The path, for relocatable schemas\n"
@@ -2117,19 +2121,19 @@ msgstr ""
 "  SCHEMA    The name of the schema\n"
 "  PATH      The path, for relocatable schemas\n"
 
-#: ../gio/gsettings-tool.c:661
+#: ../gio/gsettings-tool.c:658
 msgid "  KEY       The (optional) key within the schema\n"
 msgstr "  KEY       The (optional) key within the schema\n"
 
-#: ../gio/gsettings-tool.c:665
+#: ../gio/gsettings-tool.c:662
 msgid "  KEY       The key within the schema\n"
 msgstr "  KEY       The key within the schema\n"
 
-#: ../gio/gsettings-tool.c:669
+#: ../gio/gsettings-tool.c:666
 msgid "  VALUE     The value to set\n"
 msgstr "  VALUE     The value to set\n"
 
-#: ../gio/gsettings-tool.c:766
+#: ../gio/gsettings-tool.c:787
 #, c-format
 msgid "Empty schema name given\n"
 msgstr "Empty schema name given\n"
@@ -2248,32 +2252,32 @@ msgstr "Error receiving message: %s"
 msgid "g_socket_get_credentials not implemented for this OS"
 msgstr "g_socket_get_credentials not implemented for this OS"
 
-#: ../gio/gsocketclient.c:163
+#: ../gio/gsocketclient.c:171
 #, c-format
 msgid "Could not connect to proxy server %s: "
 msgstr "Could not connect to proxy server %s: "
 
-#: ../gio/gsocketclient.c:177
+#: ../gio/gsocketclient.c:185
 #, c-format
 msgid "Could not connect to %s: "
 msgstr "Could not connect to %s: "
 
-#: ../gio/gsocketclient.c:179
+#: ../gio/gsocketclient.c:187
 msgid "Could not connect: "
 msgstr "Could not connect: "
 
-#: ../gio/gsocketclient.c:834
-#: ../gio/gsocketclient.c:1399
+#: ../gio/gsocketclient.c:973
+#: ../gio/gsocketclient.c:1544
 msgid "Unknown error on connect"
 msgstr "Unknown error on connect"
 
-#: ../gio/gsocketclient.c:874
-#: ../gio/gsocketclient.c:1291
+#: ../gio/gsocketclient.c:1026
+#: ../gio/gsocketclient.c:1483
 msgid "Trying to proxy over non-TCP connection is not supported."
 msgstr "Trying to proxy over non-TCP connection is not supported."
 
-#: ../gio/gsocketclient.c:896
-#: ../gio/gsocketclient.c:1311
+#: ../gio/gsocketclient.c:1052
+#: ../gio/gsocketclient.c:1504
 #, c-format
 msgid "Proxy protocol '%s' is not supported."
 msgstr "Proxy protocol '%s' is not supported."
@@ -3079,13 +3083,13 @@ msgstr "Key file contains unsupported encoding '%s'"
 
 #: ../glib/gkeyfile.c:1548
 #: ../glib/gkeyfile.c:1710
-#: ../glib/gkeyfile.c:3087
-#: ../glib/gkeyfile.c:3153
-#: ../glib/gkeyfile.c:3288
-#: ../glib/gkeyfile.c:3421
-#: ../glib/gkeyfile.c:3563
-#: ../glib/gkeyfile.c:3795
-#: ../glib/gkeyfile.c:3864
+#: ../glib/gkeyfile.c:3088
+#: ../glib/gkeyfile.c:3154
+#: ../glib/gkeyfile.c:3289
+#: ../glib/gkeyfile.c:3422
+#: ../glib/gkeyfile.c:3564
+#: ../glib/gkeyfile.c:3802
+#: ../glib/gkeyfile.c:3871
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "Key file does not have group '%s'"
@@ -3103,55 +3107,55 @@ msgstr "Key file contains key '%s' with value '%s' which is not UTF-8"
 
 #: ../glib/gkeyfile.c:1849
 #: ../glib/gkeyfile.c:1965
-#: ../glib/gkeyfile.c:2333
+#: ../glib/gkeyfile.c:2334
 #, c-format
 msgid "Key file contains key '%s' which has a value that cannot be interpreted."
 msgstr "Key file contains key '%s' which has a value that cannot be interpreted."
 
-#: ../glib/gkeyfile.c:2550
-#: ../glib/gkeyfile.c:2916
+#: ../glib/gkeyfile.c:2551
+#: ../glib/gkeyfile.c:2917
 #, c-format
 msgid "Key file contains key '%s' in group '%s' which has a value that cannot be interpreted."
 msgstr "Key file contains key '%s' in group '%s' which has a value that cannot be interpreted."
 
-#: ../glib/gkeyfile.c:2628
-#: ../glib/gkeyfile.c:2704
+#: ../glib/gkeyfile.c:2629
+#: ../glib/gkeyfile.c:2705
 #, c-format
 msgid "Key '%s' in group '%s' has value '%s' where %s was expected"
 msgstr "Key '%s' in group '%s' has value '%s' where %s was expected"
 
-#: ../glib/gkeyfile.c:3102
-#: ../glib/gkeyfile.c:3303
-#: ../glib/gkeyfile.c:3875
+#: ../glib/gkeyfile.c:3103
+#: ../glib/gkeyfile.c:3304
+#: ../glib/gkeyfile.c:3882
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "Key file does not have key '%s' in group '%s'"
 
-#: ../glib/gkeyfile.c:4109
+#: ../glib/gkeyfile.c:4116
 msgid "Key file contains escape character at end of line"
 msgstr "Key file contains escape character at end of line"
 
-#: ../glib/gkeyfile.c:4131
+#: ../glib/gkeyfile.c:4138
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "Key file contains invalid escape sequence '%s'"
 
-#: ../glib/gkeyfile.c:4273
+#: ../glib/gkeyfile.c:4280
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "Value '%s' cannot be interpreted as a number."
 
-#: ../glib/gkeyfile.c:4287
+#: ../glib/gkeyfile.c:4294
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "Integer value '%s' out of range"
 
-#: ../glib/gkeyfile.c:4320
+#: ../glib/gkeyfile.c:4327
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr "Value '%s' cannot be interpreted as a float number."
 
-#: ../glib/gkeyfile.c:4344
+#: ../glib/gkeyfile.c:4351
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "Value '%s' cannot be interpreted as a boolean."
@@ -3835,89 +3839,89 @@ msgstr "Invalid sequence in conversion input"
 msgid "Character out of range for UTF-16"
 msgstr "Character out of range for UTF-16"
 
-#: ../glib/gutils.c:2167
-#: ../glib/gutils.c:2194
-#: ../glib/gutils.c:2298
+#: ../glib/gutils.c:2166
+#: ../glib/gutils.c:2193
+#: ../glib/gutils.c:2297
 #, c-format
 msgid "%u byte"
 msgid_plural "%u bytes"
 msgstr[0] "בית אחד"
 msgstr[1] "%u בתים"
 
-#: ../glib/gutils.c:2173
+#: ../glib/gutils.c:2172
 #, c-format
 msgid "%.1f KiB"
 msgstr "%.1f KiB"
 
-#: ../glib/gutils.c:2175
+#: ../glib/gutils.c:2174
 #, c-format
 msgid "%.1f MiB"
 msgstr "%.1f MiB"
 
-#: ../glib/gutils.c:2178
+#: ../glib/gutils.c:2177
 #, c-format
 msgid "%.1f GiB"
 msgstr "%.1f GiB"
 
-#: ../glib/gutils.c:2181
+#: ../glib/gutils.c:2180
 #, c-format
 msgid "%.1f TiB"
 msgstr "%.1f TiB"
 
-#: ../glib/gutils.c:2184
+#: ../glib/gutils.c:2183
 #, c-format
 msgid "%.1f PiB"
 msgstr "%.1f PiB"
 
-#: ../glib/gutils.c:2187
+#: ../glib/gutils.c:2186
 #, c-format
 msgid "%.1f EiB"
 msgstr "%.1f EiB"
 
-#: ../glib/gutils.c:2200
+#: ../glib/gutils.c:2199
 #, c-format
 msgid "%.1f kB"
 msgstr "%.1f ק״ב"
 
-#: ../glib/gutils.c:2203
-#: ../glib/gutils.c:2311
+#: ../glib/gutils.c:2202
+#: ../glib/gutils.c:2310
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f מ״ב"
 
-#: ../glib/gutils.c:2206
-#: ../glib/gutils.c:2316
+#: ../glib/gutils.c:2205
+#: ../glib/gutils.c:2315
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f ג״ב"
 
-#: ../glib/gutils.c:2208
-#: ../glib/gutils.c:2321
+#: ../glib/gutils.c:2207
+#: ../glib/gutils.c:2320
 #, c-format
 msgid "%.1f TB"
 msgstr "%.1f ט״ב"
 
-#: ../glib/gutils.c:2211
-#: ../glib/gutils.c:2326
+#: ../glib/gutils.c:2210
+#: ../glib/gutils.c:2325
 #, c-format
 msgid "%.1f PB"
 msgstr "%.1f פ״ב"
 
-#: ../glib/gutils.c:2214
-#: ../glib/gutils.c:2331
+#: ../glib/gutils.c:2213
+#: ../glib/gutils.c:2330
 #, c-format
 msgid "%.1f EB"
 msgstr "%.1f א״ב"
 
 #. Translators: the %s in "%s bytes" will always be replaced by a number.
-#: ../glib/gutils.c:2251
+#: ../glib/gutils.c:2250
 #, c-format
 msgid "%s byte"
 msgid_plural "%s bytes"
 msgstr[0] "בית אחד"
 msgstr[1] "%s בתים"
 
-#: ../glib/gutils.c:2306
+#: ../glib/gutils.c:2305
 #, c-format
 msgid "%.1f KB"
 msgstr "%.1f ק״ב"
diff --git a/po/nb.po b/po/nb.po
index 6c068ef..6272729 100644
--- a/po/nb.po
+++ b/po/nb.po
@@ -1,4 +1,4 @@
-# Norwegian (bokmål) translation of glib.
+# Norwegian bokmål translation of glib.
 # Copyright (C) 2001-2003, 2005 Free Software Foundation, Inc.
 #
 # Kjartan Maraas <kmaraas@gnome.org>, 2001-2011.
@@ -8,10 +8,10 @@ msgid ""
 msgstr ""
 "Project-Id-Version: glib 2.31.x\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2011-12-01 18:00+0100\n"
-"PO-Revision-Date: 2011-12-01 18:00+0100\n"
+"POT-Creation-Date: 2011-12-21 22:19+0100\n"
+"PO-Revision-Date: 2011-12-21 22:22+0100\n"
 "Last-Translator: Kjartan Maraas <kmaraas@gnome.org>\n"
-"Language-Team: Norwegian Bokmål <i18n-nb@lister.ping.uio.no>\n"
+"Language-Team: Norwegian bokmål <i18n-nb@lister.ping.uio.no>\n"
 "Language:\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -21,18 +21,18 @@ msgstr ""
 #: ../gio/gbufferedinputstream.c:411 ../gio/gbufferedinputstream.c:492
 #: ../gio/ginputstream.c:185 ../gio/ginputstream.c:317
 #: ../gio/ginputstream.c:556 ../gio/ginputstream.c:680
-#: ../gio/goutputstream.c:201 ../gio/goutputstream.c:750
+#: ../gio/goutputstream.c:201 ../gio/goutputstream.c:751
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "Tellerverdi gitt til %s er for stor"
 
 #: ../gio/gbufferedinputstream.c:881 ../gio/ginputstream.c:888
-#: ../gio/giostream.c:292 ../gio/goutputstream.c:1224
+#: ../gio/giostream.c:292 ../gio/goutputstream.c:1226
 msgid "Stream is already closed"
 msgstr "Strømmen er allerede lukket"
 
-#: ../gio/gcancellable.c:318 ../gio/gdbusconnection.c:1850
-#: ../gio/gdbusconnection.c:1941 ../gio/gdbusconnection.c:2115
+#: ../gio/gcancellable.c:318 ../gio/gdbusconnection.c:1839
+#: ../gio/gdbusconnection.c:1930 ../gio/gdbusconnection.c:2104
 #: ../gio/gdbusprivate.c:1419 ../gio/glocalfile.c:2100
 #: ../gio/gsimpleasyncresult.c:810 ../gio/gsimpleasyncresult.c:836
 #, c-format
@@ -240,7 +240,7 @@ msgid "Cannot determine session bus address (not implemented for this OS)"
 msgstr ""
 "Kan ikke bestemme adresse til øktbussen (ikke implementert på dette OSet)"
 
-#: ../gio/gdbusaddress.c:1254 ../gio/gdbusconnection.c:6704
+#: ../gio/gdbusaddress.c:1254 ../gio/gdbusconnection.c:6693
 #, c-format
 msgid ""
 "Cannot determine bus address from DBUS_STARTER_BUS_TYPE environment variable "
@@ -249,7 +249,7 @@ msgstr ""
 "Kan ikke bestemme adresse for buss fra miljøvariabelen DBUS_STARTER_BUS_TYPE "
 "- ukjent verdi «%s»"
 
-#: ../gio/gdbusaddress.c:1263 ../gio/gdbusconnection.c:6713
+#: ../gio/gdbusaddress.c:1263 ../gio/gdbusconnection.c:6702
 msgid ""
 "Cannot determine bus address because the DBUS_STARTER_BUS_TYPE environment "
 "variable is not set"
@@ -360,86 +360,86 @@ msgstr "Feil under åpning av nøkkelring «%s» for skriving: "
 msgid "(Additionally, releasing the lock for `%s' also failed: %s) "
 msgstr "(I tillegg feilet frislipp av lås for «%s» også: %s) "
 
-#: ../gio/gdbusconnection.c:605 ../gio/gdbusconnection.c:2418
+#: ../gio/gdbusconnection.c:594 ../gio/gdbusconnection.c:2407
 msgid "The connection is closed"
 msgstr "Tilkoblingen er lukket"
 
-#: ../gio/gdbusconnection.c:1895
+#: ../gio/gdbusconnection.c:1884
 msgid "Timeout was reached"
 msgstr "Tidsavbrudd ble nådd"
 
-#: ../gio/gdbusconnection.c:2540
+#: ../gio/gdbusconnection.c:2529
 msgid ""
 "Unsupported flags encountered when constructing a client-side connection"
 msgstr "Ikke støttede flagg funnet ved oppretting av en klientside tilkobling"
 
-#: ../gio/gdbusconnection.c:4042 ../gio/gdbusconnection.c:4358
+#: ../gio/gdbusconnection.c:4031 ../gio/gdbusconnection.c:4347
 #, c-format
 msgid ""
 "No such interface `org.freedesktop.DBus.Properties' on object at path %s"
 msgstr ""
 "Grensesnitt «org.freedesktop.DBus.Properties» finnes ikke på objekt i sti %s"
 
-#: ../gio/gdbusconnection.c:4113
+#: ../gio/gdbusconnection.c:4102
 #, c-format
 msgid "Error setting property `%s': Expected type `%s' but got `%s'"
 msgstr "Feil ved setting av egenskap «%s»: Forventet type «%s», men fikk «%s»"
 
-#: ../gio/gdbusconnection.c:4208
+#: ../gio/gdbusconnection.c:4197
 #, c-format
 msgid "No such property `%s'"
 msgstr "Egenskap «%s» finnes ikke"
 
-#: ../gio/gdbusconnection.c:4220
+#: ../gio/gdbusconnection.c:4209
 #, c-format
 msgid "Property `%s' is not readable"
 msgstr "Egenskap «%s» er er ikke lesbar"
 
-#: ../gio/gdbusconnection.c:4231
+#: ../gio/gdbusconnection.c:4220
 #, c-format
 msgid "Property `%s' is not writable"
 msgstr "Egenskap «%s» er er ikke skrivbar"
 
-#: ../gio/gdbusconnection.c:4301 ../gio/gdbusconnection.c:6147
+#: ../gio/gdbusconnection.c:4290 ../gio/gdbusconnection.c:6136
 #, c-format
 msgid "No such interface `%s'"
 msgstr "Grensesnitt «%s» finnes ikke"
 
-#: ../gio/gdbusconnection.c:4485
+#: ../gio/gdbusconnection.c:4474
 msgid "No such interface"
 msgstr "Grensesnittet finnes ikke"
 
-#: ../gio/gdbusconnection.c:4706 ../gio/gdbusconnection.c:6653
+#: ../gio/gdbusconnection.c:4695 ../gio/gdbusconnection.c:6642
 #, c-format
 msgid "No such interface `%s' on object at path %s"
 msgstr "Grensesnitt «%s» finnes ikke på objektsti %s"
 
-#: ../gio/gdbusconnection.c:4758
+#: ../gio/gdbusconnection.c:4747
 #, c-format
 msgid "No such method `%s'"
 msgstr "Metoden «%s» finnes ikke"
 
-#: ../gio/gdbusconnection.c:4789
+#: ../gio/gdbusconnection.c:4778
 #, c-format
 msgid "Type of message, `%s', does not match expected type `%s'"
 msgstr "Type melding, «%s», stemmer ikke overens med forventet type «%s»"
 
-#: ../gio/gdbusconnection.c:5009
+#: ../gio/gdbusconnection.c:4998
 #, c-format
 msgid "An object is already exported for the interface %s at %s"
 msgstr "Et objekt er allerede eksportert for grensesnitt %s ved %s"
 
-#: ../gio/gdbusconnection.c:5207
+#: ../gio/gdbusconnection.c:5196
 #, c-format
 msgid "Method `%s' returned type `%s', but expected `%s'"
 msgstr "Metode «%s» returnerte type «%s», men forventet «%s»"
 
-#: ../gio/gdbusconnection.c:6258
+#: ../gio/gdbusconnection.c:6247
 #, c-format
 msgid "Method `%s' on interface `%s' with signature `%s' does not exist"
 msgstr "Metode «%s» på grensesnitt «%s» med signatur «%s» eksisterer ikke"
 
-#: ../gio/gdbusconnection.c:6377
+#: ../gio/gdbusconnection.c:6366
 #, c-format
 msgid "A subtree is already exported for %s"
 msgstr "Et undertre er allerede eksportert for %s"
@@ -980,15 +980,15 @@ msgstr "Feil antall tegn (%d) i GEmblemedIcon-koding"
 msgid "Expected a GEmblem for GEmblemedIcon"
 msgstr "Ventet et GEmblem for GEmblemedIcon"
 
-#: ../gio/gfile.c:871 ../gio/gfile.c:1102 ../gio/gfile.c:1237
-#: ../gio/gfile.c:1474 ../gio/gfile.c:1528 ../gio/gfile.c:1585
-#: ../gio/gfile.c:1668 ../gio/gfile.c:1723 ../gio/gfile.c:1783
-#: ../gio/gfile.c:1837 ../gio/gfile.c:3309 ../gio/gfile.c:3363
-#: ../gio/gfile.c:3497 ../gio/gfile.c:3538 ../gio/gfile.c:3868
-#: ../gio/gfile.c:4270 ../gio/gfile.c:4356 ../gio/gfile.c:4445
-#: ../gio/gfile.c:4543 ../gio/gfile.c:4630 ../gio/gfile.c:4724
-#: ../gio/gfile.c:5045 ../gio/gfile.c:5312 ../gio/gfile.c:5377
-#: ../gio/gfile.c:6954 ../gio/gfile.c:7044 ../gio/gfile.c:7130
+#: ../gio/gfile.c:874 ../gio/gfile.c:1105 ../gio/gfile.c:1240
+#: ../gio/gfile.c:1477 ../gio/gfile.c:1531 ../gio/gfile.c:1588
+#: ../gio/gfile.c:1671 ../gio/gfile.c:1726 ../gio/gfile.c:1786
+#: ../gio/gfile.c:1840 ../gio/gfile.c:3312 ../gio/gfile.c:3366
+#: ../gio/gfile.c:3500 ../gio/gfile.c:3541 ../gio/gfile.c:3871
+#: ../gio/gfile.c:4273 ../gio/gfile.c:4359 ../gio/gfile.c:4448
+#: ../gio/gfile.c:4546 ../gio/gfile.c:4633 ../gio/gfile.c:4727
+#: ../gio/gfile.c:5048 ../gio/gfile.c:5315 ../gio/gfile.c:5380
+#: ../gio/gfile.c:7008 ../gio/gfile.c:7098 ../gio/gfile.c:7184
 #: ../gio/win32/gwinhttpfile.c:439
 msgid "Operation not supported"
 msgstr "Operasjonen er ikke støttet"
@@ -1001,58 +1001,58 @@ msgstr "Operasjonen er ikke støttet"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: ../gio/gfile.c:1358 ../gio/glocalfile.c:1051 ../gio/glocalfile.c:1062
+#: ../gio/gfile.c:1361 ../gio/glocalfile.c:1051 ../gio/glocalfile.c:1062
 #: ../gio/glocalfile.c:1075
 msgid "Containing mount does not exist"
 msgstr "Omsluttende monteringspunkt finnes ikke"
 
-#: ../gio/gfile.c:2411 ../gio/glocalfile.c:2256
+#: ../gio/gfile.c:2414 ../gio/glocalfile.c:2256
 msgid "Can't copy over directory"
 msgstr "Kan ikke kopiere over katalog"
 
-#: ../gio/gfile.c:2472
+#: ../gio/gfile.c:2475
 msgid "Can't copy directory over directory"
 msgstr "Kan ikke kopiere katalog over katalog"
 
-#: ../gio/gfile.c:2480 ../gio/glocalfile.c:2265
+#: ../gio/gfile.c:2483 ../gio/glocalfile.c:2265
 msgid "Target file exists"
 msgstr "Målfilen eksisterer"
 
-#: ../gio/gfile.c:2498
+#: ../gio/gfile.c:2501
 msgid "Can't recursively copy directory"
 msgstr "Kan ikke kopiere katalog rekursivt"
 
-#: ../gio/gfile.c:2758
+#: ../gio/gfile.c:2761
 msgid "Splice not supported"
 msgstr "Splice er ikke støttet"
 
-#: ../gio/gfile.c:2762
+#: ../gio/gfile.c:2765
 #, c-format
 msgid "Error splicing file: %s"
 msgstr "Feil ved bruk av  splice(2) på fil: %s"
 
-#: ../gio/gfile.c:2909
+#: ../gio/gfile.c:2912
 msgid "Can't copy special file"
 msgstr "Kan ikke kopiere spesiell fil"
 
-#: ../gio/gfile.c:3487
+#: ../gio/gfile.c:3490
 msgid "Invalid symlink value given"
 msgstr "Ugyldig verdi oppgitt for symbolsk lenke"
 
-#: ../gio/gfile.c:3581
+#: ../gio/gfile.c:3584
 msgid "Trash not supported"
 msgstr "Papirkurv er ikke støttet"
 
-#: ../gio/gfile.c:3630
+#: ../gio/gfile.c:3633
 #, c-format
 msgid "File names cannot contain '%c'"
 msgstr "Filnavn kan ikke inneholde «%c»"
 
-#: ../gio/gfile.c:6013 ../gio/gvolume.c:332
+#: ../gio/gfile.c:6067 ../gio/gvolume.c:332
 msgid "volume doesn't implement mount"
 msgstr "volumet implementerer ikke montering"
 
-#: ../gio/gfile.c:6124
+#: ../gio/gfile.c:6178
 msgid "No application is registered as handling this file"
 msgstr "Ingen program registrert for å håndtere denne filen"
 
@@ -1169,7 +1169,7 @@ msgstr "Inndatastrøm implementerer ikke lesing"
 #. * already an operation running against this stream when
 #. * you try to start one
 #: ../gio/ginputstream.c:898 ../gio/giostream.c:302
-#: ../gio/goutputstream.c:1234
+#: ../gio/goutputstream.c:1236
 msgid "Stream has outstanding operation"
 msgstr "Strømmen har utestående operasjoner"
 
@@ -1320,17 +1320,17 @@ msgstr "stien for en liste må slutte med «:/»"
 msgid "<%s id='%s'> already specified"
 msgstr "<%s id=«%s»> er allerede spesifisert"
 
-#: ../gio/glib-compile-schemas.c:1416
+#: ../gio/glib-compile-schemas.c:1416 ../gio/gmenumarkup.c:263
 #, c-format
 msgid "Element <%s> not allowed inside <%s>"
 msgstr "Element <%s> er ikke tillatt inne i <%s>"
 
-#: ../gio/glib-compile-schemas.c:1420
+#: ../gio/glib-compile-schemas.c:1420 ../gio/gmenumarkup.c:268
 #, c-format
 msgid "Element <%s> not allowed at toplevel"
 msgstr "Element <%s> er ikke tillatt på toppnivå"
 
-#: ../gio/glib-compile-schemas.c:1511
+#: ../gio/glib-compile-schemas.c:1511 ../gio/gmenumarkup.c:347
 #, c-format
 msgid "text may not appear inside <%s>"
 msgstr "tekst kan ikke forekomme inne i <%s>"
@@ -1479,9 +1479,9 @@ msgid "Can't rename file, filename already exists"
 msgstr "Kan ikke endre navn på filen. Filnavnet eksisterer allerede"
 
 #: ../gio/glocalfile.c:1139 ../gio/glocalfile.c:2129 ../gio/glocalfile.c:2158
-#: ../gio/glocalfile.c:2318 ../gio/glocalfileoutputstream.c:571
-#: ../gio/glocalfileoutputstream.c:624 ../gio/glocalfileoutputstream.c:669
-#: ../gio/glocalfileoutputstream.c:1157
+#: ../gio/glocalfile.c:2318 ../gio/glocalfileoutputstream.c:581
+#: ../gio/glocalfileoutputstream.c:634 ../gio/glocalfileoutputstream.c:679
+#: ../gio/glocalfileoutputstream.c:1167
 msgid "Invalid filename"
 msgstr "Ugyldig filnavn"
 
@@ -1556,9 +1556,9 @@ msgstr "Feil under flytting av fil: %s"
 msgid "Can't move directory over directory"
 msgstr "Kan ikke flytte katalog over katalog"
 
-#: ../gio/glocalfile.c:2278 ../gio/glocalfileoutputstream.c:955
-#: ../gio/glocalfileoutputstream.c:969 ../gio/glocalfileoutputstream.c:984
-#: ../gio/glocalfileoutputstream.c:1000 ../gio/glocalfileoutputstream.c:1014
+#: ../gio/glocalfile.c:2278 ../gio/glocalfileoutputstream.c:965
+#: ../gio/glocalfileoutputstream.c:979 ../gio/glocalfileoutputstream.c:994
+#: ../gio/glocalfileoutputstream.c:1010 ../gio/glocalfileoutputstream.c:1024
 msgid "Backup file creation failed"
 msgstr "Oppretting av sikkerhetskopi feilet"
 
@@ -1592,7 +1592,7 @@ msgstr "Feil under setting av utvidet attributt «%s»: %s"
 msgid " (invalid encoding)"
 msgstr " (ugyldig koding)"
 
-#: ../gio/glocalfileinfo.c:1527 ../gio/glocalfileoutputstream.c:833
+#: ../gio/glocalfileinfo.c:1527 ../gio/glocalfileoutputstream.c:843
 #, c-format
 msgid "Error when getting information for file '%s': %s"
 msgstr "Feil ved henting av informasjon for fil «%s»: %s"
@@ -1665,14 +1665,14 @@ msgstr "SELinux er ikke slått på på dette systemet"
 msgid "Setting attribute %s not supported"
 msgstr "Støtter ikke å sette attributt %s"
 
-#: ../gio/glocalfileinputstream.c:185 ../gio/glocalfileoutputstream.c:722
+#: ../gio/glocalfileinputstream.c:185 ../gio/glocalfileoutputstream.c:732
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "Feil under lesing fra fil: %s"
 
 #: ../gio/glocalfileinputstream.c:216 ../gio/glocalfileinputstream.c:228
 #: ../gio/glocalfileinputstream.c:340 ../gio/glocalfileoutputstream.c:470
-#: ../gio/glocalfileoutputstream.c:1032
+#: ../gio/glocalfileoutputstream.c:1042
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "Feil under søking i fil: %s"
@@ -1688,7 +1688,7 @@ msgid "Unable to find default local file monitor type"
 msgstr "Kan ikke finne forvalgt lokal filovervåkingstype"
 
 #: ../gio/glocalfileoutputstream.c:202 ../gio/glocalfileoutputstream.c:235
-#: ../gio/glocalfileoutputstream.c:743
+#: ../gio/glocalfileoutputstream.c:753
 #, c-format
 msgid "Error writing to file: %s"
 msgstr "Feil under skriving til fil: %s"
@@ -1708,31 +1708,31 @@ msgstr "Feil under oppretting av sikkerhetskopi: %s"
 msgid "Error renaming temporary file: %s"
 msgstr "Feil ved endring av navn på midlertidig fil: %s"
 
-#: ../gio/glocalfileoutputstream.c:516 ../gio/glocalfileoutputstream.c:1083
+#: ../gio/glocalfileoutputstream.c:516 ../gio/glocalfileoutputstream.c:1093
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "Feil under avkorting av fil: «%s»"
 
-#: ../gio/glocalfileoutputstream.c:577 ../gio/glocalfileoutputstream.c:630
-#: ../gio/glocalfileoutputstream.c:675 ../gio/glocalfileoutputstream.c:815
-#: ../gio/glocalfileoutputstream.c:1064 ../gio/glocalfileoutputstream.c:1163
+#: ../gio/glocalfileoutputstream.c:587 ../gio/glocalfileoutputstream.c:640
+#: ../gio/glocalfileoutputstream.c:685 ../gio/glocalfileoutputstream.c:825
+#: ../gio/glocalfileoutputstream.c:1074 ../gio/glocalfileoutputstream.c:1173
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "Feil under åpning av fil «%s»: %s"
 
-#: ../gio/glocalfileoutputstream.c:846
+#: ../gio/glocalfileoutputstream.c:856
 msgid "Target file is a directory"
 msgstr "Målfilen er en katalog"
 
-#: ../gio/glocalfileoutputstream.c:851
+#: ../gio/glocalfileoutputstream.c:861
 msgid "Target file is not a regular file"
 msgstr "Målfilen er ikke en vanlig fil"
 
-#: ../gio/glocalfileoutputstream.c:863
+#: ../gio/glocalfileoutputstream.c:873
 msgid "The file was externally modified"
 msgstr "Filen ble endret eksternt"
 
-#: ../gio/glocalfileoutputstream.c:1048
+#: ../gio/glocalfileoutputstream.c:1058
 #, c-format
 msgid "Error removing old file: %s"
 msgstr "Feil ved fjerning av gammel fil: %s"
@@ -1835,25 +1835,25 @@ msgstr "Nettverk kan ikke nås"
 msgid "Host unreachable"
 msgstr "Kan ikke nå vert"
 
-#: ../gio/gnetworkmonitornetlink.c:94 ../gio/gnetworkmonitornetlink.c:106
-#: ../gio/gnetworkmonitornetlink.c:117
+#: ../gio/gnetworkmonitornetlink.c:97 ../gio/gnetworkmonitornetlink.c:109
+#: ../gio/gnetworkmonitornetlink.c:120
 #, c-format
 msgid "Could not create network monitor: %s"
 msgstr "Kunne ikke lage nettverksovervåker: %s"
 
-#: ../gio/gnetworkmonitornetlink.c:126
+#: ../gio/gnetworkmonitornetlink.c:129
 msgid "Could not create network monitor: "
 msgstr "Kunne ikke lage nettverksovervåker: "
 
-#: ../gio/gnetworkmonitornetlink.c:174
+#: ../gio/gnetworkmonitornetlink.c:177
 msgid "Could not get network status: "
 msgstr "Kunne ikke hente nettverksstatus: "
 
-#: ../gio/goutputstream.c:210 ../gio/goutputstream.c:414
+#: ../gio/goutputstream.c:210 ../gio/goutputstream.c:415
 msgid "Output stream doesn't implement write"
 msgstr "Ut-strømmen implementerer ikke skriving"
 
-#: ../gio/goutputstream.c:375 ../gio/goutputstream.c:873
+#: ../gio/goutputstream.c:376 ../gio/goutputstream.c:874
 msgid "Source stream is already closed"
 msgstr "Kildestrømmen er allerede lukket"
 
@@ -1882,77 +1882,77 @@ msgstr "Midlertidig ute av stand til å slå opp «%s»"
 msgid "Error resolving '%s'"
 msgstr "Feil ved oppslag av «%s»"
 
-#: ../gio/gsettings-tool.c:60
-#, c-format
-msgid "Schema '%s' is not relocatable (path must not be specified)\n"
-msgstr "Skjema «%s» er ikke omplasserbar (stien må ikke oppgis)\n"
-
-#: ../gio/gsettings-tool.c:65 ../gio/gsettings-tool.c:82
+#: ../gio/gsettings-tool.c:53 ../gio/gsettings-tool.c:74
 #, c-format
 msgid "No such schema '%s'\n"
 msgstr "Skjema «%s» finnes ikke\n"
 
-#: ../gio/gsettings-tool.c:77
+#: ../gio/gsettings-tool.c:59
+#, c-format
+msgid "Schema '%s' is not relocatable (path must not be specified)\n"
+msgstr "Skjema «%s» er ikke omplasserbar (stien må ikke oppgis)\n"
+
+#: ../gio/gsettings-tool.c:80
 #, c-format
 msgid "Schema '%s' is relocatable (path must be specified)\n"
 msgstr "Skjema «%s» er omplasserbart (sti må oppgis)\n"
 
-#: ../gio/gsettings-tool.c:92
+#: ../gio/gsettings-tool.c:94
 #, c-format
 msgid "Empty path given.\n"
 msgstr "Stien som ble oppgitt er tom.\n"
 
-#: ../gio/gsettings-tool.c:98
+#: ../gio/gsettings-tool.c:100
 #, c-format
 msgid "Path must begin with a slash (/)\n"
 msgstr "Stien må starte med en skråstrek (/)\n"
 
-#: ../gio/gsettings-tool.c:104
+#: ../gio/gsettings-tool.c:106
 #, c-format
 msgid "Path must end with a slash (/)\n"
 msgstr "Stien må slutte med skråstrek (/)\n"
 
-#: ../gio/gsettings-tool.c:110
+#: ../gio/gsettings-tool.c:112
 #, c-format
 msgid "Path must not contain two adjacent slashes (//)\n"
 msgstr "Sti må ikke inneholde to etterfølgende skråstreker (//)\n"
 
-#: ../gio/gsettings-tool.c:131
+#: ../gio/gsettings-tool.c:133
 #, c-format
 msgid "No such key '%s'\n"
 msgstr "Nøkkel «%s» finnes ikke\n"
 
-#: ../gio/gsettings-tool.c:504
+#: ../gio/gsettings-tool.c:500
 #, c-format
 msgid "The provided value is outside of the valid range\n"
 msgstr "Oppgitt verdi er utenfor gyldig område\n"
 
-#: ../gio/gsettings-tool.c:533
+#: ../gio/gsettings-tool.c:529
 msgid "Print help"
 msgstr "Skriv ut hjelp"
 
-#: ../gio/gsettings-tool.c:539
+#: ../gio/gsettings-tool.c:535
 msgid "List the installed (non-relocatable) schemas"
 msgstr "Vis installerte (ikke-flyttbare) schema"
 
-#: ../gio/gsettings-tool.c:545
+#: ../gio/gsettings-tool.c:541
 msgid "List the installed relocatable schemas"
 msgstr "Vis installerte flyttbare schema"
 
-#: ../gio/gsettings-tool.c:551
+#: ../gio/gsettings-tool.c:547
 msgid "List the keys in SCHEMA"
 msgstr "Vis nøklene i SCHEMA"
 
-#: ../gio/gsettings-tool.c:552 ../gio/gsettings-tool.c:558
-#: ../gio/gsettings-tool.c:595
+#: ../gio/gsettings-tool.c:548 ../gio/gsettings-tool.c:554
+#: ../gio/gsettings-tool.c:591
 msgid "SCHEMA[:PATH]"
 msgstr "SKJEMA[:STI]"
 
-#: ../gio/gsettings-tool.c:557
+#: ../gio/gsettings-tool.c:553
 msgid "List the children of SCHEMA"
 msgstr "Vis barn av SCHEMA"
 
-#: ../gio/gsettings-tool.c:563
+#: ../gio/gsettings-tool.c:559
 msgid ""
 "List keys and values, recursively\n"
 "If no SCHEMA is given, list all keys\n"
@@ -1960,44 +1960,44 @@ msgstr ""
 "Vis nøkler og verdier rekursivt\n"
 "Vis alle nøkler hvis SKJEMA ikke oppgis\n"
 
-#: ../gio/gsettings-tool.c:565
+#: ../gio/gsettings-tool.c:561
 msgid "[SCHEMA[:PATH]]"
 msgstr "SKJEMA[:STI]"
 
-#: ../gio/gsettings-tool.c:570
+#: ../gio/gsettings-tool.c:566
 msgid "Get the value of KEY"
 msgstr "Hent verdi for NØKKEL"
 
-#: ../gio/gsettings-tool.c:571 ../gio/gsettings-tool.c:577
-#: ../gio/gsettings-tool.c:589 ../gio/gsettings-tool.c:601
+#: ../gio/gsettings-tool.c:567 ../gio/gsettings-tool.c:573
+#: ../gio/gsettings-tool.c:585 ../gio/gsettings-tool.c:597
 msgid "SCHEMA[:PATH] KEY"
 msgstr "SKJEMA[:STI] NØKKEL"
 
-#: ../gio/gsettings-tool.c:576
+#: ../gio/gsettings-tool.c:572
 msgid "Query the range of valid values for KEY"
 msgstr "Spør på gyldig verdiområde for NØKKEL"
 
-#: ../gio/gsettings-tool.c:582
+#: ../gio/gsettings-tool.c:578
 msgid "Set the value of KEY to VALUE"
 msgstr "Sett verdien for NØKKEL til VERDI"
 
-#: ../gio/gsettings-tool.c:583
+#: ../gio/gsettings-tool.c:579
 msgid "SCHEMA[:PATH] KEY VALUE"
 msgstr "SKJEMA[:STI] NØKKEL VERDI"
 
-#: ../gio/gsettings-tool.c:588
+#: ../gio/gsettings-tool.c:584
 msgid "Reset KEY to its default value"
 msgstr "Nullstill NØKKEL til forvalgt verdi"
 
-#: ../gio/gsettings-tool.c:594
+#: ../gio/gsettings-tool.c:590
 msgid "Reset all keys in SCHEMA to their defaults"
 msgstr "Nullstill alle nøkler i SKJEMA til sine forvalgte verdier"
 
-#: ../gio/gsettings-tool.c:600
+#: ../gio/gsettings-tool.c:596
 msgid "Check if KEY is writable"
 msgstr "Sjekk om NØKKEL er skrivbar"
 
-#: ../gio/gsettings-tool.c:606
+#: ../gio/gsettings-tool.c:602
 msgid ""
 "Monitor KEY for changes.\n"
 "If no KEY is specified, monitor all keys in SCHEMA.\n"
@@ -2007,11 +2007,11 @@ msgstr ""
 "Hvis ingen NØKKEL oppgis overvåkes alle nøkler i SKJEMA.\n"
 "Bruk Ctrl+C for å stoppe overvåking.\n"
 
-#: ../gio/gsettings-tool.c:609
+#: ../gio/gsettings-tool.c:605
 msgid "SCHEMA[:PATH] [KEY]"
 msgstr "SCHEMA[:STI] [NØKKEL]"
 
-#: ../gio/gsettings-tool.c:613
+#: ../gio/gsettings-tool.c:609
 #, c-format
 msgid ""
 "Unknown command %s\n"
@@ -2020,10 +2020,10 @@ msgstr ""
 "Ukjent kommando «%s»\n"
 "\n"
 
-#: ../gio/gsettings-tool.c:621
+#: ../gio/gsettings-tool.c:617
 msgid ""
 "Usage:\n"
-"  gsettings COMMAND [ARGS...]\n"
+"  gsettings [--schemadir SCHEMADIR] COMMAND [ARGS...]\n"
 "\n"
 "Commands:\n"
 "  help                      Show this information\n"
@@ -2064,30 +2064,34 @@ msgstr ""
 "Bruk «gsettings help KOMMANDO» for å få detaljert hjelp.\n"
 "\n"
 
-#: ../gio/gsettings-tool.c:643
+#: ../gio/gsettings-tool.c:639
 #, c-format
 msgid ""
 "Usage:\n"
-"  gsettings %s %s\n"
+"  gsettings [--schemadir SCHEMADIR] %s %s\n"
 "\n"
 "%s\n"
 "\n"
 msgstr ""
 "Bruk:\n"
-"  gsettings %s %s\n"
+"  gsettings [--schemadir SCHEMAKATALOG] %s %s\n"
 "\n"
 "%s\n"
 "\n"
 
-#: ../gio/gsettings-tool.c:648
+#: ../gio/gsettings-tool.c:642
 msgid "Arguments:\n"
 msgstr "Argumenter:\n"
 
-#: ../gio/gsettings-tool.c:652
+#: ../gio/gsettings-tool.c:645
+msgid "  SCHEMADIR A directory to search for additional schemas\n"
+msgstr "  SCHEMAKATALOG en katalog for søk etter ekstra schemas\n"
+
+#: ../gio/gsettings-tool.c:649
 msgid "  COMMAND   The (optional) command to explain\n"
 msgstr "  KOMMANDO   Valgfri kommando som skal forklares\n"
 
-#: ../gio/gsettings-tool.c:656
+#: ../gio/gsettings-tool.c:653
 msgid ""
 "  SCHEMA    The name of the schema\n"
 "  PATH      The path, for relocatable schemas\n"
@@ -2096,19 +2100,19 @@ msgstr ""
 "  SCHEMA      Id for schema\n"
 "  PATH        Sti, for schema som kan relokeres\n"
 
-#: ../gio/gsettings-tool.c:661
+#: ../gio/gsettings-tool.c:658
 msgid "  KEY       The (optional) key within the schema\n"
 msgstr "  NØKKEL    Valgfri nøkkel i schema\n"
 
-#: ../gio/gsettings-tool.c:665
+#: ../gio/gsettings-tool.c:662
 msgid "  KEY       The key within the schema\n"
 msgstr "  NØKKEL       Nøkkel i schema\n"
 
-#: ../gio/gsettings-tool.c:669
+#: ../gio/gsettings-tool.c:666
 msgid "  VALUE     The value to set\n"
 msgstr "  VERDI     Verdi som skal settes\n"
 
-#: ../gio/gsettings-tool.c:766
+#: ../gio/gsettings-tool.c:787
 #, c-format
 msgid "Empty schema name given\n"
 msgstr "Tomt navn på schema oppgitt\n"
@@ -3032,9 +3036,9 @@ msgstr "Ugyldig navn på nøkkel: %s"
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "Nøkkelfil inneholder ustøttet tegnkoding «%s»"
 
-#: ../glib/gkeyfile.c:1548 ../glib/gkeyfile.c:1710 ../glib/gkeyfile.c:3087
-#: ../glib/gkeyfile.c:3153 ../glib/gkeyfile.c:3288 ../glib/gkeyfile.c:3421
-#: ../glib/gkeyfile.c:3563 ../glib/gkeyfile.c:3795 ../glib/gkeyfile.c:3864
+#: ../glib/gkeyfile.c:1548 ../glib/gkeyfile.c:1710 ../glib/gkeyfile.c:3088
+#: ../glib/gkeyfile.c:3154 ../glib/gkeyfile.c:3289 ../glib/gkeyfile.c:3422
+#: ../glib/gkeyfile.c:3564 ../glib/gkeyfile.c:3802 ../glib/gkeyfile.c:3871
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "Nøkkelfil har ikke gruppe «%s»"
@@ -3049,7 +3053,7 @@ msgstr "Nøkkelfil har ikke nøkkelen «%s»"
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr "Nøkkelfilen inneholder nøkkelen «%s» med verdi «%s» som ikke er UTF-8"
 
-#: ../glib/gkeyfile.c:1849 ../glib/gkeyfile.c:1965 ../glib/gkeyfile.c:2333
+#: ../glib/gkeyfile.c:1849 ../glib/gkeyfile.c:1965 ../glib/gkeyfile.c:2334
 #, c-format
 msgid ""
 "Key file contains key '%s' which has a value that cannot be interpreted."
@@ -3057,7 +3061,7 @@ msgstr ""
 "Nøkkelfilen inneholder nøkkelen «%s» som har en verdi som ikke kan bli "
 "tolket."
 
-#: ../glib/gkeyfile.c:2550 ../glib/gkeyfile.c:2916
+#: ../glib/gkeyfile.c:2551 ../glib/gkeyfile.c:2917
 #, c-format
 msgid ""
 "Key file contains key '%s' in group '%s' which has a value that cannot be "
@@ -3066,41 +3070,41 @@ msgstr ""
 "Nøkkelfilen inneholder nøkkelen «%s» i gruppen «%s» som har en verdi som "
 "ikke kan bli tolket."
 
-#: ../glib/gkeyfile.c:2628 ../glib/gkeyfile.c:2704
+#: ../glib/gkeyfile.c:2629 ../glib/gkeyfile.c:2705
 #, c-format
 msgid "Key '%s' in group '%s' has value '%s' where %s was expected"
 msgstr "Nøkkel «%s» i gruppe «%s» har en verdi «%s» hvor %s var forventet"
 
-#: ../glib/gkeyfile.c:3102 ../glib/gkeyfile.c:3303 ../glib/gkeyfile.c:3875
+#: ../glib/gkeyfile.c:3103 ../glib/gkeyfile.c:3304 ../glib/gkeyfile.c:3882
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "Nøkkelfilen har ikke nøkkelen i «%s» i gruppen «%s»"
 
-#: ../glib/gkeyfile.c:4109
+#: ../glib/gkeyfile.c:4116
 msgid "Key file contains escape character at end of line"
 msgstr "Nøkkelfilen inneholder skiftetegn ved linjeslutt"
 
-#: ../glib/gkeyfile.c:4131
+#: ../glib/gkeyfile.c:4138
 #, c-format
 msgid "Key file contains invalid escape sequence '%s'"
 msgstr "Nøkkelfil inneholder ugyldig skiftesekvens «%s»"
 
-#: ../glib/gkeyfile.c:4273
+#: ../glib/gkeyfile.c:4280
 #, c-format
 msgid "Value '%s' cannot be interpreted as a number."
 msgstr "Vedien «%s» kan ikke bli tolket som et tall."
 
-#: ../glib/gkeyfile.c:4287
+#: ../glib/gkeyfile.c:4294
 #, c-format
 msgid "Integer value '%s' out of range"
 msgstr "Heltallsverdi «%s» er utenfor gyldig område"
 
-#: ../glib/gkeyfile.c:4320
+#: ../glib/gkeyfile.c:4327
 #, c-format
 msgid "Value '%s' cannot be interpreted as a float number."
 msgstr "Verdi «%s» kan ikke tolkes som et flyttall."
 
-#: ../glib/gkeyfile.c:4344
+#: ../glib/gkeyfile.c:4351
 #, c-format
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "Verdi «%s» kan ikke tolkes som en bolsk verdi."
diff --git a/po/nn.po b/po/nn.po
index c7cffa7..090cea2 100644
--- a/po/nn.po
+++ b/po/nn.po
@@ -1,15 +1,14 @@
 # translation of nn.po to Norwegian Nynorsk
 # Roy-Magne Mo <rmo@sunnmore.net>, 2002.
-# Åsmund Skjæveland <aasmunds@ulrik.uio.no>, 2003-2008.
+# Åsmund Skjæveland <aasmunds@ulrik.uio.no>, 2003-2008, 2011.
 # Norwegian (Nynorsk) translation of glib
 # Copyright (C) Free Software Foundation, 2002.
 msgid ""
 msgstr ""
 "Project-Id-Version: nn\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
-"product=glib&keywords=I18N+L10N&component=general\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=glib&keywords=I18N+L10N&component=general\n"
 "POT-Creation-Date: 2011-09-04 23:56-0400\n"
-"PO-Revision-Date: 2008-02-24 17:33+0100\n"
+"PO-Revision-Date: 2011-12-26 17:14+0100\n"
 "Last-Translator: Åsmund Skjæveland <aasmunds@ulrik.uio.no>\n"
 "Language-Team: Norwegian Nynorsk <i18n-nn@lister.ping.uio.no>\n"
 "Language: nn\n"
@@ -17,27 +16,33 @@ msgstr ""
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
-"Plural-Forms:  nplurals=2; plural=(n != 1);\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
 #: ../glib/gbookmarkfile.c:780
 #, c-format
 msgid "Unexpected attribute '%s' for element '%s'"
 msgstr "Uventa attributt «%s» til elementet «%s»"
 
-#: ../glib/gbookmarkfile.c:791 ../glib/gbookmarkfile.c:862
-#: ../glib/gbookmarkfile.c:872 ../glib/gbookmarkfile.c:979
+#: ../glib/gbookmarkfile.c:791
+#: ../glib/gbookmarkfile.c:862
+#: ../glib/gbookmarkfile.c:872
+#: ../glib/gbookmarkfile.c:979
 #, c-format
 msgid "Attribute '%s' of element '%s' not found"
-msgstr "Attributt «%s» til elementet «%s» ikkje funne"
+msgstr "Attributt «%s» til elementet «%s» ikkje funnen"
 
-#: ../glib/gbookmarkfile.c:1149 ../glib/gbookmarkfile.c:1214
-#: ../glib/gbookmarkfile.c:1278 ../glib/gbookmarkfile.c:1288
+#: ../glib/gbookmarkfile.c:1149
+#: ../glib/gbookmarkfile.c:1214
+#: ../glib/gbookmarkfile.c:1278
+#: ../glib/gbookmarkfile.c:1288
 #, c-format
 msgid "Unexpected tag '%s', tag '%s' expected"
 msgstr "Uventa merke «%s», venta merket «%s»"
 
-#: ../glib/gbookmarkfile.c:1174 ../glib/gbookmarkfile.c:1188
-#: ../glib/gbookmarkfile.c:1256 ../glib/gbookmarkfile.c:1308
+#: ../glib/gbookmarkfile.c:1174
+#: ../glib/gbookmarkfile.c:1188
+#: ../glib/gbookmarkfile.c:1256
+#: ../glib/gbookmarkfile.c:1308
 #, c-format
 msgid "Unexpected tag '%s' inside '%s'"
 msgstr "Uventa merke «%s» inni «%s»"
@@ -51,14 +56,22 @@ msgstr "Klarte ikkje å finna gyldig bokmerkefil i datamappene"
 msgid "A bookmark for URI '%s' already exists"
 msgstr "Eit bokmerke for adressa «%s» finst frå før"
 
-#: ../glib/gbookmarkfile.c:2081 ../glib/gbookmarkfile.c:2239
-#: ../glib/gbookmarkfile.c:2324 ../glib/gbookmarkfile.c:2404
-#: ../glib/gbookmarkfile.c:2489 ../glib/gbookmarkfile.c:2572
-#: ../glib/gbookmarkfile.c:2650 ../glib/gbookmarkfile.c:2729
-#: ../glib/gbookmarkfile.c:2771 ../glib/gbookmarkfile.c:2868
-#: ../glib/gbookmarkfile.c:2994 ../glib/gbookmarkfile.c:3184
-#: ../glib/gbookmarkfile.c:3260 ../glib/gbookmarkfile.c:3425
-#: ../glib/gbookmarkfile.c:3514 ../glib/gbookmarkfile.c:3604
+#: ../glib/gbookmarkfile.c:2081
+#: ../glib/gbookmarkfile.c:2239
+#: ../glib/gbookmarkfile.c:2324
+#: ../glib/gbookmarkfile.c:2404
+#: ../glib/gbookmarkfile.c:2489
+#: ../glib/gbookmarkfile.c:2572
+#: ../glib/gbookmarkfile.c:2650
+#: ../glib/gbookmarkfile.c:2729
+#: ../glib/gbookmarkfile.c:2771
+#: ../glib/gbookmarkfile.c:2868
+#: ../glib/gbookmarkfile.c:2994
+#: ../glib/gbookmarkfile.c:3184
+#: ../glib/gbookmarkfile.c:3260
+#: ../glib/gbookmarkfile.c:3425
+#: ../glib/gbookmarkfile.c:3514
+#: ../glib/gbookmarkfile.c:3604
 #: ../glib/gbookmarkfile.c:3732
 #, c-format
 msgid "No bookmark found for URI '%s'"
@@ -79,45 +92,59 @@ msgstr "Privat-flagg er ikkje definert i bokmerket for adressa «%s»"
 msgid "No groups set in bookmark for URI '%s'"
 msgstr "Det er ikkje laga nokon grupper i bokmerket for adressa «%s»"
 
-#: ../glib/gbookmarkfile.c:3278 ../glib/gbookmarkfile.c:3435
+#: ../glib/gbookmarkfile.c:3278
+#: ../glib/gbookmarkfile.c:3435
 #, c-format
 msgid "No application with name '%s' registered a bookmark for '%s'"
-msgstr ""
-"Det er ikkje nokon program som heiter «%s» som har registrert bokmerke for "
-"«%s»"
+msgstr "Det er ikkje nokon program som heiter «%s» som har registrert bokmerke for «%s»"
 
 #: ../glib/gbookmarkfile.c:3458
 #, c-format
 msgid "Failed to expand exec line '%s' with URI '%s'"
 msgstr "Klarte ikkje å utvida køyrelinja «%s» med adressa «%s»"
 
-#: ../glib/gconvert.c:567 ../glib/gconvert.c:645 ../glib/giochannel.c:1404
+#: ../glib/gconvert.c:567
+#: ../glib/gconvert.c:645
+#: ../glib/giochannel.c:1404
 #: ../gio/gcharsetconverter.c:458
 #, c-format
 msgid "Conversion from character set '%s' to '%s' is not supported"
 msgstr "<Konvertering frå teiknsettet «%s» til «%s» er ikkje støtta"
 
-#: ../glib/gconvert.c:571 ../glib/gconvert.c:649
+#: ../glib/gconvert.c:571
+#: ../glib/gconvert.c:649
 #: ../gio/gcharsetconverter.c:462
 #, c-format
 msgid "Could not open converter from '%s' to '%s'"
 msgstr "Kunne ikkje opna konverterar frå «%s» til «%s»"
 
-#: ../glib/gconvert.c:768 ../glib/gconvert.c:1162 ../glib/giochannel.c:1576
-#: ../glib/giochannel.c:1618 ../glib/giochannel.c:2461 ../glib/gutf8.c:1012
-#: ../glib/gutf8.c:1463 ../gio/gcharsetconverter.c:345
-#: ../gio/gdatainputstream.c:854 ../gio/gdatainputstream.c:1291
+#: ../glib/gconvert.c:768
+#: ../glib/gconvert.c:1162
+#: ../glib/giochannel.c:1576
+#: ../glib/giochannel.c:1618
+#: ../glib/giochannel.c:2461
+#: ../glib/gutf8.c:1012
+#: ../glib/gutf8.c:1463
+#: ../gio/gcharsetconverter.c:345
+#: ../gio/gdatainputstream.c:854
+#: ../gio/gdatainputstream.c:1291
 msgid "Invalid byte sequence in conversion input"
 msgstr "Ugyldig bytesekvens i inndata for konvertering"
 
-#: ../glib/gconvert.c:777 ../glib/gconvert.c:1087 ../glib/giochannel.c:1583
-#: ../glib/giochannel.c:2473 ../gio/gcharsetconverter.c:350
+#: ../glib/gconvert.c:777
+#: ../glib/gconvert.c:1087
+#: ../glib/giochannel.c:1583
+#: ../glib/giochannel.c:2473
+#: ../gio/gcharsetconverter.c:350
 #, c-format
 msgid "Error during conversion: %s"
 msgstr "Feil under konvertering: %s"
 
-#: ../glib/gconvert.c:809 ../glib/gutf8.c:1008 ../glib/gutf8.c:1218
-#: ../glib/gutf8.c:1355 ../glib/gutf8.c:1459
+#: ../glib/gconvert.c:809
+#: ../glib/gutf8.c:1008
+#: ../glib/gutf8.c:1218
+#: ../glib/gutf8.c:1355
+#: ../glib/gutf8.c:1459
 msgid "Partial character sequence at end of input"
 msgstr "Delvis teiknsekvens på slutten av inndata"
 
@@ -176,19 +203,19 @@ msgstr ""
 #: ../glib/gdatetime.c:207
 msgctxt "GDateTime"
 msgid "%a %b %e %H:%M:%S %Y"
-msgstr "%a %d. %b %Y kl. %H.%M %z"
+msgstr "%a %d. %b %Y %H.%M.%S"
 
 #. Translators: this is the preferred format for expressing the date
 #: ../glib/gdatetime.c:210
 msgctxt "GDateTime"
 msgid "%m/%d/%y"
-msgstr "%d. %b %Y"
+msgstr "%d.%m.%Y"
 
 #. Translators: this is the preferred format for expressing the time
 #: ../glib/gdatetime.c:213
 msgctxt "GDateTime"
 msgid "%H:%M:%S"
-msgstr "kl. %H.%M %z"
+msgstr "%H.%M.%S"
 
 #. Translators: this is the preferred format for expressing 12 hour time
 #: ../glib/gdatetime.c:216
@@ -386,12 +413,14 @@ msgctxt "abbreviated weekday name"
 msgid "Sun"
 msgstr "su."
 
-#: ../glib/gdir.c:115 ../glib/gdir.c:138
+#: ../glib/gdir.c:115
+#: ../glib/gdir.c:138
 #, c-format
 msgid "Error opening directory '%s': %s"
 msgstr "Feil ved opning av katalog «%s»: %s"
 
-#: ../glib/gfileutils.c:540 ../glib/gfileutils.c:628
+#: ../glib/gfileutils.c:540
+#: ../glib/gfileutils.c:628
 #, c-format
 msgid "Could not allocate %lu bytes to read file \"%s\""
 msgstr "Klarte ikkje allokera %lu byte for å lesa «%s»"
@@ -411,12 +440,14 @@ msgstr ""
 msgid "Failed to read from file '%s': %s"
 msgstr "Klarte ikkje å lesa frå fila «%s»: %s"
 
-#: ../glib/gfileutils.c:703 ../glib/gfileutils.c:790
+#: ../glib/gfileutils.c:703
+#: ../glib/gfileutils.c:790
 #, c-format
 msgid "Failed to open file '%s': %s"
 msgstr "Klarte ikkje å opna fila «%s»: %s"
 
-#: ../glib/gfileutils.c:720 ../glib/gmappedfile.c:169
+#: ../glib/gfileutils.c:720
+#: ../glib/gmappedfile.c:169
 #, c-format
 msgid "Failed to get attributes of file '%s': fstat() failed: %s"
 msgstr "Klarte ikkje å få tak i eigenskapar for fila «%s»: fstat() feila: %s"
@@ -429,10 +460,10 @@ msgstr "Kunne ikkje opna fila «%s»: fdopen() feila: %s"
 #: ../glib/gfileutils.c:862
 #, c-format
 msgid "Failed to rename file '%s' to '%s': g_rename() failed: %s"
-msgstr ""
-"Klarte ikkje å endra namnet på fila «%s» til «%s»: g_rename() feila: %s"
+msgstr "Klarte ikkje å endra namnet på fila «%s» til «%s»: g_rename() feila: %s"
 
-#: ../glib/gfileutils.c:904 ../glib/gfileutils.c:1449
+#: ../glib/gfileutils.c:904
+#: ../glib/gfileutils.c:1449
 #, c-format
 msgid "Failed to create file '%s': %s"
 msgstr "Klarte ikkje å oppretta fila «%s»: %s"
@@ -448,14 +479,14 @@ msgid "Failed to write file '%s': fwrite() failed: %s"
 msgstr "Klarte ikkje å skriva til fila «%s»: fwrite() feila: %s"
 
 #: ../glib/gfileutils.c:962
-#, fuzzy, c-format
+#, c-format
 msgid "Failed to write file '%s': fflush() failed: %s"
-msgstr "Klarte ikkje å skriva til fila «%s»: fwrite() feila: %s"
+msgstr "Klarte ikkje å skriva fila «%s»: fwrite() feila: %s"
 
 #: ../glib/gfileutils.c:1006
-#, fuzzy, c-format
+#, c-format
 msgid "Failed to write file '%s': fsync() failed: %s"
-msgstr "Klarte ikkje å skriva til fila «%s»: fwrite() feila: %s"
+msgstr "Klarte ikkje å skriva fila «%s»: fwrite() feila: %s"
 
 #: ../glib/gfileutils.c:1030
 #, c-format
@@ -477,7 +508,8 @@ msgstr "Malen «%s» er ugyldig, kan ikkje ikkje innehalda ein «%s»"
 msgid "Template '%s' doesn't contain XXXXXX"
 msgstr "Malfila «%s» inneheld ikkje XXXXXX"
 
-#: ../glib/gfileutils.c:2001 ../glib/gfileutils.c:2029
+#: ../glib/gfileutils.c:2001
+#: ../glib/gfileutils.c:2029
 #: ../glib/gfileutils.c:2134
 #, c-format
 msgid "%u byte"
@@ -486,72 +518,77 @@ msgstr[0] "%u byte"
 msgstr[1] "%u byte"
 
 #: ../glib/gfileutils.c:2007
-#, fuzzy, c-format
+#, c-format
 msgid "%.1f KiB"
-msgstr "%.1f KB"
+msgstr "%.1f KiB"
 
 #: ../glib/gfileutils.c:2010
-#, fuzzy, c-format
+#, c-format
 msgid "%.1f MiB"
-msgstr "%.1f MB"
+msgstr "%.1f MiB"
 
 #: ../glib/gfileutils.c:2013
-#, fuzzy, c-format
+#, c-format
 msgid "%.1f GiB"
-msgstr "%.1f GB"
+msgstr "%.1f GiB"
 
 #: ../glib/gfileutils.c:2016
-#, fuzzy, c-format
+#, c-format
 msgid "%.1f TiB"
-msgstr "%.1f TB"
+msgstr "%.1f TiB"
 
 #: ../glib/gfileutils.c:2019
-#, fuzzy, c-format
+#, c-format
 msgid "%.1f PiB"
-msgstr "%.1f PB"
+msgstr "%.1f PiB"
 
 #: ../glib/gfileutils.c:2022
-#, fuzzy, c-format
+#, c-format
 msgid "%.1f EiB"
-msgstr "%.1f EB"
+msgstr "%.1f EiB"
 
 #: ../glib/gfileutils.c:2035
-#, fuzzy, c-format
+#, c-format
 msgid "%.1f kB"
-msgstr "%.1f KB"
+msgstr "%.1f kB"
 
-#: ../glib/gfileutils.c:2038 ../glib/gfileutils.c:2147
+#: ../glib/gfileutils.c:2038
+#: ../glib/gfileutils.c:2147
 #, c-format
 msgid "%.1f MB"
 msgstr "%.1f MB"
 
-#: ../glib/gfileutils.c:2041 ../glib/gfileutils.c:2152
+#: ../glib/gfileutils.c:2041
+#: ../glib/gfileutils.c:2152
 #, c-format
 msgid "%.1f GB"
 msgstr "%.1f GB"
 
-#: ../glib/gfileutils.c:2044 ../glib/gfileutils.c:2157
-#, fuzzy, c-format
+#: ../glib/gfileutils.c:2044
+#: ../glib/gfileutils.c:2157
+#, c-format
 msgid "%.1f TB"
 msgstr "%.1f TB"
 
-#: ../glib/gfileutils.c:2047 ../glib/gfileutils.c:2162
-#, fuzzy, c-format
+#: ../glib/gfileutils.c:2047
+#: ../glib/gfileutils.c:2162
+#, c-format
 msgid "%.1f PB"
 msgstr "%.1f PB"
 
-#: ../glib/gfileutils.c:2050 ../glib/gfileutils.c:2167
-#, fuzzy, c-format
+#: ../glib/gfileutils.c:2050
+#: ../glib/gfileutils.c:2167
+#, c-format
 msgid "%.1f EB"
 msgstr "%.1f EB"
 
 #. Translators: the %s in "%s bytes" will always be replaced by a number.
 #: ../glib/gfileutils.c:2087
-#, fuzzy, c-format
+#, c-format
 msgid "%s byte"
 msgid_plural "%s bytes"
-msgstr[0] "%u byte"
-msgstr[1] "%u byte"
+msgstr[0] "%s byte"
+msgstr[1] "%s bytes"
 
 #: ../glib/gfileutils.c:2142
 #, c-format
@@ -576,12 +613,14 @@ msgstr "Klarte ikkje å opna konverterar frå «%s» til «%s»: %s"
 msgid "Can't do a raw read in g_io_channel_read_line_string"
 msgstr "Klarar ikkje å gjera ei rå lesing i g_io_channel_read_line_string"
 
-#: ../glib/giochannel.c:1800 ../glib/giochannel.c:2057
+#: ../glib/giochannel.c:1800
+#: ../glib/giochannel.c:2057
 #: ../glib/giochannel.c:2144
 msgid "Leftover unconverted data in read buffer"
 msgstr "Ukonvertert data til overs i lesebufferet"
 
-#: ../glib/giochannel.c:1881 ../glib/giochannel.c:1958
+#: ../glib/giochannel.c:1881
+#: ../glib/giochannel.c:1958
 msgid "Channel terminates in a partial character"
 msgstr "Kanalen avsluttar på eit delvis teikn"
 
@@ -599,15 +638,17 @@ msgstr "Klarte ikkje å opna fila «%s»: open() feila: %s"
 msgid "Failed to map file '%s': mmap() failed: %s"
 msgstr "Klarte ikkje å kopiera fila «%s» til minnet: mmap() feila: %s"
 
-#: ../glib/gmarkup.c:355 ../glib/gmarkup.c:396
+#: ../glib/gmarkup.c:355
+#: ../glib/gmarkup.c:396
 #, c-format
 msgid "Error on line %d char %d: "
 msgstr "Feil på linje %d teikn %d: "
 
-#: ../glib/gmarkup.c:418 ../glib/gmarkup.c:501
-#, fuzzy, c-format
+#: ../glib/gmarkup.c:418
+#: ../glib/gmarkup.c:501
+#, c-format
 msgid "Invalid UTF-8 encoded text in name - not valid '%s'"
-msgstr "Ugyldig UTF-8-koda tekst - ikkje gyldig «%s»"
+msgstr "Ugyldig UTF-8-koda tekst i namne – ikkje gyldig «%s»"
 
 #: ../glib/gmarkup.c:429
 #, c-format
@@ -626,21 +667,12 @@ msgstr "Feil på linje %d: %s"
 
 #: ../glib/gmarkup.c:638
 #, c-format
-msgid ""
-"Failed to parse '%-.*s', which should have been a digit inside a character "
-"reference (&#234; for example) - perhaps the digit is too large"
-msgstr ""
-"Klarte ikkje å tolka «%-.*s», som burde vera eit teikn i ein teiknreferanse "
-"(&#234;, til dømes) – kan henda talet er for stort"
+msgid "Failed to parse '%-.*s', which should have been a digit inside a character reference (&#234; for example) - perhaps the digit is too large"
+msgstr "Klarte ikkje å tolka «%-.*s», som burde vera eit teikn i ein teiknreferanse (&#234;, til dømes) – kan henda talet er for stort"
 
 #: ../glib/gmarkup.c:650
-msgid ""
-"Character reference did not end with a semicolon; most likely you used an "
-"ampersand character without intending to start an entity - escape ampersand "
-"as &amp;"
-msgstr ""
-"Teiknreferansen slutta ikkje med eit semikolon; sannsynlegvis brukte du eit "
-"et-teikn utan å villa starte ein entitet – skriv et-teikn som &amp;"
+msgid "Character reference did not end with a semicolon; most likely you used an ampersand character without intending to start an entity - escape ampersand as &amp;"
+msgstr "Teiknreferansen slutta ikkje med eit semikolon; sannsynlegvis brukte du eit et-teikn utan å villa starte ein entitet – skriv et-teikn som &amp;"
 
 #: ../glib/gmarkup.c:676
 #, c-format
@@ -648,22 +680,17 @@ msgid "Character reference '%-.*s' does not encode a permitted character"
 msgstr "Teiknreferansen «%-.*s» kodar ikkje kan ikkje kodast eit lovleg teikn"
 
 #: ../glib/gmarkup.c:714
-msgid ""
-"Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
+msgid "Empty entity '&;' seen; valid entities are: &amp; &quot; &lt; &gt; &apos;"
 msgstr "Fann tom entitet «&;»; gyldige entitetar er: &amp; &quot; &lt; &apos;"
 
 #: ../glib/gmarkup.c:722
-#, fuzzy, c-format
+#, c-format
 msgid "Entity name '%-.*s' is not known"
-msgstr "Entitetsnamnet «%s» er ikkje kjent"
+msgstr "Entitetsnamnet «%-.*s» er ikkje kjent"
 
 #: ../glib/gmarkup.c:727
-msgid ""
-"Entity did not end with a semicolon; most likely you used an ampersand "
-"character without intending to start an entity - escape ampersand as &amp;"
-msgstr ""
-"Entiteten slutta ikkje med eit semikolon. Du brukte truleg eit et-teikn utan "
-"å meina å opna ein entitet. Skriv et-teikn som «&amp;»."
+msgid "Entity did not end with a semicolon; most likely you used an ampersand character without intending to start an entity - escape ampersand as &amp;"
+msgstr "Entiteten slutta ikkje med eit semikolon. Du brukte truleg eit et-teikn utan å meina å opna ein entitet. Skriv et-teikn som «&amp;»."
 
 #: ../glib/gmarkup.c:1078
 msgid "Document must begin with an element (e.g. <book>)"
@@ -671,67 +698,38 @@ msgstr "Dokumentet må byrja med eit element (t.d. <book>)"
 
 #: ../glib/gmarkup.c:1118
 #, c-format
-msgid ""
-"'%s' is not a valid character following a '<' character; it may not begin an "
-"element name"
-msgstr ""
-"«%s» er ikkje eit gyldig teikn etter ein «<»-teikn. Det kan ikkje vera det "
-"fyrste teiknet i eit elementnamn"
+msgid "'%s' is not a valid character following a '<' character; it may not begin an element name"
+msgstr "«%s» er ikkje eit gyldig teikn etter ein «<»-teikn. Det kan ikkje vera det fyrste teiknet i eit elementnamn"
 
 #: ../glib/gmarkup.c:1186
 #, fuzzy, c-format
-msgid ""
-"Odd character '%s', expected a '>' character to end the empty-element tag "
-"'%s'"
-msgstr ""
-"Merkeleg teikn «%s», venta eit «>»-teikn for å avslutta startmerket av "
-"elementet «%s»"
+msgid "Odd character '%s', expected a '>' character to end the empty-element tag '%s'"
+msgstr "Merkeleg teikn «%s», venta eit «>»-teikn for å avslutta startmerket av elementet «%s»"
 
 #: ../glib/gmarkup.c:1270
 #, c-format
-msgid ""
-"Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
-msgstr ""
-"Merkeleg teikn «%s», venta ein «=» etter attributtnamnet «%s» av elementet "
-"«%s»"
+msgid "Odd character '%s', expected a '=' after attribute name '%s' of element '%s'"
+msgstr "Merkeleg teikn «%s», venta ein «=» etter attributtnamnet «%s» av elementet «%s»"
 
 #: ../glib/gmarkup.c:1311
 #, c-format
-msgid ""
-"Odd character '%s', expected a '>' or '/' character to end the start tag of "
-"element '%s', or optionally an attribute; perhaps you used an invalid "
-"character in an attribute name"
-msgstr ""
-"Merkeleg teikn «%s», venta anten eit «>»-teikn eller «/»-teikn for å "
-"avslutta startmerket av elementet «%s», eller ein valfri attributt. Kan "
-"henda du brukte eit ugyldig teikn i attributtnamnet"
+msgid "Odd character '%s', expected a '>' or '/' character to end the start tag of element '%s', or optionally an attribute; perhaps you used an invalid character in an attribute name"
+msgstr "Merkeleg teikn «%s», venta anten eit «>»-teikn eller «/»-teikn for å avslutta startmerket av elementet «%s», eller ein valfri attributt. Kan henda du brukte eit ugyldig teikn i attributtnamnet"
 
 #: ../glib/gmarkup.c:1355
 #, c-format
-msgid ""
-"Odd character '%s', expected an open quote mark after the equals sign when "
-"giving value for attribute '%s' of element '%s'"
-msgstr ""
-"Merkeleg teikn «%s», venta eit ope siteringsmerke etter likskapsteiknet for "
-"å gje ein verdi for attributten «%s» av elementet «%s»"
+msgid "Odd character '%s', expected an open quote mark after the equals sign when giving value for attribute '%s' of element '%s'"
+msgstr "Merkeleg teikn «%s», venta eit ope siteringsmerke etter likskapsteiknet for å gje ein verdi for attributten «%s» av elementet «%s»"
 
 #: ../glib/gmarkup.c:1488
 #, c-format
-msgid ""
-"'%s' is not a valid character following the characters '</'; '%s' may not "
-"begin an element name"
-msgstr ""
-"«%s» er ikkje eit gyldig teikn etter teikna «<» eller «/». «%s» kan ikkje "
-"starta eit elementnamn"
+msgid "'%s' is not a valid character following the characters '</'; '%s' may not begin an element name"
+msgstr "«%s» er ikkje eit gyldig teikn etter teikna «<» eller «/». «%s» kan ikkje starta eit elementnamn"
 
 #: ../glib/gmarkup.c:1524
 #, c-format
-msgid ""
-"'%s' is not a valid character following the close element name '%s'; the "
-"allowed character is '>'"
-msgstr ""
-"«%s» er ikkje eit gyldig teikn etter avsluttande merket «%s»; det tillatne "
-"teiknet er «>»"
+msgid "'%s' is not a valid character following the close element name '%s'; the allowed character is '>'"
+msgstr "«%s» er ikkje eit gyldig teikn etter avsluttande merket «%s»; det tillatne teiknet er «>»"
 
 #: ../glib/gmarkup.c:1535
 #, c-format
@@ -751,23 +749,16 @@ msgstr "Dokumentet var tomt eller innheldt berre tomme teikn"
 msgid "Document ended unexpectedly just after an open angle bracket '<'"
 msgstr "Dokument avslutta uventa rett etter ei open vinkelhake «<»"
 
-#: ../glib/gmarkup.c:1734 ../glib/gmarkup.c:1779
+#: ../glib/gmarkup.c:1734
+#: ../glib/gmarkup.c:1779
 #, c-format
-msgid ""
-"Document ended unexpectedly with elements still open - '%s' was the last "
-"element opened"
-msgstr ""
-"Dokumentet slutta uventa med element framleis opne. «%s» var det siste "
-"elementet som vart opna"
+msgid "Document ended unexpectedly with elements still open - '%s' was the last element opened"
+msgstr "Dokumentet slutta uventa med element framleis opne. «%s» var det siste elementet som vart opna"
 
 #: ../glib/gmarkup.c:1742
 #, c-format
-msgid ""
-"Document ended unexpectedly, expected to see a close angle bracket ending "
-"the tag <%s/>"
-msgstr ""
-"Dokumentet slutta uventa, venta å sjå at ei vinkelhake lukka det avsluttande "
-"merket <%s/>"
+msgid "Document ended unexpectedly, expected to see a close angle bracket ending the tag <%s/>"
+msgstr "Dokumentet slutta uventa, venta å sjå at ei vinkelhake lukka det avsluttande merket <%s/>"
 
 #: ../glib/gmarkup.c:1748
 msgid "Document ended unexpectedly inside an element name"
@@ -779,16 +770,11 @@ msgstr "Dokumentet tok uventa slutt inni eit attributtnamn"
 
 #: ../glib/gmarkup.c:1759
 msgid "Document ended unexpectedly inside an element-opening tag."
-msgstr ""
-"Dokumentet vart uventa avslutta inne i eit merke som opnar eit element."
+msgstr "Dokumentet vart uventa avslutta inne i eit merke som opnar eit element."
 
 #: ../glib/gmarkup.c:1765
-msgid ""
-"Document ended unexpectedly after the equals sign following an attribute "
-"name; no attribute value"
-msgstr ""
-"Dokumentet slutta uventa etter likskapsteiknet etter attributtnamnet; ingen "
-"attributtverdi"
+msgid "Document ended unexpectedly after the equals sign following an attribute name; no attribute value"
+msgstr "Dokumentet slutta uventa etter likskapsteiknet etter attributtnamnet; ingen attributtverdi"
 
 #: ../glib/gmarkup.c:1772
 msgid "Document ended unexpectedly while inside an attribute value"
@@ -801,8 +787,7 @@ msgstr "Dokumentet avslutta uventa i eit lukkemerke for elementet «%s»"
 
 #: ../glib/gmarkup.c:1794
 msgid "Document ended unexpectedly inside a comment or processing instruction"
-msgstr ""
-"Dokumentet avslutta uventa inne i ein merknad eller prosseseringsinstruksjon"
+msgstr "Dokumentet avslutta uventa inne i ein merknad eller prosseseringsinstruksjon"
 
 #: ../glib/gregex.c:189
 msgid "corrupted object"
@@ -820,11 +805,13 @@ msgstr "tom for minne"
 msgid "backtracking limit reached"
 msgstr "tilbakesporingsgrensa nådd"
 
-#: ../glib/gregex.c:210 ../glib/gregex.c:218
+#: ../glib/gregex.c:210
+#: ../glib/gregex.c:218
 msgid "the pattern contains items not supported for partial matching"
 msgstr "mønsteret inneheld element som ikkje er støtta i delsamanlikning"
 
-#: ../glib/gregex.c:212 ../gio/glocalfile.c:2107
+#: ../glib/gregex.c:212
+#: ../gio/glocalfile.c:2107
 msgid "internal error"
 msgstr "intern feil"
 
@@ -870,9 +857,7 @@ msgstr "ukjend teikn etter \\"
 
 #: ../glib/gregex.c:274
 msgid "case-changing escapes (\\l, \\L, \\u, \\U) are not allowed here"
-msgstr ""
-"skiftesekvensar som påverkar små/store bokstavar (\\I, \\L, \\u, \\U) er "
-"ikkje tillatne her"
+msgstr "skiftesekvensar som påverkar små/store bokstavar (\\I, \\L, \\u, \\U) er ikkje tillatne her"
 
 #: ../glib/gregex.c:277
 msgid "numbers out of order in {} quantifier"
@@ -1026,11 +1011,8 @@ msgid "inconsistent NEWLINE options"
 msgstr "inkonsistente NEWLINE-val"
 
 #: ../glib/gregex.c:395
-msgid ""
-"\\g is not followed by a braced name or an optionally braced non-zero number"
-msgstr ""
-"\\g er ikkje følgd av eit namn i klammer eller eit ikkje-null tal i valfrie "
-"klamer"
+msgid "\\g is not followed by a braced name or an optionally braced non-zero number"
+msgstr "\\g er ikkje følgd av eit namn i klammer eller eit ikkje-null tal i valfrie klamer"
 
 #: ../glib/gregex.c:400
 msgid "unexpected repeat"
@@ -1048,7 +1030,8 @@ msgstr "gjekk utanfor kompileringsarbeidsområdet"
 msgid "previously-checked referenced subpattern not found"
 msgstr "tidlegare kontrollert referert undermønster ikkje funne"
 
-#: ../glib/gregex.c:630 ../glib/gregex.c:1753
+#: ../glib/gregex.c:630
+#: ../glib/gregex.c:1753
 #, c-format
 msgid "Error while matching regular expression %s: %s"
 msgstr "Feil under samanlikning med regulært uttrykk %s: %s"
@@ -1128,9 +1111,7 @@ msgstr "Teksten tok slutt rett etter eit «\\»-teikn (Teksten var «%s»)"
 #: ../glib/gshell.c:566
 #, c-format
 msgid "Text ended before matching quote was found for %c. (The text was '%s')"
-msgstr ""
-"Teksten tok slutt før avsluttande sitatteikn vart funne for %c. (Teksten var "
-"«%s»)"
+msgstr "Teksten tok slutt før avsluttande sitatteikn vart funne for %c. (Teksten var «%s»)"
 
 #: ../glib/gshell.c:578
 msgid "Text was empty (or contained only whitespace)"
@@ -1140,22 +1121,27 @@ msgstr "Teksten var tom (eller inneheldt berre tomme teikn)"
 msgid "Failed to read data from child process"
 msgstr "Klarte ikkje å lesa data frå barneprosess"
 
-#: ../glib/gspawn-win32.c:299 ../glib/gspawn.c:1517
+#: ../glib/gspawn-win32.c:299
+#: ../glib/gspawn.c:1517
 #, c-format
 msgid "Failed to create pipe for communicating with child process (%s)"
 msgstr "Klarte ikkje å oppretta røyr for å kommunisera med barneprosess (%s)"
 
-#: ../glib/gspawn-win32.c:338 ../glib/gspawn-win32.c:346 ../glib/gspawn.c:1170
+#: ../glib/gspawn-win32.c:338
+#: ../glib/gspawn-win32.c:346
+#: ../glib/gspawn.c:1170
 #, c-format
 msgid "Failed to read from child pipe (%s)"
 msgstr "Klarte ikkje å lesa frå røyr frå barn (%s)"
 
-#: ../glib/gspawn-win32.c:369 ../glib/gspawn.c:1383
+#: ../glib/gspawn-win32.c:369
+#: ../glib/gspawn.c:1383
 #, c-format
 msgid "Failed to change to directory '%s' (%s)"
 msgstr "Klarte ikkje å skifta til katalogen «%s» (%s)"
 
-#: ../glib/gspawn-win32.c:375 ../glib/gspawn-win32.c:494
+#: ../glib/gspawn-win32.c:375
+#: ../glib/gspawn-win32.c:494
 #, c-format
 msgid "Failed to execute child process (%s)"
 msgstr "Klarte ikkje å utføra barneprosess (%s)"
@@ -1165,19 +1151,22 @@ msgstr "Klarte ikkje å utføra barneprosess (%s)"
 msgid "Invalid program name: %s"
 msgstr "Ugyldig programnamn: %s"
 
-#: ../glib/gspawn-win32.c:454 ../glib/gspawn-win32.c:722
+#: ../glib/gspawn-win32.c:454
+#: ../glib/gspawn-win32.c:722
 #: ../glib/gspawn-win32.c:1278
 #, c-format
 msgid "Invalid string in argument vector at %d: %s"
 msgstr "Ugyldig streng i argumentvektor plass %d: %s"
 
-#: ../glib/gspawn-win32.c:465 ../glib/gspawn-win32.c:737
+#: ../glib/gspawn-win32.c:465
+#: ../glib/gspawn-win32.c:737
 #: ../glib/gspawn-win32.c:1311
 #, c-format
 msgid "Invalid string in environment: %s"
 msgstr "Ugyldig streng i miljø: %s"
 
-#: ../glib/gspawn-win32.c:718 ../glib/gspawn-win32.c:1259
+#: ../glib/gspawn-win32.c:718
+#: ../glib/gspawn-win32.c:1259
 #, c-format
 msgid "Invalid working directory: %s"
 msgstr "Ugyldig arbeidskatalog: %s"
@@ -1188,11 +1177,8 @@ msgid "Failed to execute helper program (%s)"
 msgstr "Klarte ikkje å køyra hjelpeprogram (%s)"
 
 #: ../glib/gspawn-win32.c:997
-msgid ""
-"Unexpected error in g_io_channel_win32_poll() reading data from a child "
-"process"
-msgstr ""
-"Uventa feil i g_io_channel_win32_poll() ved lesing av data frå barneprosess"
+msgid "Unexpected error in g_io_channel_win32_poll() reading data from a child process"
+msgstr "Uventa feil i g_io_channel_win32_poll() ved lesing av data frå barneprosess"
 
 #: ../glib/gspawn.c:207
 #, c-format
@@ -1243,12 +1229,17 @@ msgstr "Klarte ikkje å lesa nok data frå pid-røyr frå barn (%s)"
 msgid "Character out of range for UTF-8"
 msgstr "Teikn ikkje gyldig for UTF-8"
 
-#: ../glib/gutf8.c:1186 ../glib/gutf8.c:1195 ../glib/gutf8.c:1325
-#: ../glib/gutf8.c:1334 ../glib/gutf8.c:1473 ../glib/gutf8.c:1569
+#: ../glib/gutf8.c:1186
+#: ../glib/gutf8.c:1195
+#: ../glib/gutf8.c:1325
+#: ../glib/gutf8.c:1334
+#: ../glib/gutf8.c:1473
+#: ../glib/gutf8.c:1569
 msgid "Invalid sequence in conversion input"
 msgstr "Ugyldig sekvens i inndata-konvertering"
 
-#: ../glib/gutf8.c:1484 ../glib/gutf8.c:1580
+#: ../glib/gutf8.c:1484
+#: ../glib/gutf8.c:1580
 msgid "Character out of range for UTF-16"
 msgstr "Teikn ikkje gyldig for UTF-16"
 
@@ -1276,12 +1267,14 @@ msgstr "Vis alle hjelpevala"
 msgid "Application Options:"
 msgstr "Programval:"
 
-#: ../glib/goption.c:997 ../glib/goption.c:1067
+#: ../glib/goption.c:997
+#: ../glib/goption.c:1067
 #, c-format
 msgid "Cannot parse integer value '%s' for %s"
 msgstr "Kan ikkje tolka heiltalsverdien «%s» til %s"
 
-#: ../glib/goption.c:1007 ../glib/goption.c:1075
+#: ../glib/goption.c:1007
+#: ../glib/goption.c:1075
 #, c-format
 msgid "Integer value '%s' for %s out of range"
 msgstr "Heiltalsverdien «%s» til «%s» utanfor gyldig område"
@@ -1296,12 +1289,14 @@ msgstr "Kan ikkje tolka flyttalsverdien «%s» til «--%s»"
 msgid "Double value '%s' for %s out of range"
 msgstr "Flyttalsverdien «%s» til «%s» utanfor gyldig område"
 
-#: ../glib/goption.c:1303 ../glib/goption.c:1382
+#: ../glib/goption.c:1303
+#: ../glib/goption.c:1382
 #, c-format
 msgid "Error parsing option %s"
 msgstr "Feil under tolking av val %s"
 
-#: ../glib/goption.c:1413 ../glib/goption.c:1526
+#: ../glib/goption.c:1413
+#: ../glib/goption.c:1526
 #, c-format
 msgid "Missing argument for %s"
 msgstr "Argument manglar for %s"
@@ -1325,11 +1320,8 @@ msgstr "Fila er tom"
 
 #: ../glib/gkeyfile.c:768
 #, c-format
-msgid ""
-"Key file contains line '%s' which is not a key-value pair, group, or comment"
-msgstr ""
-"Nøkkelfila inneheld linja «%s» som ikkje er eit nøkkel-verdi-par, ei gruppe "
-"eller ein kommentar"
+msgid "Key file contains line '%s' which is not a key-value pair, group, or comment"
+msgstr "Nøkkelfila inneheld linja «%s» som ikkje er eit nøkkel-verdi-par, ei gruppe eller ein kommentar"
 
 #: ../glib/gkeyfile.c:828
 #, c-format
@@ -1350,9 +1342,15 @@ msgstr "Ugyldig nøkkelnamn: %s"
 msgid "Key file contains unsupported encoding '%s'"
 msgstr "Nøkkelfila inneheld den ikkje støtta kodinga «%s»"
 
-#: ../glib/gkeyfile.c:1149 ../glib/gkeyfile.c:1311 ../glib/gkeyfile.c:2686
-#: ../glib/gkeyfile.c:2752 ../glib/gkeyfile.c:2887 ../glib/gkeyfile.c:3020
-#: ../glib/gkeyfile.c:3162 ../glib/gkeyfile.c:3394 ../glib/gkeyfile.c:3463
+#: ../glib/gkeyfile.c:1149
+#: ../glib/gkeyfile.c:1311
+#: ../glib/gkeyfile.c:2686
+#: ../glib/gkeyfile.c:2752
+#: ../glib/gkeyfile.c:2887
+#: ../glib/gkeyfile.c:3020
+#: ../glib/gkeyfile.c:3162
+#: ../glib/gkeyfile.c:3394
+#: ../glib/gkeyfile.c:3463
 #, c-format
 msgid "Key file does not have group '%s'"
 msgstr "Nøkkelfila manglar gruppa «%s»"
@@ -1362,31 +1360,32 @@ msgstr "Nøkkelfila manglar gruppa «%s»"
 msgid "Key file does not have key '%s'"
 msgstr "Nøkkelfila manglar nøkkelen «%s»"
 
-#: ../glib/gkeyfile.c:1430 ../glib/gkeyfile.c:1546
+#: ../glib/gkeyfile.c:1430
+#: ../glib/gkeyfile.c:1546
 #, c-format
 msgid "Key file contains key '%s' with value '%s' which is not UTF-8"
 msgstr "Nøkkelfila har nøkkelen «%s» med verdien «%s», som ikkje er UTF-8"
 
-#: ../glib/gkeyfile.c:1450 ../glib/gkeyfile.c:1934
+#: ../glib/gkeyfile.c:1450
+#: ../glib/gkeyfile.c:1934
 #, c-format
 msgid "Key file contains key '%s' which has value that cannot be interpreted."
 msgstr "Nøkkelfila har nøkkelen «%s» med ein verdi som ikkje kan tolkast."
 
 #: ../glib/gkeyfile.c:1566
 #, fuzzy, c-format
-msgid ""
-"Key file contains key '%s' which has a value that cannot be interpreted."
+msgid "Key file contains key '%s' which has a value that cannot be interpreted."
 msgstr "Nøkkelfila har nøkkelen «%s» med ein verdi som ikkje kan tolkast."
 
-#: ../glib/gkeyfile.c:2151 ../glib/gkeyfile.c:2515
+#: ../glib/gkeyfile.c:2151
+#: ../glib/gkeyfile.c:2515
 #, c-format
-msgid ""
-"Key file contains key '%s' in group '%s' which has value that cannot be "
-"interpreted."
-msgstr ""
-"Nøkkelfila har feil i nøkkelen «%s» i gruppa «%s». Verdien kan ikkje tolkast."
+msgid "Key file contains key '%s' in group '%s' which has value that cannot be interpreted."
+msgstr "Nøkkelfila har feil i nøkkelen «%s» i gruppa «%s». Verdien kan ikkje tolkast."
 
-#: ../glib/gkeyfile.c:2701 ../glib/gkeyfile.c:2902 ../glib/gkeyfile.c:3474
+#: ../glib/gkeyfile.c:2701
+#: ../glib/gkeyfile.c:2902
+#: ../glib/gkeyfile.c:3474
 #, c-format
 msgid "Key file does not have key '%s' in group '%s'"
 msgstr "Nøkkelfila har ikkje nøkkelen «%s» i gruppa «%s»"
@@ -1420,22 +1419,31 @@ msgstr "Verdien «%s» kan ikkje tolkast som eit flyttal."
 msgid "Value '%s' cannot be interpreted as a boolean."
 msgstr "Verdien «%s» kan ikkje tolkast som ein boolsk verdi."
 
-#: ../gio/gbufferedinputstream.c:411 ../gio/gbufferedinputstream.c:492
-#: ../gio/ginputstream.c:185 ../gio/ginputstream.c:317
-#: ../gio/ginputstream.c:556 ../gio/ginputstream.c:680
-#: ../gio/goutputstream.c:198 ../gio/goutputstream.c:732
+#: ../gio/gbufferedinputstream.c:411
+#: ../gio/gbufferedinputstream.c:492
+#: ../gio/ginputstream.c:185
+#: ../gio/ginputstream.c:317
+#: ../gio/ginputstream.c:556
+#: ../gio/ginputstream.c:680
+#: ../gio/goutputstream.c:198
+#: ../gio/goutputstream.c:732
 #, c-format
 msgid "Too large count value passed to %s"
 msgstr "For stor teljingsverdi sendt til %s"
 
-#: ../gio/gbufferedinputstream.c:881 ../gio/ginputstream.c:888
-#: ../gio/giostream.c:306 ../gio/goutputstream.c:1206
+#: ../gio/gbufferedinputstream.c:881
+#: ../gio/ginputstream.c:888
+#: ../gio/giostream.c:306
+#: ../gio/goutputstream.c:1206
 msgid "Stream is already closed"
 msgstr "Straumen er allereie stengt"
 
-#: ../gio/gcancellable.c:321 ../gio/gdbusconnection.c:1640
-#: ../gio/gdbusconnection.c:1729 ../gio/gdbusconnection.c:1916
-#: ../gio/glocalfile.c:2100 ../gio/gsimpleasyncresult.c:814
+#: ../gio/gcancellable.c:321
+#: ../gio/gdbusconnection.c:1640
+#: ../gio/gdbusconnection.c:1729
+#: ../gio/gdbusconnection.c:1916
+#: ../gio/glocalfile.c:2100
+#: ../gio/gsimpleasyncresult.c:814
 #: ../gio/gsimpleasyncresult.c:840
 msgid "Operation was cancelled"
 msgstr "Operasjonen vart avbroten"
@@ -1444,16 +1452,19 @@ msgstr "Operasjonen vart avbroten"
 msgid "Invalid object, not initialized"
 msgstr ""
 
-#: ../gio/gcharsetconverter.c:284 ../gio/gcharsetconverter.c:312
+#: ../gio/gcharsetconverter.c:284
+#: ../gio/gcharsetconverter.c:312
 #, fuzzy
 msgid "Incomplete multibyte sequence in input"
 msgstr "Ugyldig bytesekvens i inndata for konvertering"
 
-#: ../gio/gcharsetconverter.c:318 ../gio/gcharsetconverter.c:327
+#: ../gio/gcharsetconverter.c:318
+#: ../gio/gcharsetconverter.c:327
 msgid "Not enough space in destination"
 msgstr ""
 
-#: ../gio/gcharsetconverter.c:447 ../gio/gsocket.c:854
+#: ../gio/gcharsetconverter.c:447
+#: ../gio/gsocket.c:854
 #, fuzzy
 msgid "Cancellable initialization not supported"
 msgstr "Operasjonen er ikkje støtta"
@@ -1472,7 +1483,8 @@ msgstr "%s-filtype"
 msgid "%s type"
 msgstr "%s-type"
 
-#: ../gio/gcredentials.c:273 ../gio/gcredentials.c:495
+#: ../gio/gcredentials.c:273
+#: ../gio/gcredentials.c:495
 msgid "GCredentials is not implemented on this OS"
 msgstr ""
 
@@ -1484,7 +1496,8 @@ msgstr ""
 msgid "Unexpected early end-of-stream"
 msgstr "Uventa tidleg slutt på straumen"
 
-#: ../gio/gdbusaddress.c:142 ../gio/gdbusaddress.c:230
+#: ../gio/gdbusaddress.c:142
+#: ../gio/gdbusaddress.c:230
 #: ../gio/gdbusaddress.c:311
 #, c-format
 msgid "Unsupported key `%s' in address entry `%s'"
@@ -1492,8 +1505,7 @@ msgstr ""
 
 #: ../gio/gdbusaddress.c:169
 #, c-format
-msgid ""
-"Address `%s' is invalid (need exactly one of path, tmpdir or abstract keys)"
+msgid "Address `%s' is invalid (need exactly one of path, tmpdir or abstract keys)"
 msgstr ""
 
 #: ../gio/gdbusaddress.c:182
@@ -1501,12 +1513,14 @@ msgstr ""
 msgid "Meaningless key/value pair combination in address entry `%s'"
 msgstr ""
 
-#: ../gio/gdbusaddress.c:245 ../gio/gdbusaddress.c:326
+#: ../gio/gdbusaddress.c:245
+#: ../gio/gdbusaddress.c:326
 #, c-format
 msgid "Error in address `%s' - the port attribute is malformed"
 msgstr ""
 
-#: ../gio/gdbusaddress.c:256 ../gio/gdbusaddress.c:337
+#: ../gio/gdbusaddress.c:256
+#: ../gio/gdbusaddress.c:337
 #, c-format
 msgid "Error in address `%s' - the family attribute is malformed"
 msgstr ""
@@ -1518,23 +1532,17 @@ msgstr ""
 
 #: ../gio/gdbusaddress.c:467
 #, c-format
-msgid ""
-"Key/Value pair %d, `%s', in address element `%s', does not contain an equal "
-"sign"
+msgid "Key/Value pair %d, `%s', in address element `%s', does not contain an equal sign"
 msgstr ""
 
 #: ../gio/gdbusaddress.c:481
 #, c-format
-msgid ""
-"Error unescaping key or value in Key/Value pair %d, `%s', in address element "
-"`%s'"
+msgid "Error unescaping key or value in Key/Value pair %d, `%s', in address element `%s'"
 msgstr ""
 
 #: ../gio/gdbusaddress.c:559
 #, c-format
-msgid ""
-"Error in address `%s' - the unix transport requires exactly one of the keys "
-"`path' or `abstract' to be set"
+msgid "Error in address `%s' - the unix transport requires exactly one of the keys `path' or `abstract' to be set"
 msgstr ""
 
 #: ../gio/gdbusaddress.c:595
@@ -1610,17 +1618,15 @@ msgstr ""
 msgid "Cannot determine session bus address (not implemented for this OS)"
 msgstr ""
 
-#: ../gio/gdbusaddress.c:1254 ../gio/gdbusconnection.c:6409
+#: ../gio/gdbusaddress.c:1254
+#: ../gio/gdbusconnection.c:6409
 #, c-format
-msgid ""
-"Cannot determine bus address from DBUS_STARTER_BUS_TYPE environment variable "
-"- unknown value `%s'"
+msgid "Cannot determine bus address from DBUS_STARTER_BUS_TYPE environment variable - unknown value `%s'"
 msgstr ""
 
-#: ../gio/gdbusaddress.c:1263 ../gio/gdbusconnection.c:6418
-msgid ""
-"Cannot determine bus address because the DBUS_STARTER_BUS_TYPE environment "
-"variable is not set"
+#: ../gio/gdbusaddress.c:1263
+#: ../gio/gdbusconnection.c:6418
+msgid "Cannot determine bus address because the DBUS_STARTER_BUS_TYPE environment variable is not set"
 msgstr ""
 
 #: ../gio/gdbusaddress.c:1273
@@ -1638,8 +1644,7 @@ msgstr ""
 
 #: ../gio/gdbusauth.c:503
 #, c-format
-msgid ""
-"Exhausted all available authentication mechanisms (tried: %s) (available: %s)"
+msgid "Exhausted all available authentication mechanisms (tried: %s) (available: %s)"
 msgstr ""
 
 #: ../gio/gdbusauth.c:1159
@@ -1653,8 +1658,7 @@ msgstr "Feil ved opning av katalog «%s»: %s"
 
 #: ../gio/gdbusauthmechanismsha1.c:278
 #, c-format
-msgid ""
-"Permissions on directory `%s' are malformed. Expected mode 0700, got 0%o"
+msgid "Permissions on directory `%s' are malformed. Expected mode 0700, got 0%o"
 msgstr ""
 
 #: ../gio/gdbusauthmechanismsha1.c:299
@@ -1667,21 +1671,22 @@ msgstr "Feil ved opning av katalog «%s»: %s"
 msgid "Error opening keyring `%s' for reading: "
 msgstr "Feil ved opning av fila «%s»: %s"
 
-#: ../gio/gdbusauthmechanismsha1.c:406 ../gio/gdbusauthmechanismsha1.c:718
+#: ../gio/gdbusauthmechanismsha1.c:406
+#: ../gio/gdbusauthmechanismsha1.c:718
 #, c-format
 msgid "Line %d of the keyring at `%s' with content `%s' is malformed"
 msgstr ""
 
-#: ../gio/gdbusauthmechanismsha1.c:420 ../gio/gdbusauthmechanismsha1.c:732
+#: ../gio/gdbusauthmechanismsha1.c:420
+#: ../gio/gdbusauthmechanismsha1.c:732
 #, c-format
-msgid ""
-"First token of line %d of the keyring at `%s' with content `%s' is malformed"
+msgid "First token of line %d of the keyring at `%s' with content `%s' is malformed"
 msgstr ""
 
-#: ../gio/gdbusauthmechanismsha1.c:435 ../gio/gdbusauthmechanismsha1.c:746
+#: ../gio/gdbusauthmechanismsha1.c:435
+#: ../gio/gdbusauthmechanismsha1.c:746
 #, c-format
-msgid ""
-"Second token of line %d of the keyring at `%s' with content `%s' is malformed"
+msgid "Second token of line %d of the keyring at `%s' with content `%s' is malformed"
 msgstr ""
 
 #: ../gio/gdbusauthmechanismsha1.c:459
@@ -1719,8 +1724,10 @@ msgstr "Feil ved opning av fila «%s»: %s"
 msgid "(Additionally, releasing the lock for `%s' also failed: %s) "
 msgstr ""
 
-#: ../gio/gdbusconnection.c:1150 ../gio/gdbusconnection.c:1376
-#: ../gio/gdbusconnection.c:1415 ../gio/gdbusconnection.c:1740
+#: ../gio/gdbusconnection.c:1150
+#: ../gio/gdbusconnection.c:1376
+#: ../gio/gdbusconnection.c:1415
+#: ../gio/gdbusconnection.c:1740
 #, fuzzy
 msgid "The connection is closed"
 msgstr "Teljaren er stengt"
@@ -1730,14 +1737,13 @@ msgid "Timeout was reached"
 msgstr ""
 
 #: ../gio/gdbusconnection.c:2306
-msgid ""
-"Unsupported flags encountered when constructing a client-side connection"
+msgid "Unsupported flags encountered when constructing a client-side connection"
 msgstr ""
 
-#: ../gio/gdbusconnection.c:3770 ../gio/gdbusconnection.c:4086
+#: ../gio/gdbusconnection.c:3770
+#: ../gio/gdbusconnection.c:4086
 #, c-format
-msgid ""
-"No such interface `org.freedesktop.DBus.Properties' on object at path %s"
+msgid "No such interface `org.freedesktop.DBus.Properties' on object at path %s"
 msgstr ""
 
 #: ../gio/gdbusconnection.c:3841
@@ -1760,7 +1766,8 @@ msgstr ""
 msgid "Property `%s' is not writable"
 msgstr ""
 
-#: ../gio/gdbusconnection.c:4029 ../gio/gdbusconnection.c:5853
+#: ../gio/gdbusconnection.c:4029
+#: ../gio/gdbusconnection.c:5853
 #, c-format
 msgid "No such interface `%s'"
 msgstr ""
@@ -1769,7 +1776,8 @@ msgstr ""
 msgid "No such interface"
 msgstr ""
 
-#: ../gio/gdbusconnection.c:4432 ../gio/gdbusconnection.c:6359
+#: ../gio/gdbusconnection.c:4432
+#: ../gio/gdbusconnection.c:6359
 #, c-format
 msgid "No such interface `%s' on object at path %s"
 msgstr ""
@@ -1825,15 +1833,11 @@ msgid "SIGNAL message: PATH, INTERFACE or MEMBER header field is missing"
 msgstr ""
 
 #: ../gio/gdbusmessage.c:914
-msgid ""
-"SIGNAL message: The PATH header field is using the reserved value /org/"
-"freedesktop/DBus/Local"
+msgid "SIGNAL message: The PATH header field is using the reserved value /org/freedesktop/DBus/Local"
 msgstr ""
 
 #: ../gio/gdbusmessage.c:922
-msgid ""
-"SIGNAL message: The INTERFACE header field is using the reserved value org."
-"freedesktop.DBus.Local"
+msgid "SIGNAL message: The INTERFACE header field is using the reserved value org.freedesktop.DBus.Local"
 msgstr ""
 
 #: ../gio/gdbusmessage.c:998
@@ -1845,9 +1849,7 @@ msgstr[1] ""
 
 #: ../gio/gdbusmessage.c:1025
 #, c-format
-msgid ""
-"Expected valid UTF-8 string but found invalid bytes at byte offset %d "
-"(length of string is %d). The valid UTF-8 string up until that point was `%s'"
+msgid "Expected valid UTF-8 string but found invalid bytes at byte offset %d (length of string is %d). The valid UTF-8 string up until that point was `%s'"
 msgstr ""
 
 #: ../gio/gdbusmessage.c:1038
@@ -1867,10 +1869,8 @@ msgstr ""
 
 #: ../gio/gdbusmessage.c:1324
 #, c-format
-msgid ""
-"Encountered array of length %u byte. Maximum length is 2<<26 bytes (64 MiB)."
-msgid_plural ""
-"Encountered array of length %u bytes. Maximum length is 2<<26 bytes (64 MiB)."
+msgid "Encountered array of length %u byte. Maximum length is 2<<26 bytes (64 MiB)."
+msgid_plural "Encountered array of length %u bytes. Maximum length is 2<<26 bytes (64 MiB)."
 msgstr[0] ""
 msgstr[1] ""
 
@@ -1881,15 +1881,12 @@ msgstr ""
 
 #: ../gio/gdbusmessage.c:1517
 #, c-format
-msgid ""
-"Error deserializing GVariant with type string `%s' from the D-Bus wire format"
+msgid "Error deserializing GVariant with type string `%s' from the D-Bus wire format"
 msgstr ""
 
 #: ../gio/gdbusmessage.c:1705
 #, c-format
-msgid ""
-"Invalid endianness value. Expected 0x6c ('l') or 0x42 ('B') but found value "
-"0x%02x"
+msgid "Invalid endianness value. Expected 0x6c ('l') or 0x42 ('B') but found value 0x%02x"
 msgstr ""
 
 #: ../gio/gdbusmessage.c:1719
@@ -1920,15 +1917,12 @@ msgstr ""
 
 #: ../gio/gdbusmessage.c:2163
 #, c-format
-msgid ""
-"Error serializing GVariant with type string `%s' to the D-Bus wire format"
+msgid "Error serializing GVariant with type string `%s' to the D-Bus wire format"
 msgstr ""
 
 #: ../gio/gdbusmessage.c:2303
 #, c-format
-msgid ""
-"Message has %d file descriptors but the header field indicates %d file "
-"descriptors"
+msgid "Message has %d file descriptors but the header field indicates %d file descriptors"
 msgstr ""
 
 #: ../gio/gdbusmessage.c:2311
@@ -1942,9 +1936,7 @@ msgstr ""
 
 #: ../gio/gdbusmessage.c:2365
 #, c-format
-msgid ""
-"Message body has type signature `%s' but signature in the header field is `"
-"%s'"
+msgid "Message body has type signature `%s' but signature in the header field is `%s'"
 msgstr ""
 
 #: ../gio/gdbusmessage.c:2381
@@ -1975,10 +1967,9 @@ msgstr ""
 msgid "Unexpected reply %d from StartServiceByName(\"%s\") method"
 msgstr ""
 
-#: ../gio/gdbusproxy.c:2600 ../gio/gdbusproxy.c:2734
-msgid ""
-"Cannot invoke method; proxy is for a well-known name without an owner and "
-"proxy was constructed with the G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START flag"
+#: ../gio/gdbusproxy.c:2600
+#: ../gio/gdbusproxy.c:2734
+msgid "Cannot invoke method; proxy is for a well-known name without an owner and proxy was constructed with the G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START flag"
 msgstr ""
 
 #: ../gio/gdbusserver.c:711
@@ -2022,14 +2013,20 @@ msgid ""
 "Use \"%s COMMAND --help\" to get help on each command.\n"
 msgstr ""
 
-#: ../gio/gdbus-tool.c:162 ../gio/gdbus-tool.c:218 ../gio/gdbus-tool.c:290
-#: ../gio/gdbus-tool.c:314 ../gio/gdbus-tool.c:691 ../gio/gdbus-tool.c:1010
+#: ../gio/gdbus-tool.c:162
+#: ../gio/gdbus-tool.c:218
+#: ../gio/gdbus-tool.c:290
+#: ../gio/gdbus-tool.c:314
+#: ../gio/gdbus-tool.c:691
+#: ../gio/gdbus-tool.c:1010
 #: ../gio/gdbus-tool.c:1443
 #, fuzzy, c-format
 msgid "Error: %s\n"
 msgstr "Feil på linje %d: %s"
 
-#: ../gio/gdbus-tool.c:173 ../gio/gdbus-tool.c:231 ../gio/gdbus-tool.c:1459
+#: ../gio/gdbus-tool.c:173
+#: ../gio/gdbus-tool.c:231
+#: ../gio/gdbus-tool.c:1459
 #, fuzzy, c-format
 msgid "Error parsing introspection XML: %s\n"
 msgstr "Feil under tolking av val %s"
@@ -2066,15 +2063,12 @@ msgstr ""
 
 #: ../gio/gdbus-tool.c:463
 #, c-format
-msgid ""
-"Warning: According to introspection data, interface `%s' does not exist\n"
+msgid "Warning: According to introspection data, interface `%s' does not exist\n"
 msgstr ""
 
 #: ../gio/gdbus-tool.c:472
 #, c-format
-msgid ""
-"Warning: According to introspection data, method `%s' does not exist on "
-"interface `%s'\n"
+msgid "Warning: According to introspection data, method `%s' does not exist on interface `%s'\n"
 msgstr ""
 
 #: ../gio/gdbus-tool.c:534
@@ -2093,7 +2087,9 @@ msgstr ""
 msgid "Emit a signal."
 msgstr ""
 
-#: ../gio/gdbus-tool.c:602 ../gio/gdbus-tool.c:822 ../gio/gdbus-tool.c:1549
+#: ../gio/gdbus-tool.c:602
+#: ../gio/gdbus-tool.c:822
+#: ../gio/gdbus-tool.c:1549
 #: ../gio/gdbus-tool.c:1781
 #, fuzzy, c-format
 msgid "Error connecting: %s\n"
@@ -2104,7 +2100,9 @@ msgstr "Feil ved opning av fila: %s"
 msgid "Error: object path not specified.\n"
 msgstr ""
 
-#: ../gio/gdbus-tool.c:619 ../gio/gdbus-tool.c:883 ../gio/gdbus-tool.c:1607
+#: ../gio/gdbus-tool.c:619
+#: ../gio/gdbus-tool.c:883
+#: ../gio/gdbus-tool.c:1607
 #: ../gio/gdbus-tool.c:1840
 #, c-format
 msgid "Error: %s is not a valid object path\n"
@@ -2130,7 +2128,8 @@ msgstr "Teiknet «%s» er ikkje gyldig inne i eit entitetsnamn"
 msgid "Error: %s is not a valid unique bus name.\n"
 msgstr "Teiknet «%s» er ikkje gyldig inne i eit entitetsnamn"
 
-#: ../gio/gdbus-tool.c:669 ../gio/gdbus-tool.c:982
+#: ../gio/gdbus-tool.c:669
+#: ../gio/gdbus-tool.c:982
 #, fuzzy, c-format
 msgid "Error parsing parameter %d: %s\n"
 msgstr "Feil under tolking av val %s"
@@ -2160,12 +2159,15 @@ msgstr ""
 msgid "Invoke a method on a remote object."
 msgstr ""
 
-#: ../gio/gdbus-tool.c:842 ../gio/gdbus-tool.c:1568 ../gio/gdbus-tool.c:1800
+#: ../gio/gdbus-tool.c:842
+#: ../gio/gdbus-tool.c:1568
+#: ../gio/gdbus-tool.c:1800
 #, c-format
 msgid "Error: Destination is not specified\n"
 msgstr ""
 
-#: ../gio/gdbus-tool.c:863 ../gio/gdbus-tool.c:1587
+#: ../gio/gdbus-tool.c:863
+#: ../gio/gdbus-tool.c:1587
 #, c-format
 msgid "Error: Object path is not specified\n"
 msgstr ""
@@ -2222,7 +2224,8 @@ msgstr ""
 msgid "Monitor a remote object."
 msgstr "øydelagt objekt"
 
-#: ../gio/gdesktopappinfo.c:572 ../gio/gwin32appinfo.c:221
+#: ../gio/gdesktopappinfo.c:572
+#: ../gio/gwin32appinfo.c:221
 msgid "Unnamed"
 msgstr "Utan namn"
 
@@ -2244,7 +2247,8 @@ msgstr "Kan ikkje laga programoppsettmappe %s for brukaren: %s"
 msgid "Can't create user MIME configuration folder %s: %s"
 msgstr "Kan ikkje laga MIME-oppsettmappe %s: %s"
 
-#: ../gio/gdesktopappinfo.c:1785 ../gio/gdesktopappinfo.c:1809
+#: ../gio/gdesktopappinfo.c:1785
+#: ../gio/gdesktopappinfo.c:1809
 msgid "Application information lacks an identifier"
 msgstr ""
 
@@ -2284,7 +2288,8 @@ msgstr "stasjonen støttar ikkje å løysa ut"
 msgid "drive doesn't implement stop"
 msgstr "stasjonen støttar ikkje å løysa ut"
 
-#: ../gio/gdummytlsbackend.c:168 ../gio/gdummytlsbackend.c:288
+#: ../gio/gdummytlsbackend.c:168
+#: ../gio/gdummytlsbackend.c:288
 #: ../gio/gdummytlsbackend.c:378
 msgid "TLS support is not available"
 msgstr ""
@@ -2313,15 +2318,33 @@ msgstr ""
 msgid "Expected a GEmblem for GEmblemedIcon"
 msgstr ""
 
-#: ../gio/gfile.c:871 ../gio/gfile.c:1102 ../gio/gfile.c:1237
-#: ../gio/gfile.c:1474 ../gio/gfile.c:1528 ../gio/gfile.c:1585
-#: ../gio/gfile.c:1668 ../gio/gfile.c:1723 ../gio/gfile.c:1783
-#: ../gio/gfile.c:1837 ../gio/gfile.c:3307 ../gio/gfile.c:3361
-#: ../gio/gfile.c:3493 ../gio/gfile.c:3534 ../gio/gfile.c:3864
-#: ../gio/gfile.c:4266 ../gio/gfile.c:4352 ../gio/gfile.c:4441
-#: ../gio/gfile.c:4539 ../gio/gfile.c:4626 ../gio/gfile.c:4720
-#: ../gio/gfile.c:5041 ../gio/gfile.c:5308 ../gio/gfile.c:5373
-#: ../gio/gfile.c:6947 ../gio/gfile.c:7037 ../gio/gfile.c:7123
+#: ../gio/gfile.c:871
+#: ../gio/gfile.c:1102
+#: ../gio/gfile.c:1237
+#: ../gio/gfile.c:1474
+#: ../gio/gfile.c:1528
+#: ../gio/gfile.c:1585
+#: ../gio/gfile.c:1668
+#: ../gio/gfile.c:1723
+#: ../gio/gfile.c:1783
+#: ../gio/gfile.c:1837
+#: ../gio/gfile.c:3307
+#: ../gio/gfile.c:3361
+#: ../gio/gfile.c:3493
+#: ../gio/gfile.c:3534
+#: ../gio/gfile.c:3864
+#: ../gio/gfile.c:4266
+#: ../gio/gfile.c:4352
+#: ../gio/gfile.c:4441
+#: ../gio/gfile.c:4539
+#: ../gio/gfile.c:4626
+#: ../gio/gfile.c:4720
+#: ../gio/gfile.c:5041
+#: ../gio/gfile.c:5308
+#: ../gio/gfile.c:5373
+#: ../gio/gfile.c:6947
+#: ../gio/gfile.c:7037
+#: ../gio/gfile.c:7123
 #: ../gio/win32/gwinhttpfile.c:439
 msgid "Operation not supported"
 msgstr "Operasjonen er ikkje støtta"
@@ -2334,12 +2357,15 @@ msgstr "Operasjonen er ikkje støtta"
 #. Translators: This is an error message when trying to find
 #. * the enclosing (user visible) mount of a file, but none
 #. * exists.
-#: ../gio/gfile.c:1358 ../gio/glocalfile.c:1051 ../gio/glocalfile.c:1062
+#: ../gio/gfile.c:1358
+#: ../gio/glocalfile.c:1051
+#: ../gio/glocalfile.c:1062
 #: ../gio/glocalfile.c:1075
 msgid "Containing mount does not exist"
 msgstr "Omsluttande monteringspunkt finst ikkje"
 
-#: ../gio/gfile.c:2411 ../gio/glocalfile.c:2256
+#: ../gio/gfile.c:2411
+#: ../gio/glocalfile.c:2256
 msgid "Can't copy over directory"
 msgstr "Kan ikkje skriva over mappe"
 
@@ -2347,7 +2373,8 @@ msgstr "Kan ikkje skriva over mappe"
 msgid "Can't copy directory over directory"
 msgstr "Kan ikkje skriva ei mappe over ei mappe"
 
-#: ../gio/gfile.c:2480 ../gio/glocalfile.c:2265
+#: ../gio/gfile.c:2480
+#: ../gio/glocalfile.c:2265
 msgid "Target file exists"
 msgstr "Målfila finst"
 
@@ -2383,7 +2410,8 @@ msgstr "Papirkorg er ikkje støtta"
 msgid "File names cannot contain '%c'"
 msgstr "Filnamn kan ikkje innehalda «%c»"
 
-#: ../gio/gfile.c:6006 ../gio/gvolume.c:332
+#: ../gio/gfile.c:6006
+#: ../gio/gvolume.c:332
 msgid "volume doesn't implement mount"
 msgstr "volumet støttar ikkje montering"
 
@@ -2395,12 +2423,15 @@ msgstr "Ingen program er registrert til å handtera denne fila"
 msgid "Enumerator is closed"
 msgstr "Teljaren er stengt"
 
-#: ../gio/gfileenumerator.c:212 ../gio/gfileenumerator.c:271
-#: ../gio/gfileenumerator.c:371 ../gio/gfileenumerator.c:480
+#: ../gio/gfileenumerator.c:212
+#: ../gio/gfileenumerator.c:271
+#: ../gio/gfileenumerator.c:371
+#: ../gio/gfileenumerator.c:480
 msgid "File enumerator has outstanding operation"
 msgstr "Filteljaren har ventande operasjon"
 
-#: ../gio/gfileenumerator.c:361 ../gio/gfileenumerator.c:470
+#: ../gio/gfileenumerator.c:361
+#: ../gio/gfileenumerator.c:470
 msgid "File enumerator is already closed"
 msgstr "Filteljaren er allereie lukka"
 
@@ -2413,13 +2444,16 @@ msgstr ""
 msgid "Malformed input data for GFileIcon"
 msgstr ""
 
-#: ../gio/gfileinputstream.c:154 ../gio/gfileinputstream.c:420
-#: ../gio/gfileiostream.c:170 ../gio/gfileoutputstream.c:169
+#: ../gio/gfileinputstream.c:154
+#: ../gio/gfileinputstream.c:420
+#: ../gio/gfileiostream.c:170
+#: ../gio/gfileoutputstream.c:169
 #: ../gio/gfileoutputstream.c:523
 msgid "Stream doesn't support query_info"
 msgstr "Straumen støttar ikkje query_info"
 
-#: ../gio/gfileinputstream.c:335 ../gio/gfileiostream.c:387
+#: ../gio/gfileinputstream.c:335
+#: ../gio/gfileiostream.c:387
 #: ../gio/gfileoutputstream.c:381
 msgid "Seek not supported on stream"
 msgstr "Søking ikkje støtta i straumen"
@@ -2428,7 +2462,8 @@ msgstr "Søking ikkje støtta i straumen"
 msgid "Truncate not allowed on input stream"
 msgstr "Trunkering ikkje tillate på innstraumen"
 
-#: ../gio/gfileiostream.c:463 ../gio/gfileoutputstream.c:457
+#: ../gio/gfileiostream.c:463
+#: ../gio/gfileoutputstream.c:457
 msgid "Truncate not supported on stream"
 msgstr "Trunkerung ikkje tillate på straumen"
 
@@ -2476,12 +2511,14 @@ msgstr "Innstraumen støttar ikkje lesing"
 #. Translators: This is an error you get if there is
 #. * already an operation running against this stream when
 #. * you try to start one
-#: ../gio/ginputstream.c:898 ../gio/giostream.c:316
+#: ../gio/ginputstream.c:898
+#: ../gio/giostream.c:316
 #: ../gio/goutputstream.c:1216
 msgid "Stream has outstanding operation"
 msgstr "Straumen har ventande operasjon"
 
-#: ../gio/ginetsocketaddress.c:181 ../gio/ginetsocketaddress.c:198
+#: ../gio/ginetsocketaddress.c:181
+#: ../gio/ginetsocketaddress.c:198
 #: ../gio/gunixsocketaddress.c:221
 msgid "Not enough space for socket address"
 msgstr ""
@@ -2502,9 +2539,7 @@ msgstr ""
 
 #: ../gio/glib-compile-schemas.c:763
 #, c-format
-msgid ""
-"invalid name '%s': invalid character '%c'; only lowercase letters, numbers "
-"and dash ('-') are permitted."
+msgid "invalid name '%s': invalid character '%c'; only lowercase letters, numbers and dash ('-') are permitted."
 msgstr ""
 
 #: ../gio/glib-compile-schemas.c:772
@@ -2538,16 +2573,12 @@ msgstr ""
 
 #: ../gio/glib-compile-schemas.c:913
 #, c-format
-msgid ""
-"<key name='%s'> shadows <key name='%s'> in <schema id='%s'>; use <override> "
-"to modify value"
+msgid "<key name='%s'> shadows <key name='%s'> in <schema id='%s'>; use <override> to modify value"
 msgstr ""
 
 #: ../gio/glib-compile-schemas.c:924
 #, c-format
-msgid ""
-"exactly one of 'type', 'enum' or 'flags' must be specified as an attribute "
-"to <key>"
+msgid "exactly one of 'type', 'enum' or 'flags' must be specified as an attribute to <key>"
 msgstr ""
 
 #: ../gio/glib-compile-schemas.c:943
@@ -2601,15 +2632,12 @@ msgstr ""
 
 #: ../gio/glib-compile-schemas.c:1136
 #, c-format
-msgid ""
-"<schema id='%s'> is a list, extending <schema id='%s'> which is not a list"
+msgid "<schema id='%s'> is a list, extending <schema id='%s'> which is not a list"
 msgstr ""
 
 #: ../gio/glib-compile-schemas.c:1146
 #, c-format
-msgid ""
-"<schema id='%s' list-of='%s'> extends <schema id='%s' list-of='%s'> but '%s' "
-"does not extend '%s'"
+msgid "<schema id='%s' list-of='%s'> extends <schema id='%s' list-of='%s'> but '%s' does not extend '%s'"
 msgstr ""
 
 #: ../gio/glib-compile-schemas.c:1163
@@ -2643,7 +2671,8 @@ msgid "text may not appear inside <%s>"
 msgstr ""
 
 #. Translators: Do not translate "--strict".
-#: ../gio/glib-compile-schemas.c:1696 ../gio/glib-compile-schemas.c:1767
+#: ../gio/glib-compile-schemas.c:1696
+#: ../gio/glib-compile-schemas.c:1767
 #: ../gio/glib-compile-schemas.c:1843
 #, c-format
 msgid "--strict was specified; exiting.\n"
@@ -2664,13 +2693,15 @@ msgstr ""
 msgid "No such key `%s' in schema `%s' as specified in override file `%s'"
 msgstr ""
 
-#: ../gio/glib-compile-schemas.c:1809 ../gio/glib-compile-schemas.c:1867
+#: ../gio/glib-compile-schemas.c:1809
+#: ../gio/glib-compile-schemas.c:1867
 #: ../gio/glib-compile-schemas.c:1895
 #, c-format
 msgid "; ignoring override for this key.\n"
 msgstr ""
 
-#: ../gio/glib-compile-schemas.c:1813 ../gio/glib-compile-schemas.c:1871
+#: ../gio/glib-compile-schemas.c:1813
+#: ../gio/glib-compile-schemas.c:1871
 #: ../gio/glib-compile-schemas.c:1899
 #, c-format
 msgid " and --strict was specified; exiting.\n"
@@ -2678,9 +2709,7 @@ msgstr ""
 
 #: ../gio/glib-compile-schemas.c:1829
 #, c-format
-msgid ""
-"error parsing key `%s' in schema `%s' as specified in override file `%s': "
-"%s.  "
+msgid "error parsing key `%s' in schema `%s' as specified in override file `%s': %s.  "
 msgstr ""
 
 #: ../gio/glib-compile-schemas.c:1839
@@ -2690,23 +2719,20 @@ msgstr ""
 
 #: ../gio/glib-compile-schemas.c:1857
 #, c-format
-msgid ""
-"override for key `%s' in schema `%s' in override file `%s' is out of the "
-"range given in the schema"
+msgid "override for key `%s' in schema `%s' in override file `%s' is out of the range given in the schema"
 msgstr ""
 
 #: ../gio/glib-compile-schemas.c:1885
 #, c-format
-msgid ""
-"override for key `%s' in schema `%s' in override file `%s' is not in the "
-"list of valid choices"
+msgid "override for key `%s' in schema `%s' in override file `%s' is not in the list of valid choices"
 msgstr ""
 
 #: ../gio/glib-compile-schemas.c:1939
 msgid "where to store the gschemas.compiled file"
 msgstr ""
 
-#: ../gio/glib-compile-schemas.c:1939 ../gio/glib-compile-schemas.c:1970
+#: ../gio/glib-compile-schemas.c:1939
+#: ../gio/glib-compile-schemas.c:1970
 msgid "DIRECTORY"
 msgstr ""
 
@@ -2757,7 +2783,8 @@ msgstr ""
 msgid "Unable to find default local directory monitor type"
 msgstr "Klarer ikkje å finna typen standard lokal mappeovervakar"
 
-#: ../gio/glocalfile.c:571 ../gio/win32/gwinhttpfile.c:422
+#: ../gio/glocalfile.c:571
+#: ../gio/win32/gwinhttpfile.c:422
 #, c-format
 msgid "Invalid filename %s"
 msgstr "Ugyldig filnamn %s"
@@ -2771,7 +2798,8 @@ msgstr "Feil ved henting av filsysteminfo: %s"
 msgid "Can't rename root directory"
 msgstr "Kan ikkje gje rotmappa nytt namn"
 
-#: ../gio/glocalfile.c:1117 ../gio/glocalfile.c:1143
+#: ../gio/glocalfile.c:1117
+#: ../gio/glocalfile.c:1143
 #, c-format
 msgid "Error renaming file: %s"
 msgstr "Feil ved namnebyte på fila: %s"
@@ -2781,9 +2809,13 @@ msgstr "Feil ved namnebyte på fila: %s"
 msgid "Can't rename file, filename already exists"
 msgstr "Kan ikkje gje fila nytt namn, filnamnet finst frå før"
 
-#: ../gio/glocalfile.c:1139 ../gio/glocalfile.c:2129 ../gio/glocalfile.c:2158
-#: ../gio/glocalfile.c:2318 ../gio/glocalfileoutputstream.c:571
-#: ../gio/glocalfileoutputstream.c:624 ../gio/glocalfileoutputstream.c:669
+#: ../gio/glocalfile.c:1139
+#: ../gio/glocalfile.c:2129
+#: ../gio/glocalfile.c:2158
+#: ../gio/glocalfile.c:2318
+#: ../gio/glocalfileoutputstream.c:571
+#: ../gio/glocalfileoutputstream.c:624
+#: ../gio/glocalfileoutputstream.c:669
 #: ../gio/glocalfileoutputstream.c:1157
 msgid "Invalid filename"
 msgstr "Ugyldig filnamn"
@@ -2816,7 +2848,8 @@ msgstr "Klarte ikkje å laga papirkorgmappa %s: %s"
 msgid "Unable to find toplevel directory for trash"
 msgstr "Klarar ikkje å finna toppnivåmappe for papirkorga"
 
-#: ../gio/glocalfile.c:1931 ../gio/glocalfile.c:1951
+#: ../gio/glocalfile.c:1931
+#: ../gio/glocalfile.c:1951
 msgid "Unable to find or create trash directory"
 msgstr "Klarar ikkje å finna eller laga papirkorgmappa"
 
@@ -2825,7 +2858,9 @@ msgstr "Klarar ikkje å finna eller laga papirkorgmappa"
 msgid "Unable to create trashing info file: %s"
 msgstr "Klarte ikkje å laga infofil om kassering: %s"
 
-#: ../gio/glocalfile.c:2014 ../gio/glocalfile.c:2019 ../gio/glocalfile.c:2099
+#: ../gio/glocalfile.c:2014
+#: ../gio/glocalfile.c:2019
+#: ../gio/glocalfile.c:2099
 #: ../gio/glocalfile.c:2106
 #, c-format
 msgid "Unable to trash file: %s"
@@ -2846,7 +2881,8 @@ msgstr "Klarte ikkje å lesa den symbolske lenkja «%s»: %s"
 msgid "Error making symbolic link: %s"
 msgstr "Klarte ikkje å laga symbolsk lenkje: %s"
 
-#: ../gio/glocalfile.c:2228 ../gio/glocalfile.c:2322
+#: ../gio/glocalfile.c:2228
+#: ../gio/glocalfile.c:2322
 #, c-format
 msgid "Error moving file: %s"
 msgstr "Feil under flytting av fil: %s"
@@ -2855,9 +2891,12 @@ msgstr "Feil under flytting av fil: %s"
 msgid "Can't move directory over directory"
 msgstr "Kan ikkje flytta mappa over ei mappe"
 
-#: ../gio/glocalfile.c:2278 ../gio/glocalfileoutputstream.c:955
-#: ../gio/glocalfileoutputstream.c:969 ../gio/glocalfileoutputstream.c:984
-#: ../gio/glocalfileoutputstream.c:1000 ../gio/glocalfileoutputstream.c:1014
+#: ../gio/glocalfile.c:2278
+#: ../gio/glocalfileoutputstream.c:955
+#: ../gio/glocalfileoutputstream.c:969
+#: ../gio/glocalfileoutputstream.c:984
+#: ../gio/glocalfileoutputstream.c:1000
+#: ../gio/glocalfileoutputstream.c:1014
 msgid "Backup file creation failed"
 msgstr "Klarte ikkje å laga tryggleikskopi av fila"
 
@@ -2887,7 +2926,8 @@ msgstr "Ugyldig utvida attributtnamn"
 msgid "Error setting extended attribute '%s': %s"
 msgstr "Feil under endring av utvida attributtverdi «%s»: %s"
 
-#: ../gio/glocalfileinfo.c:1482 ../gio/glocalfileoutputstream.c:833
+#: ../gio/glocalfileinfo.c:1482
+#: ../gio/glocalfileoutputstream.c:833
 #, c-format
 msgid "Error stating file '%s': %s"
 msgstr "Feil under lesing av informasjon om fila «%s»: %s"
@@ -2909,7 +2949,8 @@ msgstr "Ugyldig attributtype (venta uint32)"
 msgid "Invalid attribute type (uint64 expected)"
 msgstr "Ugyldig attributtype (venta uint64)"
 
-#: ../gio/glocalfileinfo.c:1850 ../gio/glocalfileinfo.c:1869
+#: ../gio/glocalfileinfo.c:1850
+#: ../gio/glocalfileinfo.c:1869
 msgid "Invalid attribute type (byte string expected)"
 msgstr "Ugyldig attributtype (venta byte-streng)"
 
@@ -2932,7 +2973,8 @@ msgstr "Feil under eigarskifte: %s"
 msgid "symlink must be non-NULL"
 msgstr "symbolsk lenkje må vera ikkje-NULL"
 
-#: ../gio/glocalfileinfo.c:2004 ../gio/glocalfileinfo.c:2023
+#: ../gio/glocalfileinfo.c:2004
+#: ../gio/glocalfileinfo.c:2023
 #: ../gio/glocalfileinfo.c:2034
 #, c-format
 msgid "Error setting symlink: %s"
@@ -2940,8 +2982,7 @@ msgstr "Fil under oppretting av symbolsk lenkje: %s"
 
 #: ../gio/glocalfileinfo.c:2013
 msgid "Error setting symlink: file is not a symlink"
-msgstr ""
-"Fil under oppretting av symbolsk lenkje: Fila er ikkje ei symbolsk lenkje"
+msgstr "Fil under oppretting av symbolsk lenkje: Fila er ikkje ei symbolsk lenkje"
 
 #: ../gio/glocalfileinfo.c:2139
 #, fuzzy, c-format
@@ -2967,19 +3008,23 @@ msgstr ""
 msgid "Setting attribute %s not supported"
 msgstr "Å setja attributten %s er ikkje støtta"
 
-#: ../gio/glocalfileinputstream.c:185 ../gio/glocalfileoutputstream.c:722
+#: ../gio/glocalfileinputstream.c:185
+#: ../gio/glocalfileoutputstream.c:722
 #, c-format
 msgid "Error reading from file: %s"
 msgstr "Feil ved lesing frå fila: %s"
 
-#: ../gio/glocalfileinputstream.c:216 ../gio/glocalfileinputstream.c:228
-#: ../gio/glocalfileinputstream.c:340 ../gio/glocalfileoutputstream.c:470
+#: ../gio/glocalfileinputstream.c:216
+#: ../gio/glocalfileinputstream.c:228
+#: ../gio/glocalfileinputstream.c:340
+#: ../gio/glocalfileoutputstream.c:470
 #: ../gio/glocalfileoutputstream.c:1032
 #, c-format
 msgid "Error seeking in file: %s"
 msgstr "Feil ved søking i fila: %s"
 
-#: ../gio/glocalfileinputstream.c:261 ../gio/glocalfileoutputstream.c:256
+#: ../gio/glocalfileinputstream.c:261
+#: ../gio/glocalfileoutputstream.c:256
 #: ../gio/glocalfileoutputstream.c:351
 #, c-format
 msgid "Error closing file: %s"
@@ -2989,7 +3034,8 @@ msgstr "Feil ved stenging av fila: %s"
 msgid "Unable to find default local file monitor type"
 msgstr "Klarer ikkje å finna typen standard lokal filovervakar"
 
-#: ../gio/glocalfileoutputstream.c:202 ../gio/glocalfileoutputstream.c:235
+#: ../gio/glocalfileoutputstream.c:202
+#: ../gio/glocalfileoutputstream.c:235
 #: ../gio/glocalfileoutputstream.c:743
 #, c-format
 msgid "Error writing to file: %s"
@@ -3000,7 +3046,8 @@ msgstr "Feil ved skriving til fila: %s"
 msgid "Error removing old backup link: %s"
 msgstr "Feil under fjerning av gamal tryggleikskopilenkje: %s"
 
-#: ../gio/glocalfileoutputstream.c:297 ../gio/glocalfileoutputstream.c:310
+#: ../gio/glocalfileoutputstream.c:297
+#: ../gio/glocalfileoutputstream.c:310
 #, c-format
 msgid "Error creating backup copy: %s"
 msgstr "Feil ved oppretting av tryggleikskopi: %s"
@@ -3010,14 +3057,18 @@ msgstr "Feil ved oppretting av tryggleikskopi: %s"
 msgid "Error renaming temporary file: %s"
 msgstr "Feil ved namnebyte på mellombels fil: %s"
 
-#: ../gio/glocalfileoutputstream.c:516 ../gio/glocalfileoutputstream.c:1083
+#: ../gio/glocalfileoutputstream.c:516
+#: ../gio/glocalfileoutputstream.c:1083
 #, c-format
 msgid "Error truncating file: %s"
 msgstr "Feil ved trunkering av fila: %s"
 
-#: ../gio/glocalfileoutputstream.c:577 ../gio/glocalfileoutputstream.c:630
-#: ../gio/glocalfileoutputstream.c:675 ../gio/glocalfileoutputstream.c:815
-#: ../gio/glocalfileoutputstream.c:1064 ../gio/glocalfileoutputstream.c:1163
+#: ../gio/glocalfileoutputstream.c:577
+#: ../gio/glocalfileoutputstream.c:630
+#: ../gio/glocalfileoutputstream.c:675
+#: ../gio/glocalfileoutputstream.c:815
+#: ../gio/glocalfileoutputstream.c:1064
+#: ../gio/glocalfileoutputstream.c:1163
 #, c-format
 msgid "Error opening file '%s': %s"
 msgstr "Feil ved opning av fila «%s»: %s"
@@ -3039,7 +3090,8 @@ msgstr "Fila vart endra utanfrå"
 msgid "Error removing old file: %s"
 msgstr "Feil under fjerning av fila: %s"
 
-#: ../gio/gmemoryinputstream.c:486 ../gio/gmemoryoutputstream.c:746
+#: ../gio/gmemoryinputstream.c:486
+#: ../gio/gmemoryoutputstream.c:746
 msgid "Invalid GSeekType supplied"
 msgstr "Ugyldig GSeekType sendt med"
 
@@ -3060,9 +3112,7 @@ msgid "Failed to resize memory output stream"
 msgstr "Klarte ikkje å endra storleik på utstraumen frå minnet"
 
 #: ../gio/gmemoryoutputstream.c:600
-msgid ""
-"Amount of memory required to process the write is larger than available "
-"address space"
+msgid "Amount of memory required to process the write is larger than available address space"
 msgstr ""
 
 #: ../gio/gmemoryoutputstream.c:756
@@ -3134,11 +3184,13 @@ msgstr "monteringspunktet støttar ikkje avmontering"
 msgid "Hostname '%s' contains '[' but not ']'"
 msgstr ""
 
-#: ../gio/goutputstream.c:207 ../gio/goutputstream.c:411
+#: ../gio/goutputstream.c:207
+#: ../gio/goutputstream.c:411
 msgid "Output stream doesn't implement write"
 msgstr "utstraumen støttar ikkje skriving"
 
-#: ../gio/goutputstream.c:372 ../gio/goutputstream.c:855
+#: ../gio/goutputstream.c:372
+#: ../gio/goutputstream.c:855
 msgid "Source stream is already closed"
 msgstr "Kjeldestraumen er allereie stengt"
 
@@ -3152,17 +3204,20 @@ msgstr "Feil ved lesing av fil «%s»: %s"
 msgid "Error reverse-resolving '%s': %s"
 msgstr "Feil ved lesing av fil «%s»: %s"
 
-#: ../gio/gresolver.c:864 ../gio/gresolver.c:943
+#: ../gio/gresolver.c:864
+#: ../gio/gresolver.c:943
 #, c-format
 msgid "No service record for '%s'"
 msgstr ""
 
-#: ../gio/gresolver.c:869 ../gio/gresolver.c:948
+#: ../gio/gresolver.c:869
+#: ../gio/gresolver.c:948
 #, c-format
 msgid "Temporarily unable to resolve '%s'"
 msgstr ""
 
-#: ../gio/gresolver.c:874 ../gio/gresolver.c:953
+#: ../gio/gresolver.c:874
+#: ../gio/gresolver.c:953
 #, fuzzy, c-format
 msgid "Error resolving '%s'"
 msgstr "Feil under fjerning av fila: %s"
@@ -3172,7 +3227,8 @@ msgstr "Feil under fjerning av fila: %s"
 msgid "Schema '%s' is not relocatable (path must not be specified)\n"
 msgstr ""
 
-#: ../gio/gsettings-tool.c:65 ../gio/gsettings-tool.c:82
+#: ../gio/gsettings-tool.c:65
+#: ../gio/gsettings-tool.c:82
 #, c-format
 msgid "No such schema '%s'\n"
 msgstr ""
@@ -3228,7 +3284,8 @@ msgstr ""
 msgid "List the keys in SCHEMA"
 msgstr ""
 
-#: ../gio/gsettings-tool.c:552 ../gio/gsettings-tool.c:558
+#: ../gio/gsettings-tool.c:552
+#: ../gio/gsettings-tool.c:558
 #: ../gio/gsettings-tool.c:595
 msgid "SCHEMA[:PATH]"
 msgstr ""
@@ -3251,8 +3308,10 @@ msgstr ""
 msgid "Get the value of KEY"
 msgstr ""
 
-#: ../gio/gsettings-tool.c:571 ../gio/gsettings-tool.c:577
-#: ../gio/gsettings-tool.c:589 ../gio/gsettings-tool.c:601
+#: ../gio/gsettings-tool.c:571
+#: ../gio/gsettings-tool.c:577
+#: ../gio/gsettings-tool.c:589
+#: ../gio/gsettings-tool.c:601
 msgid "SCHEMA[:PATH] KEY"
 msgstr ""
 
@@ -3377,7 +3436,9 @@ msgstr ""
 msgid "Socket is already closed"
 msgstr "Kjeldestraumen er allereie stengt"
 
-#: ../gio/gsocket.c:298 ../gio/gsocket.c:2798 ../gio/gsocket.c:2842
+#: ../gio/gsocket.c:298
+#: ../gio/gsocket.c:2798
+#: ../gio/gsocket.c:2842
 msgid "Socket I/O timed out"
 msgstr ""
 
@@ -3386,7 +3447,8 @@ msgstr ""
 msgid "creating GSocket from fd: %s"
 msgstr "Feil ved lesing frå fila: %s"
 
-#: ../gio/gsocket.c:498 ../gio/gsocket.c:514
+#: ../gio/gsocket.c:498
+#: ../gio/gsocket.c:514
 #, fuzzy, c-format
 msgid "Unable to create socket: %s"
 msgstr "Klarte ikkje å laga papirkorgmappa %s: %s"
@@ -3434,7 +3496,8 @@ msgstr ""
 msgid "Error connecting: %s"
 msgstr "Feil ved opning av fila: %s"
 
-#: ../gio/gsocket.c:1738 ../gio/gsocket.c:3579
+#: ../gio/gsocket.c:1738
+#: ../gio/gsocket.c:3579
 #, fuzzy, c-format
 msgid "Unable to get pending error: %s"
 msgstr "Klarte ikkje å kassera fila: %s"
@@ -3464,7 +3527,8 @@ msgstr "Feil ved stenging av fila: %s"
 msgid "Waiting for socket condition: %s"
 msgstr ""
 
-#: ../gio/gsocket.c:3056 ../gio/gsocket.c:3137
+#: ../gio/gsocket.c:3056
+#: ../gio/gsocket.c:3137
 #, fuzzy, c-format
 msgid "Error sending message: %s"
 msgstr "Feil ved opning av fila: %s"
@@ -3474,7 +3538,8 @@ msgstr "Feil ved opning av fila: %s"
 msgid "GSocketControlMessage not supported on windows"
 msgstr "å endra assosiasjonar er ikkje støtta på win32"
 
-#: ../gio/gsocket.c:3358 ../gio/gsocket.c:3494
+#: ../gio/gsocket.c:3358
+#: ../gio/gsocket.c:3494
 #, fuzzy, c-format
 msgid "Error receiving message: %s"
 msgstr "Feil under fjerning av fila: %s"
@@ -3483,16 +3548,19 @@ msgstr "Feil under fjerning av fila: %s"
 msgid "g_socket_get_credentials not implemented for this OS"
 msgstr ""
 
-#: ../gio/gsocketclient.c:798 ../gio/gsocketclient.c:1368
+#: ../gio/gsocketclient.c:798
+#: ../gio/gsocketclient.c:1368
 #, fuzzy
 msgid "Unknown error on connect"
 msgstr "ukjend feil"
 
-#: ../gio/gsocketclient.c:836 ../gio/gsocketclient.c:1252
+#: ../gio/gsocketclient.c:836
+#: ../gio/gsocketclient.c:1252
 msgid "Trying to proxy over non-TCP connection is not supported."
 msgstr ""
 
-#: ../gio/gsocketclient.c:858 ../gio/gsocketclient.c:1277
+#: ../gio/gsocketclient.c:858
+#: ../gio/gsocketclient.c:1277
 #, fuzzy, c-format
 msgid "Proxy protocol '%s' is not supported."
 msgstr "Symbolske lenkjer er ikkje støtta"
@@ -3529,7 +3597,8 @@ msgstr ""
 msgid "Connection through SOCKSv4 server was rejected"
 msgstr ""
 
-#: ../gio/gsocks5proxy.c:155 ../gio/gsocks5proxy.c:328
+#: ../gio/gsocks5proxy.c:155
+#: ../gio/gsocks5proxy.c:328
 #: ../gio/gsocks5proxy.c:338
 msgid "The server is not a SOCKSv5 proxy server."
 msgstr ""
@@ -3539,9 +3608,7 @@ msgid "The SOCKSv5 proxy requires authentication."
 msgstr ""
 
 #: ../gio/gsocks5proxy.c:179
-msgid ""
-"The SOCKSv5 proxy requires an authentication method that is not supported by "
-"GLib."
+msgid "The SOCKSv5 proxy requires an authentication method that is not supported by GLib."
 msgstr ""
 
 #: ../gio/gsocks5proxy.c:208
@@ -3616,27 +3683,25 @@ msgid "Could not parse PEM-encoded certificate"
 msgstr ""
 
 #: ../gio/gtlspassword.c:114
-msgid ""
-"This is the last chance to enter the password correctly before your access "
-"is locked out."
+msgid "This is the last chance to enter the password correctly before your access is locked out."
 msgstr ""
 
 #: ../gio/gtlspassword.c:116
-msgid ""
-"Several password entered have been incorrect, and your access will be locked "
-"out after further failures."
+msgid "Several password entered have been incorrect, and your access will be locked out after further failures."
 msgstr ""
 
 #: ../gio/gtlspassword.c:118
 msgid "The password entered is incorrect."
 msgstr ""
 
-#: ../gio/gunixconnection.c:164 ../gio/gunixconnection.c:521
+#: ../gio/gunixconnection.c:164
+#: ../gio/gunixconnection.c:521
 #, c-format
 msgid "Expecting 1 control message, got %d"
 msgstr ""
 
-#: ../gio/gunixconnection.c:177 ../gio/gunixconnection.c:531
+#: ../gio/gunixconnection.c:177
+#: ../gio/gunixconnection.c:531
 #, fuzzy
 msgid "Unexpected type of ancillary data"
 msgstr "Uventa tidleg slutt på straumen"
@@ -3662,9 +3727,7 @@ msgstr ""
 
 #: ../gio/gunixconnection.c:461
 #, c-format
-msgid ""
-"Unexpected option length while checking if SO_PASSCRED is enabled for "
-"socket. Expected %d bytes, got %d"
+msgid "Unexpected option length while checking if SO_PASSCRED is enabled for socket. Expected %d bytes, got %d"
 msgstr ""
 
 #: ../gio/gunixconnection.c:478
@@ -3673,8 +3736,7 @@ msgid "Error enabling SO_PASSCRED: %s"
 msgstr "Feil ved namnebyte på fila: %s"
 
 #: ../gio/gunixconnection.c:509
-msgid ""
-"Expecting to read a single byte for receiving credentials but read zero bytes"
+msgid "Expecting to read a single byte for receiving credentials but read zero bytes"
 msgstr ""
 
 #: ../gio/gunixconnection.c:545
@@ -3687,23 +3749,28 @@ msgstr ""
 msgid "Error while disabling SO_PASSCRED: %s"
 msgstr ""
 
-#: ../gio/gunixinputstream.c:368 ../gio/gunixinputstream.c:388
+#: ../gio/gunixinputstream.c:368
+#: ../gio/gunixinputstream.c:388
 #: ../gio/gunixinputstream.c:466
 #, c-format
 msgid "Error reading from unix: %s"
 msgstr "Feil ved lesing frå unix: %s"
 
-#: ../gio/gunixinputstream.c:421 ../gio/gunixinputstream.c:601
-#: ../gio/gunixoutputstream.c:407 ../gio/gunixoutputstream.c:556
+#: ../gio/gunixinputstream.c:421
+#: ../gio/gunixinputstream.c:601
+#: ../gio/gunixoutputstream.c:407
+#: ../gio/gunixoutputstream.c:556
 #, c-format
 msgid "Error closing unix: %s"
 msgstr "Feilved lukking av: %s"
 
-#: ../gio/gunixmounts.c:1900 ../gio/gunixmounts.c:1937
+#: ../gio/gunixmounts.c:1900
+#: ../gio/gunixmounts.c:1937
 msgid "Filesystem root"
 msgstr "Filsystemrot"
 
-#: ../gio/gunixoutputstream.c:353 ../gio/gunixoutputstream.c:374
+#: ../gio/gunixoutputstream.c:353
+#: ../gio/gunixoutputstream.c:374
 #: ../gio/gunixoutputstream.c:452
 #, c-format
 msgid "Error writing to unix: %s"
@@ -3751,7 +3818,8 @@ msgstr "Å laga assosiasjonar er ikkje støtta på win32"
 msgid "Error reading from handle: %s"
 msgstr "Feil ved lesing frå fila: %s"
 
-#: ../gio/gwin32inputstream.c:348 ../gio/gwin32outputstream.c:348
+#: ../gio/gwin32inputstream.c:348
+#: ../gio/gwin32outputstream.c:348
 #, fuzzy, c-format
 msgid "Error closing handle: %s"
 msgstr "Feil ved stenging av fila: %s"
@@ -3761,17 +3829,20 @@ msgstr "Feil ved stenging av fila: %s"
 msgid "Error writing to handle: %s"
 msgstr "Feil ved skriving til fila: %s"
 
-#: ../gio/gzlibcompressor.c:396 ../gio/gzlibdecompressor.c:349
+#: ../gio/gzlibcompressor.c:396
+#: ../gio/gzlibdecompressor.c:349
 #, fuzzy
 msgid "Not enough memory"
 msgstr "tom for minne"
 
-#: ../gio/gzlibcompressor.c:403 ../gio/gzlibdecompressor.c:356
+#: ../gio/gzlibcompressor.c:403
+#: ../gio/gzlibdecompressor.c:356
 #, fuzzy, c-format
 msgid "Internal error: %s"
 msgstr "intern feil"
 
-#: ../gio/gzlibcompressor.c:416 ../gio/gzlibdecompressor.c:370
+#: ../gio/gzlibcompressor.c:416
+#: ../gio/gzlibdecompressor.c:370
 msgid "Need more input"
 msgstr ""
 
