From 3fb80b26cc67e40353c07606ea32c6963f428537 Mon Sep 17 00:00:00 2001
From: Thierry Reding <thierry.reding@avionic-design.de>
Date: Wed, 10 Aug 2011 08:23:42 +0200
Subject: [PATCH] Add autotools-based build system.

---
 Makefile.am              |   43 +++
 autogen.sh               |   13 +
 configure.ac             |   51 +++
 m4/docbook.m4            |   61 ++++
 talloc.3.xml             |  801 ---------------------------------------------
 talloc.3.xml.in          |  813 ++++++++++++++++++++++++++++++++++++++++++++++
 talloc.pc.in             |    8 +-
 xsl/catalog.xml.in       |   18 +
 xsl/manpages/docbook.xsl |    8 +
 9 files changed, 1011 insertions(+), 805 deletions(-)
 create mode 100644 Makefile.am
 create mode 100755 autogen.sh
 create mode 100644 configure.ac
 create mode 100644 m4/docbook.m4
 delete mode 100644 talloc.3.xml
 create mode 100644 talloc.3.xml.in
 create mode 100644 xsl/catalog.xml.in
 create mode 100644 xsl/manpages/docbook.xsl

diff --git a/Makefile.am b/Makefile.am
new file mode 100644
index 0000000..51c3482
--- /dev/null
+++ b/Makefile.am
@@ -0,0 +1,43 @@
+ACLOCAL_AMFLAGS = -I m4
+
+include_HEADERS = \
+	talloc.h
+
+lib_LTLIBRARIES = \
+	libtalloc.la
+
+libtalloc_la_CPPFLAGS = \
+	-I$(top_srcdir)/lib/replace
+
+libtalloc_la_SOURCES = \
+	lib/replace/replace.h \
+	talloc.c
+
+libtalloc_la_LDFLAGS = -version-info @VERSION_INFO@
+
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = \
+	talloc.pc
+
+XSLTPROC_FLAGS = @XSLTPROC_FLAGS@ \
+	--param man.charmap.use.subset 0 \
+	--param make.year.ranges 1 \
+	--param make.single.year.ranges 1
+STYLESHEET = $(srcdir)/xsl/manpages/docbook.xsl
+
+if HAVE_XSLTPROC
+man3_MANS = \
+	talloc.3
+
+%: %.xml
+	$(AM_V_GEN)$(XSLTPROC) $(XSLTPROC_FLAGS) $(STYLESHEET) $<
+endif
+
+BUILT_SOURCES = \
+	$(man3_MANS)
+
+EXTRA_DIST = \
+	$(STYLESHEET)
+
+CLEANFILES = \
+	$(BUILT_SOURCES)
diff --git a/autogen.sh b/autogen.sh
new file mode 100755
index 0000000..86f382e
--- /dev/null
+++ b/autogen.sh
@@ -0,0 +1,13 @@
+#!/bin/sh
+
+srcdir=`dirname $0`
+test -z "$srcdir" && srcdir=.
+
+ORIGDIR=`pwd`
+cd $srcdir
+
+test -d m4 || mkdir m4
+autoreconf -v --install || exit 1
+cd $ORIGDIR || exit $?
+
+$srcdir/configure --enable-maintainer-mode "$@"
diff --git a/configure.ac b/configure.ac
new file mode 100644
index 0000000..429f9c0
--- /dev/null
+++ b/configure.ac
@@ -0,0 +1,51 @@
+AC_PREREQ(2.65)
+AC_INIT([talloc], [2.0.5], [], [talloc])
+AC_CONFIG_MACRO_DIR([m4])
+AC_CONFIG_SRCDIR([Makefile.am])
+AC_CONFIG_HEADER([config.h])
+AC_CANONICAL_HOST
+
+AM_INIT_AUTOMAKE([dist-bzip2 dist-xz foreign])
+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
+AM_MAINTAINER_MODE
+
+AC_PROG_LIBTOOL
+AC_PROG_CC
+AM_PROG_CC_C_O
+AC_PROG_INSTALL
+AX_CHECK_DOCBOOK
+
+LT_INIT
+VERSION_INFO=2:5:0
+AC_SUBST(VERSION_INFO)
+
+AC_CHECK_FUNCS([strdup strerror strnlen strtok_r vsnprintf])
+AC_CHECK_TYPES([intptr_t, ptrdiff_t, uintptr_t])
+
+AS_IF([test "x$ac_cv_func_vsnprintf" = "xyes"], [
+	AC_DEFINE(HAVE_C99_VSNPRINTF, 1, [Define to 1 if vsnprintf() is C99 compliant])
+])
+
+AC_CACHE_CHECK([for va_copy], ac_cv_va_copy, [
+	AC_TRY_LINK([#include <stdarg.h>],
+		[va_list ap1, ap2; va_copy(ap1, ap2);],
+		[ac_cv_va_copy=yes],
+		[ac_cv_va_copy=no])])
+AS_IF([test "x$ac_cv_va_copy" = "xyes"],
+	[AC_DEFINE(HAVE_VA_COPY, 1, [Define if va_copy() is available])])
+
+CFLAGS="$CFLAGS -Wall"
+
+AC_ARG_ENABLE([werror],
+	[AS_HELP_STRING([--enable-werror],
+		[Treat warnings as errors (default: enabled)])],
+		[enable_werror="$enableval"],
+		[enable_werror=yes])
+AS_IF([test "x$enable_werror" = "xyes"], [CFLAGS="$CFLAGS -Werror"])
+
+AC_OUTPUT([
+	Makefile
+	talloc.pc
+	talloc.3.xml
+	xsl/catalog.xml
+])
diff --git a/m4/docbook.m4 b/m4/docbook.m4
new file mode 100644
index 0000000..9d1f832
--- /dev/null
+++ b/m4/docbook.m4
@@ -0,0 +1,61 @@
+AC_DEFUN([AX_CHECK_DOCBOOK], [
+	DOCBOOK_SGML=/usr/share/sgml/docbook
+	XSLTPROC_FLAGS=--nonet
+	XML_CATALOG=
+	DOCBOOK_ROOT=
+	NEXT_CAT_ENTRY_START=
+	NEXT_CAT_ENTRY_END=
+	CAT_ENTRY_START=
+	CAT_ENTRY_END=
+
+	AC_MSG_CHECKING([for XML catalog])
+
+	if test ! -f /etc/xml/catalog; then
+		NEXT_CAT_ENTRY_START='<!--'
+		NEXT_CAT_ENTRY_END='-->'
+		AC_MSG_RESULT([not found])
+
+		AC_MSG_CHECKING([for docbook root])
+
+		for i in $DOCBOOK_SGML/xsl-stylesheets $DOCBOOK_SGML/stylesheet/xsl; do
+			if test -d "$i"; then
+				DOCBOOK_ROOT=$i
+			fi
+		done
+
+		if test -z "$DOCBOOK_ROOT"; then
+			AC_MSG_RESULT([not found])
+			CAT_ENTRY_START='<!--'
+			CAT_ENTRY_END='-->'
+			XSLTPROC_FLAGS=
+		else
+			AC_MSG_RESULT([$DOCBOOK_ROOT])
+		fi
+	else
+		XML_CATALOG=/etc/xml/catalog
+		CAT_ENTRY_START='<!--'
+		CAT_ENTRY_END='-->'
+
+		AC_MSG_RESULT([$XML_CATALOG])
+	fi
+
+	AC_SUBST(XSLTPROC_FLAGS)
+	AC_SUBST(XML_CATALOG)
+	AC_SUBST(DOCBOOK_ROOT)
+	AC_SUBST(NEXT_CAT_ENTRY_START)
+	AC_SUBST(NEXT_CAT_ENTRY_END)
+	AC_SUBST(CAT_ENTRY_START)
+	AC_SUBST(CAT_ENTRY_END)
+
+	AC_CHECK_PROG(XSLTPROC, xsltproc, xsltproc, no)
+	AM_CONDITIONAL(HAVE_XSLTPROC, test "x$XSLTPROC" != "xno")
+	AC_CHECK_PROG(XMLROFF, xmlroff, xmlroff, no)
+	AM_CONDITIONAL(HAVE_XMLROFF, test "x$XMLROFF" != "xno")
+
+	if test "x$XMLROFF" = "xno"; then
+		AC_CHECK_PROG(FOP, fop, fop, no)
+		AM_CONDITIONAL(HAVE_FOP, test "x$FOP" != "xno")
+	else
+		AM_CONDITIONAL(HAVE_FOP, false)
+	fi
+])
diff --git a/talloc.3.xml b/talloc.3.xml
deleted file mode 100644
index 99e8bcd..0000000
--- a/talloc.3.xml
+++ /dev/null
@@ -1,801 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
-<refentry>
-  <refmeta>
-    <refentrytitle>talloc</refentrytitle>
-    <manvolnum>3</manvolnum>
-  </refmeta>
-  <refnamediv>
-    <refname>talloc</refname>
-<refpurpose>hierarchical reference counted memory pool system with destructors</refpurpose>
-  </refnamediv>
-  <refsynopsisdiv>
-<synopsis>#include &lt;talloc.h&gt;</synopsis>
-  </refsynopsisdiv>
-  <refsect1><title>DESCRIPTION</title>
-    <para>
-      If you are used to talloc from Samba3 then please read this
-      carefully, as talloc has changed a lot.
-    </para>
-    <para>
-      The new talloc is a hierarchical, reference counted memory pool
-      system with destructors.	Quite a mouthful really, but not too bad
-      once you get used to it.
-    </para>
-    <para>
-      Perhaps the biggest change from Samba3 is that there is no
-      distinction between a "talloc context" and a "talloc pointer".  Any
-      pointer returned from talloc() is itself a valid talloc context. 
-      This means you can do this:
-    </para>
-    <programlisting>
-    struct foo *X = talloc(mem_ctx, struct foo);
-    X->name = talloc_strdup(X, "foo");
-    </programlisting>
-    <para>
-      and the pointer <literal role="code">X-&gt;name</literal>
-      would be a "child" of the talloc context <literal
-      role="code">X</literal> which is itself a child of
-      <literal role="code">mem_ctx</literal>.  So if you do
-      <literal role="code">talloc_free(mem_ctx)</literal> then
-      it is all destroyed, whereas if you do <literal
-      role="code">talloc_free(X)</literal> then just <literal
-      role="code">X</literal> and <literal
-      role="code">X-&gt;name</literal> are destroyed, and if
-      you do <literal
-      role="code">talloc_free(X-&gt;name)</literal> then just
-      the name element of <literal role="code">X</literal> is
-      destroyed.
-    </para>
-    <para>
-      If you think about this, then what this effectively gives you is an
-      n-ary tree, where you can free any part of the tree with
-      talloc_free().
-    </para>
-    <para>
-      If you find this confusing, then I suggest you run the <literal
-      role="code">testsuite</literal> program to watch talloc
-      in action.  You may also like to add your own tests to <literal
-      role="code">testsuite.c</literal> to clarify how some
-      particular situation is handled.
-    </para>
-  </refsect1>
-  <refsect1><title>TALLOC API</title>
-    <para>
-      The following is a complete guide to the talloc API. Read it all at
-      least twice.
-    </para>
-    <refsect2><title>(type *)talloc(const void *ctx, type);</title>
-        <para>
-	  The talloc() macro is the core of the talloc library.  It takes a
-	  memory <emphasis role="italic">ctx</emphasis> and a <emphasis
-	  role="italic">type</emphasis>, and returns a pointer to a new
-	  area of memory of the given <emphasis
-	  role="italic">type</emphasis>.
-        </para>
-        <para>
-	  The returned pointer is itself a talloc context, so you can use
-	  it as the <emphasis role="italic">ctx</emphasis> argument to more
-	  calls to talloc() if you wish.
-        </para>
-        <para>
-	  The returned pointer is a "child" of the supplied context.  This
-	  means that if you talloc_free() the <emphasis
-	  role="italic">ctx</emphasis> then the new child disappears as
-	  well.  Alternatively you can free just the child.
-        </para>
-        <para>
-	  The <emphasis role="italic">ctx</emphasis> argument to talloc()
-	  can be NULL, in which case a new top level context is created.
-        </para>
-    </refsect2>
-    <refsect2><title>void *talloc_size(const void *ctx, size_t size);</title>
-        <para>
-	  The function talloc_size() should be used when you don't have a
-	  convenient type to pass to talloc().	Unlike talloc(), it is not
-	  type safe (as it returns a void *), so you are on your own for
-	  type checking.
-        </para>
-    </refsect2>
-    <refsect2><title>(typeof(ptr)) talloc_ptrtype(const void *ctx, ptr);</title>
-        <para>
-	  The talloc_ptrtype() macro should be used when you have a pointer and
-	  want to allocate memory to point at with this pointer. When compiling
-	  with gcc >= 3 it is typesafe. Note this is a wrapper of talloc_size()
-	  and talloc_get_name() will return the current location in the source file.
-	  and not the type.
-        </para>
-    </refsect2>
-    <refsect2><title>int talloc_free(void *ptr);</title>
-        <para>
-	  The talloc_free() function frees a piece of talloc memory, and
-	  all its children.  You can call talloc_free() on any pointer
-	  returned by talloc().
-        </para>
-        <para>
-	  The return value of talloc_free() indicates success or failure,
-	  with 0 returned for success and -1 for failure.  The only
-	  possible failure condition is if <emphasis
-	  role="italic">ptr</emphasis> had a destructor attached to it and
-	  the destructor returned -1.  See <link
-	  linkend="talloc_set_destructor"><quote>talloc_set_destructor()</quote></link>
-	  for details on destructors.
-        </para>
-        <para>
-	  If this pointer has an additional parent when talloc_free() is
-	  called then the memory is not actually released, but instead the
-	  most recently established parent is destroyed.  See <link
-	  linkend="talloc_reference"><quote>talloc_reference()</quote></link>
-	  for details on establishing additional parents.
-        </para>
-        <para>
-	  For more control on which parent is removed, see <link
-	  linkend="talloc_unlink"><quote>talloc_unlink()</quote></link>.
-        </para>
-        <para>
-	  talloc_free() operates recursively on its children.
-        </para>
-	<para>
-	  From the 2.0 version of talloc, as a special case,
-	  talloc_free() is refused on pointers that have more than one
-	  parent, as talloc would have no way of knowing which parent
-	  should be removed. To free a pointer that has more than one
-	  parent please use talloc_unlink().
-	</para>
-	<para>
-	  To help you find problems in your code caused by this behaviour, if
-	  you do try and free a pointer with more than one parent then the
-	  talloc logging function will be called to give output like this:
-	</para>
-	<para>
-	  <screen format="linespecific">
-	    ERROR: talloc_free with references at some_dir/source/foo.c:123
-  	  	reference at some_dir/source/other.c:325
-  	  	reference at some_dir/source/third.c:121
-	  </screen>
-	</para>
-	<para>
-	  Please see the documentation for talloc_set_log_fn() and
-	  talloc_set_log_stderr() for more information on talloc logging
-	  functions.
-	</para>
-    </refsect2>
-    <refsect2 id="talloc_reference"><title>void *talloc_reference(const void *ctx, const void *ptr);</title>
-        <para>
-	  The talloc_reference() function makes <emphasis
-	  role="italic">ctx</emphasis> an additional parent of <emphasis
-	  role="italic">ptr</emphasis>.
-        </para>
-        <para>
-	  The return value of talloc_reference() is always the original
-	  pointer <emphasis role="italic">ptr</emphasis>, unless talloc ran
-	  out of memory in creating the reference in which case it will
-	  return NULL (each additional reference consumes around 48 bytes
-	  of memory on intel x86 platforms).
-        </para>
-        <para>
-	  If <emphasis role="italic">ptr</emphasis> is NULL, then the
-	  function is a no-op, and simply returns NULL.
-        </para>
-        <para>
-	  After creating a reference you can free it in one of the
-	  following ways:
-        </para>
-      <para>
-        <itemizedlist>
-          <listitem>
-            <para>
-	      you can talloc_free() any parent of the original pointer. 
-	      That will reduce the number of parents of this pointer by 1,
-	      and will cause this pointer to be freed if it runs out of
-	      parents.
-            </para>
-          </listitem>
-          <listitem>
-            <para>
-	      you can talloc_free() the pointer itself.  That will destroy
-	      the most recently established parent to the pointer and leave
-	      the pointer as a child of its current parent.
-            </para>
-          </listitem>
-        </itemizedlist>
-      </para>
-      <para>
-	For more control on which parent to remove, see <link
-	linkend="talloc_unlink"><quote>talloc_unlink()</quote></link>.
-      </para>
-    </refsect2>
-    <refsect2 id="talloc_unlink"><title>int talloc_unlink(const void *ctx, const void *ptr);</title>
-        <para>
-	  The talloc_unlink() function removes a specific parent from
-	  <emphasis role="italic">ptr</emphasis>. The <emphasis
-	  role="italic">ctx</emphasis> passed must either be a context used
-	  in talloc_reference() with this pointer, or must be a direct
-	  parent of ptr.
-        </para>
-        <para>
-	  Note that if the parent has already been removed using
-	  talloc_free() then this function will fail and will return -1. 
-	  Likewise, if <emphasis role="italic">ptr</emphasis> is NULL, then
-	  the function will make no modifications and return -1.
-        </para>
-        <para>
-	  Usually you can just use talloc_free() instead of
-	  talloc_unlink(), but sometimes it is useful to have the
-	  additional control on which parent is removed.
-        </para>
-    </refsect2>
-    <refsect2 id="talloc_set_destructor"><title>void talloc_set_destructor(const void *ptr, int (*destructor)(void *));</title>
-        <para>
-	  The function talloc_set_destructor() sets the <emphasis
-	  role="italic">destructor</emphasis> for the pointer <emphasis
-	  role="italic">ptr</emphasis>.  A <emphasis
-	  role="italic">destructor</emphasis> is a function that is called
-	  when the memory used by a pointer is about to be released.  The
-	  destructor receives <emphasis role="italic">ptr</emphasis> as an
-	  argument, and should return 0 for success and -1 for failure.
-        </para>
-        <para>
-	  The <emphasis role="italic">destructor</emphasis> can do anything
-	  it wants to, including freeing other pieces of memory.  A common
-	  use for destructors is to clean up operating system resources
-	  (such as open file descriptors) contained in the structure the
-	  destructor is placed on.
-        </para>
-        <para>
-	  You can only place one destructor on a pointer.  If you need more
-	  than one destructor then you can create a zero-length child of
-	  the pointer and place an additional destructor on that.
-        </para>
-        <para>
-	  To remove a destructor call talloc_set_destructor() with NULL for
-	  the destructor.
-        </para>
-        <para>
-	  If your destructor attempts to talloc_free() the pointer that it
-	  is the destructor for then talloc_free() will return -1 and the
-	  free will be ignored.  This would be a pointless operation
-	  anyway, as the destructor is only called when the memory is just
-	  about to go away.
-        </para>
-    </refsect2>
-    <refsect2><title>int talloc_increase_ref_count(const void *<emphasis role="italic">ptr</emphasis>);</title>
-        <para>
-	  The talloc_increase_ref_count(<emphasis
-	  role="italic">ptr</emphasis>) function is exactly equivalent to:
-        </para>
-        <programlisting>talloc_reference(NULL, ptr);</programlisting>
-        <para>
-	  You can use either syntax, depending on which you think is
-	  clearer in your code.
-        </para>
-        <para>
-	  It returns 0 on success and -1 on failure.
-        </para>
-    </refsect2>
-    <refsect2><title>size_t talloc_reference_count(const void *<emphasis role="italic">ptr</emphasis>);</title>
-        <para>
-	  Return the number of references to the pointer.
-        </para>
-    </refsect2>
-    <refsect2 id="talloc_set_name"><title>void talloc_set_name(const void *ptr, const char *fmt, ...);</title>
-        <para>
-	  Each talloc pointer has a "name".  The name is used principally
-	  for debugging purposes, although it is also possible to set and
-	  get the name on a pointer in as a way of "marking" pointers in
-	  your code.
-        </para>
-        <para>
-	  The main use for names on pointer is for "talloc reports".  See
-	  <link
-	  linkend="talloc_report"><quote>talloc_report_depth_cb()</quote></link>,
-	  <link
-	  linkend="talloc_report"><quote>talloc_report_depth_file()</quote></link>,
-	  <link
-	  linkend="talloc_report"><quote>talloc_report()</quote></link>
-	  <link
-	  linkend="talloc_report"><quote>talloc_report()</quote></link>
-	  and <link
-	  linkend="talloc_report_full"><quote>talloc_report_full()</quote></link>
-	  for details.	Also see <link
-	  linkend="talloc_enable_leak_report"><quote>talloc_enable_leak_report()</quote></link>
-	  and <link
-	  linkend="talloc_enable_leak_report_full"><quote>talloc_enable_leak_report_full()</quote></link>.
-        </para>
-        <para>
-	  The talloc_set_name() function allocates memory as a child of the
-	  pointer.  It is logically equivalent to:
-        </para>
-        <programlisting>talloc_set_name_const(ptr, talloc_asprintf(ptr, fmt, ...));</programlisting>
-        <para>
-	  Note that multiple calls to talloc_set_name() will allocate more
-	  memory without releasing the name.  All of the memory is released
-	  when the ptr is freed using talloc_free().
-        </para>
-    </refsect2>
-    <refsect2><title>void talloc_set_name_const(const void *<emphasis role="italic">ptr</emphasis>, const char *<emphasis role="italic">name</emphasis>);</title>
-        <para>
-	  The function talloc_set_name_const() is just like
-	  talloc_set_name(), but it takes a string constant, and is much
-	  faster.  It is extensively used by the "auto naming" macros, such
-	  as talloc_p().
-        </para>
-        <para>
-	  This function does not allocate any memory.  It just copies the
-	  supplied pointer into the internal representation of the talloc
-	  ptr. This means you must not pass a <emphasis
-	  role="italic">name</emphasis> pointer to memory that will
-	  disappear before <emphasis role="italic">ptr</emphasis> is freed
-	  with talloc_free().
-        </para>
-    </refsect2>
-    <refsect2><title>void *talloc_named(const void *<emphasis role="italic">ctx</emphasis>, size_t <emphasis role="italic">size</emphasis>, const char *<emphasis role="italic">fmt</emphasis>, ...);</title>
-        <para>
-	  The talloc_named() function creates a named talloc pointer.  It
-	  is equivalent to:
-        </para>
-        <programlisting>ptr = talloc_size(ctx, size);
-talloc_set_name(ptr, fmt, ....);</programlisting>
-    </refsect2>
-    <refsect2><title>void *talloc_named_const(const void *<emphasis role="italic">ctx</emphasis>, size_t <emphasis role="italic">size</emphasis>, const char *<emphasis role="italic">name</emphasis>);</title>
-        <para>
-	  This is equivalent to:
-        </para>
-        <programlisting>ptr = talloc_size(ctx, size);
-talloc_set_name_const(ptr, name);</programlisting>
-    </refsect2>
-    <refsect2><title>const char *talloc_get_name(const void *<emphasis role="italic">ptr</emphasis>);</title>
-        <para>
-	  This returns the current name for the given talloc pointer,
-	  <emphasis role="italic">ptr</emphasis>. See <link
-	  linkend="talloc_set_name"><quote>talloc_set_name()</quote></link>
-	  for details.
-        </para>
-    </refsect2>
-    <refsect2><title>void *talloc_init(const char *<emphasis role="italic">fmt</emphasis>, ...);</title>
-        <para>
-	  This function creates a zero length named talloc context as a top
-	  level context.  It is equivalent to:
-        </para>
-        <programlisting>talloc_named(NULL, 0, fmt, ...);</programlisting>
-    </refsect2>
-    <refsect2><title>void *talloc_new(void *<emphasis role="italic">ctx</emphasis>);</title>
-        <para>
-	  This is a utility macro that creates a new memory context hanging
-	  off an existing context, automatically naming it "talloc_new:
-	  __location__" where __location__ is the source line it is called
-	  from.  It is particularly useful for creating a new temporary
-	  working context.
-        </para>
-    </refsect2>
-    <refsect2><title>(<emphasis role="italic">type</emphasis> *)talloc_realloc(const void *<emphasis role="italic">ctx</emphasis>, void *<emphasis role="italic">ptr</emphasis>, <emphasis role="italic">type</emphasis>, <emphasis role="italic">count</emphasis>);</title>
-        <para>
-	  The talloc_realloc() macro changes the size of a talloc pointer. 
-	  It has the following equivalences:
-        </para>
-        <programlisting>talloc_realloc(ctx, NULL, type, 1) ==> talloc(ctx, type);
-talloc_realloc(ctx, ptr, type, 0)  ==> talloc_free(ptr);</programlisting>
-        <para>
-	  The <emphasis role="italic">ctx</emphasis> argument is only used
-	  if <emphasis role="italic">ptr</emphasis> is not NULL, otherwise
-	  it is ignored.
-        </para>
-        <para>
-	  talloc_realloc() returns the new pointer, or NULL on failure. 
-	  The call will fail either due to a lack of memory, or because the
-	  pointer has more than one parent (see <link
-	  linkend="talloc_reference"><quote>talloc_reference()</quote></link>).
-        </para>
-    </refsect2>
-    <refsect2><title>void *talloc_realloc_size(const void *ctx, void *ptr, size_t size);</title>
-        <para>
-	  the talloc_realloc_size() function is useful when the type is not
-	  known so the type-safe talloc_realloc() cannot be used.
-        </para>
-    </refsect2>
-    <refsect2><title>TYPE *talloc_steal(const void *<emphasis role="italic">new_ctx</emphasis>, const TYPE *<emphasis role="italic">ptr</emphasis>);</title>
-        <para>
-	  The talloc_steal() function changes the parent context of a
-	  talloc pointer.  It is typically used when the context that the
-	  pointer is currently a child of is going to be freed and you wish
-	  to keep the memory for a longer time.
-        </para>
-        <para>
-	  The talloc_steal() function returns the pointer that you pass it.
-	   It does not have any failure modes.
-        </para>
-        <para>
-	  It is possible to produce loops in the parent/child
-	  relationship if you are not careful with talloc_steal().  No
-	  guarantees are provided as to your sanity or the safety of your
-	  data if you do this.
-        </para>
-        <para>
-	  Note that if you try and call talloc_steal() on a pointer that has
-	  more than one parent then the result is ambiguous. Talloc will choose
-	  to remove the parent that is currently indicated by talloc_parent()
-	  and replace it with the chosen parent. You will also get a message
-	  like this via the talloc logging functions:
-        </para>
-        <para>
-	  <screen format="linespecific">
-	  WARNING: talloc_steal with references at some_dir/source/foo.c:123
-  	  	reference at some_dir/source/other.c:325
-  	  	reference at some_dir/source/third.c:121
-	  </screen>
-        </para>
-        <para>
-	  To unambiguously change the parent of a pointer please see
-	  the
-	  function <link linkend="talloc_reference"><quote>talloc_reparent()</quote></link>. See
-	  the talloc_set_log_fn() documentation for more information
-	  on talloc logging.  
-	</para>
-    </refsect2>
-    <refsect2><title>TYPE *talloc_reparent(const void *<emphasis role="italic">old_parent</emphasis>, const void *<emphasis role="italic">new_parent</emphasis>, const TYPE *<emphasis role="italic">ptr</emphasis>);</title>
-        <para>
-	  The talloc_reparent() function changes the parent context of a talloc
-	  pointer. It is typically used when the context that the pointer is
-	  currently a child of is going to be freed and you wish to keep the
-	  memory for a longer time.
-        </para>
-        <para>
-	  The talloc_reparent() function returns the pointer that you pass it. It
-	  does not have any failure modes.
-        </para>
-        <para>
-	  The difference between talloc_reparent() and talloc_steal() is that
-	  talloc_reparent() can specify which parent you wish to change. This is
-	  useful when a pointer has multiple parents via references.
-        </para>
-    </refsect2>
-    <refsect2><title>TYPE *talloc_move(const void *<emphasis role="italic">new_ctx</emphasis>, TYPE **<emphasis role="italic">ptr</emphasis>);</title>
-        <para>
-	  The talloc_move() function is a wrapper around
-	  talloc_steal() which zeros the source pointer after the
-	  move. This avoids a potential source of bugs where a
-	  programmer leaves a pointer in two structures, and uses the
-	  pointer from the old structure after it has been moved to a
-	  new one.
-        </para>
-    </refsect2>
-    <refsect2><title>size_t talloc_total_size(const void *<emphasis role="italic">ptr</emphasis>);</title>
-        <para>
-	  The talloc_total_size() function returns the total size in bytes
-	  used by this pointer and all child pointers.	Mostly useful for
-	  debugging.
-        </para>
-        <para>
-	  Passing NULL is allowed, but it will only give a meaningful
-	  result if talloc_enable_leak_report() or
-	  talloc_enable_leak_report_full() has been called.
-        </para>
-    </refsect2>
-    <refsect2><title>size_t talloc_total_blocks(const void *<emphasis role="italic">ptr</emphasis>);</title>
-        <para>
-	  The talloc_total_blocks() function returns the total memory block
-	  count used by this pointer and all child pointers.  Mostly useful
-	  for debugging.
-        </para>
-        <para>
-	  Passing NULL is allowed, but it will only give a meaningful
-	  result if talloc_enable_leak_report() or
-	  talloc_enable_leak_report_full() has been called.
-        </para>
-    </refsect2>
-    <refsect2 id="talloc_report"><title>void talloc_report(const void *ptr, FILE *f);</title>
-        <para>
-	  The talloc_report() function prints a summary report of all
-	  memory used by <emphasis role="italic">ptr</emphasis>.  One line
-	  of report is printed for each immediate child of ptr, showing the
-	  total memory and number of blocks used by that child.
-        </para>
-        <para>
-	  You can pass NULL for the pointer, in which case a report is
-	  printed for the top level memory context, but only if
-	  talloc_enable_leak_report() or talloc_enable_leak_report_full()
-	  has been called.
-        </para>
-    </refsect2>
-    <refsect2 id="talloc_report_full"><title>void talloc_report_full(const void *<emphasis role="italic">ptr</emphasis>, FILE *<emphasis role="italic">f</emphasis>);</title>
-        <para>
-	  This provides a more detailed report than talloc_report().  It
-	  will recursively print the entire tree of memory referenced by
-	  the pointer. References in the tree are shown by giving the name
-	  of the pointer that is referenced.
-        </para>
-        <para>
-	  You can pass NULL for the pointer, in which case a report is
-	  printed for the top level memory context, but only if
-	  talloc_enable_leak_report() or talloc_enable_leak_report_full()
-	  has been called.
-        </para>
-    </refsect2>
-    <refsect2 id="talloc_report_depth_cb">
-     <funcsynopsis><funcprototype>
-      <funcdef>void <function>talloc_report_depth_cb</function></funcdef>
-      <paramdef><parameter>const void *ptr</parameter></paramdef>
-      <paramdef><parameter>int depth</parameter></paramdef>
-      <paramdef><parameter>int max_depth</parameter></paramdef>
-      <paramdef><parameter>void (*callback)(const void *ptr, int depth, int max_depth, int is_ref, void *priv)</parameter></paramdef>
-      <paramdef><parameter>void *priv</parameter></paramdef>
-     </funcprototype></funcsynopsis>
-        <para>
-	  This provides a more flexible reports than talloc_report(). It
-	  will recursively call the callback for the entire tree of memory
-	  referenced by the pointer. References in the tree are passed with
-	  <emphasis role="italic">is_ref = 1</emphasis> and the pointer that is referenced.
-        </para>
-        <para>
-	  You can pass NULL for the pointer, in which case a report is
-	  printed for the top level memory context, but only if
-	  talloc_enable_leak_report() or talloc_enable_leak_report_full()
-	  has been called.
-        </para>
-        <para>
-	  The recursion is stopped when depth >= max_depth.
-	  max_depth = -1 means only stop at leaf nodes.
-        </para>
-    </refsect2>
-    <refsect2 id="talloc_report_depth_file">
-     <funcsynopsis><funcprototype>
-      <funcdef>void <function>talloc_report_depth_file</function></funcdef>
-      <paramdef><parameter>const void *ptr</parameter></paramdef>
-      <paramdef><parameter>int depth</parameter></paramdef>
-      <paramdef><parameter>int max_depth</parameter></paramdef>
-      <paramdef><parameter>FILE *f</parameter></paramdef>
-     </funcprototype></funcsynopsis>
-        <para>
-	  This provides a more flexible reports than talloc_report(). It
-	  will let you specify the depth and max_depth.
-        </para>
-    </refsect2>
-    <refsect2 id="talloc_enable_leak_report"><title>void talloc_enable_leak_report(void);</title>
-        <para>
-	  This enables calling of talloc_report(NULL, stderr) when the
-	  program exits.  In Samba4 this is enabled by using the
-	  --leak-report command line option.
-        </para>
-        <para>
-	  For it to be useful, this function must be called before any
-	  other talloc function as it establishes a "null context" that
-	  acts as the top of the tree.	If you don't call this function
-	  first then passing NULL to talloc_report() or
-	  talloc_report_full() won't give you the full tree printout.
-        </para>
-        <para>
-	  Here is a typical talloc report:
-        </para>
-        <screen format="linespecific">talloc report on 'null_context' (total 267 bytes in 15 blocks)
-libcli/auth/spnego_parse.c:55  contains   31 bytes in   2 blocks
-libcli/auth/spnego_parse.c:55  contains   31 bytes in   2 blocks
-iconv(UTF8,CP850)              contains   42 bytes in   2 blocks
-libcli/auth/spnego_parse.c:55  contains   31 bytes in   2 blocks
-iconv(CP850,UTF8)              contains   42 bytes in   2 blocks
-iconv(UTF8,UTF-16LE)           contains   45 bytes in   2 blocks
-iconv(UTF-16LE,UTF8)           contains   45 bytes in   2 blocks
-      </screen>
-    </refsect2>
-    <refsect2 id="talloc_enable_leak_report_full"><title>void talloc_enable_leak_report_full(void);</title>
-        <para>
-	  This enables calling of talloc_report_full(NULL, stderr) when the
-	  program exits.  In Samba4 this is enabled by using the
-	  --leak-report-full command line option.
-        </para>
-        <para>
-	  For it to be useful, this function must be called before any
-	  other talloc function as it establishes a "null context" that
-	  acts as the top of the tree.	If you don't call this function
-	  first then passing NULL to talloc_report() or
-	  talloc_report_full() won't give you the full tree printout.
-        </para>
-        <para>
-	  Here is a typical full report:
-        </para>
-        <screen format="linespecific">full talloc report on 'root' (total 18 bytes in 8 blocks)
-p1               contains     18 bytes in   7 blocks (ref 0)
-    r1               contains     13 bytes in   2 blocks (ref 0)
-        reference to: p2
-    p2               contains      1 bytes in   1 blocks (ref 1)
-    x3               contains      1 bytes in   1 blocks (ref 0)
-    x2               contains      1 bytes in   1 blocks (ref 0)
-    x1               contains      1 bytes in   1 blocks (ref 0)
-      </screen>
-    </refsect2>
-    <refsect2><title>(<emphasis role="italic">type</emphasis> *)talloc_zero(const void *<emphasis role="italic">ctx</emphasis>, <emphasis role="italic">type</emphasis>);</title>
-        <para>
-	  The talloc_zero() macro is equivalent to:
-        </para>
-        <programlisting>ptr = talloc(ctx, type);
-if (ptr) memset(ptr, 0, sizeof(type));</programlisting>
-    </refsect2>
-    <refsect2><title>void *talloc_zero_size(const void *<emphasis role="italic">ctx</emphasis>, size_t <emphasis role="italic">size</emphasis>)</title>
-        <para>
-	  The talloc_zero_size() function is useful when you don't have a
-	  known type.
-        </para>
-    </refsect2>
-    <refsect2><title>void *talloc_memdup(const void *<emphasis role="italic">ctx</emphasis>, const void *<emphasis role="italic">p</emphasis>, size_t size);</title>
-        <para>
-	  The talloc_memdup() function is equivalent to:
-        </para>
-        <programlisting>ptr = talloc_size(ctx, size);
-if (ptr) memcpy(ptr, p, size);</programlisting>
-    </refsect2>
-    <refsect2><title>char *talloc_strdup(const void *<emphasis role="italic">ctx</emphasis>, const char *<emphasis role="italic">p</emphasis>);</title>
-        <para>
-	  The talloc_strdup() function is equivalent to:
-        </para>
-        <programlisting>ptr = talloc_size(ctx, strlen(p)+1);
-if (ptr) memcpy(ptr, p, strlen(p)+1);</programlisting>
-        <para>
-	  This function sets the name of the new pointer to the passed
-	  string. This is equivalent to:
-        </para>
-        <programlisting>talloc_set_name_const(ptr, ptr)</programlisting>
-    </refsect2>
-    <refsect2><title>char *talloc_strndup(const void *<emphasis role="italic">t</emphasis>, const char *<emphasis role="italic">p</emphasis>, size_t <emphasis role="italic">n</emphasis>);</title>
-        <para>
-	  The talloc_strndup() function is the talloc equivalent of the C
-	  library function strndup(3).
-        </para>
-        <para>
-	  This function sets the name of the new pointer to the passed
-	  string. This is equivalent to:
-        </para>
-        <programlisting>talloc_set_name_const(ptr, ptr)</programlisting>
-    </refsect2>
-    <refsect2><title>char *talloc_vasprintf(const void *<emphasis role="italic">t</emphasis>, const char *<emphasis role="italic">fmt</emphasis>, va_list <emphasis role="italic">ap</emphasis>);</title>
-        <para>
-	  The talloc_vasprintf() function is the talloc equivalent of the C
-	  library function vasprintf(3).
-        </para>
-        <para>
-	  This function sets the name of the new pointer to the new
-	  string. This is equivalent to:
-        </para>
-        <programlisting>talloc_set_name_const(ptr, ptr)</programlisting>
-    </refsect2>
-    <refsect2><title>char *talloc_asprintf(const void *<emphasis role="italic">t</emphasis>, const char *<emphasis role="italic">fmt</emphasis>, ...);</title>
-        <para>
-	  The talloc_asprintf() function is the talloc equivalent of the C
-	  library function asprintf(3).
-        </para>
-        <para>
-	  This function sets the name of the new pointer to the passed
-	  string. This is equivalent to:
-        </para>
-        <programlisting>talloc_set_name_const(ptr, ptr)</programlisting>
-    </refsect2>
-    <refsect2><title>char *talloc_asprintf_append(char *s, const char *fmt, ...);</title>
-        <para>
-	  The talloc_asprintf_append() function appends the given formatted
-	  string to the given string.
-        </para>
-        <para>
-	  This function sets the name of the new pointer to the new
-	  string. This is equivalent to:
-        </para>
-        <programlisting>talloc_set_name_const(ptr, ptr)</programlisting>
-    </refsect2>
-    <refsect2><title>(type *)talloc_array(const void *ctx, type, unsigned int count);</title>
-        <para>
-	  The talloc_array() macro is equivalent to:
-        </para>
-        <programlisting>(type *)talloc_size(ctx, sizeof(type) * count);</programlisting>
-        <para>
-	  except that it provides integer overflow protection for the
-	  multiply, returning NULL if the multiply overflows.
-        </para>
-    </refsect2>
-    <refsect2><title>void *talloc_array_size(const void *ctx, size_t size, unsigned int count);</title>
-        <para>
-	  The talloc_array_size() function is useful when the type is not
-	  known. It operates in the same way as talloc_array(), but takes a
-	  size instead of a type.
-        </para>
-    </refsect2>
-    <refsect2><title>(typeof(ptr)) talloc_array_ptrtype(const void *ctx, ptr, unsigned int count);</title>
-        <para>
-	  The talloc_ptrtype() macro should be used when you have a pointer to an array
-	  and want to allocate memory of an array to point at with this pointer. When compiling
-	  with gcc >= 3 it is typesafe. Note this is a wrapper of talloc_array_size()
-	  and talloc_get_name() will return the current location in the source file.
-	  and not the type.
-        </para>
-    </refsect2>
-    <refsect2><title>void *talloc_realloc_fn(const void *ctx, void *ptr, size_t size)</title>
-        <para>
-	  This is a non-macro version of talloc_realloc(), which is useful
-	  as libraries sometimes want a realloc function pointer.  A
-	  realloc(3) implementation encapsulates the functionality of
-	  malloc(3), free(3) and realloc(3) in one call, which is why it is
-	  useful to be able to pass around a single function pointer.
-        </para>
-    </refsect2>
-    <refsect2><title>void *talloc_autofree_context(void);</title>
-        <para>
-	  This is a handy utility function that returns a talloc context
-	  which will be automatically freed on program exit.  This can be
-	  used to reduce the noise in memory leak reports.
-        </para>
-    </refsect2>
-    <refsect2><title>void *talloc_check_name(const void *ptr, const char *name);</title>
-        <para>
-	  This function checks if a pointer has the specified <emphasis
-	  role="italic">name</emphasis>.  If it does then the pointer is
-	  returned.  It it doesn't then NULL is returned.
-        </para>
-    </refsect2>
-    <refsect2><title>(type *)talloc_get_type(const void *ptr, type);</title>
-        <para>
-	  This macro allows you to do type checking on talloc pointers.  It
-	  is particularly useful for void* private pointers.  It is
-	  equivalent to this:
-        </para>
-        <programlisting>(type *)talloc_check_name(ptr, #type)</programlisting>
-    </refsect2>
-    <refsect2><title>talloc_set_type(const void *ptr, type);</title>
-        <para>
-	  This macro allows you to force the name of a pointer to be a
-	  particular <emphasis>type</emphasis>.  This can be
-	  used in conjunction with talloc_get_type() to do type checking on
-	  void* pointers.
-        </para>
-        <para>
-	  It is equivalent to this:
-        </para>
-        <programlisting>talloc_set_name_const(ptr, #type)</programlisting>
-    </refsect2>
-    <refsect2><title>talloc_set_log_fn(void (*log_fn)(const char *message));</title>
-        <para>
-	  This function sets a logging function that talloc will use for
-	  warnings and errors. By default talloc will not print any warnings or
-	  errors.
-	</para>
-    </refsect2>
-    <refsect2><title>talloc_set_log_stderr(void);</title>
-        <para>
-	  This sets the talloc log function to write log messages to stderr
-	</para>
-    </refsect2>
-  </refsect1>
-  <refsect1><title>PERFORMANCE</title>
-    <para>
-      All the additional features of talloc(3) over malloc(3) do come at a
-      price.  We have a simple performance test in Samba4 that measures
-      talloc() versus malloc() performance, and it seems that talloc() is
-      about 10% slower than malloc() on my x86 Debian Linux box.  For
-      Samba, the great reduction in code complexity that we get by using
-      talloc makes this worthwhile, especially as the total overhead of
-      talloc/malloc in Samba is already quite small.
-    </para>
-  </refsect1>
-  <refsect1><title>SEE ALSO</title>
-    <para>
-      malloc(3), strndup(3), vasprintf(3), asprintf(3), 
-      <ulink url="http://talloc.samba.org/"/>
-    </para>
-  </refsect1>
-  <refsect1><title>COPYRIGHT/LICENSE</title>
-    <para>
-      Copyright (C) Andrew Tridgell 2004
-    </para>
-    <para>
-      This program is free software; you can redistribute it and/or modify
-      it under the terms of the GNU Lesser General Public License as 
-      published by the Free Software Foundation; either version 3 of the
-      License, or (at your option) any later version.
-    </para>
-    <para>
-      This program is distributed in the hope that it will be useful, but
-      WITHOUT ANY WARRANTY; without even the implied warranty of
-      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-      General Public License for more details.
-    </para>
-    <para>
-      You should have received a copy of the GNU General Public License
-      along with this program; if not, see http://www.gnu.org/licenses/.
-    </para>
-  </refsect1>
-</refentry>
diff --git a/talloc.3.xml.in b/talloc.3.xml.in
new file mode 100644
index 0000000..ac6efe2
--- /dev/null
+++ b/talloc.3.xml.in
@@ -0,0 +1,813 @@
+<?xml version="1.0"?>
+<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
+<refentry>
+  <refentryinfo>
+    <title>talloc</title>
+    <productname>@PACKAGE@</productname>
+    <releaseinfo role="version">@VERSION@</releaseinfo>
+    <authorgroup>
+      <author>
+        <firstname>Andrew</firstname>
+        <surname>Tridgell</surname>
+        <contrib>Author</contrib>
+      </author>
+    </authorgroup>
+  </refentryinfo>
+  <refmeta>
+    <refentrytitle>talloc</refentrytitle>
+    <manvolnum>3</manvolnum>
+  </refmeta>
+  <refnamediv>
+    <refname>talloc</refname>
+<refpurpose>hierarchical reference counted memory pool system with destructors</refpurpose>
+  </refnamediv>
+  <refsynopsisdiv>
+<synopsis>#include &lt;talloc.h&gt;</synopsis>
+  </refsynopsisdiv>
+  <refsect1><title>DESCRIPTION</title>
+    <para>
+      If you are used to talloc from Samba3 then please read this
+      carefully, as talloc has changed a lot.
+    </para>
+    <para>
+      The new talloc is a hierarchical, reference counted memory pool
+      system with destructors.	Quite a mouthful really, but not too bad
+      once you get used to it.
+    </para>
+    <para>
+      Perhaps the biggest change from Samba3 is that there is no
+      distinction between a "talloc context" and a "talloc pointer".  Any
+      pointer returned from talloc() is itself a valid talloc context. 
+      This means you can do this:
+    </para>
+    <programlisting>
+    struct foo *X = talloc(mem_ctx, struct foo);
+    X->name = talloc_strdup(X, "foo");
+    </programlisting>
+    <para>
+      and the pointer <literal role="code">X-&gt;name</literal>
+      would be a "child" of the talloc context <literal
+      role="code">X</literal> which is itself a child of
+      <literal role="code">mem_ctx</literal>.  So if you do
+      <literal role="code">talloc_free(mem_ctx)</literal> then
+      it is all destroyed, whereas if you do <literal
+      role="code">talloc_free(X)</literal> then just <literal
+      role="code">X</literal> and <literal
+      role="code">X-&gt;name</literal> are destroyed, and if
+      you do <literal
+      role="code">talloc_free(X-&gt;name)</literal> then just
+      the name element of <literal role="code">X</literal> is
+      destroyed.
+    </para>
+    <para>
+      If you think about this, then what this effectively gives you is an
+      n-ary tree, where you can free any part of the tree with
+      talloc_free().
+    </para>
+    <para>
+      If you find this confusing, then I suggest you run the <literal
+      role="code">testsuite</literal> program to watch talloc
+      in action.  You may also like to add your own tests to <literal
+      role="code">testsuite.c</literal> to clarify how some
+      particular situation is handled.
+    </para>
+  </refsect1>
+  <refsect1><title>TALLOC API</title>
+    <para>
+      The following is a complete guide to the talloc API. Read it all at
+      least twice.
+    </para>
+    <refsect2><title>(type *)talloc(const void *ctx, type);</title>
+        <para>
+	  The talloc() macro is the core of the talloc library.  It takes a
+	  memory <emphasis role="italic">ctx</emphasis> and a <emphasis
+	  role="italic">type</emphasis>, and returns a pointer to a new
+	  area of memory of the given <emphasis
+	  role="italic">type</emphasis>.
+        </para>
+        <para>
+	  The returned pointer is itself a talloc context, so you can use
+	  it as the <emphasis role="italic">ctx</emphasis> argument to more
+	  calls to talloc() if you wish.
+        </para>
+        <para>
+	  The returned pointer is a "child" of the supplied context.  This
+	  means that if you talloc_free() the <emphasis
+	  role="italic">ctx</emphasis> then the new child disappears as
+	  well.  Alternatively you can free just the child.
+        </para>
+        <para>
+	  The <emphasis role="italic">ctx</emphasis> argument to talloc()
+	  can be NULL, in which case a new top level context is created.
+        </para>
+    </refsect2>
+    <refsect2><title>void *talloc_size(const void *ctx, size_t size);</title>
+        <para>
+	  The function talloc_size() should be used when you don't have a
+	  convenient type to pass to talloc().	Unlike talloc(), it is not
+	  type safe (as it returns a void *), so you are on your own for
+	  type checking.
+        </para>
+    </refsect2>
+    <refsect2><title>(typeof(ptr)) talloc_ptrtype(const void *ctx, ptr);</title>
+        <para>
+	  The talloc_ptrtype() macro should be used when you have a pointer and
+	  want to allocate memory to point at with this pointer. When compiling
+	  with gcc >= 3 it is typesafe. Note this is a wrapper of talloc_size()
+	  and talloc_get_name() will return the current location in the source file.
+	  and not the type.
+        </para>
+    </refsect2>
+    <refsect2><title>int talloc_free(void *ptr);</title>
+        <para>
+	  The talloc_free() function frees a piece of talloc memory, and
+	  all its children.  You can call talloc_free() on any pointer
+	  returned by talloc().
+        </para>
+        <para>
+	  The return value of talloc_free() indicates success or failure,
+	  with 0 returned for success and -1 for failure.  The only
+	  possible failure condition is if <emphasis
+	  role="italic">ptr</emphasis> had a destructor attached to it and
+	  the destructor returned -1.  See <link
+	  linkend="talloc_set_destructor"><quote>talloc_set_destructor()</quote></link>
+	  for details on destructors.
+        </para>
+        <para>
+	  If this pointer has an additional parent when talloc_free() is
+	  called then the memory is not actually released, but instead the
+	  most recently established parent is destroyed.  See <link
+	  linkend="talloc_reference"><quote>talloc_reference()</quote></link>
+	  for details on establishing additional parents.
+        </para>
+        <para>
+	  For more control on which parent is removed, see <link
+	  linkend="talloc_unlink"><quote>talloc_unlink()</quote></link>.
+        </para>
+        <para>
+	  talloc_free() operates recursively on its children.
+        </para>
+	<para>
+	  From the 2.0 version of talloc, as a special case,
+	  talloc_free() is refused on pointers that have more than one
+	  parent, as talloc would have no way of knowing which parent
+	  should be removed. To free a pointer that has more than one
+	  parent please use talloc_unlink().
+	</para>
+	<para>
+	  To help you find problems in your code caused by this behaviour, if
+	  you do try and free a pointer with more than one parent then the
+	  talloc logging function will be called to give output like this:
+	</para>
+	<para>
+	  <screen format="linespecific">
+	    ERROR: talloc_free with references at some_dir/source/foo.c:123
+  	  	reference at some_dir/source/other.c:325
+  	  	reference at some_dir/source/third.c:121
+	  </screen>
+	</para>
+	<para>
+	  Please see the documentation for talloc_set_log_fn() and
+	  talloc_set_log_stderr() for more information on talloc logging
+	  functions.
+	</para>
+    </refsect2>
+    <refsect2 id="talloc_reference"><title>void *talloc_reference(const void *ctx, const void *ptr);</title>
+        <para>
+	  The talloc_reference() function makes <emphasis
+	  role="italic">ctx</emphasis> an additional parent of <emphasis
+	  role="italic">ptr</emphasis>.
+        </para>
+        <para>
+	  The return value of talloc_reference() is always the original
+	  pointer <emphasis role="italic">ptr</emphasis>, unless talloc ran
+	  out of memory in creating the reference in which case it will
+	  return NULL (each additional reference consumes around 48 bytes
+	  of memory on intel x86 platforms).
+        </para>
+        <para>
+	  If <emphasis role="italic">ptr</emphasis> is NULL, then the
+	  function is a no-op, and simply returns NULL.
+        </para>
+        <para>
+	  After creating a reference you can free it in one of the
+	  following ways:
+        </para>
+      <para>
+        <itemizedlist>
+          <listitem>
+            <para>
+	      you can talloc_free() any parent of the original pointer. 
+	      That will reduce the number of parents of this pointer by 1,
+	      and will cause this pointer to be freed if it runs out of
+	      parents.
+            </para>
+          </listitem>
+          <listitem>
+            <para>
+	      you can talloc_free() the pointer itself.  That will destroy
+	      the most recently established parent to the pointer and leave
+	      the pointer as a child of its current parent.
+            </para>
+          </listitem>
+        </itemizedlist>
+      </para>
+      <para>
+	For more control on which parent to remove, see <link
+	linkend="talloc_unlink"><quote>talloc_unlink()</quote></link>.
+      </para>
+    </refsect2>
+    <refsect2 id="talloc_unlink"><title>int talloc_unlink(const void *ctx, const void *ptr);</title>
+        <para>
+	  The talloc_unlink() function removes a specific parent from
+	  <emphasis role="italic">ptr</emphasis>. The <emphasis
+	  role="italic">ctx</emphasis> passed must either be a context used
+	  in talloc_reference() with this pointer, or must be a direct
+	  parent of ptr.
+        </para>
+        <para>
+	  Note that if the parent has already been removed using
+	  talloc_free() then this function will fail and will return -1. 
+	  Likewise, if <emphasis role="italic">ptr</emphasis> is NULL, then
+	  the function will make no modifications and return -1.
+        </para>
+        <para>
+	  Usually you can just use talloc_free() instead of
+	  talloc_unlink(), but sometimes it is useful to have the
+	  additional control on which parent is removed.
+        </para>
+    </refsect2>
+    <refsect2 id="talloc_set_destructor"><title>void talloc_set_destructor(const void *ptr, int (*destructor)(void *));</title>
+        <para>
+	  The function talloc_set_destructor() sets the <emphasis
+	  role="italic">destructor</emphasis> for the pointer <emphasis
+	  role="italic">ptr</emphasis>.  A <emphasis
+	  role="italic">destructor</emphasis> is a function that is called
+	  when the memory used by a pointer is about to be released.  The
+	  destructor receives <emphasis role="italic">ptr</emphasis> as an
+	  argument, and should return 0 for success and -1 for failure.
+        </para>
+        <para>
+	  The <emphasis role="italic">destructor</emphasis> can do anything
+	  it wants to, including freeing other pieces of memory.  A common
+	  use for destructors is to clean up operating system resources
+	  (such as open file descriptors) contained in the structure the
+	  destructor is placed on.
+        </para>
+        <para>
+	  You can only place one destructor on a pointer.  If you need more
+	  than one destructor then you can create a zero-length child of
+	  the pointer and place an additional destructor on that.
+        </para>
+        <para>
+	  To remove a destructor call talloc_set_destructor() with NULL for
+	  the destructor.
+        </para>
+        <para>
+	  If your destructor attempts to talloc_free() the pointer that it
+	  is the destructor for then talloc_free() will return -1 and the
+	  free will be ignored.  This would be a pointless operation
+	  anyway, as the destructor is only called when the memory is just
+	  about to go away.
+        </para>
+    </refsect2>
+    <refsect2><title>int talloc_increase_ref_count(const void *<emphasis role="italic">ptr</emphasis>);</title>
+        <para>
+	  The talloc_increase_ref_count(<emphasis
+	  role="italic">ptr</emphasis>) function is exactly equivalent to:
+        </para>
+        <programlisting>talloc_reference(NULL, ptr);</programlisting>
+        <para>
+	  You can use either syntax, depending on which you think is
+	  clearer in your code.
+        </para>
+        <para>
+	  It returns 0 on success and -1 on failure.
+        </para>
+    </refsect2>
+    <refsect2><title>size_t talloc_reference_count(const void *<emphasis role="italic">ptr</emphasis>);</title>
+        <para>
+	  Return the number of references to the pointer.
+        </para>
+    </refsect2>
+    <refsect2 id="talloc_set_name"><title>void talloc_set_name(const void *ptr, const char *fmt, ...);</title>
+        <para>
+	  Each talloc pointer has a "name".  The name is used principally
+	  for debugging purposes, although it is also possible to set and
+	  get the name on a pointer in as a way of "marking" pointers in
+	  your code.
+        </para>
+        <para>
+	  The main use for names on pointer is for "talloc reports".  See
+	  <link
+	  linkend="talloc_report"><quote>talloc_report_depth_cb()</quote></link>,
+	  <link
+	  linkend="talloc_report"><quote>talloc_report_depth_file()</quote></link>,
+	  <link
+	  linkend="talloc_report"><quote>talloc_report()</quote></link>
+	  <link
+	  linkend="talloc_report"><quote>talloc_report()</quote></link>
+	  and <link
+	  linkend="talloc_report_full"><quote>talloc_report_full()</quote></link>
+	  for details.	Also see <link
+	  linkend="talloc_enable_leak_report"><quote>talloc_enable_leak_report()</quote></link>
+	  and <link
+	  linkend="talloc_enable_leak_report_full"><quote>talloc_enable_leak_report_full()</quote></link>.
+        </para>
+        <para>
+	  The talloc_set_name() function allocates memory as a child of the
+	  pointer.  It is logically equivalent to:
+        </para>
+        <programlisting>talloc_set_name_const(ptr, talloc_asprintf(ptr, fmt, ...));</programlisting>
+        <para>
+	  Note that multiple calls to talloc_set_name() will allocate more
+	  memory without releasing the name.  All of the memory is released
+	  when the ptr is freed using talloc_free().
+        </para>
+    </refsect2>
+    <refsect2><title>void talloc_set_name_const(const void *<emphasis role="italic">ptr</emphasis>, const char *<emphasis role="italic">name</emphasis>);</title>
+        <para>
+	  The function talloc_set_name_const() is just like
+	  talloc_set_name(), but it takes a string constant, and is much
+	  faster.  It is extensively used by the "auto naming" macros, such
+	  as talloc_p().
+        </para>
+        <para>
+	  This function does not allocate any memory.  It just copies the
+	  supplied pointer into the internal representation of the talloc
+	  ptr. This means you must not pass a <emphasis
+	  role="italic">name</emphasis> pointer to memory that will
+	  disappear before <emphasis role="italic">ptr</emphasis> is freed
+	  with talloc_free().
+        </para>
+    </refsect2>
+    <refsect2><title>void *talloc_named(const void *<emphasis role="italic">ctx</emphasis>, size_t <emphasis role="italic">size</emphasis>, const char *<emphasis role="italic">fmt</emphasis>, ...);</title>
+        <para>
+	  The talloc_named() function creates a named talloc pointer.  It
+	  is equivalent to:
+        </para>
+        <programlisting>ptr = talloc_size(ctx, size);
+talloc_set_name(ptr, fmt, ....);</programlisting>
+    </refsect2>
+    <refsect2><title>void *talloc_named_const(const void *<emphasis role="italic">ctx</emphasis>, size_t <emphasis role="italic">size</emphasis>, const char *<emphasis role="italic">name</emphasis>);</title>
+        <para>
+	  This is equivalent to:
+        </para>
+        <programlisting>ptr = talloc_size(ctx, size);
+talloc_set_name_const(ptr, name);</programlisting>
+    </refsect2>
+    <refsect2><title>const char *talloc_get_name(const void *<emphasis role="italic">ptr</emphasis>);</title>
+        <para>
+	  This returns the current name for the given talloc pointer,
+	  <emphasis role="italic">ptr</emphasis>. See <link
+	  linkend="talloc_set_name"><quote>talloc_set_name()</quote></link>
+	  for details.
+        </para>
+    </refsect2>
+    <refsect2><title>void *talloc_init(const char *<emphasis role="italic">fmt</emphasis>, ...);</title>
+        <para>
+	  This function creates a zero length named talloc context as a top
+	  level context.  It is equivalent to:
+        </para>
+        <programlisting>talloc_named(NULL, 0, fmt, ...);</programlisting>
+    </refsect2>
+    <refsect2><title>void *talloc_new(void *<emphasis role="italic">ctx</emphasis>);</title>
+        <para>
+	  This is a utility macro that creates a new memory context hanging
+	  off an existing context, automatically naming it "talloc_new:
+	  __location__" where __location__ is the source line it is called
+	  from.  It is particularly useful for creating a new temporary
+	  working context.
+        </para>
+    </refsect2>
+    <refsect2><title>(<emphasis role="italic">type</emphasis> *)talloc_realloc(const void *<emphasis role="italic">ctx</emphasis>, void *<emphasis role="italic">ptr</emphasis>, <emphasis role="italic">type</emphasis>, <emphasis role="italic">count</emphasis>);</title>
+        <para>
+	  The talloc_realloc() macro changes the size of a talloc pointer. 
+	  It has the following equivalences:
+        </para>
+        <programlisting>talloc_realloc(ctx, NULL, type, 1) ==> talloc(ctx, type);
+talloc_realloc(ctx, ptr, type, 0)  ==> talloc_free(ptr);</programlisting>
+        <para>
+	  The <emphasis role="italic">ctx</emphasis> argument is only used
+	  if <emphasis role="italic">ptr</emphasis> is not NULL, otherwise
+	  it is ignored.
+        </para>
+        <para>
+	  talloc_realloc() returns the new pointer, or NULL on failure. 
+	  The call will fail either due to a lack of memory, or because the
+	  pointer has more than one parent (see <link
+	  linkend="talloc_reference"><quote>talloc_reference()</quote></link>).
+        </para>
+    </refsect2>
+    <refsect2><title>void *talloc_realloc_size(const void *ctx, void *ptr, size_t size);</title>
+        <para>
+	  the talloc_realloc_size() function is useful when the type is not
+	  known so the type-safe talloc_realloc() cannot be used.
+        </para>
+    </refsect2>
+    <refsect2><title>TYPE *talloc_steal(const void *<emphasis role="italic">new_ctx</emphasis>, const TYPE *<emphasis role="italic">ptr</emphasis>);</title>
+        <para>
+	  The talloc_steal() function changes the parent context of a
+	  talloc pointer.  It is typically used when the context that the
+	  pointer is currently a child of is going to be freed and you wish
+	  to keep the memory for a longer time.
+        </para>
+        <para>
+	  The talloc_steal() function returns the pointer that you pass it.
+	   It does not have any failure modes.
+        </para>
+        <para>
+	  It is possible to produce loops in the parent/child
+	  relationship if you are not careful with talloc_steal().  No
+	  guarantees are provided as to your sanity or the safety of your
+	  data if you do this.
+        </para>
+        <para>
+	  Note that if you try and call talloc_steal() on a pointer that has
+	  more than one parent then the result is ambiguous. Talloc will choose
+	  to remove the parent that is currently indicated by talloc_parent()
+	  and replace it with the chosen parent. You will also get a message
+	  like this via the talloc logging functions:
+        </para>
+        <para>
+	  <screen format="linespecific">
+	  WARNING: talloc_steal with references at some_dir/source/foo.c:123
+  	  	reference at some_dir/source/other.c:325
+  	  	reference at some_dir/source/third.c:121
+	  </screen>
+        </para>
+        <para>
+	  To unambiguously change the parent of a pointer please see
+	  the
+	  function <link linkend="talloc_reference"><quote>talloc_reparent()</quote></link>. See
+	  the talloc_set_log_fn() documentation for more information
+	  on talloc logging.  
+	</para>
+    </refsect2>
+    <refsect2><title>TYPE *talloc_reparent(const void *<emphasis role="italic">old_parent</emphasis>, const void *<emphasis role="italic">new_parent</emphasis>, const TYPE *<emphasis role="italic">ptr</emphasis>);</title>
+        <para>
+	  The talloc_reparent() function changes the parent context of a talloc
+	  pointer. It is typically used when the context that the pointer is
+	  currently a child of is going to be freed and you wish to keep the
+	  memory for a longer time.
+        </para>
+        <para>
+	  The talloc_reparent() function returns the pointer that you pass it. It
+	  does not have any failure modes.
+        </para>
+        <para>
+	  The difference between talloc_reparent() and talloc_steal() is that
+	  talloc_reparent() can specify which parent you wish to change. This is
+	  useful when a pointer has multiple parents via references.
+        </para>
+    </refsect2>
+    <refsect2><title>TYPE *talloc_move(const void *<emphasis role="italic">new_ctx</emphasis>, TYPE **<emphasis role="italic">ptr</emphasis>);</title>
+        <para>
+	  The talloc_move() function is a wrapper around
+	  talloc_steal() which zeros the source pointer after the
+	  move. This avoids a potential source of bugs where a
+	  programmer leaves a pointer in two structures, and uses the
+	  pointer from the old structure after it has been moved to a
+	  new one.
+        </para>
+    </refsect2>
+    <refsect2><title>size_t talloc_total_size(const void *<emphasis role="italic">ptr</emphasis>);</title>
+        <para>
+	  The talloc_total_size() function returns the total size in bytes
+	  used by this pointer and all child pointers.	Mostly useful for
+	  debugging.
+        </para>
+        <para>
+	  Passing NULL is allowed, but it will only give a meaningful
+	  result if talloc_enable_leak_report() or
+	  talloc_enable_leak_report_full() has been called.
+        </para>
+    </refsect2>
+    <refsect2><title>size_t talloc_total_blocks(const void *<emphasis role="italic">ptr</emphasis>);</title>
+        <para>
+	  The talloc_total_blocks() function returns the total memory block
+	  count used by this pointer and all child pointers.  Mostly useful
+	  for debugging.
+        </para>
+        <para>
+	  Passing NULL is allowed, but it will only give a meaningful
+	  result if talloc_enable_leak_report() or
+	  talloc_enable_leak_report_full() has been called.
+        </para>
+    </refsect2>
+    <refsect2 id="talloc_report"><title>void talloc_report(const void *ptr, FILE *f);</title>
+        <para>
+	  The talloc_report() function prints a summary report of all
+	  memory used by <emphasis role="italic">ptr</emphasis>.  One line
+	  of report is printed for each immediate child of ptr, showing the
+	  total memory and number of blocks used by that child.
+        </para>
+        <para>
+	  You can pass NULL for the pointer, in which case a report is
+	  printed for the top level memory context, but only if
+	  talloc_enable_leak_report() or talloc_enable_leak_report_full()
+	  has been called.
+        </para>
+    </refsect2>
+    <refsect2 id="talloc_report_full"><title>void talloc_report_full(const void *<emphasis role="italic">ptr</emphasis>, FILE *<emphasis role="italic">f</emphasis>);</title>
+        <para>
+	  This provides a more detailed report than talloc_report().  It
+	  will recursively print the entire tree of memory referenced by
+	  the pointer. References in the tree are shown by giving the name
+	  of the pointer that is referenced.
+        </para>
+        <para>
+	  You can pass NULL for the pointer, in which case a report is
+	  printed for the top level memory context, but only if
+	  talloc_enable_leak_report() or talloc_enable_leak_report_full()
+	  has been called.
+        </para>
+    </refsect2>
+    <refsect2 id="talloc_report_depth_cb">
+     <funcsynopsis><funcprototype>
+      <funcdef>void <function>talloc_report_depth_cb</function></funcdef>
+      <paramdef><parameter>const void *ptr</parameter></paramdef>
+      <paramdef><parameter>int depth</parameter></paramdef>
+      <paramdef><parameter>int max_depth</parameter></paramdef>
+      <paramdef><parameter>void (*callback)(const void *ptr, int depth, int max_depth, int is_ref, void *priv)</parameter></paramdef>
+      <paramdef><parameter>void *priv</parameter></paramdef>
+     </funcprototype></funcsynopsis>
+        <para>
+	  This provides a more flexible reports than talloc_report(). It
+	  will recursively call the callback for the entire tree of memory
+	  referenced by the pointer. References in the tree are passed with
+	  <emphasis role="italic">is_ref = 1</emphasis> and the pointer that is referenced.
+        </para>
+        <para>
+	  You can pass NULL for the pointer, in which case a report is
+	  printed for the top level memory context, but only if
+	  talloc_enable_leak_report() or talloc_enable_leak_report_full()
+	  has been called.
+        </para>
+        <para>
+	  The recursion is stopped when depth >= max_depth.
+	  max_depth = -1 means only stop at leaf nodes.
+        </para>
+    </refsect2>
+    <refsect2 id="talloc_report_depth_file">
+     <funcsynopsis><funcprototype>
+      <funcdef>void <function>talloc_report_depth_file</function></funcdef>
+      <paramdef><parameter>const void *ptr</parameter></paramdef>
+      <paramdef><parameter>int depth</parameter></paramdef>
+      <paramdef><parameter>int max_depth</parameter></paramdef>
+      <paramdef><parameter>FILE *f</parameter></paramdef>
+     </funcprototype></funcsynopsis>
+        <para>
+	  This provides a more flexible reports than talloc_report(). It
+	  will let you specify the depth and max_depth.
+        </para>
+    </refsect2>
+    <refsect2 id="talloc_enable_leak_report"><title>void talloc_enable_leak_report(void);</title>
+        <para>
+	  This enables calling of talloc_report(NULL, stderr) when the
+	  program exits.  In Samba4 this is enabled by using the
+	  --leak-report command line option.
+        </para>
+        <para>
+	  For it to be useful, this function must be called before any
+	  other talloc function as it establishes a "null context" that
+	  acts as the top of the tree.	If you don't call this function
+	  first then passing NULL to talloc_report() or
+	  talloc_report_full() won't give you the full tree printout.
+        </para>
+        <para>
+	  Here is a typical talloc report:
+        </para>
+        <screen format="linespecific">talloc report on 'null_context' (total 267 bytes in 15 blocks)
+libcli/auth/spnego_parse.c:55  contains   31 bytes in   2 blocks
+libcli/auth/spnego_parse.c:55  contains   31 bytes in   2 blocks
+iconv(UTF8,CP850)              contains   42 bytes in   2 blocks
+libcli/auth/spnego_parse.c:55  contains   31 bytes in   2 blocks
+iconv(CP850,UTF8)              contains   42 bytes in   2 blocks
+iconv(UTF8,UTF-16LE)           contains   45 bytes in   2 blocks
+iconv(UTF-16LE,UTF8)           contains   45 bytes in   2 blocks
+      </screen>
+    </refsect2>
+    <refsect2 id="talloc_enable_leak_report_full"><title>void talloc_enable_leak_report_full(void);</title>
+        <para>
+	  This enables calling of talloc_report_full(NULL, stderr) when the
+	  program exits.  In Samba4 this is enabled by using the
+	  --leak-report-full command line option.
+        </para>
+        <para>
+	  For it to be useful, this function must be called before any
+	  other talloc function as it establishes a "null context" that
+	  acts as the top of the tree.	If you don't call this function
+	  first then passing NULL to talloc_report() or
+	  talloc_report_full() won't give you the full tree printout.
+        </para>
+        <para>
+	  Here is a typical full report:
+        </para>
+        <screen format="linespecific">full talloc report on 'root' (total 18 bytes in 8 blocks)
+p1               contains     18 bytes in   7 blocks (ref 0)
+    r1               contains     13 bytes in   2 blocks (ref 0)
+        reference to: p2
+    p2               contains      1 bytes in   1 blocks (ref 1)
+    x3               contains      1 bytes in   1 blocks (ref 0)
+    x2               contains      1 bytes in   1 blocks (ref 0)
+    x1               contains      1 bytes in   1 blocks (ref 0)
+      </screen>
+    </refsect2>
+    <refsect2><title>(<emphasis role="italic">type</emphasis> *)talloc_zero(const void *<emphasis role="italic">ctx</emphasis>, <emphasis role="italic">type</emphasis>);</title>
+        <para>
+	  The talloc_zero() macro is equivalent to:
+        </para>
+        <programlisting>ptr = talloc(ctx, type);
+if (ptr) memset(ptr, 0, sizeof(type));</programlisting>
+    </refsect2>
+    <refsect2><title>void *talloc_zero_size(const void *<emphasis role="italic">ctx</emphasis>, size_t <emphasis role="italic">size</emphasis>)</title>
+        <para>
+	  The talloc_zero_size() function is useful when you don't have a
+	  known type.
+        </para>
+    </refsect2>
+    <refsect2><title>void *talloc_memdup(const void *<emphasis role="italic">ctx</emphasis>, const void *<emphasis role="italic">p</emphasis>, size_t size);</title>
+        <para>
+	  The talloc_memdup() function is equivalent to:
+        </para>
+        <programlisting>ptr = talloc_size(ctx, size);
+if (ptr) memcpy(ptr, p, size);</programlisting>
+    </refsect2>
+    <refsect2><title>char *talloc_strdup(const void *<emphasis role="italic">ctx</emphasis>, const char *<emphasis role="italic">p</emphasis>);</title>
+        <para>
+	  The talloc_strdup() function is equivalent to:
+        </para>
+        <programlisting>ptr = talloc_size(ctx, strlen(p)+1);
+if (ptr) memcpy(ptr, p, strlen(p)+1);</programlisting>
+        <para>
+	  This function sets the name of the new pointer to the passed
+	  string. This is equivalent to:
+        </para>
+        <programlisting>talloc_set_name_const(ptr, ptr)</programlisting>
+    </refsect2>
+    <refsect2><title>char *talloc_strndup(const void *<emphasis role="italic">t</emphasis>, const char *<emphasis role="italic">p</emphasis>, size_t <emphasis role="italic">n</emphasis>);</title>
+        <para>
+	  The talloc_strndup() function is the talloc equivalent of the C
+	  library function strndup(3).
+        </para>
+        <para>
+	  This function sets the name of the new pointer to the passed
+	  string. This is equivalent to:
+        </para>
+        <programlisting>talloc_set_name_const(ptr, ptr)</programlisting>
+    </refsect2>
+    <refsect2><title>char *talloc_vasprintf(const void *<emphasis role="italic">t</emphasis>, const char *<emphasis role="italic">fmt</emphasis>, va_list <emphasis role="italic">ap</emphasis>);</title>
+        <para>
+	  The talloc_vasprintf() function is the talloc equivalent of the C
+	  library function vasprintf(3).
+        </para>
+        <para>
+	  This function sets the name of the new pointer to the new
+	  string. This is equivalent to:
+        </para>
+        <programlisting>talloc_set_name_const(ptr, ptr)</programlisting>
+    </refsect2>
+    <refsect2><title>char *talloc_asprintf(const void *<emphasis role="italic">t</emphasis>, const char *<emphasis role="italic">fmt</emphasis>, ...);</title>
+        <para>
+	  The talloc_asprintf() function is the talloc equivalent of the C
+	  library function asprintf(3).
+        </para>
+        <para>
+	  This function sets the name of the new pointer to the passed
+	  string. This is equivalent to:
+        </para>
+        <programlisting>talloc_set_name_const(ptr, ptr)</programlisting>
+    </refsect2>
+    <refsect2><title>char *talloc_asprintf_append(char *s, const char *fmt, ...);</title>
+        <para>
+	  The talloc_asprintf_append() function appends the given formatted
+	  string to the given string.
+        </para>
+        <para>
+	  This function sets the name of the new pointer to the new
+	  string. This is equivalent to:
+        </para>
+        <programlisting>talloc_set_name_const(ptr, ptr)</programlisting>
+    </refsect2>
+    <refsect2><title>(type *)talloc_array(const void *ctx, type, unsigned int count);</title>
+        <para>
+	  The talloc_array() macro is equivalent to:
+        </para>
+        <programlisting>(type *)talloc_size(ctx, sizeof(type) * count);</programlisting>
+        <para>
+	  except that it provides integer overflow protection for the
+	  multiply, returning NULL if the multiply overflows.
+        </para>
+    </refsect2>
+    <refsect2><title>void *talloc_array_size(const void *ctx, size_t size, unsigned int count);</title>
+        <para>
+	  The talloc_array_size() function is useful when the type is not
+	  known. It operates in the same way as talloc_array(), but takes a
+	  size instead of a type.
+        </para>
+    </refsect2>
+    <refsect2><title>(typeof(ptr)) talloc_array_ptrtype(const void *ctx, ptr, unsigned int count);</title>
+        <para>
+	  The talloc_ptrtype() macro should be used when you have a pointer to an array
+	  and want to allocate memory of an array to point at with this pointer. When compiling
+	  with gcc >= 3 it is typesafe. Note this is a wrapper of talloc_array_size()
+	  and talloc_get_name() will return the current location in the source file.
+	  and not the type.
+        </para>
+    </refsect2>
+    <refsect2><title>void *talloc_realloc_fn(const void *ctx, void *ptr, size_t size)</title>
+        <para>
+	  This is a non-macro version of talloc_realloc(), which is useful
+	  as libraries sometimes want a realloc function pointer.  A
+	  realloc(3) implementation encapsulates the functionality of
+	  malloc(3), free(3) and realloc(3) in one call, which is why it is
+	  useful to be able to pass around a single function pointer.
+        </para>
+    </refsect2>
+    <refsect2><title>void *talloc_autofree_context(void);</title>
+        <para>
+	  This is a handy utility function that returns a talloc context
+	  which will be automatically freed on program exit.  This can be
+	  used to reduce the noise in memory leak reports.
+        </para>
+    </refsect2>
+    <refsect2><title>void *talloc_check_name(const void *ptr, const char *name);</title>
+        <para>
+	  This function checks if a pointer has the specified <emphasis
+	  role="italic">name</emphasis>.  If it does then the pointer is
+	  returned.  It it doesn't then NULL is returned.
+        </para>
+    </refsect2>
+    <refsect2><title>(type *)talloc_get_type(const void *ptr, type);</title>
+        <para>
+	  This macro allows you to do type checking on talloc pointers.  It
+	  is particularly useful for void* private pointers.  It is
+	  equivalent to this:
+        </para>
+        <programlisting>(type *)talloc_check_name(ptr, #type)</programlisting>
+    </refsect2>
+    <refsect2><title>talloc_set_type(const void *ptr, type);</title>
+        <para>
+	  This macro allows you to force the name of a pointer to be a
+	  particular <emphasis>type</emphasis>.  This can be
+	  used in conjunction with talloc_get_type() to do type checking on
+	  void* pointers.
+        </para>
+        <para>
+	  It is equivalent to this:
+        </para>
+        <programlisting>talloc_set_name_const(ptr, #type)</programlisting>
+    </refsect2>
+    <refsect2><title>talloc_set_log_fn(void (*log_fn)(const char *message));</title>
+        <para>
+	  This function sets a logging function that talloc will use for
+	  warnings and errors. By default talloc will not print any warnings or
+	  errors.
+	</para>
+    </refsect2>
+    <refsect2><title>talloc_set_log_stderr(void);</title>
+        <para>
+	  This sets the talloc log function to write log messages to stderr
+	</para>
+    </refsect2>
+  </refsect1>
+  <refsect1><title>PERFORMANCE</title>
+    <para>
+      All the additional features of talloc(3) over malloc(3) do come at a
+      price.  We have a simple performance test in Samba4 that measures
+      talloc() versus malloc() performance, and it seems that talloc() is
+      about 10% slower than malloc() on my x86 Debian Linux box.  For
+      Samba, the great reduction in code complexity that we get by using
+      talloc makes this worthwhile, especially as the total overhead of
+      talloc/malloc in Samba is already quite small.
+    </para>
+  </refsect1>
+  <refsect1><title>SEE ALSO</title>
+    <para>
+      malloc(3), strndup(3), vasprintf(3), asprintf(3), 
+      <ulink url="http://talloc.samba.org/"/>
+    </para>
+  </refsect1>
+  <refsect1><title>COPYRIGHT/LICENSE</title>
+    <para>
+      Copyright (C) Andrew Tridgell 2004
+    </para>
+    <para>
+      This program is free software; you can redistribute it and/or modify
+      it under the terms of the GNU Lesser General Public License as
+      published by the Free Software Foundation; either version 3 of the
+      License, or (at your option) any later version.
+    </para>
+    <para>
+      This program is distributed in the hope that it will be useful, but
+      WITHOUT ANY WARRANTY; without even the implied warranty of
+      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+      General Public License for more details.
+    </para>
+    <para>
+      You should have received a copy of the GNU General Public License
+      along with this program; if not, see http://www.gnu.org/licenses/.
+    </para>
+  </refsect1>
+</refentry>
diff --git a/talloc.pc.in b/talloc.pc.in
index 437281a..c1dffcc 100644
--- a/talloc.pc.in
+++ b/talloc.pc.in
@@ -3,9 +3,9 @@ exec_prefix=@exec_prefix@
 libdir=@libdir@
 includedir=@includedir@
 
-Name: talloc 
+Name: talloc
 Description: A hierarchical pool based memory system with destructors
-Version: @TALLOC_VERSION@
-Libs: @LIB_RPATH@ -L${libdir} -ltalloc
-Cflags: -I${includedir} 
+Version: @VERSION@
+Libs: -L${libdir} -ltalloc
+Cflags: -I${includedir}
 URL: http://talloc.samba.org/
diff --git a/xsl/catalog.xml.in b/xsl/catalog.xml.in
new file mode 100644
index 0000000..02d595f
--- /dev/null
+++ b/xsl/catalog.xml.in
@@ -0,0 +1,18 @@
+<?xml version="1.0"?>
+<!DOCTYPE catalog PUBLIC "-//OASIS/DTD Entity Resolution XML Catalog V1.0//EN"
+	"http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd">
+
+<catalog xmlns="urn:oasis:names:tc:entity:xmlns:xml:catalog">
+	@NEXT_CAT_ENTRY_START@
+	<nextCatalog catalog="@XML_CATALOG@"/>
+	@NEXT_CAT_ENTRY_END@
+
+	@CAT_ENTRY_START@
+	<uri name="http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl"
+		uri="@DOCBOOK_ROOT@/manpages/docbook.xsl"/>
+	<uri name="http://docbook.sourceforge.net/release/xsl/current/fo/docbook.xsl"
+		uri="@DOCBOOK_ROOT@/fo/docbook.xsl"/>
+	@CAT_ENTRY_END@
+</catalog>
+
+<!-- vim: set ts=4 sts=4 sw=4 tw=0: -->
diff --git a/xsl/manpages/docbook.xsl b/xsl/manpages/docbook.xsl
new file mode 100644
index 0000000..e4161a3
--- /dev/null
+++ b/xsl/manpages/docbook.xsl
@@ -0,0 +1,8 @@
+<?xml version="1.0"?>
+<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+	xmlns:doc="http://nwalsh.com/xsl/documentation/1.0"
+	version="1.0">
+
+	<xsl:import href="http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl"/>
+
+</xsl:stylesheet>
-- 
1.7.6

