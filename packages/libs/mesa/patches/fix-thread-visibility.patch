From b7a81b6e511c03876c852d049befa50079c74ec5 Mon Sep 17 00:00:00 2001
From: Matt Turner <mattst88@gmail.com>
Date: Tue, 24 Jan 2012 10:05:52 -0500
Subject: [PATCH] Fix visibility of u_thread functions by inlining them

-fvisibility=hidden was preventing them from being exported, which
combined with shared-glapi was causing undefined symbol errors at
runtime.

We don't want to make these functions part of the ABI, and given
how simple they are, we simply inline them.
---
 src/mapi/mapi/sources.mak |    3 +-
 src/mapi/mapi/u_thread.c  |  210 ---------------------------------------------
 src/mapi/mapi/u_thread.h  |  148 +++++++++++++++++++++++++++++---
 3 files changed, 138 insertions(+), 223 deletions(-)
 delete mode 100644 src/mapi/mapi/u_thread.c

diff --git a/src/mapi/mapi/sources.mak b/src/mapi/mapi/sources.mak
index c50234b..2814186 100644
--- a/src/mapi/mapi/sources.mak
+++ b/src/mapi/mapi/sources.mak
@@ -16,8 +16,7 @@
 
 MAPI_UTIL_SOURCES = \
 	u_current.c \
-	u_execmem.c \
-	u_thread.c
+	u_execmem.c
 
 MAPI_SOURCES = \
 	entry.c \
diff --git a/src/mapi/mapi/u_thread.c b/src/mapi/mapi/u_thread.c
deleted file mode 100644
index 7b52ca9..0000000
--- a/src/mapi/mapi/u_thread.c
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * Mesa 3-D graphics library
- * Version:  6.5.1
- *
- * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
- * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "u_compiler.h"
-#include "u_thread.h"
-
-
-/*
- * This file should still compile even when THREADS is not defined.
- * This is to make things easier to deal with on the makefile scene..
- */
-#ifdef THREADS
-#include <errno.h>
-
-/*
- * Error messages
- */
-#define INIT_TSD_ERROR "_glthread_: failed to allocate key for thread specific data"
-#define GET_TSD_ERROR "_glthread_: failed to get thread specific data"
-#define SET_TSD_ERROR "_glthread_: thread failed to set thread specific data"
-
-
-/*
- * Magic number to determine if a TSD object has been initialized.
- * Kind of a hack but there doesn't appear to be a better cross-platform
- * solution.
- */
-#define INIT_MAGIC 0xff8adc98
-
-
-
-/*
- * POSIX Threads -- The best way to go if your platform supports them.
- *                  Solaris >= 2.5 have POSIX threads, IRIX >= 6.4 reportedly
- *                  has them, and many of the free Unixes now have them.
- *                  Be sure to use appropriate -mt or -D_REENTRANT type
- *                  compile flags when building.
- */
-#ifdef PTHREADS
-
-unsigned long
-u_thread_self(void)
-{
-   return (unsigned long) pthread_self();
-}
-
-
-void
-u_tsd_init(struct u_tsd *tsd)
-{
-   if (pthread_key_create(&tsd->key, NULL/*free*/) != 0) {
-      perror(INIT_TSD_ERROR);
-      exit(-1);
-   }
-   tsd->initMagic = INIT_MAGIC;
-}
-
-
-void *
-u_tsd_get(struct u_tsd *tsd)
-{
-   if (tsd->initMagic != (int) INIT_MAGIC) {
-      u_tsd_init(tsd);
-   }
-   return pthread_getspecific(tsd->key);
-}
-
-
-void
-u_tsd_set(struct u_tsd *tsd, void *ptr)
-{
-   if (tsd->initMagic != (int) INIT_MAGIC) {
-      u_tsd_init(tsd);
-   }
-   if (pthread_setspecific(tsd->key, ptr) != 0) {
-      perror(SET_TSD_ERROR);
-      exit(-1);
-   }
-}
-
-#endif /* PTHREADS */
-
-
-
-/*
- * Win32 Threads.  The only available option for Windows 95/NT.
- * Be sure that you compile using the Multithreaded runtime, otherwise
- * bad things will happen.
- */
-#ifdef WIN32
-
-unsigned long
-u_thread_self(void)
-{
-   return GetCurrentThreadId();
-}
-
-
-void
-u_tsd_init(struct u_tsd *tsd)
-{
-   tsd->key = TlsAlloc();
-   if (tsd->key == TLS_OUT_OF_INDEXES) {
-      perror(INIT_TSD_ERROR);
-      exit(-1);
-   }
-   tsd->initMagic = INIT_MAGIC;
-}
-
-
-void
-u_tsd_destroy(struct u_tsd *tsd)
-{
-   if (tsd->initMagic != INIT_MAGIC) {
-      return;
-   }
-   TlsFree(tsd->key);
-   tsd->initMagic = 0x0;
-}
-
-
-void *
-u_tsd_get(struct u_tsd *tsd)
-{
-   if (tsd->initMagic != INIT_MAGIC) {
-      u_tsd_init(tsd);
-   }
-   return TlsGetValue(tsd->key);
-}
-
-
-void
-u_tsd_set(struct u_tsd *tsd, void *ptr)
-{
-   /* the following code assumes that the struct u_tsd has been initialized
-      to zero at creation */
-   if (tsd->initMagic != INIT_MAGIC) {
-      u_tsd_init(tsd);
-   }
-   if (TlsSetValue(tsd->key, ptr) == 0) {
-      perror(SET_TSD_ERROR);
-      exit(-1);
-   }
-}
-
-#endif /* WIN32 */
-
-
-#else  /* THREADS */
-
-
-/*
- * no-op functions
- */
-
-unsigned long
-u_thread_self(void)
-{
-   return 0;
-}
-
-
-void
-u_tsd_init(struct u_tsd *tsd)
-{
-   (void) tsd;
-}
-
-
-void *
-u_tsd_get(struct u_tsd *tsd)
-{
-   (void) tsd;
-   return NULL;
-}
-
-
-void
-u_tsd_set(struct u_tsd *tsd, void *ptr)
-{
-   (void) tsd;
-   (void) ptr;
-}
-
-
-#endif /* THREADS */
diff --git a/src/mapi/mapi/u_thread.h b/src/mapi/mapi/u_thread.h
index 7db22b7..0b2beef 100644
--- a/src/mapi/mapi/u_thread.h
+++ b/src/mapi/mapi/u_thread.h
@@ -42,6 +42,8 @@
 #ifndef _U_THREAD_H_
 #define _U_THREAD_H_
 
+#include <stdio.h>
+#include <stdlib.h>
 #include "u_compiler.h"
 
 #if defined(PTHREADS)
@@ -57,6 +59,20 @@
 #endif
 #endif
 
+/*
+ * Error messages
+ */
+#define INIT_TSD_ERROR "_glthread_: failed to allocate key for thread specific data"
+#define GET_TSD_ERROR "_glthread_: failed to get thread specific data"
+#define SET_TSD_ERROR "_glthread_: thread failed to set thread specific data"
+
+
+/*
+ * Magic number to determine if a TSD object has been initialized.
+ * Kind of a hack but there doesn't appear to be a better cross-platform
+ * solution.
+ */
+#define INIT_MAGIC 0xff8adc98
 
 #ifdef __cplusplus
 extern "C" {
@@ -89,6 +105,46 @@ typedef pthread_mutex_t u_mutex;
 #define u_mutex_lock(name)    (void) pthread_mutex_lock(&(name))
 #define u_mutex_unlock(name)  (void) pthread_mutex_unlock(&(name))
 
+static INLINE unsigned long
+u_thread_self(void)
+{
+   return (unsigned long) pthread_self();
+}
+
+
+static INLINE void
+u_tsd_init(struct u_tsd *tsd)
+{
+   if (pthread_key_create(&tsd->key, NULL/*free*/) != 0) {
+      perror(INIT_TSD_ERROR);
+      exit(-1);
+   }
+   tsd->initMagic = INIT_MAGIC;
+}
+
+
+static INLINE void *
+u_tsd_get(struct u_tsd *tsd)
+{
+   if (tsd->initMagic != (int) INIT_MAGIC) {
+      u_tsd_init(tsd);
+   }
+   return pthread_getspecific(tsd->key);
+}
+
+
+static INLINE void
+u_tsd_set(struct u_tsd *tsd, void *ptr)
+{
+   if (tsd->initMagic != (int) INIT_MAGIC) {
+      u_tsd_init(tsd);
+   }
+   if (pthread_setspecific(tsd->key, ptr) != 0) {
+      perror(SET_TSD_ERROR);
+      exit(-1);
+   }
+}
+
 #endif /* PTHREADS */
 
 
@@ -115,6 +171,60 @@ typedef CRITICAL_SECTION u_mutex;
 #define u_mutex_lock(name)    EnterCriticalSection(&name)
 #define u_mutex_unlock(name)  LeaveCriticalSection(&name)
 
+static INLINE unsigned long
+u_thread_self(void)
+{
+   return GetCurrentThreadId();
+}
+
+
+static INLINE void
+u_tsd_init(struct u_tsd *tsd)
+{
+   tsd->key = TlsAlloc();
+   if (tsd->key == TLS_OUT_OF_INDEXES) {
+      perror(INIT_TSD_ERROR);
+      exit(-1);
+   }
+   tsd->initMagic = INIT_MAGIC;
+}
+
+
+static INLINE void
+u_tsd_destroy(struct u_tsd *tsd)
+{
+   if (tsd->initMagic != INIT_MAGIC) {
+      return;
+   }
+   TlsFree(tsd->key);
+   tsd->initMagic = 0x0;
+}
+
+
+static INLINE void *
+u_tsd_get(struct u_tsd *tsd)
+{
+   if (tsd->initMagic != INIT_MAGIC) {
+      u_tsd_init(tsd);
+   }
+   return TlsGetValue(tsd->key);
+}
+
+
+static INLINE void
+u_tsd_set(struct u_tsd *tsd, void *ptr)
+{
+   /* the following code assumes that the struct u_tsd has been initialized
+      to zero at creation */
+   if (tsd->initMagic != INIT_MAGIC) {
+      u_tsd_init(tsd);
+   }
+   if (TlsSetValue(tsd->key, ptr) == 0) {
+      perror(SET_TSD_ERROR);
+      exit(-1);
+   }
+}
+
 #endif /* WIN32 */
 
 
@@ -135,23 +245,39 @@ typedef unsigned u_mutex;
 #define u_mutex_lock(name)             (void) name
 #define u_mutex_unlock(name)           (void) name
 
-#endif /* THREADS */
+/*
+ * no-op functions
+ */
+
+static INLINE unsigned long
+u_thread_self(void)
+{
+   return 0;
+}
 
 
-unsigned long
-u_thread_self(void);
+static INLINE void
+u_tsd_init(struct u_tsd *tsd)
+{
+   (void) tsd;
+}
 
-void
-u_tsd_init(struct u_tsd *tsd);
 
-void
-u_tsd_destroy(struct u_tsd *tsd); /* WIN32 only */
+static INLINE void *
+u_tsd_get(struct u_tsd *tsd)
+{
+   (void) tsd;
+   return NULL;
+}
 
-void *
-u_tsd_get(struct u_tsd *tsd);
 
-void
-u_tsd_set(struct u_tsd *tsd, void *ptr);
+static INLINE void
+u_tsd_set(struct u_tsd *tsd, void *ptr)
+{
+   (void) tsd;
+   (void) ptr;
+}
+#endif /* THREADS */
 
 
 #ifdef __cplusplus
-- 
1.7.10

