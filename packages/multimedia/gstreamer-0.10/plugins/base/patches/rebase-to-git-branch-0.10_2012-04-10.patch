diff --git a/autogen.sh b/autogen.sh
index 820a017..9b38463 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -1,6 +1,12 @@
 #!/bin/sh
 # Run this to generate all the initial makefiles, etc.
 
+test -n "$srcdir" || srcdir=`dirname "$0"`
+test -n "$srcdir" || srcdir=.
+
+olddir=`pwd`
+cd "$srcdir"
+
 DIE=0
 package=gst-plugins-base
 srcfile=gst/audiotestsrc/gstaudiotestsrc.c
@@ -29,6 +35,9 @@ then
     ln -s ../../common/hooks/pre-commit.hook .git/hooks/pre-commit
 fi
 
+# GNU gettext automake support doesn't get along with git.
+# https://bugzilla.gnome.org/show_bug.cgi?id=661128
+touch -t 200001010000 po/gst-plugins-base-0.10.pot
 
 CONFIGURE_DEF_OPT='--enable-maintainer-mode --enable-gtk-doc'
 
@@ -106,13 +115,15 @@ test -n "$NOCONFIGURE" && {
   exit 0
 }
 
+cd "$olddir"
+
 echo "+ running configure ... "
-test ! -z "$CONFIGURE_DEF_OPT" && echo "  ./configure default flags: $CONFIGURE_DEF_OPT"
-test ! -z "$CONFIGURE_EXT_OPT" && echo "  ./configure external flags: $CONFIGURE_EXT_OPT"
-test ! -z "$CONFIGURE_FILE_OPT" && echo "  ./configure enable/disable flags: $CONFIGURE_FILE_OPT"
+test ! -z "$CONFIGURE_DEF_OPT" && echo "  $srcdir/configure default flags: $CONFIGURE_DEF_OPT"
+test ! -z "$CONFIGURE_EXT_OPT" && echo "  $srcdir/configure external flags: $CONFIGURE_EXT_OPT"
+test ! -z "$CONFIGURE_FILE_OPT" && echo "  $srcdir/configure enable/disable flags: $CONFIGURE_FILE_OPT"
 echo
 
-./configure $CONFIGURE_DEF_OPT $CONFIGURE_EXT_OPT $CONFIGURE_FILE_OPT || {
+"$srcdir/configure" $CONFIGURE_DEF_OPT $CONFIGURE_EXT_OPT $CONFIGURE_FILE_OPT || {
         echo "  configure failed"
         exit 1
 }
diff --git a/configure.ac b/configure.ac
index 1901bcf..3b87f43 100644
--- a/configure.ac
+++ b/configure.ac
@@ -5,7 +5,7 @@ dnl please read gstreamer/docs/random/autotools before changing this file
 dnl initialize autoconf
 dnl releases only do -Wall, git and prerelease does -Werror too
 dnl use a three digit version number for releases, and four for git/prerelease
-AC_INIT(GStreamer Base Plug-ins, 0.10.36,
+AC_INIT(GStreamer Base Plug-ins, 0.10.36.1,
     http://bugzilla.gnome.org/enter_bug.cgi?product=GStreamer,
     gst-plugins-base)
 
@@ -49,7 +49,7 @@ dnl - interfaces added/removed/changed -> increment CURRENT, REVISION = 0
 dnl - interfaces added -> increment AGE
 dnl - interfaces removed -> AGE = 0
 dnl sets GST_LT_LDFLAGS
-AS_LIBTOOL(GST, 25, 0, 25)
+AS_LIBTOOL(GST, 26, 0, 26)
 
 dnl FIXME: this macro doesn't actually work;
 dnl the generated libtool script has no support for the listed tags.
@@ -178,14 +180,18 @@ AC_CHECK_HEADERS([malloc.h])
 
 ac_cppflags_save="$CPPFLAGS"
 CPPFLAGS="`$PKG_CONFIG --cflags libxml-2.0`"
-AC_COMPILE_IFELSE(
-  AC_LANG_PROGRAM([
+AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM([[
 #include <libxml/HTMLparser.h>
-                     ],[
+]],[[
 #ifndef LIBXML_HTML_ENABLED
 #error libxml2 has no HTML support
 #endif /* LIBXML_HTML_ENABLED */
-                   ]), HAVE_LIBXML_HTML="yes", HAVE_LIBXML_HTML="no")
+]])], [
+  HAVE_LIBXML_HTML="yes"
+], [
+  HAVE_LIBXML_HTML="no"
+])
 CPPFLAGS="$ac_cppflags_save"
 AM_CONDITIONAL(HAVE_LIBXML_HTML, test "x$HAVE_LIBXML_HTML" = "xyes")
 
@@ -367,14 +373,14 @@ AG_GST_CHECK_GST_DEBUG_DISABLED([NO_WARNINGS="-Wno-unused"], [NO_WARNINGS=""])
 
 dnl define an ERROR_CFLAGS Makefile variable
 dnl -Wformat-nonliteral - see ext/pango/gstclockoverlay.c and http://gcc.gnu.org/bugzilla/show_bug.cgi?id=39438
-AG_GST_SET_ERROR_CFLAGS($GST_GIT, [
+AG_GST_SET_ERROR_CFLAGS($FATAL_WARNINGS, [
     -Wmissing-declarations -Wmissing-prototypes -Wredundant-decls -Wundef
     -Wwrite-strings -Wformat-nonliteral -Wformat-security
     -Winit-self -Wmissing-include-dirs -Waddress -Waggregate-return
     -Wno-multichar -Wnested-externs $NO_WARNINGS])
 
 dnl define an ERROR_CXXFLAGS Makefile variable
-AG_GST_SET_ERROR_CXXFLAGS($GST_GIT, [
+AG_GST_SET_ERROR_CXXFLAGS($FATAL_WARNINGS, [
     -Wmissing-declarations -Wredundant-decls -Wundef
     -Wwrite-strings -Wformat-nonliteral -Wformat-security
     -Winit-self -Wmissing-include-dirs -Waddress -Waggregate-return
@@ -787,7 +793,7 @@ AG_GST_CHECK_FEATURE(OGG, [Xiph Ogg library], ogg, [
 dnl *** pango ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_PANGO, true)
 AG_GST_CHECK_FEATURE(PANGO, [Pango font rendering], pango, [
-  AG_GST_PKG_CHECK_MODULES(PANGO, pango >= 1.16.0  pangocairo >= 1.16.0)
+  AG_GST_PKG_CHECK_MODULES(PANGO, pango >= 1.22.0  pangocairo >= 1.22.0)
 ])
 
 dnl *** theora ***
@@ -810,14 +816,14 @@ AG_GST_CHECK_FEATURE(VORBIS, [Xiph Vorbis audio codec], vorbis, [
 
 if test "x$HAVE_VORBIS" = "xyes"; then
   ac_cflags_save="$CFLAGS"
-  AC_COMPILE_IFELSE(
-    AC_LANG_PROGRAM([
+  AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[
 #include <vorbis/codec.h>
-                     ],[
+                     ]],[[
 vorbis_dsp_state *v;
 
 vorbis_synthesis_restart (v);
-                     ]), HAVE_VSR=yes, HAVE_VSR=no)
+                     ]])], HAVE_VSR=yes, HAVE_VSR=no)
   if test "x$HAVE_VSR" = "xyes"; then
     AC_DEFINE_UNQUOTED(HAVE_VORBIS_SYNTHESIS_RESTART, 1,
                        [defined if vorbis_synthesis_restart is present])
@@ -1021,6 +1027,7 @@ tests/examples/gio/Makefile
 tests/examples/overlay/Makefile
 tests/examples/seek/Makefile
 tests/examples/snapshot/Makefile
+tests/examples/playback/Makefile
 tests/examples/playrec/Makefile
 tests/examples/v4l/Makefile
 tests/files/Makefile
diff --git a/docs/libs/gst-plugins-base-libs-sections.txt b/docs/libs/gst-plugins-base-libs-sections.txt
index d8c5b35..9e54a75 100644
--- a/docs/libs/gst-plugins-base-libs-sections.txt
+++ b/docs/libs/gst-plugins-base-libs-sections.txt
@@ -1979,6 +1979,7 @@ gst_tag_get_language_code
 gst_tag_get_language_code_iso_639_1
 gst_tag_get_language_code_iso_639_2B
 gst_tag_get_language_code_iso_639_2T
+gst_tag_check_language_code
 </SECTION>
 
 <SECTION>
@@ -2352,6 +2353,7 @@ gst_video_overlay_rectangle_get_render_rectangle
 gst_video_overlay_rectangle_get_seqnum
 gst_video_overlay_rectangle_set_render_rectangle
 gst_video_overlay_rectangle_copy
+gst_video_overlay_rectangle_get_flags
 <SUBSECTION Standard>
 GST_TYPE_VIDEO_OVERLAY_COMPOSITION
 GST_VIDEO_OVERLAY_COMPOSITION
diff --git a/docs/libs/gst-plugins-base-libs.types b/docs/libs/gst-plugins-base-libs.types
index 991a975..1ea7046 100644
--- a/docs/libs/gst-plugins-base-libs.types
+++ b/docs/libs/gst-plugins-base-libs.types
@@ -60,6 +60,9 @@ gst_base_rtp_audio_payload_get_type
 gst_video_filter_get_type
 #include <gst/video/gstvideosink.h>
 gst_video_sink_get_type
+#include <gst/video/video-overlay-composition.h>
+gst_video_overlay_rectangle_get_type
+gst_video_overlay_composition_get_type
 
 #include <gst/pbutils/pbutils.h>
 gst_discoverer_get_type
diff --git a/docs/plugins/gst-plugins-base-plugins.args b/docs/plugins/gst-plugins-base-plugins.args
index ccd21e9..574eded 100644
--- a/docs/plugins/gst-plugins-base-plugins.args
+++ b/docs/plugins/gst-plugins-base-plugins.args
@@ -711,7 +711,7 @@
 <ARG>
 <NAME>GstMultiFdSink::buffers-max</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Buffers max</NICK>
 <BLURB>max number of buffers to queue for a client (-1 = no limit).</BLURB>
@@ -731,7 +731,7 @@
 <ARG>
 <NAME>GstMultiFdSink::buffers-soft-max</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Buffers soft max</NICK>
 <BLURB>Recover client when going over this limit (-1 = no limit).</BLURB>
@@ -821,7 +821,7 @@
 <ARG>
 <NAME>GstMultiFdSink::buffers-min</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Buffers min</NICK>
 <BLURB>min number of buffers to queue (-1 = as few as possible).</BLURB>
@@ -851,7 +851,7 @@
 <ARG>
 <NAME>GstMultiFdSink::bytes-min</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Bytes min</NICK>
 <BLURB>min number of bytes to queue (-1 = as little as possible).</BLURB>
@@ -861,7 +861,7 @@
 <ARG>
 <NAME>GstMultiFdSink::time-min</NAME>
 <TYPE>gint64</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Time min</NICK>
 <BLURB>min number of time to queue (-1 = as little as possible).</BLURB>
@@ -881,7 +881,7 @@
 <ARG>
 <NAME>GstMultiFdSink::units-max</NAME>
 <TYPE>gint64</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Units max</NICK>
 <BLURB>max number of units to queue (-1 = no limit).</BLURB>
@@ -891,7 +891,7 @@
 <ARG>
 <NAME>GstMultiFdSink::units-soft-max</NAME>
 <TYPE>gint64</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Units soft max</NICK>
 <BLURB>Recover client when going over this limit (-1 = no limit).</BLURB>
@@ -901,7 +901,7 @@
 <ARG>
 <NAME>GstMultiFdSink::qos-dscp</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,63]</RANGE>
+<RANGE>[G_MAXULONG,63]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>QoS diff srv code point</NICK>
 <BLURB>Quality of Service, differentiated services code point (-1 default).</BLURB>
@@ -1081,7 +1081,7 @@
 <ARG>
 <NAME>GstVorbisEnc::bitrate</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,250001]</RANGE>
+<RANGE>[G_MAXULONG,250001]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Target Bitrate</NICK>
 <BLURB>Attempt to encode at a bitrate averaging this (in bps). This uses the bitrate management engine, and is not recommended for most users. Quality is a better alternative. (-1 == disabled).</BLURB>
@@ -1111,7 +1111,7 @@
 <ARG>
 <NAME>GstVorbisEnc::max-bitrate</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,250001]</RANGE>
+<RANGE>[G_MAXULONG,250001]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Maximum Bitrate</NICK>
 <BLURB>Specify a maximum bitrate (in bps). Useful for streaming applications. (-1 == disabled).</BLURB>
@@ -1121,7 +1121,7 @@
 <ARG>
 <NAME>GstVorbisEnc::min-bitrate</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,250001]</RANGE>
+<RANGE>[G_MAXULONG,250001]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Minimum Bitrate</NICK>
 <BLURB>Specify a minimum bitrate (in bps). Useful for encoding for a fixed-size channel. (-1 == disabled).</BLURB>
@@ -1349,6 +1349,16 @@
 </ARG>
 
 <ARG>
+<NAME>GstTheoraEnc::dup-on-gap</NAME>
+<TYPE>gboolean</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Create DUP frame on GAP flag</NICK>
+<BLURB>Allow codec to handle frames with GAP flag as duplicates of previous frame. This is good to work with variable frame rate stabilized by videorate element. It will add variable latency with maximal size of keyframe distance, this way it is a bad idea to use with live streams.</BLURB>
+<DEFAULT>FALSE</DEFAULT>
+</ARG>
+
+<ARG>
 <NAME>GstGnomeVFSSrc::handle</NAME>
 <TYPE>GnomeVFSHandle*</TYPE>
 <RANGE></RANGE>
@@ -1741,7 +1751,7 @@
 <ARG>
 <NAME>GstVideoRate::average-period</NAME>
 <TYPE>guint64</TYPE>
-<RANGE><= G_MAXINT64</RANGE>
+<RANGE><= G_MAXLONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Period over which to average</NICK>
 <BLURB>Period over which to average the framerate (in ns) (0 = disabled).</BLURB>
@@ -2321,7 +2331,7 @@
 <ARG>
 <NAME>GstCdParanoiaSrc::read-speed</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Read speed</NICK>
 <BLURB>Read from device at specified speed.</BLURB>
@@ -2331,7 +2341,7 @@
 <ARG>
 <NAME>GstCdParanoiaSrc::search-overlap</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,75]</RANGE>
+<RANGE>[G_MAXULONG,75]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Search overlap</NICK>
 <BLURB>Force minimum overlap search during verification to n sectors.</BLURB>
@@ -2341,7 +2351,7 @@
 <ARG>
 <NAME>GstCdParanoiaSrc::cache-size</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Cache size</NICK>
 <BLURB>Set CD cache size to n sectors (-1 = auto).</BLURB>
@@ -2571,7 +2581,7 @@
 <ARG>
 <NAME>GstURIDecodeBin::buffer-duration</NAME>
 <TYPE>gint64</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Buffer duration (ns)</NICK>
 <BLURB>Buffer duration when buffering streams (-1 default value).</BLURB>
@@ -2581,7 +2591,7 @@
 <ARG>
 <NAME>GstURIDecodeBin::buffer-size</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Buffer size (bytes)</NICK>
 <BLURB>Buffer size when buffering streams (-1 default value).</BLURB>
@@ -2791,7 +2801,7 @@
 <ARG>
 <NAME>GstPlayBin2::current-audio</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Current audio</NICK>
 <BLURB>Currently playing audio stream (-1 = auto).</BLURB>
@@ -2801,7 +2811,7 @@
 <ARG>
 <NAME>GstPlayBin2::current-text</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Current Text</NICK>
 <BLURB>Currently playing text stream (-1 = auto).</BLURB>
@@ -2811,7 +2821,7 @@
 <ARG>
 <NAME>GstPlayBin2::current-video</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Current Video</NICK>
 <BLURB>Currently playing video stream (-1 = auto).</BLURB>
@@ -2825,7 +2835,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>Flags</NICK>
 <BLURB>Flags to control behaviour.</BLURB>
-<DEFAULT>Render the video stream|Render the audio stream|Render subtitles|Use software volume</DEFAULT>
+<DEFAULT>Render the video stream|Render the audio stream|Render subtitles|Use software volume|Use software color balance</DEFAULT>
 </ARG>
 
 <ARG>
@@ -2961,7 +2971,7 @@
 <ARG>
 <NAME>GstPlayBin2::buffer-duration</NAME>
 <TYPE>gint64</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Buffer duration (ns)</NICK>
 <BLURB>Buffer duration when buffering network streams.</BLURB>
@@ -2971,7 +2981,7 @@
 <ARG>
 <NAME>GstPlayBin2::buffer-size</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Buffer size (bytes)</NICK>
 <BLURB>Buffer size when buffering network streams.</BLURB>
@@ -3351,7 +3361,7 @@
 <ARG>
 <NAME>GstAppSrc::max-latency</NAME>
 <TYPE>gint64</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Max Latency</NICK>
 <BLURB>The maximum latency (-1 = unlimited).</BLURB>
@@ -3361,7 +3371,7 @@
 <ARG>
 <NAME>GstAppSrc::min-latency</NAME>
 <TYPE>gint64</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Min Latency</NICK>
 <BLURB>The minimum latency (-1 = default).</BLURB>
@@ -3371,7 +3381,7 @@
 <ARG>
 <NAME>GstAppSrc::size</NAME>
 <TYPE>gint64</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Size</NICK>
 <BLURB>The size of the data stream in bytes (-1 if unknown).</BLURB>
@@ -3445,7 +3455,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>Flags</NICK>
 <BLURB>Flags to control behaviour.</BLURB>
-<DEFAULT>Render the video stream|Render the audio stream|Render subtitles|Use software volume</DEFAULT>
+<DEFAULT>Render the video stream|Render the audio stream|Render subtitles|Use software volume|Use software color balance</DEFAULT>
 </ARG>
 
 <ARG>
@@ -3647,4 +3657,3 @@
 <BLURB>Flags to control behaviour.</BLURB>
 <DEFAULT></DEFAULT>
 </ARG>
-
diff --git a/docs/plugins/gst-plugins-base-plugins.hierarchy b/docs/plugins/gst-plugins-base-plugins.hierarchy
index 111bd43..b55999f 100644
--- a/docs/plugins/gst-plugins-base-plugins.hierarchy
+++ b/docs/plugins/gst-plugins-base-plugins.hierarchy
@@ -3,7 +3,6 @@ GObject
   GOutputStream
   GstColorBalanceChannel
   GstMixerTrack
-    GstMixerOptions
   GstObject
     GstBus
     GstClock
diff --git a/docs/plugins/gst-plugins-base-plugins.interfaces b/docs/plugins/gst-plugins-base-plugins.interfaces
index 12c9f78..3d81d8f 100644
--- a/docs/plugins/gst-plugins-base-plugins.interfaces
+++ b/docs/plugins/gst-plugins-base-plugins.interfaces
@@ -20,6 +20,7 @@ GstPlayBaseBin GstChildProxy
 GstPlayBin GstChildProxy
 GstPlayBin2 GstChildProxy GstStreamVolume
 GstPlaySink GstChildProxy
+GstPlaySink GstChildProxy GstStreamVolume
 GstSubtitleOverlay GstChildProxy
 GstTheoraEnc GstPreset
 GstURIDecodeBin GstChildProxy
diff --git a/docs/plugins/inspect/plugin-adder.xml b/docs/plugins/inspect/plugin-adder.xml
index e55c6fd..6d7ce49 100644
--- a/docs/plugins/inspect/plugin-adder.xml
+++ b/docs/plugins/inspect/plugin-adder.xml
@@ -3,10 +3,10 @@
   <description>Adds multiple streams</description>
   <filename>../../gst/adder/.libs/libgstadder.so</filename>
   <basename>libgstadder.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-alsa.xml b/docs/plugins/inspect/plugin-alsa.xml
index 1f04e6d..7098c5c 100644
--- a/docs/plugins/inspect/plugin-alsa.xml
+++ b/docs/plugins/inspect/plugin-alsa.xml
@@ -3,10 +3,10 @@
   <description>ALSA plugin library</description>
   <filename>../../ext/alsa/.libs/libgstalsa.so</filename>
   <basename>libgstalsa.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-app.xml b/docs/plugins/inspect/plugin-app.xml
index 99301b1..7aafd66 100644
--- a/docs/plugins/inspect/plugin-app.xml
+++ b/docs/plugins/inspect/plugin-app.xml
@@ -3,10 +3,10 @@
   <description>Elements used to communicate with applications</description>
   <filename>../../gst/app/.libs/libgstapp.so</filename>
   <basename>libgstapp.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-audioconvert.xml b/docs/plugins/inspect/plugin-audioconvert.xml
index 373c697..6dcb775 100644
--- a/docs/plugins/inspect/plugin-audioconvert.xml
+++ b/docs/plugins/inspect/plugin-audioconvert.xml
@@ -3,10 +3,10 @@
   <description>Convert audio to different formats</description>
   <filename>../../gst/audioconvert/.libs/libgstaudioconvert.so</filename>
   <basename>libgstaudioconvert.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-audiorate.xml b/docs/plugins/inspect/plugin-audiorate.xml
index 00d9f6e..f6ecc75 100644
--- a/docs/plugins/inspect/plugin-audiorate.xml
+++ b/docs/plugins/inspect/plugin-audiorate.xml
@@ -3,10 +3,10 @@
   <description>Adjusts audio frames</description>
   <filename>../../gst/audiorate/.libs/libgstaudiorate.so</filename>
   <basename>libgstaudiorate.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-audioresample.xml b/docs/plugins/inspect/plugin-audioresample.xml
index f257476..e58baf9 100644
--- a/docs/plugins/inspect/plugin-audioresample.xml
+++ b/docs/plugins/inspect/plugin-audioresample.xml
@@ -3,10 +3,10 @@
   <description>Resamples audio</description>
   <filename>../../gst/audioresample/.libs/libgstaudioresample.so</filename>
   <basename>libgstaudioresample.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-audiotestsrc.xml b/docs/plugins/inspect/plugin-audiotestsrc.xml
index 95f38b8..e12cf31 100644
--- a/docs/plugins/inspect/plugin-audiotestsrc.xml
+++ b/docs/plugins/inspect/plugin-audiotestsrc.xml
@@ -3,10 +3,10 @@
   <description>Creates audio test signals of given frequency and volume</description>
   <filename>../../gst/audiotestsrc/.libs/libgstaudiotestsrc.so</filename>
   <basename>libgstaudiotestsrc.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-cdparanoia.xml b/docs/plugins/inspect/plugin-cdparanoia.xml
index 852657e..2ba49b7 100644
--- a/docs/plugins/inspect/plugin-cdparanoia.xml
+++ b/docs/plugins/inspect/plugin-cdparanoia.xml
@@ -3,10 +3,10 @@
   <description>Read audio from CD in paranoid mode</description>
   <filename>../../ext/cdparanoia/.libs/libgstcdparanoia.so</filename>
   <basename>libgstcdparanoia.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-decodebin.xml b/docs/plugins/inspect/plugin-decodebin.xml
index 7ad14c7..31a18a9 100644
--- a/docs/plugins/inspect/plugin-decodebin.xml
+++ b/docs/plugins/inspect/plugin-decodebin.xml
@@ -3,10 +3,10 @@
   <description>decoder bin</description>
   <filename>../../gst/playback/.libs/libgstdecodebin.so</filename>
   <basename>libgstdecodebin.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-encoding.xml b/docs/plugins/inspect/plugin-encoding.xml
index 63923a4..589e3ee 100644
--- a/docs/plugins/inspect/plugin-encoding.xml
+++ b/docs/plugins/inspect/plugin-encoding.xml
@@ -3,10 +3,10 @@
   <description>various encoding-related elements</description>
   <filename>../../gst/encoding/.libs/libgstencodebin.so</filename>
   <basename>libgstencodebin.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-ffmpegcolorspace.xml b/docs/plugins/inspect/plugin-ffmpegcolorspace.xml
index fd4a87a..c0ddeeb 100644
--- a/docs/plugins/inspect/plugin-ffmpegcolorspace.xml
+++ b/docs/plugins/inspect/plugin-ffmpegcolorspace.xml
@@ -3,7 +3,7 @@
   <description>colorspace conversion copied from FFMpeg 0.4.9-pre1</description>
   <filename>../../gst/ffmpegcolorspace/.libs/libgstffmpegcolorspace.so</filename>
   <basename>libgstffmpegcolorspace.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
   <package>FFMpeg</package>
diff --git a/docs/plugins/inspect/plugin-gdp.xml b/docs/plugins/inspect/plugin-gdp.xml
index 4f0530a..970505e 100644
--- a/docs/plugins/inspect/plugin-gdp.xml
+++ b/docs/plugins/inspect/plugin-gdp.xml
@@ -3,10 +3,10 @@
   <description>Payload/depayload GDP packets</description>
   <filename>../../gst/gdp/.libs/libgstgdp.so</filename>
   <basename>libgstgdp.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-gio.xml b/docs/plugins/inspect/plugin-gio.xml
index e0d6844..aecd4bd 100644
--- a/docs/plugins/inspect/plugin-gio.xml
+++ b/docs/plugins/inspect/plugin-gio.xml
@@ -3,10 +3,10 @@
   <description>GIO elements</description>
   <filename>../../ext/gio/.libs/libgstgio.so</filename>
   <basename>libgstgio.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-gnomevfs.xml b/docs/plugins/inspect/plugin-gnomevfs.xml
index 9fab8cb..781e2c1 100644
--- a/docs/plugins/inspect/plugin-gnomevfs.xml
+++ b/docs/plugins/inspect/plugin-gnomevfs.xml
@@ -3,10 +3,10 @@
   <description>elements to read from and write to  Gnome-VFS uri&apos;s</description>
   <filename>../../ext/gnomevfs/.libs/libgstgnomevfs.so</filename>
   <basename>libgstgnomevfs.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-libvisual.xml b/docs/plugins/inspect/plugin-libvisual.xml
index 10ea0ae..4d82ace 100644
--- a/docs/plugins/inspect/plugin-libvisual.xml
+++ b/docs/plugins/inspect/plugin-libvisual.xml
@@ -3,10 +3,10 @@
   <description>libvisual visualization plugins</description>
   <filename>../../ext/libvisual/.libs/libgstlibvisual.so</filename>
   <basename>libgstlibvisual.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-ogg.xml b/docs/plugins/inspect/plugin-ogg.xml
index 2b2d462..1811f0d 100644
--- a/docs/plugins/inspect/plugin-ogg.xml
+++ b/docs/plugins/inspect/plugin-ogg.xml
@@ -3,10 +3,10 @@
   <description>ogg stream manipulation (info about ogg: http://xiph.org)</description>
   <filename>../../ext/ogg/.libs/libgstogg.so</filename>
   <basename>libgstogg.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -152,7 +152,7 @@
           <name>src</name>
           <direction>source</direction>
           <presence>sometimes</presence>
-          <details>video/x-3ivx, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-asus, asusversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-asus, asusversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-cirrus-logic-accupak, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-camstudio, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-compressed-yuv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-rgb, bpp=(int){ 8, 24, 32 }, depth=(int){ 8, 24 }, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-truemotion, trueversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dv, systemstream=(boolean)false, dvversion=(int)25, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dv, systemstream=(boolean)false, dvversion=(int)50, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, mpegversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-flash-video, flvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6-flash, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)lucent, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-huffyuv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-intel-h263, variant=(string)intel, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)I420, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)lead, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)lead, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)microsoft, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, mpegversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; image/jpeg, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)42, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)43, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, systemstream=(boolean)false, mpegversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, systemstream=(boolean)false, mpegversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)41, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-mszh, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; image/png, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-rle, layout=(string)microsoft, depth=(int)[ 1, 64 ], framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/sp5x, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-truemotion, trueversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-camtasia, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ultimotion, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)UYVY, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ati-vcr, vcrversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ati-vcr, vcrversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)vdolive, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)vivo, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vmnc, version=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)videosoft, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-xvid, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-xan, wcversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YUY2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YVU9, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-zlib, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-cinepak, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msvideocodec, msvideoversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)xirlink, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dirac, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ffv, ffvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-kmvc, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6-flash, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp7, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp8, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-mimic, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-apple-video, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-theora, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-fraps, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-aasc, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YV12, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-loco, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-zmbv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]</details>
+          <details>video/x-3ivx, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-asus, asusversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-asus, asusversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-cirrus-logic-accupak, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-camstudio, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-compressed-yuv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-rgb, bpp=(int){ 8, 24, 32 }, depth=(int){ 8, 24 }, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-truemotion, trueversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dv, systemstream=(boolean)false, dvversion=(int)25, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dv, systemstream=(boolean)false, dvversion=(int)50, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, mpegversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-flash-video, flvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6-flash, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)lucent, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-huffyuv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-intel-h263, variant=(string)intel, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)I420, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)lead, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)lead, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)microsoft, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, mpegversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; image/jpeg, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)42, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)43, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, systemstream=(boolean)false, mpegversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, systemstream=(boolean)false, mpegversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)41, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-mszh, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; image/png, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-rle, layout=(string)microsoft, depth=(int)[ 1, 64 ], framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/sp5x, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-truemotion, trueversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-camtasia, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ultimotion, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)UYVY, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ati-vcr, vcrversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ati-vcr, vcrversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)vdolive, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)vivo, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vmnc, version=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)videosoft, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-xvid, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-xan, wcversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YUY2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YVU9, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-zlib, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-cinepak, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msvideocodec, msvideoversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)xirlink, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dirac, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ffv, ffvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-kmvc, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6-flash, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp7, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp8, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-mimic, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-apple-video, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-theora, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-fraps, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-aasc, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YV12, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-loco, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-zmbv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)v210, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-rgb, endianness=(int)4321, depth=(int)30, bpp=(int)32, red_mask=(int)1072693248, green_mask=(int)1047552, blue_mask=(int)1023, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]</details>
         </caps>
       </pads>
     </element>
diff --git a/docs/plugins/inspect/plugin-pango.xml b/docs/plugins/inspect/plugin-pango.xml
index 9c0e2bd..95d7d96 100644
--- a/docs/plugins/inspect/plugin-pango.xml
+++ b/docs/plugins/inspect/plugin-pango.xml
@@ -3,10 +3,10 @@
   <description>Pango-based text rendering and overlay</description>
   <filename>../../ext/pango/.libs/libgstpango.so</filename>
   <basename>libgstpango.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-playback.xml b/docs/plugins/inspect/plugin-playback.xml
index cd2dbf2..6b6b535 100644
--- a/docs/plugins/inspect/plugin-playback.xml
+++ b/docs/plugins/inspect/plugin-playback.xml
@@ -3,10 +3,10 @@
   <description>various playback elements</description>
   <filename>../../gst/playback/.libs/libgstplaybin.so</filename>
   <basename>libgstplaybin.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-subparse.xml b/docs/plugins/inspect/plugin-subparse.xml
index 862a0aa..eda6f05 100644
--- a/docs/plugins/inspect/plugin-subparse.xml
+++ b/docs/plugins/inspect/plugin-subparse.xml
@@ -3,10 +3,10 @@
   <description>Subtitle parsing</description>
   <filename>../../gst/subparse/.libs/libgstsubparse.so</filename>
   <basename>libgstsubparse.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-tcp.xml b/docs/plugins/inspect/plugin-tcp.xml
index 8b4647a..33f77d8 100644
--- a/docs/plugins/inspect/plugin-tcp.xml
+++ b/docs/plugins/inspect/plugin-tcp.xml
@@ -3,10 +3,10 @@
   <description>transfer data over the network via TCP</description>
   <filename>../../gst/tcp/.libs/libgsttcp.so</filename>
   <basename>libgsttcp.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-theora.xml b/docs/plugins/inspect/plugin-theora.xml
index b1c3ec8..a01c70e 100644
--- a/docs/plugins/inspect/plugin-theora.xml
+++ b/docs/plugins/inspect/plugin-theora.xml
@@ -3,10 +3,10 @@
   <description>Theora plugin library</description>
   <filename>../../ext/theora/.libs/libgsttheora.so</filename>
   <basename>libgsttheora.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-typefindfunctions.xml b/docs/plugins/inspect/plugin-typefindfunctions.xml
index 535a49f..f55aa1e 100644
--- a/docs/plugins/inspect/plugin-typefindfunctions.xml
+++ b/docs/plugins/inspect/plugin-typefindfunctions.xml
@@ -3,10 +3,10 @@
   <description>default typefind functions</description>
   <filename>../../gst/typefind/.libs/libgsttypefindfunctions.so</filename>
   <basename>libgsttypefindfunctions.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
   </elements>
diff --git a/docs/plugins/inspect/plugin-uridecodebin.xml b/docs/plugins/inspect/plugin-uridecodebin.xml
index bbe1fbc..38057b7 100644
--- a/docs/plugins/inspect/plugin-uridecodebin.xml
+++ b/docs/plugins/inspect/plugin-uridecodebin.xml
@@ -3,10 +3,10 @@
   <description>URI Decoder bin</description>
   <filename>../../gst/playback/.libs/libgstdecodebin2.so</filename>
   <basename>libgstdecodebin2.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-videorate.xml b/docs/plugins/inspect/plugin-videorate.xml
index 689fc2c..676b842 100644
--- a/docs/plugins/inspect/plugin-videorate.xml
+++ b/docs/plugins/inspect/plugin-videorate.xml
@@ -3,10 +3,10 @@
   <description>Adjusts video frames</description>
   <filename>../../gst/videorate/.libs/libgstvideorate.so</filename>
   <basename>libgstvideorate.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-videoscale.xml b/docs/plugins/inspect/plugin-videoscale.xml
index 7d1d524..bb96a68 100644
--- a/docs/plugins/inspect/plugin-videoscale.xml
+++ b/docs/plugins/inspect/plugin-videoscale.xml
@@ -3,10 +3,10 @@
   <description>Resizes video</description>
   <filename>../../gst/videoscale/.libs/libgstvideoscale.so</filename>
   <basename>libgstvideoscale.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -20,13 +20,13 @@
           <name>sink</name>
           <direction>sink</direction>
           <presence>always</presence>
-          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, alpha_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, alpha_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)AYUV, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y444, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)v308, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y42B, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YUY2, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YVYU, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)I420, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YV12, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y41B, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)16, depth=(int)16, endianness=(int)1234, red_mask=(int)63488, green_mask=(int)2016, blue_mask=(int)31, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)16, depth=(int)15, endianness=(int)1234, red_mask=(int)31744, green_mask=(int)992, blue_mask=(int)31, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)16, depth=(int)16, endianness=(int)1234, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y16 , width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)8, depth=(int)8, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y800, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y8  , width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)GREY, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)AY64, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)64, depth=(int)64, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
+          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, alpha_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, alpha_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)AYUV, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y444, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)v308, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y42B, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YUY2, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YVYU, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)I420, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YV12, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y41B, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)16, depth=(int)16, endianness=(int)1234, red_mask=(int)63488, green_mask=(int)2016, blue_mask=(int)31, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)16, depth=(int)15, endianness=(int)1234, red_mask=(int)31744, green_mask=(int)992, blue_mask=(int)31, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)16, depth=(int)16, endianness=(int)1234, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y16 , width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)8, depth=(int)8, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y800, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y8  , width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)GREY, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)AY64, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)64, depth=(int)64, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)NV12, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
         </caps>
         <caps>
           <name>src</name>
           <direction>source</direction>
           <presence>always</presence>
-          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, alpha_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, alpha_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)AYUV, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y444, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)v308, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y42B, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YUY2, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YVYU, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)I420, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YV12, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y41B, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)16, depth=(int)16, endianness=(int)1234, red_mask=(int)63488, green_mask=(int)2016, blue_mask=(int)31, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)16, depth=(int)15, endianness=(int)1234, red_mask=(int)31744, green_mask=(int)992, blue_mask=(int)31, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)16, depth=(int)16, endianness=(int)1234, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y16 , width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)8, depth=(int)8, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y800, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y8  , width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)GREY, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)AY64, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)64, depth=(int)64, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
+          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, alpha_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, alpha_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)AYUV, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y444, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)v308, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y42B, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YUY2, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YVYU, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)I420, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)YV12, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y41B, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)16, depth=(int)16, endianness=(int)1234, red_mask=(int)63488, green_mask=(int)2016, blue_mask=(int)31, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)16, depth=(int)15, endianness=(int)1234, red_mask=(int)31744, green_mask=(int)992, blue_mask=(int)31, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)16, depth=(int)16, endianness=(int)1234, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y16 , width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)8, depth=(int)8, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y800, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)Y8  , width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)GREY, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)AY64, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)64, depth=(int)64, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc)NV12, width=(int)[ 1, 32767 ], height=(int)[ 1, 32767 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
         </caps>
       </pads>
     </element>
diff --git a/docs/plugins/inspect/plugin-videotestsrc.xml b/docs/plugins/inspect/plugin-videotestsrc.xml
index 31b0d19..03a6803 100644
--- a/docs/plugins/inspect/plugin-videotestsrc.xml
+++ b/docs/plugins/inspect/plugin-videotestsrc.xml
@@ -3,10 +3,10 @@
   <description>Creates a test video stream</description>
   <filename>../../gst/videotestsrc/.libs/libgstvideotestsrc.so</filename>
   <basename>libgstvideotestsrc.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-volume.xml b/docs/plugins/inspect/plugin-volume.xml
index e7414e7..23f3bd2 100644
--- a/docs/plugins/inspect/plugin-volume.xml
+++ b/docs/plugins/inspect/plugin-volume.xml
@@ -3,10 +3,10 @@
   <description>plugin for controlling audio volume</description>
   <filename>../../gst/volume/.libs/libgstvolume.so</filename>
   <basename>libgstvolume.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-vorbis.xml b/docs/plugins/inspect/plugin-vorbis.xml
index 664011f..323df30 100644
--- a/docs/plugins/inspect/plugin-vorbis.xml
+++ b/docs/plugins/inspect/plugin-vorbis.xml
@@ -3,10 +3,10 @@
   <description>Vorbis plugin library</description>
   <filename>../../ext/vorbis/.libs/libgstvorbis.so</filename>
   <basename>libgstvorbis.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-ximagesink.xml b/docs/plugins/inspect/plugin-ximagesink.xml
index 8a23410..d9bc6c0 100644
--- a/docs/plugins/inspect/plugin-ximagesink.xml
+++ b/docs/plugins/inspect/plugin-ximagesink.xml
@@ -3,10 +3,10 @@
   <description>X11 video output element based on standard Xlib calls</description>
   <filename>../../sys/ximage/.libs/libgstximagesink.so</filename>
   <basename>libgstximagesink.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-xvimagesink.xml b/docs/plugins/inspect/plugin-xvimagesink.xml
index 8e11797..d18497b 100644
--- a/docs/plugins/inspect/plugin-xvimagesink.xml
+++ b/docs/plugins/inspect/plugin-xvimagesink.xml
@@ -3,10 +3,10 @@
   <description>XFree86 video output plugin using Xv extension</description>
   <filename>../../sys/xvimage/.libs/libgstxvimagesink.so</filename>
   <basename>libgstxvimagesink.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gst-plugins-base</source>
-  <package>GStreamer Base Plug-ins source release</package>
+  <package>GStreamer Base Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/ext/alsa/gstalsadeviceprobe.c b/ext/alsa/gstalsadeviceprobe.c
index 4b22d34..337c21b 100644
--- a/ext/alsa/gstalsadeviceprobe.c
+++ b/ext/alsa/gstalsadeviceprobe.c
@@ -19,6 +19,10 @@
  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/ext/alsa/gstalsasink.c b/ext/alsa/gstalsasink.c
index 53fd1c2..7a5604a 100644
--- a/ext/alsa/gstalsasink.c
+++ b/ext/alsa/gstalsasink.c
@@ -290,9 +290,11 @@ gst_alsasink_init (GstAlsaSink * alsasink, GstAlsaSinkClass * g_class)
 }
 
 #define CHECK(call, error) \
-G_STMT_START {                  \
-if ((err = call) < 0)           \
-  goto error;                   \
+G_STMT_START {             \
+  if ((err = call) < 0) {  \
+    GST_WARNING_OBJECT (alsa, "Error %d (%s) calling " #call, err, snd_strerror (err)); \
+    goto error;            \
+  }                        \
 } G_STMT_END;
 
 static GstCaps *
diff --git a/ext/pango/gsttextoverlay.c b/ext/pango/gsttextoverlay.c
index a92659f..329be50 100644
--- a/ext/pango/gsttextoverlay.c
+++ b/ext/pango/gsttextoverlay.c
@@ -375,7 +375,7 @@ gst_text_overlay_base_init (gpointer g_class)
     g_mutex_lock (klass->pango_lock);
   fontmap = pango_cairo_font_map_get_default ();
   klass->pango_context =
-      pango_cairo_font_map_create_context (PANGO_CAIRO_FONT_MAP (fontmap));
+      pango_font_map_create_context (PANGO_FONT_MAP (fontmap));
   if (klass->pango_lock)
     g_mutex_unlock (klass->pango_lock);
 }
@@ -743,7 +743,8 @@ gst_text_overlay_update_render_mode (GstTextOverlay * overlay)
   } else {
     pango_context_set_base_gravity (context, PANGO_GRAVITY_SOUTH);
     pango_context_set_matrix (context, &matrix);
-    pango_layout_set_alignment (overlay->layout, overlay->line_align);
+    pango_layout_set_alignment (overlay->layout,
+        (PangoAlignment) overlay->line_align);
   }
 }
 
diff --git a/ext/pango/gsttextrender.c b/ext/pango/gsttextrender.c
index 38ea44a..6a9a29b 100644
--- a/ext/pango/gsttextrender.c
+++ b/ext/pango/gsttextrender.c
@@ -203,7 +203,7 @@ gst_text_render_class_init (GstTextRenderClass * klass)
 
   fontmap = pango_cairo_font_map_get_default ();
   klass->pango_context =
-      pango_cairo_font_map_create_context (PANGO_CAIRO_FONT_MAP (fontmap));
+      pango_font_map_create_context (PANGO_FONT_MAP (fontmap));
   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_FONT_DESC,
       g_param_spec_string ("font-desc", "font description",
           "Pango font description of font "
diff --git a/ext/theora/gsttheoraenc.c b/ext/theora/gsttheoraenc.c
index f468439..bff2384 100644
--- a/ext/theora/gsttheoraenc.c
+++ b/ext/theora/gsttheoraenc.c
@@ -130,6 +130,7 @@ _ilog (unsigned int v)
 #define THEORA_DEF_RATE_BUFFER          0
 #define THEORA_DEF_MULTIPASS_CACHE_FILE NULL
 #define THEORA_DEF_MULTIPASS_MODE       MULTIPASS_MODE_SINGLE_PASS
+#define THEORA_DEF_DUP_ON_GAP           FALSE
 enum
 {
   PROP_0,
@@ -152,7 +153,8 @@ enum
   PROP_CAP_UNDERFLOW,
   PROP_RATE_BUFFER,
   PROP_MULTIPASS_CACHE_FILE,
-  PROP_MULTIPASS_MODE
+  PROP_MULTIPASS_MODE,
+  PROP_DUP_ON_GAP
       /* FILL ME */
 };
 
@@ -279,6 +281,11 @@ static gboolean theora_enc_write_multipass_cache (GstTheoraEnc * enc,
 
 static char *theora_enc_get_supported_formats (void);
 
+static void theora_timefifo_free (GstTheoraEnc * enc);
+static GstFlowReturn
+theora_enc_encode_and_push (GstTheoraEnc * enc, ogg_packet op,
+    GstBuffer * buffer);
+
 static void
 gst_theora_enc_base_init (gpointer g_class)
 {
@@ -418,6 +425,16 @@ gst_theora_enc_class_init (GstTheoraEncClass * klass)
           "Single pass or first/second pass", GST_TYPE_MULTIPASS_MODE,
           THEORA_DEF_MULTIPASS_MODE,
           (GParamFlags) G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_DUP_ON_GAP,
+      g_param_spec_boolean ("dup-on-gap", "Create DUP frame on GAP flag",
+          "Allow codec to handle frames with GAP flag as duplicates "
+          "of previous frame. "
+          "This is good to work with variable frame rate stabilized "
+          "by videorate element. It will add variable latency with maximal "
+          "size of keyframe distance, this way it is a bad idea "
+          "to use with live streams.",
+          THEORA_DEF_DUP_ON_GAP,
+          (GParamFlags) G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   caps_string = g_strdup_printf ("video/x-raw-yuv, "
       "format = (fourcc) { %s }, "
@@ -463,6 +480,7 @@ gst_theora_enc_init (GstTheoraEnc * enc, GstTheoraEncClass * g_class)
   enc->cap_overflow = THEORA_DEF_CAP_OVERFLOW;
   enc->cap_underflow = THEORA_DEF_CAP_UNDERFLOW;
   enc->rate_buffer = THEORA_DEF_RATE_BUFFER;
+  enc->dup_on_gap = THEORA_DEF_DUP_ON_GAP;
 
   enc->multipass_mode = THEORA_DEF_MULTIPASS_MODE;
   enc->multipass_cache_file = THEORA_DEF_MULTIPASS_CACHE_FILE;
@@ -565,6 +583,8 @@ theora_enc_clear (GstTheoraEnc * enc)
   enc->granulepos_offset = 0;
   enc->timestamp_offset = 0;
 
+  theora_timefifo_free (enc);
+
   enc->next_ts = GST_CLOCK_TIME_NONE;
   enc->next_discont = FALSE;
   enc->expected_ts = GST_CLOCK_TIME_NONE;
@@ -906,6 +926,9 @@ theora_enc_sink_event (GstPad * pad, GstEvent * event)
     }
     case GST_EVENT_EOS:
       if (enc->initialised) {
+        /* clear all standing buffers */
+        if (enc->dup_on_gap)
+          theora_enc_encode_and_push (enc, op, NULL);
         /* push last packet with eos flag, should not be called */
         while (th_encode_packetout (enc->encoder, 1, &op)) {
           GstClockTime next_time =
@@ -927,6 +950,7 @@ theora_enc_sink_event (GstPad * pad, GstEvent * event)
     case GST_EVENT_FLUSH_STOP:
       gst_segment_init (&enc->segment, GST_FORMAT_UNDEFINED);
       res = gst_pad_push_event (enc->srcpad, event);
+      theora_timefifo_free (enc);
       break;
     case GST_EVENT_CUSTOM_DOWNSTREAM:
     {
@@ -1149,18 +1173,193 @@ theora_enc_write_multipass_cache (GstTheoraEnc * enc, gboolean begin,
   return TRUE;
 }
 
+/**
+ * g_slice_free can't be used with g_queue_foreach.
+ * so we create new function with predefined GstClockTime size.
+ */
+static void
+theora_free_gstclocktime (gpointer mem)
+{
+  g_slice_free (GstClockTime, mem);
+}
+
+static void
+theora_timefifo_in (GstTheoraEnc * enc, const GstClockTime * timestamp)
+{
+  GstClockTime *ptr;
+
+  if (!enc->t_queue)
+    enc->t_queue = g_queue_new ();
+
+  g_assert (enc->t_queue != NULL);
+
+  ptr = g_slice_new (GstClockTime);
+  *ptr = *timestamp;
+
+  g_queue_push_head (enc->t_queue, ptr);
+}
+
+static GstClockTime
+theora_timefifo_out (GstTheoraEnc * enc)
+{
+  GstClockTime ret, *ptr;
+
+  g_assert (enc->t_queue != NULL);
+
+  ptr = g_queue_pop_tail (enc->t_queue);
+  g_assert (ptr != NULL);
+
+  ret = *ptr;
+  theora_free_gstclocktime (ptr);
+
+  return ret;
+}
+
+/**
+ * theora_timefifo_truncate - truncate the timestamp queue.
+ * After frame encoding we should have only one buffer for next time.
+ * The count of timestamps should be the same. If it is less,
+ * some thing really bad has happened. If it is bigger, encoder
+ * decided to return less then we ordered.
+ * TODO: for now we will just drop this timestamps. The better solution
+ * probably will be to recovery frames by recovery timestamps with
+ * last buffer.
+ */
+static void
+theora_timefifo_truncate (GstTheoraEnc * enc)
+{
+  if (enc->dup_on_gap) {
+    guint length;
+    g_assert (enc->t_queue != NULL);
+    length = g_queue_get_length (enc->t_queue);
+
+    if (length > 1) {
+      /* it is also not good if we have more then 1. */
+      GST_DEBUG_OBJECT (enc, "Dropping %u time stamps", length - 1);
+      while (g_queue_get_length (enc->t_queue) > 1) {
+        theora_timefifo_out (enc);
+      }
+    }
+  }
+}
+
+static void
+theora_timefifo_free (GstTheoraEnc * enc)
+{
+  if (enc->t_queue) {
+    if (g_queue_get_length (enc->t_queue))
+      g_queue_foreach (enc->t_queue, (GFunc) theora_free_gstclocktime, NULL);
+    g_queue_free (enc->t_queue);
+    enc->t_queue = NULL;
+  }
+  /* prevbuf makes no sense without timestamps,
+   * so clear it too. */
+  if (enc->prevbuf) {
+    gst_buffer_unref (enc->prevbuf);
+    enc->prevbuf = NULL;
+  }
+
+}
+
+static void
+theora_update_prevbuf (GstTheoraEnc * enc, GstBuffer * buffer)
+{
+  if (enc->prevbuf) {
+    gst_buffer_unref (enc->prevbuf);
+    enc->prevbuf = NULL;
+  }
+  enc->prevbuf = gst_buffer_ref (buffer);
+}
+
+/**
+ * theora_enc_encode_and_push - encode buffer or queued previous buffer
+ * buffer - buffer to encode. If set to NULL it should encode only
+ *          queued buffers and produce dups if needed.
+ */
+
 static GstFlowReturn
 theora_enc_encode_and_push (GstTheoraEnc * enc, ogg_packet op,
-    GstClockTime timestamp, GstClockTime running_time,
-    GstClockTime duration, GstBuffer * buffer)
+    GstBuffer * buffer)
 {
   GstFlowReturn ret;
   th_ycbcr_buffer ycbcr;
   gint res;
 
-  theora_enc_init_buffer (ycbcr, &enc->info, GST_BUFFER_DATA (buffer));
-
-  if (theora_enc_is_discontinuous (enc, running_time, duration)) {
+  if (enc->dup_on_gap) {
+    guint t_queue_length;
+
+    if (enc->t_queue)
+      t_queue_length = g_queue_get_length (enc->t_queue);
+    else
+      t_queue_length = 0;
+
+    if (buffer) {
+      GstClockTime timestamp = GST_BUFFER_TIMESTAMP (buffer);
+
+      /* videorate can easy create 200 dup frames in one shot.
+       * In this case th_encode_ctl will just return TH_EINVAL
+       * and we will generate only one frame as result.
+       * To make us more bullet proof, make sure we have no
+       * more dup frames than keyframe interval.
+       */
+      if (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_GAP) &&
+          enc->keyframe_force > t_queue_length) {
+        GST_DEBUG_OBJECT (enc, "Got GAP frame, queue as duplicate.");
+
+        theora_timefifo_in (enc, &timestamp);
+        gst_buffer_unref (buffer);
+        return GST_FLOW_OK;
+      } else {
+        theora_timefifo_in (enc, &timestamp);
+        /* We should have one frame delay to create correct frame order.
+         * First time we got buffer, prevbuf should be empty. Nothing else
+         * should be done here.
+         */
+        if (!enc->prevbuf) {
+          theora_update_prevbuf (enc, buffer);
+          gst_buffer_unref (buffer);
+          return GST_FLOW_OK;
+        } else {
+          theora_update_prevbuf (enc, buffer);
+          /* after theora_update_prevbuf t_queue_length was changed */
+          t_queue_length++;
+
+          if (t_queue_length > 2) {
+            /* now in t_queue_length should be two real buffers: current and
+             * previous. All others are timestamps of duplicate frames. */
+            t_queue_length -= 2;
+            res = th_encode_ctl (enc->encoder, TH_ENCCTL_SET_DUP_COUNT,
+                &t_queue_length, sizeof (t_queue_length));
+            if (res < 0)
+              GST_WARNING_OBJECT (enc, "Failed marking dups for last frame");
+          }
+        }
+      }
+    } else {
+      /* if there is no buffer, then probably we got EOS or discontinuous.
+       * We need to encode every thing what was left in the queue
+       */
+      GST_DEBUG_OBJECT (enc, "Encode collected buffers.");
+      if (t_queue_length > 1) {
+        t_queue_length--;
+        res = th_encode_ctl (enc->encoder, TH_ENCCTL_SET_DUP_COUNT,
+            &t_queue_length, sizeof (t_queue_length));
+        if (res < 0)
+          GST_WARNING_OBJECT (enc, "Failed marking dups for last frame.");
+      } else {
+        GST_DEBUG_OBJECT (enc, "Prevbuffer is empty. Nothing to encode.");
+        return GST_FLOW_OK;
+      }
+    }
+    theora_enc_init_buffer (ycbcr, &enc->info, GST_BUFFER_DATA (enc->prevbuf));
+  } else
+    theora_enc_init_buffer (ycbcr, &enc->info, GST_BUFFER_DATA (buffer));
+
+  /* check for buffer, it can be optional */
+  if (enc->current_discont && buffer) {
+    GstClockTime timestamp = GST_BUFFER_TIMESTAMP (buffer);
+    GstClockTime running_time =
+        gst_segment_to_running_time (&enc->segment, GST_FORMAT_TIME, timestamp);
     theora_enc_reset (enc);
     enc->granulepos_offset =
         gst_util_uint64_scale (running_time, enc->fps_n,
@@ -1177,6 +1376,11 @@ theora_enc_encode_and_push (GstTheoraEnc * enc, ogg_packet op,
       goto multipass_read_failed;
     }
   }
+#ifdef TH_ENCCTL_SET_DUPLICATE_FLAG
+  if (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_GAP)) {
+    th_encode_ctl (enc->encoder, TH_ENCCTL_SET_DUPLICATE_FLAG, NULL, 0);
+  }
+#endif
 
   res = th_encode_ycbcr_in (enc->encoder, ycbcr);
   /* none of the failure cases can happen here */
@@ -1192,19 +1396,32 @@ theora_enc_encode_and_push (GstTheoraEnc * enc, ogg_packet op,
 
   ret = GST_FLOW_OK;
   while (th_encode_packetout (enc->encoder, 0, &op)) {
-    GstClockTime next_time;
+    GstClockTime next_time, duration;
+    GstClockTime timestamp = 0;
+    GST_DEBUG_OBJECT (enc, "encoded. granule:%" G_GINT64_FORMAT ", packet:%p, "
+        "bytes:%ld", (gint64) op.granulepos, op.packet, op.bytes);
 
     next_time = th_granule_time (enc->encoder, op.granulepos) * GST_SECOND;
+    duration = next_time - enc->next_ts;
 
-    ret =
-        theora_push_packet (enc, &op, timestamp, enc->next_ts,
-        next_time - enc->next_ts);
+    if (enc->dup_on_gap && !enc->current_discont)
+      timestamp = theora_timefifo_out (enc);
+    else
+      timestamp = GST_BUFFER_TIMESTAMP (buffer);
+
+    ret = theora_push_packet (enc, &op, timestamp, enc->next_ts, duration);
 
     enc->next_ts = next_time;
-    if (ret != GST_FLOW_OK)
+    if (ret != GST_FLOW_OK) {
+      theora_timefifo_truncate (enc);
       goto data_push;
+    }
   }
-  gst_buffer_unref (buffer);
+
+  theora_timefifo_truncate (enc);
+  if (buffer)
+    gst_buffer_unref (buffer);
+  enc->current_discont = FALSE;
 
   return ret;
 
@@ -1374,8 +1591,14 @@ theora_enc_chain (GstPad * pad, GstBuffer * buffer)
     enc->next_ts = 0;
   }
 
-  ret = theora_enc_encode_and_push (enc, op, timestamp, running_time, duration,
-      buffer);
+  enc->current_discont = theora_enc_is_discontinuous (enc,
+      running_time, duration);
+
+  /* empty queue if discontinuous */
+  if (enc->current_discont && enc->dup_on_gap)
+    theora_enc_encode_and_push (enc, op, NULL);
+
+  ret = theora_enc_encode_and_push (enc, op, buffer);
 
   return ret;
 
@@ -1557,6 +1780,9 @@ theora_enc_set_property (GObject * object, guint prop_id,
     case PROP_MULTIPASS_MODE:
       enc->multipass_mode = g_value_get_enum (value);
       break;
+    case PROP_DUP_ON_GAP:
+      enc->dup_on_gap = g_value_get_boolean (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1634,6 +1860,9 @@ theora_enc_get_property (GObject * object, guint prop_id,
     case PROP_MULTIPASS_MODE:
       g_value_set_enum (value, enc->multipass_mode);
       break;
+    case PROP_DUP_ON_GAP:
+      g_value_set_boolean (value, enc->dup_on_gap);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
diff --git a/ext/theora/gsttheoraenc.h b/ext/theora/gsttheoraenc.h
index 69d4050..fdb43ff 100644
--- a/ext/theora/gsttheoraenc.h
+++ b/ext/theora/gsttheoraenc.h
@@ -122,6 +122,13 @@ struct _GstTheoraEnc
   gboolean cap_underflow;
   int rate_buffer;
 
+  /* variables for dup-on-gap */
+  gboolean dup_on_gap;
+  gboolean current_discont;
+  GstBuffer *prevbuf;
+  GQueue *t_queue;
+  /* end dup-on-gap */
+
   GstTheoraEncMultipassMode multipass_mode;
   GIOChannel *multipass_cache_fd;
   GstAdapter *multipass_cache_adapter;
diff --git a/ext/theora/gsttheoraparse.c b/ext/theora/gsttheoraparse.c
index 4e356c6..ed5e934 100644
--- a/ext/theora/gsttheoraparse.c
+++ b/ext/theora/gsttheoraparse.c
@@ -56,6 +56,10 @@
  * Last reviewed on 2008-05-28 (0.10.20)
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
diff --git a/ext/vorbis/gstvorbisdec.c b/ext/vorbis/gstvorbisdec.c
index f476d45..b17ebfe 100644
--- a/ext/vorbis/gstvorbisdec.c
+++ b/ext/vorbis/gstvorbisdec.c
@@ -128,14 +128,6 @@ vorbis_dec_finalize (GObject * object)
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
-static void
-gst_vorbis_dec_reset (GstVorbisDec * dec)
-{
-  if (dec->taglist)
-    gst_tag_list_free (dec->taglist);
-  dec->taglist = NULL;
-}
-
 static gboolean
 vorbis_dec_start (GstAudioDecoder * dec)
 {
@@ -145,7 +137,6 @@ vorbis_dec_start (GstAudioDecoder * dec)
   vorbis_info_init (&vd->vi);
   vorbis_comment_init (&vd->vc);
   vd->initialized = FALSE;
-  gst_vorbis_dec_reset (vd);
 
   return TRUE;
 }
@@ -163,7 +154,6 @@ vorbis_dec_stop (GstAudioDecoder * dec)
   vorbis_dsp_clear (&vd->vd);
   vorbis_comment_clear (&vd->vc);
   vorbis_info_clear (&vd->vi);
-  gst_vorbis_dec_reset (vd);
 
   return TRUE;
 }
@@ -308,7 +298,7 @@ vorbis_handle_comment_packet (GstVorbisDec * vd, ogg_packet * packet)
 {
   guint bitrate = 0;
   gchar *encoder = NULL;
-  GstTagList *list, *old_list;
+  GstTagList *list;
   GstBuffer *buf;
 
   GST_DEBUG_OBJECT (vd, "parsing comment packet");
@@ -321,58 +311,53 @@ vorbis_handle_comment_packet (GstVorbisDec * vd, ogg_packet * packet)
       gst_tag_list_from_vorbiscomment_buffer (buf, (guint8 *) "\003vorbis", 7,
       &encoder);
 
-  old_list = vd->taglist;
-  vd->taglist = gst_tag_list_merge (vd->taglist, list, GST_TAG_MERGE_REPLACE);
+  if (!list) {
+    GST_ERROR_OBJECT (vd, "couldn't decode comments");
+    list = gst_tag_list_new ();
+  }
 
-  if (old_list)
-    gst_tag_list_free (old_list);
-  gst_tag_list_free (list);
   gst_buffer_unref (buf);
 
-  if (!vd->taglist) {
-    GST_ERROR_OBJECT (vd, "couldn't decode comments");
-    vd->taglist = gst_tag_list_new ();
-  }
   if (encoder) {
     if (encoder[0])
-      gst_tag_list_add (vd->taglist, GST_TAG_MERGE_REPLACE,
+      gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
           GST_TAG_ENCODER, encoder, NULL);
     g_free (encoder);
   }
-  gst_tag_list_add (vd->taglist, GST_TAG_MERGE_REPLACE,
+  gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
       GST_TAG_ENCODER_VERSION, vd->vi.version,
       GST_TAG_AUDIO_CODEC, "Vorbis", NULL);
   if (vd->vi.bitrate_nominal > 0 && vd->vi.bitrate_nominal <= 0x7FFFFFFF) {
-    gst_tag_list_add (vd->taglist, GST_TAG_MERGE_REPLACE,
+    gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
         GST_TAG_NOMINAL_BITRATE, (guint) vd->vi.bitrate_nominal, NULL);
     bitrate = vd->vi.bitrate_nominal;
   }
   if (vd->vi.bitrate_upper > 0 && vd->vi.bitrate_upper <= 0x7FFFFFFF) {
-    gst_tag_list_add (vd->taglist, GST_TAG_MERGE_REPLACE,
+    gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
         GST_TAG_MAXIMUM_BITRATE, (guint) vd->vi.bitrate_upper, NULL);
     if (!bitrate)
       bitrate = vd->vi.bitrate_upper;
   }
   if (vd->vi.bitrate_lower > 0 && vd->vi.bitrate_lower <= 0x7FFFFFFF) {
-    gst_tag_list_add (vd->taglist, GST_TAG_MERGE_REPLACE,
+    gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
         GST_TAG_MINIMUM_BITRATE, (guint) vd->vi.bitrate_lower, NULL);
     if (!bitrate)
       bitrate = vd->vi.bitrate_lower;
   }
   if (bitrate) {
-    gst_tag_list_add (vd->taglist, GST_TAG_MERGE_REPLACE,
+    gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
         GST_TAG_BITRATE, (guint) bitrate, NULL);
   }
 
+  gst_audio_decoder_merge_tags (GST_AUDIO_DECODER_CAST (vd), list,
+      GST_TAG_MERGE_REPLACE);
   if (vd->initialized) {
-    gst_element_found_tags_for_pad (GST_ELEMENT_CAST (vd),
-        GST_AUDIO_DECODER_SRC_PAD (vd), vd->taglist);
-    vd->taglist = NULL;
+    gst_tag_list_free (list);
   } else {
     /* Only post them as messages for the time being. *
      * They will be pushed on the pad once the decoder is initialized */
     gst_element_post_message (GST_ELEMENT_CAST (vd),
-        gst_message_new_tag (GST_OBJECT (vd), gst_tag_list_copy (vd->taglist)));
+        gst_message_new_tag (GST_OBJECT (vd), list));
   }
 
   return GST_FLOW_OK;
@@ -398,12 +383,6 @@ vorbis_handle_type_packet (GstVorbisDec * vd)
 
   vd->initialized = TRUE;
 
-  if (vd->taglist) {
-    /* The tags have already been sent on the bus as messages. */
-    gst_pad_push_event (GST_AUDIO_DECODER_SRC_PAD (vd),
-        gst_event_new_tag (vd->taglist));
-    vd->taglist = NULL;
-  }
   return GST_FLOW_OK;
 
   /* ERRORS */
@@ -728,7 +707,4 @@ vorbis_dec_flush (GstAudioDecoder * dec, gboolean hard)
 #ifdef HAVE_VORBIS_SYNTHESIS_RESTART
   vorbis_synthesis_restart (&vd->vd);
 #endif
-
-  if (hard)
-    gst_vorbis_dec_reset (vd);
 }
diff --git a/ext/vorbis/gstvorbisdec.h b/ext/vorbis/gstvorbisdec.h
index 56f9ca4..712e50e 100644
--- a/ext/vorbis/gstvorbisdec.h
+++ b/ext/vorbis/gstvorbisdec.h
@@ -64,8 +64,6 @@ struct _GstVorbisDec {
   gboolean          initialized;
   guint             width;
 
-  GstTagList       *taglist;
-
   CopySampleFunc    copy_samples;
 };
 
diff --git a/ext/vorbis/gstvorbisdeclib.h b/ext/vorbis/gstvorbisdeclib.h
index ca00af9..e147591 100644
--- a/ext/vorbis/gstvorbisdeclib.h
+++ b/ext/vorbis/gstvorbisdeclib.h
@@ -29,11 +29,6 @@
 
 #ifndef TREMOR
 
-#include <vorbis/codec.h>
-
-typedef float                          vorbis_sample_t;
-typedef ogg_packet                     ogg_packet_wrapper;
-
 #define GST_VORBIS_DEC_DESCRIPTION "decode raw vorbis streams to float audio"
 
 #define GST_VORBIS_DEC_SRC_CAPS \
@@ -47,6 +42,42 @@ typedef ogg_packet                     ogg_packet_wrapper;
 
 #define GST_VORBIS_DEC_GLIB_TYPE_NAME      GstVorbisDec
 
+#else /* TREMOR */
+
+#define GST_VORBIS_DEC_DESCRIPTION "decode raw vorbis streams to integer audio"
+
+#define GST_VORBIS_DEC_SRC_CAPS \
+    GST_STATIC_CAPS ("audio/x-raw-int, "   \
+        "rate = (int) [ 1, MAX ], "        \
+        "channels = (int) [ 1, 6 ], "      \
+        "endianness = (int) BYTE_ORDER, "  \
+        "width = (int) { 16, 32 }, "       \
+        "depth = (int) 16, "               \
+        "signed = (boolean) true")
+
+#define GST_VORBIS_DEC_DEFAULT_SAMPLE_WIDTH           (16)
+
+/* we need a different type name here */
+#define GST_VORBIS_DEC_GLIB_TYPE_NAME      GstIVorbisDec
+
+/* and still have it compile */
+typedef struct _GstVorbisDec               GstIVorbisDec;
+typedef struct _GstVorbisDecClass          GstIVorbisDecClass;
+
+#endif /* TREMOR */
+
+#ifndef USE_TREMOLO
+
+#ifdef TREMOR
+ #include <tremor/ivorbiscodec.h>
+ typedef ogg_int32_t                    vorbis_sample_t;
+#else
+ #include <vorbis/codec.h>
+ typedef float                          vorbis_sample_t;
+#endif
+
+typedef ogg_packet                     ogg_packet_wrapper;
+
 static inline guint8 *
 gst_ogg_packet_data (ogg_packet * p)
 {
@@ -72,17 +103,11 @@ gst_ogg_packet_from_wrapper (ogg_packet_wrapper * packet)
   return packet;
 }
 
-#else
-
-#ifdef USE_TREMOLO
-  #include <Tremolo/ivorbiscodec.h>
-  #include <Tremolo/codec_internal.h>
-  typedef ogg_int16_t                    vorbis_sample_t;
-#else
-  #include <tremor/ivorbiscodec.h>
-  typedef ogg_int32_t                    vorbis_sample_t;
-#endif
+#else /* USE_TREMOLO */
 
+#include <Tremolo/ivorbiscodec.h>
+#include <Tremolo/codec_internal.h>
+typedef ogg_int16_t                    vorbis_sample_t;
 typedef struct _ogg_packet_wrapper     ogg_packet_wrapper;
 
 struct _ogg_packet_wrapper {
@@ -91,26 +116,6 @@ struct _ogg_packet_wrapper {
   ogg_buffer          buf;
 };
 
-#define GST_VORBIS_DEC_DESCRIPTION "decode raw vorbis streams to integer audio"
-
-#define GST_VORBIS_DEC_SRC_CAPS \
-    GST_STATIC_CAPS ("audio/x-raw-int, "   \
-        "rate = (int) [ 1, MAX ], "        \
-        "channels = (int) [ 1, 6 ], "      \
-        "endianness = (int) BYTE_ORDER, "  \
-        "width = (int) { 16, 32 }, "       \
-        "depth = (int) 16, "               \
-        "signed = (boolean) true")
-
-#define GST_VORBIS_DEC_DEFAULT_SAMPLE_WIDTH           (16)
-
-/* we need a different type name here */
-#define GST_VORBIS_DEC_GLIB_TYPE_NAME      GstIVorbisDec
-
-/* and still have it compile */
-typedef struct _GstVorbisDec               GstIVorbisDec;
-typedef struct _GstVorbisDecClass          GstIVorbisDecClass;
-
 /* compensate minor variation */
 #define vorbis_synthesis(a, b)             vorbis_synthesis (a, b, 1)
 
@@ -154,7 +159,7 @@ gst_ogg_packet_from_wrapper (ogg_packet_wrapper * packet)
   return &(packet->packet);
 }
 
-#endif
+#endif /* USE_TREMOLO */
 
 typedef void (*CopySampleFunc)(vorbis_sample_t *out, vorbis_sample_t **in,
                            guint samples, gint channels, gint width);
diff --git a/gst-libs/gst/app/gstappsink.c b/gst-libs/gst/app/gstappsink.c
index 9a891b6..871d6f0 100644
--- a/gst-libs/gst/app/gstappsink.c
+++ b/gst-libs/gst/app/gstappsink.c
@@ -158,6 +158,7 @@ static gboolean gst_app_sink_unlock_stop (GstBaseSink * bsink);
 static gboolean gst_app_sink_start (GstBaseSink * psink);
 static gboolean gst_app_sink_stop (GstBaseSink * psink);
 static gboolean gst_app_sink_event (GstBaseSink * sink, GstEvent * event);
+static gboolean gst_app_sink_query (GstBaseSink * bsink, GstQuery * query);
 static GstFlowReturn gst_app_sink_preroll (GstBaseSink * psink,
     GstBuffer * buffer);
 static GstFlowReturn gst_app_sink_render_common (GstBaseSink * psink,
@@ -436,6 +437,7 @@ gst_app_sink_class_init (GstAppSinkClass * klass)
   basesink_class->render = gst_app_sink_render;
   basesink_class->render_list = gst_app_sink_render_list;
   basesink_class->get_caps = gst_app_sink_getcaps;
+  basesink_class->query = gst_app_sink_query;
 
   klass->pull_preroll = gst_app_sink_pull_preroll;
   klass->pull_buffer = gst_app_sink_pull_buffer;
@@ -875,6 +877,30 @@ gst_app_sink_getcaps (GstBaseSink * psink)
   return caps;
 }
 
+static gboolean
+gst_app_sink_query (GstBaseSink * bsink, GstQuery * query)
+{
+  gboolean ret;
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_SEEKING:{
+      GstFormat fmt;
+
+      /* we don't supporting seeking */
+      gst_query_parse_seeking (query, &fmt, NULL, NULL, NULL);
+      gst_query_set_seeking (query, fmt, FALSE, 0, -1);
+      ret = TRUE;
+      break;
+    }
+
+    default:
+      ret = GST_BASE_SINK_CLASS (parent_class)->query (bsink, query);
+      break;
+  }
+
+  return ret;
+}
+
 static GstMiniObject *
 gst_app_sink_pull_object (GstAppSink * appsink)
 {
diff --git a/gst-libs/gst/audio/gstaudiodecoder.c b/gst-libs/gst/audio/gstaudiodecoder.c
index e35779e..6bc054d 100644
--- a/gst-libs/gst/audio/gstaudiodecoder.c
+++ b/gst-libs/gst/audio/gstaudiodecoder.c
@@ -220,6 +220,7 @@ struct _GstAudioDecoderPrivate
   GstAdapter *adapter;
   /* tracking input ts for changes */
   GstClockTime prev_ts;
+  guint64 prev_distance;
   /* frames obtained from input */
   GQueue frames;
   /* collected output data */
@@ -323,7 +324,8 @@ gst_audio_decoder_class_init (GstAudioDecoderClass * klass)
   gobject_class->get_property = gst_audio_decoder_get_property;
   gobject_class->finalize = gst_audio_decoder_finalize;
 
-  element_class->change_state = gst_audio_decoder_change_state;
+  element_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_audio_decoder_change_state);
 
   /* Properties */
   g_object_class_install_property (gobject_class, PROP_LATENCY,
@@ -444,6 +446,7 @@ gst_audio_decoder_reset (GstAudioDecoder * dec, gboolean full)
   dec->priv->out_ts = GST_CLOCK_TIME_NONE;
   dec->priv->out_dur = 0;
   dec->priv->prev_ts = GST_CLOCK_TIME_NONE;
+  dec->priv->prev_distance = 0;
   dec->priv->drained = TRUE;
   dec->priv->base_ts = GST_CLOCK_TIME_NONE;
   dec->priv->samples = 0;
@@ -976,6 +979,7 @@ gst_audio_decoder_push_buffers (GstAudioDecoder * dec, gboolean force)
     if (G_LIKELY (av)) {
       gint len;
       GstClockTime ts;
+      guint64 distance;
 
       /* parse if needed */
       if (klass->parse) {
@@ -990,7 +994,7 @@ gst_audio_decoder_push_buffers (GstAudioDecoder * dec, gboolean force)
         g_assert (offset <= av);
         if (offset) {
           /* jumped a bit */
-          GST_DEBUG_OBJECT (dec, "setting DISCONT");
+          GST_DEBUG_OBJECT (dec, "skipped %d; setting DISCONT", offset);
           gst_adapter_flush (priv->adapter, offset);
           flush = offset;
           /* avoid parsing indefinitely */
@@ -1015,12 +1019,13 @@ gst_audio_decoder_push_buffers (GstAudioDecoder * dec, gboolean force)
         len = av;
       }
       /* track upstream ts, but do not get stuck if nothing new upstream */
-      ts = gst_adapter_prev_timestamp (priv->adapter, NULL);
-      if (ts == priv->prev_ts) {
+      ts = gst_adapter_prev_timestamp (priv->adapter, &distance);
+      if (ts != priv->prev_ts || distance <= priv->prev_distance) {
+        priv->prev_ts = ts;
+        priv->prev_distance = distance;
+      } else {
         GST_LOG_OBJECT (dec, "ts == prev_ts; discarding");
         ts = GST_CLOCK_TIME_NONE;
-      } else {
-        priv->prev_ts = ts;
       }
       buffer = gst_adapter_take_buffer (priv->adapter, len);
       buffer = gst_buffer_make_metadata_writable (buffer);
@@ -2069,12 +2074,18 @@ static GstStateChangeReturn
 gst_audio_decoder_change_state (GstElement * element, GstStateChange transition)
 {
   GstAudioDecoder *codec;
+  GstAudioDecoderClass *klass;
   GstStateChangeReturn ret;
 
   codec = GST_AUDIO_DECODER (element);
+  klass = GST_AUDIO_DECODER_GET_CLASS (codec);
 
   switch (transition) {
     case GST_STATE_CHANGE_NULL_TO_READY:
+      if (klass->open) {
+        if (!klass->open (codec))
+          goto open_failed;
+      }
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
       if (!gst_audio_decoder_start (codec)) {
@@ -2098,6 +2109,10 @@ gst_audio_decoder_change_state (GstElement * element, GstStateChange transition)
       }
       break;
     case GST_STATE_CHANGE_READY_TO_NULL:
+      if (klass->close) {
+        if (!klass->close (codec))
+          goto close_failed;
+      }
       break;
     default:
       break;
@@ -2115,6 +2130,16 @@ stop_failed:
     GST_ELEMENT_ERROR (codec, LIBRARY, INIT, (NULL), ("Failed to stop codec"));
     return GST_STATE_CHANGE_FAILURE;
   }
+open_failed:
+  {
+    GST_ELEMENT_ERROR (codec, LIBRARY, INIT, (NULL), ("Failed to open codec"));
+    return GST_STATE_CHANGE_FAILURE;
+  }
+close_failed:
+  {
+    GST_ELEMENT_ERROR (codec, LIBRARY, INIT, (NULL), ("Failed to close codec"));
+    return GST_STATE_CHANGE_FAILURE;
+  }
 }
 
 GstFlowReturn
@@ -2584,3 +2609,40 @@ gst_audio_decoder_get_needs_format (GstAudioDecoder * dec)
 
   return result;
 }
+
+/**
+ * gst_audio_decoder_merge_tags:
+ * @dec: a #GstAudioDecoder
+ * @tags: a #GstTagList to merge
+ * @mode: the #GstTagMergeMode to use
+ *
+ * Adds tags to so-called pending tags, which will be processed
+ * before pushing out data downstream.
+ *
+ * Note that this is provided for convenience, and the subclass is
+ * not required to use this and can still do tag handling on its own,
+ * although it should be aware that baseclass already takes care
+ * of the usual CODEC/AUDIO_CODEC tags.
+ *
+ * MT safe.
+ *
+ * Since: 0.10.37
+ */
+void
+gst_audio_decoder_merge_tags (GstAudioDecoder * dec,
+    const GstTagList * tags, GstTagMergeMode mode)
+{
+  GstTagList *otags;
+
+  g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
+  g_return_if_fail (tags == NULL || GST_IS_TAG_LIST (tags));
+
+  GST_AUDIO_DECODER_STREAM_LOCK (dec);
+  if (tags)
+    GST_DEBUG_OBJECT (dec, "merging tags %" GST_PTR_FORMAT, tags);
+  otags = dec->priv->taglist;
+  dec->priv->taglist = gst_tag_list_merge (dec->priv->taglist, tags, mode);
+  if (otags)
+    gst_tag_list_free (otags);
+  GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
+}
diff --git a/gst-libs/gst/audio/gstaudiodecoder.h b/gst-libs/gst/audio/gstaudiodecoder.h
index ba4fff3..bf1c44e 100644
--- a/gst-libs/gst/audio/gstaudiodecoder.h
+++ b/gst-libs/gst/audio/gstaudiodecoder.h
@@ -41,6 +41,8 @@ G_BEGIN_DECLS
   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_DECODER))
 #define GST_IS_AUDIO_DECODER_CLASS(obj) \
   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_DECODER))
+#define GST_AUDIO_DECODER_CAST(obj) \
+  ((GstAudioDecoder *)(obj))
 
 /**
  * GST_AUDIO_DECODER_SINK_NAME:
@@ -199,6 +201,12 @@ struct _GstAudioDecoder
  *                  Called just prior to pushing (encoded data) buffer downstream.
  *                  Subclass has full discretionary access to buffer,
  *                  and a not OK flow return will abort downstream pushing.
+ * @open:           Optional.
+ *                  Called when the element changes to GST_STATE_READY.
+ *                  Allows opening external resources. Since: 0.10.37.
+ * @close:          Optional.
+ *                  Called when the element changes to GST_STATE_NULL.
+ *                  Allows closing external resources. Since: 0.10.37.
  *
  * Subclasses can override any of the available virtual methods or not, as
  * needed. At minimum @handle_frame (and likely @set_format) needs to be
@@ -235,8 +243,12 @@ struct _GstAudioDecoderClass
   gboolean      (*event)              (GstAudioDecoder *dec,
                                        GstEvent *event);
 
+  gboolean      (*open)               (GstAudioDecoder *dec);
+  
+  gboolean      (*close)              (GstAudioDecoder *dec);
+
   /*< private >*/
-  gpointer       _gst_reserved[GST_PADDING_LARGE];
+  gpointer       _gst_reserved[GST_PADDING_LARGE-2];
 };
 
 GType             gst_audio_decoder_get_type (void);
@@ -303,6 +315,9 @@ void              gst_audio_decoder_set_needs_format (GstAudioDecoder * dec,
 
 gboolean          gst_audio_decoder_get_needs_format (GstAudioDecoder * dec);
 
+void              gst_audio_decoder_merge_tags (GstAudioDecoder * dec,
+                                                const GstTagList * tags, GstTagMergeMode mode);
+
 G_END_DECLS
 
 #endif /* _GST_AUDIO_DECODER_H_ */
diff --git a/gst-libs/gst/audio/gstaudioencoder.c b/gst-libs/gst/audio/gstaudioencoder.c
index b915ae7..ea2595e 100644
--- a/gst-libs/gst/audio/gstaudioencoder.c
+++ b/gst-libs/gst/audio/gstaudioencoder.c
@@ -301,6 +301,9 @@ static void gst_audio_encoder_set_property (GObject * object,
 static void gst_audio_encoder_get_property (GObject * object,
     guint prop_id, GValue * value, GParamSpec * pspec);
 
+static GstStateChangeReturn gst_audio_encoder_change_state (GstElement *
+    element, GstStateChange transition);
+
 static gboolean gst_audio_encoder_sink_activate_push (GstPad * pad,
     gboolean active);
 
@@ -317,8 +320,10 @@ static void
 gst_audio_encoder_class_init (GstAudioEncoderClass * klass)
 {
   GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
 
   gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
   parent_class = g_type_class_peek_parent (klass);
 
   GST_DEBUG_CATEGORY_INIT (gst_audio_encoder_debug, "audioencoder", 0,
@@ -349,6 +354,9 @@ gst_audio_encoder_class_init (GstAudioEncoderClass * klass)
           "Consider discontinuity if timestamp jitter/imperfection exceeds tolerance (ns)",
           0, G_MAXINT64, DEFAULT_TOLERANCE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  gstelement_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_audio_encoder_change_state);
 }
 
 static void
@@ -460,6 +468,49 @@ gst_audio_encoder_finalize (GObject * object)
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
+static GstStateChangeReturn
+gst_audio_encoder_change_state (GstElement * element, GstStateChange transition)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstAudioEncoder *enc = GST_AUDIO_ENCODER (element);
+  GstAudioEncoderClass *klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (klass->open) {
+        if (!klass->open (enc))
+          goto open_failed;
+      }
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      if (klass->close) {
+        if (!klass->close (enc))
+          goto close_failed;
+      }
+    default:
+      break;
+  }
+
+  return ret;
+
+open_failed:
+  {
+    GST_ELEMENT_ERROR (enc, LIBRARY, INIT, (NULL), ("Failed to open codec"));
+    return GST_STATE_CHANGE_FAILURE;
+  }
+close_failed:
+  {
+    GST_ELEMENT_ERROR (enc, LIBRARY, INIT, (NULL), ("Failed to close codec"));
+    return GST_STATE_CHANGE_FAILURE;
+  }
+}
+
 /**
  * gst_audio_encoder_finish_frame:
  * @enc: a #GstAudioEncoder
diff --git a/gst-libs/gst/audio/gstaudioencoder.h b/gst-libs/gst/audio/gstaudioencoder.h
index aa40677..2db19ab 100644
--- a/gst-libs/gst/audio/gstaudioencoder.h
+++ b/gst-libs/gst/audio/gstaudioencoder.h
@@ -151,6 +151,12 @@ struct _GstAudioEncoder {
  *                  for multichannel input specification).  If not implemented,
  *                  default returns gst_audio_encoder_proxy_getcaps
  *                  applied to sink template caps.
+ * @open:           Optional.
+ *                  Called when the element changes to GST_STATE_READY.
+ *                  Allows opening external resources. Since: 0.10.37.
+ * @close:          Optional.
+ *                  Called when the element changes to GST_STATE_NULL.
+ *                  Allows closing external resources. Since: 0.10.37.
  *
  * Subclasses can override any of the available virtual methods or not, as
  * needed. At minimum @set_format and @handle_frame needs to be overridden.
@@ -183,8 +189,12 @@ struct _GstAudioEncoderClass {
 
   GstCaps *     (*getcaps)            (GstAudioEncoder *enc);
 
+  gboolean      (*open)               (GstAudioEncoder *enc);
+
+  gboolean      (*close)              (GstAudioEncoder *enc);
+
   /*< private >*/
-  gpointer       _gst_reserved[GST_PADDING_LARGE];
+  gpointer       _gst_reserved[GST_PADDING_LARGE-2];
 };
 
 GType           gst_audio_encoder_get_type         (void);
diff --git a/gst-libs/gst/audio/gstbaseaudiosink.c b/gst-libs/gst/audio/gstbaseaudiosink.c
index e7ff30d..03e332d 100644
--- a/gst-libs/gst/audio/gstbaseaudiosink.c
+++ b/gst-libs/gst/audio/gstbaseaudiosink.c
@@ -1654,7 +1654,7 @@ gst_base_audio_sink_render (GstBaseSink * bsink, GstBuffer * buf)
         GST_BUFFER_SIZE (buf), render_start);
     /* we don't have a start so we don't know stop either */
     stop = -1;
-    goto no_sync;
+    goto no_align;
   }
 
   /* let's calc stop based on the number of samples in the buffer instead
@@ -1730,7 +1730,7 @@ gst_base_audio_sink_render (GstBaseSink * bsink, GstBuffer * buf)
     render_stop = render_start + samples;
     GST_DEBUG_OBJECT (sink,
         "no sync needed. Using render_start=%" G_GUINT64_FORMAT, render_start);
-    goto no_sync;
+    goto no_align;
   }
 
   /* bring buffer start and stop times to running time */
@@ -1856,7 +1856,6 @@ no_align:
   /* number of target samples is difference between start and stop */
   out_samples = render_stop - render_start;
 
-no_sync:
   /* we render the first or last sample first, depending on the rate */
   if (bsink->segment.rate >= 0.0)
     sample_offset = render_start;
diff --git a/gst-libs/gst/audio/mixerutils.c b/gst-libs/gst/audio/mixerutils.c
index 94cdde3..f500497 100644
--- a/gst-libs/gst/audio/mixerutils.c
+++ b/gst-libs/gst/audio/mixerutils.c
@@ -31,6 +31,10 @@
  * </refsect2>
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/gst-libs/gst/audio/multichannel.h b/gst-libs/gst/audio/multichannel.h
index 8bf92d7..df2aa96 100644
--- a/gst-libs/gst/audio/multichannel.h
+++ b/gst-libs/gst/audio/multichannel.h
@@ -77,8 +77,7 @@ typedef enum {
    * are defined or all positions are undefined, but can't mix'n'match  */
   GST_AUDIO_CHANNEL_POSITION_NONE,
 
-  /*< private >*/
-  /* don't use - counter */
+  /* don't use - counter (private) */
   GST_AUDIO_CHANNEL_POSITION_NUM
 } GstAudioChannelPosition;
 
diff --git a/gst-libs/gst/interfaces/colorbalance.c b/gst-libs/gst/interfaces/colorbalance.c
index 0bf52a9..464d737 100644
--- a/gst-libs/gst/interfaces/colorbalance.c
+++ b/gst-libs/gst/interfaces/colorbalance.c
@@ -102,13 +102,15 @@ gst_color_balance_class_init (GstColorBalanceClass * klass)
 
     initialized = TRUE;
   }
-
+#ifndef GST_REMOVE_DEPRECATED
   klass->balance_type = GST_COLOR_BALANCE_SOFTWARE;
+#endif
 
   /* default virtual functions */
   klass->list_channels = NULL;
   klass->set_value = NULL;
   klass->get_value = NULL;
+  klass->get_balance_type = NULL;
 }
 
 /**
@@ -212,7 +214,14 @@ gst_color_balance_get_balance_type (GstColorBalance * balance)
 
   klass = GST_COLOR_BALANCE_GET_CLASS (balance);
 
+  if (klass->get_balance_type)
+    return klass->get_balance_type (balance);
+
+#ifndef GST_REMOVE_DEPRECATED
   return klass->balance_type;
+#else
+  g_return_val_if_reached (GST_COLOR_BALANCE_SOFTWARE);
+#endif
 }
 
 /**
diff --git a/gst-libs/gst/interfaces/colorbalance.h b/gst-libs/gst/interfaces/colorbalance.h
index 62771b5..9f0a1cd 100644
--- a/gst-libs/gst/interfaces/colorbalance.h
+++ b/gst-libs/gst/interfaces/colorbalance.h
@@ -80,7 +80,10 @@ typedef enum
 struct _GstColorBalanceClass {
   GTypeInterface klass;
 
+/* FIXME 0.11: Remove this */
+#ifndef GST_REMOVE_DEPRECATED
   GstColorBalanceType balance_type;
+#endif
 
   /* virtual functions */
   const GList * (* list_channels) (GstColorBalance        *balance);
@@ -96,8 +99,10 @@ struct _GstColorBalanceClass {
                           GstColorBalanceChannel *channel,
                           gint                    value);
 
+  GstColorBalanceType (*get_balance_type)  (GstColorBalance *balance);
+
   /*< private >*/
-  gpointer _gst_reserved[GST_PADDING];
+  gpointer _gst_reserved[GST_PADDING-1];
 };
 
 GType   gst_color_balance_get_type      (void);
diff --git a/gst-libs/gst/interfaces/mixer.c b/gst-libs/gst/interfaces/mixer.c
index 0c6abf0..5b8aeed 100644
--- a/gst-libs/gst/interfaces/mixer.c
+++ b/gst-libs/gst/interfaces/mixer.c
@@ -134,7 +134,9 @@ gst_mixer_class_init (GstMixerClass * klass)
   }
 #endif
 
+#ifndef GST_REMOVE_DEPRECATED
   klass->mixer_type = GST_MIXER_SOFTWARE;
+#endif
 
   /* default virtual functions */
   klass->list_tracks = NULL;
@@ -355,7 +357,14 @@ gst_mixer_get_mixer_type (GstMixer * mixer)
 {
   GstMixerClass *klass = GST_MIXER_GET_CLASS (mixer);
 
+  if (klass->get_mixer_type)
+    return klass->get_mixer_type (mixer);
+
+#ifndef GST_REMOVE_DEPRECATED
   return klass->mixer_type;
+#else
+  g_return_if_reached (GST_MIXER_TYPE_SOFTWARE);
+#endif
 }
 
 /**
diff --git a/gst-libs/gst/interfaces/mixer.h b/gst-libs/gst/interfaces/mixer.h
index 71c8f75..491c14c 100644
--- a/gst-libs/gst/interfaces/mixer.h
+++ b/gst-libs/gst/interfaces/mixer.h
@@ -117,7 +117,10 @@ typedef enum
 struct _GstMixerClass {
   GTypeInterface klass;
 
+/* FIXME 0.11: Remove this */
+#ifndef GST_REMOVE_DEPRECATED
   GstMixerType mixer_type;
+#endif
 
   /* virtual functions */
   const GList *  (* list_tracks)   (GstMixer      *mixer);
@@ -166,8 +169,10 @@ struct _GstMixerClass {
 
   GstMixerFlags (* get_mixer_flags) (GstMixer *mixer);
 
+  GstMixerType  (* get_mixer_type)  (GstMixer *mixer);
+
   /*< private >*/
-  gpointer _gst_reserved[GST_PADDING-1];
+  gpointer _gst_reserved[GST_PADDING-2];
 };
 
 GType           gst_mixer_get_type      (void);
diff --git a/gst-libs/gst/interfaces/navigation.h b/gst-libs/gst/interfaces/navigation.h
index b4eaca5..4b21441 100644
--- a/gst-libs/gst/interfaces/navigation.h
+++ b/gst-libs/gst/interfaces/navigation.h
@@ -44,7 +44,7 @@ typedef struct _GstNavigationInterface GstNavigationInterface;
  * @g_iface: the parent interface
  * @send_event: sending a navigation event
  *
- * Color-balance interface.
+ * Navigation interface.
  */
 struct _GstNavigationInterface {
   GTypeInterface g_iface;
diff --git a/gst-libs/gst/interfaces/xoverlay.c b/gst-libs/gst/interfaces/xoverlay.c
index 77c9e75..a5d9d60 100644
--- a/gst-libs/gst/interfaces/xoverlay.c
+++ b/gst-libs/gst/interfaces/xoverlay.c
@@ -148,8 +148,11 @@
  * #ifdef GDK_WINDOWING_X11
  * #include &lt;gdk/gdkx.h&gt;  // for GDK_WINDOW_XID
  * #endif
+ * #ifdef GDK_WINDOWING_WIN32
+ * #include &lt;gdk/gdkwin32.h&gt;  // for GDK_WINDOW_HWND
+ * #endif
  * ...
- * static gulong video_window_xid = 0;
+ * static guintptr video_window_handle = 0;
  * ...
  * static GstBusSyncReply
  * bus_sync_handler (GstBus * bus, GstMessage * message, gpointer user_data)
@@ -160,14 +163,14 @@
  *  if (!gst_structure_has_name (message-&gt;structure, "prepare-xwindow-id"))
  *    return GST_BUS_PASS;
  *
- *  if (video_window_xid != 0) {
+ *  if (video_window_handle != 0) {
  *    GstXOverlay *xoverlay;
  *
  *    // GST_MESSAGE_SRC (message) will be the video sink element
  *    xoverlay = GST_X_OVERLAY (GST_MESSAGE_SRC (message));
- *    gst_x_overlay_set_window_handle (xoverlay, video_window_xid);
+ *    gst_x_overlay_set_window_handle (xoverlay, video_window_handle);
  *  } else {
- *    g_warning ("Should have obtained video_window_xid by now!");
+ *    g_warning ("Should have obtained video_window_handle by now!");
  *  }
  *
  *  gst_message_unref (message);
@@ -178,6 +181,8 @@
  * video_widget_realize_cb (GtkWidget * widget, gpointer data)
  * {
  * #if GTK_CHECK_VERSION(2,18,0)
+ *   // Tell Gtk+/Gdk to create a native window for this widget instead of
+ *   // drawing onto the parent widget.
  *   // This is here just for pedagogical purposes, GDK_WINDOW_XID will call
  *   // it as well in newer Gtk versions
  *   if (!gdk_window_ensure_native (widget->window))
@@ -185,7 +190,16 @@
  * #endif
  *
  * #ifdef GDK_WINDOWING_X11
- *   video_window_xid = GDK_WINDOW_XID (gtk_widget_get_window (video_window));
+ *   {
+ *     gulong xid = GDK_WINDOW_XID (gtk_widget_get_window (video_window));
+ *     video_window_handle = xid;
+ *   }
+ * #endif
+ * #ifdef GDK_WINDOWING_WIN32
+ *   {
+ *     HWND wnd = GDK_WINDOW_HWND (gtk_widget_get_window (video_window));
+ *     video_window_handle = (guintptr) wnd;
+ *   }
  * #endif
  * }
  * ...
@@ -211,12 +225,12 @@
  *   gtk_widget_show_all (app_window);
  *
  *   // realize window now so that the video window gets created and we can
- *   // obtain its XID before the pipeline is started up and the videosink
- *   // asks for the XID of the window to render onto
+ *   // obtain its XID/HWND before the pipeline is started up and the videosink
+ *   // asks for the XID/HWND of the window to render onto
  *   gtk_widget_realize (video_window);
  *
- *   // we should have the XID now
- *   g_assert (video_window_xid != 0);
+ *   // we should have the XID/HWND now
+ *   g_assert (video_window_handle != 0);
  *   ...
  *   // set up sync handler for setting the xid once the pipeline is started
  *   bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
diff --git a/gst-libs/gst/pbutils/descriptions.c b/gst-libs/gst/pbutils/descriptions.c
index 63f5aa6..a58de31 100644
--- a/gst-libs/gst/pbutils/descriptions.c
+++ b/gst-libs/gst/pbutils/descriptions.c
@@ -234,13 +234,18 @@ static const FormatInfo formats[] = {
   {"image/vnd.wap.wbmp", "Wireless Bitmap", 0},
 
   /* subtitle formats with static descriptions */
-  {"application/x-ass", "ASS", 0},
+  {"application/x-ssa", "SubStation Alpha", 0},
+  {"application/x-ass", "Advanced SubStation Alpha", 0},
+  /* FIXME: add variant field to typefinder? */
+  {"application/x-subtitle", N_("Subtitle"), 0},
+  {"application/x-subtitle-mpl2", N_("MPL2 subtitle format"), 0},
+  {"application/x-subtitle-dks", N_("DKS subtitle format"), 0},
+  {"application/x-subtitle-qttext", N_("QTtext subtitle format"), 0},
   {"application/x-subtitle-sami", N_("Sami subtitle format"), 0},
   {"application/x-subtitle-tmplayer", N_("TMPlayer subtitle format"), 0},
   {"application/x-kate", "Kate", 0},
   {"subtitle/x-kate", N_("Kate subtitle format"), 0},
   {"subpicture/x-dvb", "DVB subtitles", 0},
-  /* add variant field to typefinder? { "application/x-subtitle", N_("subtitle"), 0}, */
 
   /* non-audio/video/container formats */
   {"hdv/aux-v", "HDV AUX-V", 0},
diff --git a/gst-libs/gst/pbutils/gstdiscoverer.c b/gst-libs/gst/pbutils/gstdiscoverer.c
index ba02cdb..3486656 100644
--- a/gst-libs/gst/pbutils/gstdiscoverer.c
+++ b/gst-libs/gst/pbutils/gstdiscoverer.c
@@ -1158,8 +1158,15 @@ handle_message (GstDiscoverer * dc, GstMessage * msg)
       /* We need to stop */
       done = TRUE;
 
-      GST_DEBUG ("Setting result to ERROR");
-      dc->priv->current_info->result = GST_DISCOVERER_ERROR;
+      /* Don't override missing plugin result code for missing plugin errors */
+      if (dc->priv->current_info->result != GST_DISCOVERER_MISSING_PLUGINS ||
+          (!g_error_matches (gerr, GST_CORE_ERROR,
+                  GST_CORE_ERROR_MISSING_PLUGIN) &&
+              !g_error_matches (gerr, GST_STREAM_ERROR,
+                  GST_STREAM_ERROR_CODEC_NOT_FOUND))) {
+        GST_DEBUG ("Setting result to ERROR");
+        dc->priv->current_info->result = GST_DISCOVERER_ERROR;
+      }
     }
       break;
 
diff --git a/gst-libs/gst/pbutils/install-plugins.c b/gst-libs/gst/pbutils/install-plugins.c
index 9b5f45e..93965de 100644
--- a/gst-libs/gst/pbutils/install-plugins.c
+++ b/gst-libs/gst/pbutils/install-plugins.c
@@ -569,7 +569,7 @@ gst_install_plugins_return_from_status (gint status)
     ret = (GstInstallPluginsReturn) WEXITSTATUS (status);
 
     /* did the helper return an invalid status code? */
-    if ((ret < 0 || ret >= GST_INSTALL_PLUGINS_STARTED_OK) &&
+    if (((guint) ret) >= GST_INSTALL_PLUGINS_STARTED_OK &&
         ret != GST_INSTALL_PLUGINS_INTERNAL_FAILURE) {
       ret = GST_INSTALL_PLUGINS_INVALID;
     }
diff --git a/gst-libs/gst/riff/riff-ids.h b/gst-libs/gst/riff/riff-ids.h
index 106f71a..9442018 100644
--- a/gst-libs/gst/riff/riff-ids.h
+++ b/gst-libs/gst/riff/riff-ids.h
@@ -96,7 +96,7 @@ G_BEGIN_DECLS
 #define GST_RIFF_INFO_IMED GST_MAKE_FOURCC ('I','M','E','D') /* medium */
 #define GST_RIFF_INFO_INAM GST_MAKE_FOURCC ('I','N','A','M') /* name */
 #define GST_RIFF_INFO_IPLT GST_MAKE_FOURCC ('I','P','L','T') /* palette setting */
-#define GST_RIFF_INFO_IPRD GST_MAKE_FOURCC ('I','P','R','D') /* product */
+#define GST_RIFF_INFO_IPRD GST_MAKE_FOURCC ('I','P','R','D') /* product (album) */
 #define GST_RIFF_INFO_ISBJ GST_MAKE_FOURCC ('I','S','B','J') /* subject */
 #define GST_RIFF_INFO_ISFT GST_MAKE_FOURCC ('I','S','F','T') /* software */
 #define GST_RIFF_INFO_ISHP GST_MAKE_FOURCC ('I','S','H','P') /* sharpness */
@@ -104,6 +104,9 @@ G_BEGIN_DECLS
 #define GST_RIFF_INFO_ISRF GST_MAKE_FOURCC ('I','S','R','F') /* source form */
 #define GST_RIFF_INFO_ITCH GST_MAKE_FOURCC ('I','T','C','H') /* technician(s) */
 
+#define GST_RIFF_INFO_IAAR GST_MAKE_FOURCC ('I','A','A','R') /* album artist */
+#define GST_RIFF_INFO_ITRK GST_MAKE_FOURCC ('I','T','R','K') /* track number */
+
 /*********Chunk Names***************/
 #define GST_RIFF_FF00 GST_MAKE_FOURCC (0xFF,0xFF,0x00,0x00)
 #define GST_RIFF_00   GST_MAKE_FOURCC ('0', '0',0x00,0x00)
diff --git a/gst-libs/gst/riff/riff-media.c b/gst-libs/gst/riff/riff-media.c
index 40b2bf6..53d9c88 100644
--- a/gst-libs/gst/riff/riff-media.c
+++ b/gst-libs/gst/riff/riff-media.c
@@ -104,6 +104,19 @@ gst_riff_create_video_caps (guint32 codec_fcc,
       }
       break;
     }
+    case GST_MAKE_FOURCC ('r', '2', '1', '0'):
+      caps = gst_caps_new_simple ("video/x-raw-rgb",
+          "endianness", G_TYPE_INT, G_BIG_ENDIAN, "depth", G_TYPE_INT, 30,
+          "bpp", G_TYPE_INT, 32,
+          "endianness", G_TYPE_INT, G_BIG_ENDIAN,
+          "red_mask", G_TYPE_INT, 0x3ff00000,
+          "green_mask", G_TYPE_INT, 0x000ffc00,
+          "blue_mask", G_TYPE_INT, 0x000003ff, NULL);
+
+      if (codec_name)
+        *codec_name = g_strdup ("Uncompressed packed RGB 10-bit 4:4:4");
+      break;
+
     case GST_MAKE_FOURCC ('I', '4', '2', '0'):
       caps = gst_caps_new_simple ("video/x-raw-yuv",
           "format", GST_TYPE_FOURCC, codec_fcc, NULL);
@@ -142,6 +155,12 @@ gst_riff_create_video_caps (guint32 codec_fcc,
       if (codec_name)
         *codec_name = g_strdup ("Uncompressed packed YVU 4:2:2");
       break;
+    case GST_MAKE_FOURCC ('v', '2', '1', '0'):
+      caps = gst_caps_new_simple ("video/x-raw-yuv",
+          "format", GST_TYPE_FOURCC, codec_fcc, NULL);
+      if (codec_name)
+        *codec_name = g_strdup ("Uncompressed packed 10-bit YUV 4:2:2");
+      break;
 
     case GST_MAKE_FOURCC ('M', 'J', 'P', 'G'): /* YUY2 MJPEG */
     case GST_MAKE_FOURCC ('A', 'V', 'R', 'n'):
@@ -1828,6 +1847,8 @@ gst_riff_create_video_template_caps (void)
     GST_MAKE_FOURCC ('Y', 'V', '1', '2'),
     GST_MAKE_FOURCC ('L', 'O', 'C', 'O'),
     GST_MAKE_FOURCC ('Z', 'M', 'B', 'V'),
+    GST_MAKE_FOURCC ('v', '2', '1', '0'),
+    GST_MAKE_FOURCC ('r', '2', '1', '0'),
     /* FILL ME */
   };
   guint i;
diff --git a/gst-libs/gst/riff/riff-read.c b/gst-libs/gst/riff/riff-read.c
index 314c19f..746ad93 100644
--- a/gst-libs/gst/riff/riff-read.c
+++ b/gst-libs/gst/riff/riff-read.c
@@ -620,6 +620,9 @@ gst_riff_parse_info (GstElement * element,
   while (size > 8) {
     tag = GST_READ_UINT32_LE (data);
     tsize = GST_READ_UINT32_LE (data + 4);
+
+    GST_MEMDUMP_OBJECT (element, "tag chunk", data, MIN (tsize + 8, size));
+
     size -= 8;
     data += 8;
 
@@ -632,11 +635,17 @@ gst_riff_parse_info (GstElement * element,
       tsize = size;
     }
 
+    /* make uppercase */
+    tag = tag & 0xDFDFDFDF;
+
     /* find out the type of metadata */
     switch (tag) {
       case GST_RIFF_INFO_IARL:
         type = GST_TAG_LOCATION;
         break;
+      case GST_RIFF_INFO_IAAR:
+        type = GST_TAG_ALBUM_ARTIST;
+        break;
       case GST_RIFF_INFO_IART:
         type = GST_TAG_ARTIST;
         break;
@@ -683,10 +692,10 @@ gst_riff_parse_info (GstElement * element,
         type = NULL;            /*"Palette"; */
         break;
       case GST_RIFF_INFO_IPRD:
-        type = NULL;            /*"Product"; */
+        type = GST_TAG_ALBUM;
         break;
       case GST_RIFF_INFO_ISBJ:
-        type = NULL;            /*"Subject"; */
+        type = GST_TAG_ALBUM_ARTIST;
         break;
       case GST_RIFF_INFO_ISFT:
         type = GST_TAG_ENCODER;
@@ -703,6 +712,9 @@ gst_riff_parse_info (GstElement * element,
       case GST_RIFF_INFO_ITCH:
         type = NULL;            /*"Technician"; */
         break;
+      case GST_RIFF_INFO_ITRK:
+        type = GST_TAG_TRACK_NUMBER;
+        break;
       default:
         type = NULL;
         GST_WARNING_OBJECT (element,
@@ -715,12 +727,31 @@ gst_riff_parse_info (GstElement * element,
       static const gchar *env_vars[] = { "GST_AVI_TAG_ENCODING",
         "GST_RIFF_TAG_ENCODING", "GST_TAG_ENCODING", NULL
       };
+      GType tag_type;
       gchar *val;
 
+      GST_DEBUG_OBJECT (element, "mapped tag %" GST_FOURCC_FORMAT " to tag %s",
+          GST_FOURCC_ARGS (tag), type);
+
+      tag_type = gst_tag_get_type (type);
       val = gst_tag_freeform_string_to_utf8 ((gchar *) data, tsize, env_vars);
 
-      if (val) {
-        gst_tag_list_add (taglist, GST_TAG_MERGE_APPEND, type, val, NULL);
+      if (val != NULL) {
+        if (tag_type == G_TYPE_STRING) {
+          gst_tag_list_add (taglist, GST_TAG_MERGE_APPEND, type, val, NULL);
+        } else {
+          GValue tag_val = { 0, };
+
+          g_value_init (&tag_val, tag_type);
+          if (gst_value_deserialize (&tag_val, val)) {
+            gst_tag_list_add_value (taglist, GST_TAG_MERGE_APPEND, type,
+                &tag_val);
+          } else {
+            GST_WARNING_OBJECT (element, "could not deserialize '%s' into a "
+                "tag %s of type %s", val, type, g_type_name (tag_type));
+          }
+          g_value_unset (&tag_val);
+        }
         g_free (val);
       } else {
         GST_WARNING_OBJECT (element, "could not extract %s tag", type);
@@ -738,6 +769,7 @@ gst_riff_parse_info (GstElement * element,
   }
 
   if (!gst_tag_list_is_empty (taglist)) {
+    GST_INFO_OBJECT (element, "extracted tags: %" GST_PTR_FORMAT, taglist);
     *_taglist = taglist;
   } else {
     *_taglist = NULL;
diff --git a/gst-libs/gst/rtsp/gstrtspdefs.h b/gst-libs/gst/rtsp/gstrtspdefs.h
index 3727bf2..aab8d3e 100644
--- a/gst-libs/gst/rtsp/gstrtspdefs.h
+++ b/gst-libs/gst/rtsp/gstrtspdefs.h
@@ -228,10 +228,9 @@ typedef enum {
 /**
  * GstRTSPHeaderField:
  *
- * Enumeration of rtsp header fields.
+ * Enumeration of rtsp header fields
  */
 typedef enum {
-  /*< protected >*/
   GST_RTSP_HDR_INVALID,
 
   /*
@@ -342,10 +341,9 @@ typedef enum {
 /**
  * GstRTSPStatusCode:
  *
- * Enumeration of rtsp status codes.
+ * Enumeration of rtsp status codes
  */
 typedef enum {
-  /*< protected >*/
   GST_RTSP_STS_INVALID                              = 0,
   GST_RTSP_STS_CONTINUE                             = 100,
   GST_RTSP_STS_OK                                   = 200,
diff --git a/gst-libs/gst/tag/gstxmptag.c b/gst-libs/gst/tag/gstxmptag.c
index 1fb7f39..5a51f62 100644
--- a/gst-libs/gst/tag/gstxmptag.c
+++ b/gst-libs/gst/tag/gstxmptag.c
@@ -173,8 +173,11 @@ xmp_tag_type_get_name (GstXmpTagType tagtype)
     case GstXmpTagTypeBag:
       return "rdf:Bag";
     default:
-      g_assert_not_reached ();
+      break;
   }
+
+  /* Make compiler happy */
+  g_return_val_if_reached ("");
 }
 
 struct _PendingXmpTag
diff --git a/gst-libs/gst/tag/lang.c b/gst-libs/gst/tag/lang.c
index a0838fe..c37366e 100644
--- a/gst-libs/gst/tag/lang.c
+++ b/gst-libs/gst/tag/lang.c
@@ -30,8 +30,6 @@
  * </refsect2>
  */
 
-/* FIXME 0.11: maybe switch to ISO-639-2 everywhere incl. GST_TAG_LANGUAGE? */
-
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -311,8 +309,8 @@ gst_tag_get_language_codes (void)
  * gst_tag_get_language_name:
  * @language_code: two or three-letter ISO-639 language code
  *
- * Returns the name of the language given an ISO-639 language code, such
- * as often found in a GST_TAG_LANGUAGE tag. The name will be translated
+ * Returns the name of the language given an ISO-639 language code as
+ * found in a GST_TAG_LANGUAGE_CODE tag. The name will be translated
  * according to the current locale (if the library was built against the
  * iso-codes package, otherwise the English name will be returned).
  *
@@ -492,3 +490,25 @@ gst_tag_get_language_code_iso_639_2B (const gchar * lang_code)
 
   return c;
 }
+
+/**
+ * gst_tag_check_language_code:
+ * @lang_code: ISO-639 language code (e.g. "deu" or "ger" or "de")
+ *
+ * Check if a given string contains a known ISO 639 language code.
+ *
+ * This is useful in situations where it's not clear whether a given
+ * string is a language code (which should be put into a #GST_TAG_LANGUAGE_CODE
+ * tag) or a free-form language name descriptor (which should be put into a
+ * #GST_TAG_LANGUAGE_NAME tag instead).
+ *
+ * Returns: TRUE if the two- or three-letter language code in @lang_code
+ *     is a valid ISO-639 language code.
+ *
+ * Since: 0.10.37
+ */
+gboolean
+gst_tag_check_language_code (const gchar * lang_code)
+{
+  return (gst_tag_get_language_code_iso_639_1 (lang_code) != NULL);
+}
diff --git a/gst-libs/gst/tag/tag.h b/gst-libs/gst/tag/tag.h
index 057378c..074f81e 100644
--- a/gst-libs/gst/tag/tag.h
+++ b/gst-libs/gst/tag/tag.h
@@ -551,6 +551,8 @@ const gchar *  gst_tag_get_language_code_iso_639_2B (const gchar * lang_code);
 
 const gchar *  gst_tag_get_language_code_iso_639_2T (const gchar * lang_code);
 
+gboolean       gst_tag_check_language_code          (const gchar * lang_code);
+
 /**
  * gst_tag_get_language_code:
  * @lang_code: ISO-639 language code (e.g. "deu" or "ger" or "de")
diff --git a/gst-libs/gst/video/video-blend.c b/gst-libs/gst/video/video-blend.c
index 8dc21c3..140e2bb 100644
--- a/gst-libs/gst/video/video-blend.c
+++ b/gst-libs/gst/video/video-blend.c
@@ -1156,6 +1156,34 @@ matrix_identity (guint8 * tmpline, guint width)
 }
 
 static void
+matrix_prea_rgb_to_yuv (guint8 * tmpline, guint width)
+{
+  int i;
+  int a, r, g, b;
+  int y, u, v;
+
+  for (i = 0; i < width; i++) {
+    a = tmpline[i * 4 + 0];
+    r = tmpline[i * 4 + 1];
+    g = tmpline[i * 4 + 2];
+    b = tmpline[i * 4 + 3];
+    if (a) {
+      r = (r * 255 + a / 2) / a;
+      g = (g * 255 + a / 2) / a;
+      b = (b * 255 + a / 2) / a;
+    }
+
+    y = (47 * r + 157 * g + 16 * b + 4096) >> 8;
+    u = (-26 * r - 87 * g + 112 * b + 32768) >> 8;
+    v = (112 * r - 102 * g - 10 * b + 32768) >> 8;
+
+    tmpline[i * 4 + 1] = CLAMP (y, 0, 255);
+    tmpline[i * 4 + 2] = CLAMP (u, 0, 255);
+    tmpline[i * 4 + 3] = CLAMP (v, 0, 255);
+  }
+}
+
+static void
 matrix_rgb_to_yuv (guint8 * tmpline, guint width)
 {
   int i;
@@ -1221,15 +1249,22 @@ lookup_getput (GetPutLine * getput, GstVideoFormat fmt)
   return FALSE;
 }
 
-#define BLEND(ret, alpha, v0, v1) \
-{ \
+#define BLEND00(ret, alpha, v0, v1) \
+G_STMT_START { \
   ret = (v0 * alpha + v1 * (255 - alpha)) / 255; \
-}
+} G_STMT_END
 
+#define BLEND10(ret, alpha, v0, v1) \
+G_STMT_START { \
+  ret = v0 + (v1 * (255 - alpha)) / 255; \
+} G_STMT_END
+
+/* returns newly-allocated pixels in src->pixels, which caller must g_free() */
 void
 video_blend_scale_linear_RGBA (GstBlendVideoFormatInfo * src,
     gint dest_height, gint dest_width)
 {
+  const guint8 *src_pixels;
   int acc;
   int y_increment;
   int x_increment;
@@ -1260,8 +1295,10 @@ video_blend_scale_linear_RGBA (GstBlendVideoFormatInfo * src,
 
 #define LINE(x) ((tmpbuf) + (dest_size)*((x)&1))
 
+  src_pixels = src->pixels;
+
   acc = 0;
-  orc_resample_bilinear_u32 (LINE (0), src->pixels, 0, x_increment, dest_width);
+  orc_resample_bilinear_u32 (LINE (0), src_pixels, 0, x_increment, dest_width);
   y1 = 0;
   for (i = 0; i < dest_height; i++) {
     j = acc >> 16;
@@ -1272,12 +1309,12 @@ video_blend_scale_linear_RGBA (GstBlendVideoFormatInfo * src,
     } else {
       if (j > y1) {
         orc_resample_bilinear_u32 (LINE (j),
-            src->pixels + j * src_stride, 0, x_increment, dest_width);
+            src_pixels + j * src_stride, 0, x_increment, dest_width);
         y1++;
       }
       if (j >= y1) {
         orc_resample_bilinear_u32 (LINE (j + 1),
-            src->pixels + (j + 1) * src_stride, 0, x_increment, dest_width);
+            src_pixels + (j + 1) * src_stride, 0, x_increment, dest_width);
         y1++;
       }
       orc_merge_linear_u8 (dest_pixels + i * dest_stride,
@@ -1289,7 +1326,7 @@ video_blend_scale_linear_RGBA (GstBlendVideoFormatInfo * src,
 
   /* Update src, our reference to the old src->pixels is lost */
   video_blend_format_info_init (src, dest_pixels, dest_height, dest_width,
-      src->fmt);
+      src->fmt, src->premultiplied_alpha);
 
   g_free (tmpbuf);
 }
@@ -1300,20 +1337,34 @@ video_blend_scale_linear_RGBA (GstBlendVideoFormatInfo * src,
  * @dest
  * @x: The x offset in pixel where the @src image should be blended
  * @y: the y offset in pixel where the @src image should be blended
+ * @global_alpha: the global_alpha each per-pixel alpha value is multiplied
+ *                with
  *
  * Lets you blend the @src image into the @dest image
  */
 gboolean
 video_blend (GstBlendVideoFormatInfo * dest,
-    GstBlendVideoFormatInfo * src, guint x, guint y)
+    GstBlendVideoFormatInfo * src, guint x, guint y, gfloat global_alpha)
 {
-  guint i, j;
-  guint8 alpha;
+  guint i, j, global_alpha_val, src_width, src_height;
   GetPutLine getputdest, getputsrc;
+  gint src_stride;
+  guint8 *tmpdestline = NULL, *tmpsrcline = NULL;
+  gboolean src_premultiplied_alpha;
 
-  gint src_stride = src->width * 4;
-  guint8 *tmpdestline = g_malloc (sizeof (guint8) * (dest->width + 8) * 4);
-  guint8 *tmpsrcline = g_malloc (sizeof (guint8) * (dest->width + 8) * 4);
+  g_assert (dest != NULL);
+  g_assert (src != NULL);
+
+  global_alpha_val = 256.0 * global_alpha;
+
+  /* we do no support writing to premultiplied alpha, though that should
+     just be a matter of adding blenders below (BLEND01 and BLEND11) */
+  g_return_val_if_fail (!dest->premultiplied_alpha, FALSE);
+  src_premultiplied_alpha = src->premultiplied_alpha;
+
+  src_stride = src->width * 4;
+  tmpdestline = g_malloc (sizeof (guint8) * (dest->width + 8) * 4);
+  tmpsrcline = g_malloc (sizeof (guint8) * (dest->width + 8) * 4);
 
   ensure_debug_category ();
 
@@ -1324,9 +1375,18 @@ video_blend (GstBlendVideoFormatInfo * dest,
   if (!lookup_getput (&getputsrc, src->fmt))
     goto failed;
 
-  if (gst_video_format_is_rgb (src->fmt) != gst_video_format_is_rgb (dest->fmt))
-    getputsrc.matrix = gst_video_format_is_rgb (src->fmt) ?
-        matrix_rgb_to_yuv : matrix_yuv_to_rgb;
+  if (gst_video_format_is_rgb (src->fmt) != gst_video_format_is_rgb (dest->fmt)) {
+    if (gst_video_format_is_rgb (src->fmt)) {
+      if (src_premultiplied_alpha) {
+        getputsrc.matrix = matrix_prea_rgb_to_yuv;
+        src_premultiplied_alpha = FALSE;
+      } else {
+        getputsrc.matrix = matrix_rgb_to_yuv;
+      }
+    } else {
+      getputsrc.matrix = matrix_yuv_to_rgb;
+    }
+  }
 
   /* adjust src pointers for negative sizes */
   if (x < 0) {
@@ -1348,24 +1408,56 @@ video_blend (GstBlendVideoFormatInfo * dest,
   if (y + src->height > dest->height)
     src->height = dest->height - y;
 
+  src_width = src->width;
+  src_height = src->height;
+
   /* Mainloop doing the needed conversions, and blending */
-  for (i = y; i < y + src->height; i++) {
+  for (i = y; i < y + src_height; i++) {
 
     getputdest.getline (tmpdestline, dest, x, i);
     getputsrc.getline (tmpsrcline, src, 0, (i - y));
 
-    getputsrc.matrix (tmpsrcline, src->width);
+    getputsrc.matrix (tmpsrcline, src_width);
 
     /* Here dest and src are both either in AYUV or ARGB
      * TODO: Make the orc version working properly*/
-    for (j = 0; j < src->width * 4; j += 4) {
-      alpha = tmpsrcline[j];
-
-      BLEND (tmpdestline[j + 1], alpha, tmpsrcline[j + 1], tmpdestline[j + 1]);
-      BLEND (tmpdestline[j + 2], alpha, tmpsrcline[j + 2], tmpdestline[j + 2]);
-      BLEND (tmpdestline[j + 3], alpha, tmpsrcline[j + 3], tmpdestline[j + 3]);
+#define BLENDLOOP(blender,alpha_val,alpha_scale)                                  \
+  do {                                                                            \
+    for (j = 0; j < src_width * 4; j += 4) {                                      \
+      guint8 alpha;                                                               \
+                                                                                  \
+      alpha = (tmpsrcline[j] * alpha_val) / alpha_scale;                          \
+                                                                                  \
+      blender (tmpdestline[j + 1], alpha, tmpsrcline[j + 1], tmpdestline[j + 1]); \
+      blender (tmpdestline[j + 2], alpha, tmpsrcline[j + 2], tmpdestline[j + 2]); \
+      blender (tmpdestline[j + 3], alpha, tmpsrcline[j + 3], tmpdestline[j + 3]); \
+    }                                                                             \
+  } while(0)
+
+    if (G_LIKELY (global_alpha == 1.0)) {
+      if (src_premultiplied_alpha && dest->premultiplied_alpha) {
+        /* BLENDLOOP (BLEND11, 1, 1); */
+      } else if (!src_premultiplied_alpha && dest->premultiplied_alpha) {
+        /* BLENDLOOP (BLEND01, 1, 1); */
+      } else if (src_premultiplied_alpha && !dest->premultiplied_alpha) {
+        BLENDLOOP (BLEND10, 1, 1);
+      } else {
+        BLENDLOOP (BLEND00, 1, 1);
+      }
+    } else {
+      if (src_premultiplied_alpha && dest->premultiplied_alpha) {
+        /* BLENDLOOP (BLEND11, global_alpha_val, 256); */
+      } else if (!src_premultiplied_alpha && dest->premultiplied_alpha) {
+        /* BLENDLOOP (BLEND01, global_alpha_val, 256); */
+      } else if (src_premultiplied_alpha && !dest->premultiplied_alpha) {
+        BLENDLOOP (BLEND10, global_alpha_val, 256);
+      } else {
+        BLENDLOOP (BLEND00, global_alpha_val, 256);
+      }
     }
 
+#undef BLENDLOOP
+
     /* FIXME
      * #if G_BYTE_ORDER == LITTLE_ENDIAN
      * orc_blend_little (tmpdestline, tmpsrcline, dest->width);
@@ -1403,7 +1495,8 @@ failed:
  */
 void
 video_blend_format_info_init (GstBlendVideoFormatInfo * info,
-    guint8 * pixels, guint height, guint width, GstVideoFormat fmt)
+    guint8 * pixels, guint height, guint width, GstVideoFormat fmt,
+    gboolean premultiplied_alpha)
 {
   guint nb_component = gst_video_format_has_alpha (fmt) ? 4 : 3;
 
@@ -1417,6 +1510,7 @@ video_blend_format_info_init (GstBlendVideoFormatInfo * info,
   info->height = height;
   info->pixels = pixels;
   info->fmt = fmt;
+  info->premultiplied_alpha = premultiplied_alpha;
   info->size = gst_video_format_get_size (fmt, height, width);
 
   fill_planes (info);
diff --git a/gst-libs/gst/video/video-blend.h b/gst-libs/gst/video/video-blend.h
index 3f5e0cd..7e4c50f 100644
--- a/gst-libs/gst/video/video-blend.h
+++ b/gst-libs/gst/video/video-blend.h
@@ -53,6 +53,8 @@ struct _GstBlendVideoFormatInfo
     guint8        * pixels;
     gsize           size;
 
+    gboolean        premultiplied_alpha;
+
     /* YUV components: Y=0, U=1, V=2, A=3
      * RGB components: R=0, G=1, B=2, A=3 */
     gint            offset[MAX_VIDEO_PLANES];
@@ -61,13 +63,15 @@ struct _GstBlendVideoFormatInfo
 
 void       video_blend_format_info_init   (GstBlendVideoFormatInfo * info,
                                            guint8 *pixels, guint height,
-                                           guint width, GstVideoFormat fmt);
+                                           guint width, GstVideoFormat fmt,
+                                           gboolean premultiplied_alpha);
 
 void       video_blend_scale_linear_RGBA  (GstBlendVideoFormatInfo * src,
                                            gint dest_height, gint dest_width);
 
 gboolean   video_blend                    (GstBlendVideoFormatInfo * dest,
                                            GstBlendVideoFormatInfo * src,
-                                           guint x, guint y);
+                                           guint x, guint y,
+                                           gfloat global_alpha);
 
 #endif
diff --git a/gst-libs/gst/video/video-overlay-composition.c b/gst-libs/gst/video/video-overlay-composition.c
index 3bfbad1..f9f90c5 100644
--- a/gst-libs/gst/video/video-overlay-composition.c
+++ b/gst-libs/gst/video/video-overlay-composition.c
@@ -69,6 +69,7 @@
 
 #include "video-overlay-composition.h"
 #include "video-blend.h"
+#include <string.h>
 
 struct _GstVideoOverlayComposition
 {
@@ -108,6 +109,9 @@ struct _GstVideoOverlayRectangle
   /* The format of the data in pixels */
   GstVideoFormat format;
 
+  /* The flags associated to this rectangle */
+  GstVideoOverlayFormatFlags flags;
+
   /* Refcounted blob of memory, no caps or timestamps */
   GstBuffer *pixels;
 
@@ -131,6 +135,19 @@ struct _GstVideoOverlayRectangle
    * rectangles have expired. */
   guint seq_num;
 
+  /* global alpha: global alpha value of the rectangle. Each each per-pixel
+   * alpha value of image-data will be multiplied with the global alpha value
+   * during blending.
+   * Can be used for efficient fading in/out of overlay rectangles.
+   * GstElements that render OverlayCompositions and don't support global alpha
+   * should simply ignore it.*/
+  gfloat global_alpha;
+
+  /* track alpha-values already applied: */
+  gfloat applied_global_alpha;
+  /* store initial per-pixel alpha values: */
+  guint8 *initial_alpha;
+
   /* FIXME: we may also need a (private) way to cache converted/scaled
    * pixel blobs */
 #if !GLIB_CHECK_VERSION (2, 31, 0)
@@ -501,7 +518,7 @@ gst_video_overlay_composition_blend (GstVideoOverlayComposition * comp,
   }
 
   video_blend_format_info_init (&video_info, GST_BUFFER_DATA (video_buf),
-      h, w, fmt);
+      h, w, fmt, FALSE);
 
   num = comp->num_rectangles;
   GST_LOG ("Blending composition %p with %u rectangles onto video buffer %p "
@@ -518,7 +535,8 @@ gst_video_overlay_composition_blend (GstVideoOverlayComposition * comp,
 
     video_blend_format_info_init (&rectangle_info,
         GST_BUFFER_DATA (rect->pixels), rect->height, rect->width,
-        rect->format);
+        rect->format,
+        ! !(rect->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA));
 
     needs_scaling = gst_video_overlay_rectangle_needs_scaling (rect);
     if (needs_scaling) {
@@ -526,7 +544,8 @@ gst_video_overlay_composition_blend (GstVideoOverlayComposition * comp,
           rect->render_width);
     }
 
-    ret = video_blend (&video_info, &rectangle_info, rect->x, rect->y);
+    ret = video_blend (&video_info, &rectangle_info, rect->x, rect->y,
+        rect->global_alpha);
     if (!ret) {
       GST_WARNING ("Could not blend overlay rectangle onto video buffer");
     }
@@ -679,6 +698,8 @@ gst_video_overlay_rectangle_finalize (GstMiniObject * mini_obj)
     rect->scaled_rectangles =
         g_list_delete_link (rect->scaled_rectangles, rect->scaled_rectangles);
   }
+
+  g_free (rect->initial_alpha);
 #if !GLIB_CHECK_VERSION (2, 31, 0)
   g_static_mutex_free (&rect->lock);
 #else
@@ -706,6 +727,23 @@ gst_video_overlay_rectangle_instance_init (GstMiniObject * mini_obj)
 #endif
 }
 
+static inline gboolean
+gst_video_overlay_rectangle_check_flags (GstVideoOverlayFormatFlags flags)
+{
+  /* Check flags only contains flags we know about */
+  return (flags & ~(GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA |
+          GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA)) == 0;
+}
+
+static gboolean
+gst_video_overlay_rectangle_is_same_alpha_type (GstVideoOverlayFormatFlags
+    flags1, GstVideoOverlayFormatFlags flags2)
+{
+  return ((flags1 ^ flags2) & GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)
+      == 0;
+}
+
+
 /**
  * gst_video_overlay_rectangle_new_argb:
  * @pixels: (transfer none): a #GstBuffer pointing to the pixel memory
@@ -718,7 +756,7 @@ gst_video_overlay_rectangle_instance_init (GstMiniObject * mini_obj)
  *     overlay rectangle should be rendered to
  * @render_width: the render width of this rectangle on the video
  * @render_height: the render height of this rectangle on the video
- * @flags: flags (currently unused)
+ * @flags: flags
  *
  * Creates a new video overlay rectangle with ARGB pixel data. The layout
  * of the components in memory is B-G-R-A on little-endian platforms
@@ -726,9 +764,9 @@ gst_video_overlay_rectangle_instance_init (GstMiniObject * mini_obj)
  * platforms (corresponding to #GST_VIDEO_FORMAT_ARGB). In other words,
  * pixels are treated as 32-bit words and the lowest 8 bits then contain
  * the blue component value and the highest 8 bits contain the alpha
- * component value. The RGB values are non-premultiplied. This is the
- * format that is used by most hardware, and also many rendering libraries
- * such as Cairo, for example.
+ * component value. Unless specified in the flags, the RGB values are
+ * non-premultiplied. This is the format that is used by most hardware,
+ * and also many rendering libraries such as Cairo, for example.
  *
  * Returns: (transfer full): a new #GstVideoOverlayRectangle. Unref with
  *     gst_video_overlay_rectangle_unref() when no longer needed.
@@ -748,7 +786,7 @@ gst_video_overlay_rectangle_new_argb (GstBuffer * pixels,
   g_return_val_if_fail (stride >= (4 * width), NULL);
   g_return_val_if_fail (height > 0 && width > 0, NULL);
   g_return_val_if_fail (render_height > 0 && render_width > 0, NULL);
-  g_return_val_if_fail (flags == 0, NULL);
+  g_return_val_if_fail (gst_video_overlay_rectangle_check_flags (flags), NULL);
 
   rect = (GstVideoOverlayRectangle *)
       gst_mini_object_new (GST_TYPE_VIDEO_OVERLAY_RECTANGLE);
@@ -758,6 +796,7 @@ gst_video_overlay_rectangle_new_argb (GstBuffer * pixels,
 #else
   rect->format = GST_VIDEO_FORMAT_ARGB;
 #endif
+
   rect->pixels = gst_buffer_ref (pixels);
 
   rect->width = width;
@@ -769,11 +808,18 @@ gst_video_overlay_rectangle_new_argb (GstBuffer * pixels,
   rect->render_width = render_width;
   rect->render_height = render_height;
 
+  rect->global_alpha = 1.0;
+  rect->applied_global_alpha = 1.0;
+  rect->initial_alpha = NULL;
+
+  rect->flags = flags;
+
   rect->seq_num = gst_video_overlay_get_seqnum ();
 
   GST_LOG ("new rectangle %p: %ux%u => %ux%u @ %u,%u, seq_num %u, format %u, "
-      "pixels %p", rect, width, height, render_width, render_height, render_x,
-      render_y, rect->seq_num, rect->format, pixels);
+      "flags %x, pixels %p, global_alpha=%f", rect, width, height, render_width,
+      render_height, render_x, render_y, rect->seq_num, rect->format,
+      rect->flags, pixels, rect->global_alpha);
 
   return rect;
 }
@@ -846,39 +892,158 @@ gst_video_overlay_rectangle_set_render_rectangle (GstVideoOverlayRectangle *
   rectangle->render_height = render_height;
 }
 
-/**
- * gst_video_overlay_rectangle_get_pixels_argb:
- * @rectangle: a #GstVideoOverlayRectangle
- * @stride: (out) (allow-none): address of guint variable where to store the
- *    row stride of the ARGB pixel data in the buffer
- * @flags: flags (unused)
- *
- * Returns: (transfer none): a #GstBuffer holding the ARGB pixel data with
- *    row stride @stride and width and height of the render dimensions as per
- *    gst_video_overlay_rectangle_get_render_rectangle(). This function does
- *    not return a reference, the caller should obtain a reference of her own
- *    with gst_buffer_ref() if needed.
- *
- * Since: 0.10.36
- */
-GstBuffer *
-gst_video_overlay_rectangle_get_pixels_argb (GstVideoOverlayRectangle *
-    rectangle, guint * stride, GstVideoOverlayFormatFlags flags)
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+# define ARGB_A 3
+# define ARGB_R 2
+# define ARGB_G 1
+# define ARGB_B 0
+#else
+# define ARGB_A 0
+# define ARGB_R 1
+# define ARGB_G 2
+# define ARGB_B 3
+#endif
+
+/* FIXME: orc-ify */
+static void
+gst_video_overlay_rectangle_premultiply (GstBlendVideoFormatInfo * info)
+{
+  int i, j;
+  for (j = 0; j < info->height; ++j) {
+    guint8 *line = info->pixels + info->stride[0] * j;
+    for (i = 0; i < info->width; ++i) {
+      int a = line[ARGB_A];
+      line[ARGB_R] = line[ARGB_R] * a / 255;
+      line[ARGB_G] = line[ARGB_G] * a / 255;
+      line[ARGB_B] = line[ARGB_B] * a / 255;
+      line += 4;
+    }
+  }
+}
+
+/* FIXME: orc-ify */
+static void
+gst_video_overlay_rectangle_unpremultiply (GstBlendVideoFormatInfo * info)
+{
+  int i, j;
+  for (j = 0; j < info->height; ++j) {
+    guint8 *line = info->pixels + info->stride[0] * j;
+    for (i = 0; i < info->width; ++i) {
+      int a = line[ARGB_A];
+      if (a) {
+        line[ARGB_R] = MIN ((line[ARGB_R] * 255 + a / 2) / a, 255);
+        line[ARGB_G] = MIN ((line[ARGB_G] * 255 + a / 2) / a, 255);
+        line[ARGB_B] = MIN ((line[ARGB_B] * 255 + a / 2) / a, 255);
+      }
+      line += 4;
+    }
+  }
+}
+
+
+static void
+gst_video_overlay_rectangle_extract_alpha (GstVideoOverlayRectangle * rect)
+{
+  guint8 *src, *dst;
+  int offset = 0;
+  int alpha_size = rect->stride * rect->height / 4;
+
+  g_free (rect->initial_alpha);
+  rect->initial_alpha = NULL;
+
+  rect->initial_alpha = g_malloc (alpha_size);
+  src = GST_BUFFER_DATA (rect->pixels);
+  dst = rect->initial_alpha;
+  /* FIXME we're accessing possibly uninitialised bytes from the row padding */
+  while (offset < alpha_size) {
+    dst[offset] = src[offset * 4 + ARGB_A];
+    ++offset;
+  }
+}
+
+
+static void
+gst_video_overlay_rectangle_apply_global_alpha (GstVideoOverlayRectangle * rect,
+    float global_alpha)
 {
+  guint8 *src, *dst;
+  guint offset = 0;
+
+  g_assert (!(rect->applied_global_alpha != 1.0
+          && rect->initial_alpha == NULL));
+
+  if (global_alpha == rect->applied_global_alpha)
+    return;
+
+  if (rect->initial_alpha == NULL)
+    gst_video_overlay_rectangle_extract_alpha (rect);
+
+  src = rect->initial_alpha;
+  rect->pixels = gst_buffer_make_writable (rect->pixels);
+  dst = GST_BUFFER_DATA (rect->pixels);
+  while (offset < (rect->height * rect->stride / 4)) {
+    guint doff = offset * 4;
+    guint8 na = (guint8) src[offset] * global_alpha;
+    if (! !(rect->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)) {
+      dst[doff + ARGB_R] =
+          (guint8) ((double) (dst[doff + ARGB_R] * 255) / (double) dst[doff +
+              ARGB_A]) * na / 255;
+      dst[doff + ARGB_G] =
+          (guint8) ((double) (dst[doff + ARGB_G] * 255) / (double) dst[doff +
+              ARGB_A]) * na / 255;
+      dst[doff + ARGB_B] =
+          (guint8) ((double) (dst[doff + ARGB_B] * 255) / (double) dst[doff +
+              ARGB_A]) * na / 255;
+    }
+    dst[doff + ARGB_A] = na;
+    ++offset;
+  }
+
+  rect->applied_global_alpha = global_alpha;
+}
+
+static GstBuffer *
+gst_video_overlay_rectangle_get_pixels_argb_internal (GstVideoOverlayRectangle *
+    rectangle, guint * stride, GstVideoOverlayFormatFlags flags,
+    gboolean unscaled)
+{
+  GstVideoOverlayFormatFlags new_flags;
   GstVideoOverlayRectangle *scaled_rect = NULL;
   GstBlendVideoFormatInfo info;
   GstBuffer *buf;
   GList *l;
+  guint wanted_width = unscaled ? rectangle->width : rectangle->render_width;
+  guint wanted_height = unscaled ? rectangle->height : rectangle->render_height;
+  gboolean apply_global_alpha;
+  gboolean revert_global_alpha;
 
   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), NULL);
-  g_return_val_if_fail (flags == 0, NULL);
   g_return_val_if_fail (stride != NULL, NULL);
+  g_return_val_if_fail (gst_video_overlay_rectangle_check_flags (flags), NULL);
+
+  apply_global_alpha =
+      (! !(rectangle->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA)
+      && !(flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA));
+  revert_global_alpha =
+      (! !(rectangle->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA)
+      && ! !(flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA));
 
   /* This assumes we don't need to adjust the format */
-  if (rectangle->render_width == rectangle->width &&
-      rectangle->render_height == rectangle->height) {
-    *stride = rectangle->stride;
-    return rectangle->pixels;
+  if (wanted_width == rectangle->width &&
+      wanted_height == rectangle->height &&
+      gst_video_overlay_rectangle_is_same_alpha_type (rectangle->flags,
+          flags)) {
+    /* don't need to apply/revert global-alpha either: */
+    if ((!apply_global_alpha
+            || rectangle->applied_global_alpha == rectangle->global_alpha)
+        && (!revert_global_alpha || rectangle->applied_global_alpha == 1.0)) {
+      *stride = rectangle->stride;
+      return rectangle->pixels;
+    } else {
+      /* only apply/revert global-alpha */
+      scaled_rect = rectangle;
+      goto done;
+    }
   }
 
   /* see if we've got one cached already */
@@ -886,8 +1051,9 @@ gst_video_overlay_rectangle_get_pixels_argb (GstVideoOverlayRectangle *
   for (l = rectangle->scaled_rectangles; l != NULL; l = l->next) {
     GstVideoOverlayRectangle *r = l->data;
 
-    if (r->width == rectangle->render_width &&
-        r->height == rectangle->render_height) {
+    if (r->width == wanted_width &&
+        r->height == wanted_height &&
+        gst_video_overlay_rectangle_is_same_alpha_type (r->flags, flags)) {
       /* we'll keep these rectangles around until finalize, so it's ok not
        * to take our own ref here */
       scaled_rect = r;
@@ -899,12 +1065,31 @@ gst_video_overlay_rectangle_get_pixels_argb (GstVideoOverlayRectangle *
   if (scaled_rect != NULL)
     goto done;
 
-  /* not cached yet, do the scaling and put the result into our cache */
+  /* not cached yet, do the preprocessing and put the result into our cache */
   video_blend_format_info_init (&info, GST_BUFFER_DATA (rectangle->pixels),
-      rectangle->height, rectangle->width, rectangle->format);
+      rectangle->height, rectangle->width, rectangle->format,
+      ! !(rectangle->flags &
+          GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA));
+
+  if (wanted_width != rectangle->width || wanted_height != rectangle->height) {
+    /* we could check the cache for a scaled rect with global_alpha == 1 here */
+    video_blend_scale_linear_RGBA (&info, wanted_height, wanted_width);
+  } else {
+    /* if we don't have to scale, we have to modify the alpha values, so we
+     * need to make a copy of the pixel memory (and we take ownership below) */
+    info.pixels = g_memdup (info.pixels, info.size);
+  }
 
-  video_blend_scale_linear_RGBA (&info, rectangle->render_height,
-      rectangle->render_width);
+  new_flags = rectangle->flags;
+  if (!gst_video_overlay_rectangle_is_same_alpha_type (rectangle->flags, flags)) {
+    if (rectangle->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA) {
+      gst_video_overlay_rectangle_unpremultiply (&info);
+      new_flags &= ~GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA;
+    } else {
+      gst_video_overlay_rectangle_premultiply (&info);
+      new_flags |= GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA;
+    }
+  }
 
   buf = gst_buffer_new ();
   GST_BUFFER_DATA (buf) = info.pixels;
@@ -912,9 +1097,11 @@ gst_video_overlay_rectangle_get_pixels_argb (GstVideoOverlayRectangle *
   GST_BUFFER_SIZE (buf) = info.size;
 
   scaled_rect = gst_video_overlay_rectangle_new_argb (buf,
-      rectangle->render_width, rectangle->render_height, info.stride[0],
-      0, 0, rectangle->render_width, rectangle->render_height, 0);
-
+      wanted_width, wanted_height, info.stride[0],
+      0, 0, wanted_width, wanted_height, new_flags);
+  if (rectangle->global_alpha != 1.0)
+    gst_video_overlay_rectangle_set_global_alpha (scaled_rect,
+        rectangle->global_alpha);
   gst_buffer_unref (buf);
 
   GST_RECTANGLE_LOCK (rectangle);
@@ -924,10 +1111,50 @@ gst_video_overlay_rectangle_get_pixels_argb (GstVideoOverlayRectangle *
 
 done:
 
+  GST_RECTANGLE_LOCK (rectangle);
+  if (apply_global_alpha
+      && scaled_rect->applied_global_alpha != rectangle->global_alpha) {
+    gst_video_overlay_rectangle_apply_global_alpha (scaled_rect,
+        rectangle->global_alpha);
+    gst_video_overlay_rectangle_set_global_alpha (scaled_rect,
+        rectangle->global_alpha);
+  } else if (revert_global_alpha && scaled_rect->applied_global_alpha != 1.0) {
+    gst_video_overlay_rectangle_apply_global_alpha (scaled_rect, 1.0);
+  }
+  GST_RECTANGLE_UNLOCK (rectangle);
+
   *stride = scaled_rect->stride;
   return scaled_rect->pixels;
 }
 
+
+/**
+ * gst_video_overlay_rectangle_get_pixels_argb:
+ * @rectangle: a #GstVideoOverlayRectangle
+ * @stride: (out) (allow-none): address of guint variable where to store the
+ *    row stride of the ARGB pixel data in the buffer
+ * @flags: flags
+ *    If a global_alpha value != 1 is set for the rectangle, the caller
+ *    should set the #GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA flag
+ *    if he wants to apply global-alpha himself. If the flag is not set
+ *    global_alpha is applied internally before returning the pixel-data.
+ *
+ * Returns: (transfer none): a #GstBuffer holding the ARGB pixel data with
+ *    row stride @stride and width and height of the render dimensions as per
+ *    gst_video_overlay_rectangle_get_render_rectangle(). This function does
+ *    not return a reference, the caller should obtain a reference of her own
+ *    with gst_buffer_ref() if needed.
+ *
+ * Since: 0.10.36
+ */
+GstBuffer *
+gst_video_overlay_rectangle_get_pixels_argb (GstVideoOverlayRectangle *
+    rectangle, guint * stride, GstVideoOverlayFormatFlags flags)
+{
+  return gst_video_overlay_rectangle_get_pixels_argb_internal (rectangle,
+      stride, flags, FALSE);
+}
+
 /**
  * gst_video_overlay_rectangle_get_pixels_unscaled_argb:
  * @rectangle: a #GstVideoOverlayRectangle
@@ -937,7 +1164,11 @@ done:
  *    rectangle in pixels
  * @stride: (out): address of guint variable where to store the row
  *    stride of the ARGB pixel data in the buffer
- * @flags: flags for future use (unused)
+ * @flags: flags.
+ *    If a global_alpha value != 1 is set for the rectangle, the caller
+ *    should set the #GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA flag
+ *    if he wants to apply global-alpha himself. If the flag is not set
+ *    global_alpha is applied internally before returning the pixel-data.
  *
  * Retrieves the pixel data as it is. This is useful if the caller can
  * do the scaling itself when handling the overlaying. The rectangle will
@@ -959,13 +1190,89 @@ gst_video_overlay_rectangle_get_pixels_unscaled_argb (GstVideoOverlayRectangle *
   g_return_val_if_fail (width != NULL, NULL);
   g_return_val_if_fail (height != NULL, NULL);
   g_return_val_if_fail (stride != NULL, NULL);
-  g_return_val_if_fail (flags == 0, NULL);
 
   *width = rectangle->width;
   *height = rectangle->height;
-  *stride = rectangle->stride;
+  return gst_video_overlay_rectangle_get_pixels_argb_internal (rectangle,
+      stride, flags, TRUE);
+}
+
+/**
+ * gst_video_overlay_rectangle_get_flags:
+ * @rectangle: a #GstVideoOverlayRectangle
+ *
+ * Retrieves the flags associated with a #GstVideoOverlayRectangle.
+ * This is useful if the caller can handle both premultiplied alpha and
+ * non premultiplied alpha, for example. By knowing whether the rectangle
+ * uses premultiplied or not, it can request the pixel data in the format
+ * it is stored in, to avoid unnecessary conversion.
+ *
+ * Returns: the #GstVideoOverlayFormatFlags associated with the rectangle.
+ *
+ * Since: 0.10.37
+ */
+GstVideoOverlayFormatFlags
+gst_video_overlay_rectangle_get_flags (GstVideoOverlayRectangle * rectangle)
+{
+  g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle),
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+
+  return rectangle->flags;
+}
+
+/**
+ * gst_video_overlay_rectangle_get_global_alpha:
+ * @rectangle: a #GstVideoOverlayRectangle
+ *
+ * Retrieves the global-alpha value associated with a #GstVideoOverlayRectangle.
+ *
+ * Returns: the global-alpha value associated with the rectangle.
+ *
+ * Since: 0.10.37
+ */
+gfloat
+gst_video_overlay_rectangle_get_global_alpha (GstVideoOverlayRectangle *
+    rectangle)
+{
+  g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), -1);
 
-  return rectangle->pixels;
+  return rectangle->global_alpha;
+}
+
+/**
+ * gst_video_overlay_rectangle_set_global_alpha:
+ * @rectangle: a #GstVideoOverlayRectangle
+ *
+ * Sets the global alpha value associated with a #GstVideoOverlayRectangle. Per-
+ * pixel alpha values are multiplied with this value. Valid
+ * values: 0 <= global_alpha <= 1; 1 to deactivate.
+ *
+ # @rectangle must be writable, meaning its refcount must be 1. You can
+ * make the rectangles inside a #GstVideoOverlayComposition writable using
+ * gst_video_overlay_composition_make_writable() or
+ * gst_video_overlay_composition_copy().
+ *
+ * Since: 0.10.37
+ */
+void
+gst_video_overlay_rectangle_set_global_alpha (GstVideoOverlayRectangle *
+    rectangle, gfloat global_alpha)
+{
+  g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
+  g_return_if_fail (global_alpha >= 0 && global_alpha <= 1);
+
+  if (rectangle->global_alpha != global_alpha) {
+    rectangle->global_alpha = global_alpha;
+    if (global_alpha != 1)
+      rectangle->flags |= GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA;
+    else
+      rectangle->flags &= ~GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA;
+    /* update seq_num automatically to signal the consumer, that data has changed
+     * note, that this might mislead renderers, that can handle global-alpha
+     * themselves, because what they want to know is whether the actual pixel data
+     * has changed. */
+    rectangle->seq_num = gst_video_overlay_get_seqnum ();
+  }
 }
 
 /**
@@ -992,7 +1299,10 @@ gst_video_overlay_rectangle_copy (GstVideoOverlayRectangle * rectangle)
   copy = gst_video_overlay_rectangle_new_argb (rectangle->pixels,
       rectangle->width, rectangle->height, rectangle->stride,
       rectangle->x, rectangle->y,
-      rectangle->render_width, rectangle->render_height, 0);
+      rectangle->render_width, rectangle->render_height, rectangle->flags);
+  if (rectangle->global_alpha != 1)
+    gst_video_overlay_rectangle_set_global_alpha (copy,
+        rectangle->global_alpha);
 
   return copy;
 }
@@ -1006,6 +1316,16 @@ gst_video_overlay_rectangle_copy (GstVideoOverlayRectangle * rectangle)
  * (meaning there will never be a rectangle with the same sequence number as
  * a composition).
  *
+ * Using the sequence number of a rectangle as an indicator for changed
+ * pixel-data of a rectangle is dangereous. Some API calls, like e.g.
+ * gst_video_overlay_rectangle_set_global_alpha(), automatically update
+ * the per rectangle sequence number, which is misleading for renderers/
+ * consumers, that handle global-alpha themselves. For them  the
+ * pixel-data returned by gst_video_overlay_rectangle_get_pixels_*()
+ * wont be different for different global-alpha values. In this case a
+ * renderer could also use the GstBuffer pointers as a hint for changed
+ * pixel-data.
+ *
  * Returns: the sequence number of @rectangle
  *
  * Since: 0.10.36
diff --git a/gst-libs/gst/video/video-overlay-composition.h b/gst-libs/gst/video/video-overlay-composition.h
index 5ff7ce3..65538e4 100644
--- a/gst-libs/gst/video/video-overlay-composition.h
+++ b/gst-libs/gst/video/video-overlay-composition.h
@@ -95,13 +95,17 @@ gst_video_overlay_rectangle_unref (GstVideoOverlayRectangle * comp)
 /**
  * GstVideoOverlayFormatFlags:
  * @GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE: no flags
+ * @GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA: RGB are premultiplied by A/255. Since: 0.10.37
+ * @GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA: a global-alpha value != 1 is set. Since: 0.10.37
  *
  * Overlay format flags.
  *
  * Since: 0.10.36
  */
 typedef enum {
-  GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE = 0
+  GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE = 0,
+  GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA = 1,
+  GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA = 2
 } GstVideoOverlayFormatFlags;
 
 GType                        gst_video_overlay_rectangle_get_type (void);
@@ -138,6 +142,12 @@ GstBuffer *                  gst_video_overlay_rectangle_get_pixels_unscaled_arg
                                                                                    guint                     * stride,
                                                                                    GstVideoOverlayFormatFlags  flags);
 
+GstVideoOverlayFormatFlags   gst_video_overlay_rectangle_get_flags                (GstVideoOverlayRectangle  * rectangle);
+
+gfloat                       gst_video_overlay_rectangle_get_global_alpha         (GstVideoOverlayRectangle  * rectangle);
+void                         gst_video_overlay_rectangle_set_global_alpha         (GstVideoOverlayRectangle  * rectangle,
+                                                                                   gfloat                      global_alpha);
+
 /**
  * GstVideoOverlayComposition:
  *
diff --git a/gst-libs/gst/video/video.c b/gst-libs/gst/video/video.c
index f22ff4c..f68de1c 100644
--- a/gst-libs/gst/video/video.c
+++ b/gst-libs/gst/video/video.c
@@ -673,7 +673,7 @@ gst_video_format_new_caps_raw (GstVideoFormat format)
 
     if (bpp != 8) {
       gst_caps_set_simple (caps,
-          "endianness", G_TYPE_INT, G_BIG_ENDIAN,
+          "endianness", G_TYPE_INT, bpp == 16 ? G_BYTE_ORDER : G_BIG_ENDIAN,
           "red_mask", G_TYPE_INT, red_mask,
           "green_mask", G_TYPE_INT, green_mask,
           "blue_mask", G_TYPE_INT, blue_mask, NULL);
diff --git a/gst-plugins-base.doap b/gst-plugins-base.doap
index 08bd57e..4f0ff3a 100644
--- a/gst-plugins-base.doap
+++ b/gst-plugins-base.doap
@@ -36,18 +36,6 @@ A wide range of video and audio decoders, encoders, and filters are included.
 
  <release>
   <Version>
-   <revision>0.10.36</revision>
-   <branch>0.10</branch>
-   <name>Better</name>
-   <created>2012-02-20</created>
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gst-plugins-base/gst-plugins-base-0.10.36.tar.bz2" />
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gst-plugins-base/gst-plugins-base-0.10.36.tar.gz" />
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gst-plugins-base/gst-plugins-base-0.10.36.tar.xz" />
-  </Version>
- </release>
-
- <release>
-  <Version>
    <revision>0.10.35</revision>
    <branch>0.10</branch>
    <name>Short Notice</name>
diff --git a/gst/adder/gstadder.c b/gst/adder/gstadder.c
index 9f6895f..8910d6c 100644
--- a/gst/adder/gstadder.c
+++ b/gst/adder/gstadder.c
@@ -43,6 +43,11 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include "gstadder.h"
 #include <gst/audio/audio.h>
 #include <string.h>             /* strcmp */
@@ -127,7 +132,8 @@ static void gst_adder_get_property (GObject * object, guint prop_id,
 static gboolean gst_adder_setcaps (GstPad * pad, GstCaps * caps);
 static gboolean gst_adder_query (GstPad * pad, GstQuery * query);
 static gboolean gst_adder_src_event (GstPad * pad, GstEvent * event);
-static gboolean gst_adder_sink_event (GstPad * pad, GstEvent * event);
+static gboolean gst_adder_sink_event (GstCollectPads2 * pads,
+    GstCollectData2 * pad, GstEvent * event, gpointer user_data);
 
 static GstPad *gst_adder_request_new_pad (GstElement * element,
     GstPadTemplate * temp, const gchar * unused);
@@ -136,9 +142,10 @@ static void gst_adder_release_pad (GstElement * element, GstPad * pad);
 static GstStateChangeReturn gst_adder_change_state (GstElement * element,
     GstStateChange transition);
 
-static GstBuffer *gst_adder_do_clip (GstCollectPads * pads,
-    GstCollectData * data, GstBuffer * buffer, gpointer user_data);
-static GstFlowReturn gst_adder_collected (GstCollectPads * pads,
+static GstFlowReturn gst_adder_do_clip (GstCollectPads2 * pads,
+    GstCollectData2 * data, GstBuffer * buffer, GstBuffer ** out,
+    gpointer user_data);
+static GstFlowReturn gst_adder_collected (GstCollectPads2 * pads,
     gpointer user_data);
 
 /* non-clipping versions (for float) */
@@ -537,6 +544,8 @@ gst_adder_query (GstPad * pad, GstQuery * query)
   return res;
 }
 
+/* event handling */
+
 typedef struct
 {
   GstEvent *event;
@@ -627,8 +636,8 @@ gst_adder_src_event (GstPad * pad, GstEvent * event)
 
   adder = GST_ADDER (gst_pad_get_parent (pad));
 
-  GST_DEBUG_OBJECT (pad, "Got %s event on src pad",
-      GST_EVENT_TYPE_NAME (event));
+  GST_DEBUG_OBJECT (pad, "Got %s event on src pad from %s",
+      GST_EVENT_TYPE_NAME (event), GST_OBJECT_NAME (GST_EVENT_SRC (event)));
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_SEEK:
@@ -659,12 +668,14 @@ gst_adder_src_event (GstPad * pad, GstEvent * event)
 
       /* check if we are flushing */
       if (flush) {
-        /* make sure we accept nothing anymore and return WRONG_STATE */
-        gst_collect_pads_set_flushing (adder->collect, TRUE);
-
         /* flushing seek, start flush downstream, the flush will be done
-         * when all pads received a FLUSH_STOP. */
+         * when all pads received a FLUSH_STOP.
+         * Make sure we accept nothing anymore and return WRONG_STATE.
+         * We send a flush-start before, to ensure no streaming is done
+         * as we need to take the stream lock.
+         */
         gst_pad_push_event (adder->srcpad, gst_event_new_flush_start ());
+        gst_collect_pads2_set_flushing (adder->collect, TRUE);
 
         /* We can't send FLUSH_STOP here since upstream could start pushing data
          * after we unlock adder->collect.
@@ -679,7 +690,7 @@ gst_adder_src_event (GstPad * pad, GstEvent * event)
       /* now wait for the collected to be finished and mark a new
        * segment. After we have the lock, no collect function is running and no
        * new collect function will be called for as long as we're flushing. */
-      GST_OBJECT_LOCK (adder->collect);
+      GST_COLLECT_PADS2_STREAM_LOCK (adder->collect);
       if (curtype == GST_SEEK_TYPE_SET)
         adder->segment_start = cur;
       else
@@ -691,9 +702,9 @@ gst_adder_src_event (GstPad * pad, GstEvent * event)
       if (flush) {
         /* Yes, we need to call _set_flushing again *WHEN* the streaming threads
          * have stopped so that the cookie gets properly updated. */
-        gst_collect_pads_set_flushing (adder->collect, TRUE);
+        gst_collect_pads2_set_flushing (adder->collect, TRUE);
       }
-      GST_OBJECT_UNLOCK (adder->collect);
+      GST_COLLECT_PADS2_STREAM_UNLOCK (adder->collect);
       GST_DEBUG_OBJECT (adder, "forwarding seek event: %" GST_PTR_FORMAT,
           event);
 
@@ -735,42 +746,47 @@ done:
 }
 
 static gboolean
-gst_adder_sink_event (GstPad * pad, GstEvent * event)
+gst_adder_sink_event (GstCollectPads2 * pads, GstCollectData2 * pad,
+    GstEvent * event, gpointer user_data)
 {
-  GstAdder *adder;
-  gboolean ret = TRUE;
+  GstAdder *adder = GST_ADDER (user_data);
+  gboolean res = FALSE;
 
-  adder = GST_ADDER (gst_pad_get_parent (pad));
-
-  GST_DEBUG_OBJECT (pad, "Got %s event on sink pad",
-      GST_EVENT_TYPE_NAME (event));
+  GST_DEBUG_OBJECT (pad->pad, "Got %s event on sink pad from %s",
+      GST_EVENT_TYPE_NAME (event), GST_OBJECT_NAME (GST_EVENT_SRC (event)));
 
   switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_START:
+      /* drop flush start events, as we forwarded one already when handing the
+       * flushing seek on the sink pad */
+      gst_event_unref (event);
+      res = TRUE;
+      break;
     case GST_EVENT_FLUSH_STOP:
-      /* we received a flush-stop. The collect_event function will push the
-       * event past our element. We simply forward all flush-stop events, even
-       * when no flush-stop was pending, this is required because collectpads
-       * does not provide an API to handle-but-not-forward the flush-stop.
-       * We unset the pending flush-stop flag so that we don't send anymore
-       * flush-stop from the collect function later.
+      /* we received a flush-stop. We will only forward it when
+       * flush_stop_pending is set, and we will unset it then.
        */
-      GST_OBJECT_LOCK (adder->collect);
-      g_atomic_int_set (&adder->new_segment_pending, TRUE);
-      g_atomic_int_set (&adder->flush_stop_pending, FALSE);
+      if (g_atomic_int_compare_and_exchange (&adder->flush_stop_pending,
+              TRUE, FALSE)) {
+        g_atomic_int_set (&adder->new_segment_pending, TRUE);
+        GST_DEBUG_OBJECT (pad->pad, "forwarding flush stop");
+      } else {
+        gst_event_unref (event);
+        res = TRUE;
+        GST_DEBUG_OBJECT (pad->pad, "eating flush stop");
+      }
       /* Clear pending tags */
       if (adder->pending_events) {
         g_list_foreach (adder->pending_events, (GFunc) gst_event_unref, NULL);
         g_list_free (adder->pending_events);
         adder->pending_events = NULL;
       }
-      GST_OBJECT_UNLOCK (adder->collect);
       break;
     case GST_EVENT_TAG:
-      GST_OBJECT_LOCK (adder->collect);
       /* collect tags here so we can push them out when we collect data */
       adder->pending_events = g_list_append (adder->pending_events, event);
-      GST_OBJECT_UNLOCK (adder->collect);
-      goto beach;
+      res = TRUE;
+      break;
     case GST_EVENT_NEWSEGMENT:
       if (g_atomic_int_compare_and_exchange (&adder->wait_for_new_segment,
               TRUE, FALSE)) {
@@ -778,17 +794,13 @@ gst_adder_sink_event (GstPad * pad, GstEvent * event)
          * see FIXME in gst_adder_collected() */
         g_atomic_int_set (&adder->new_segment_pending, TRUE);
       }
+      gst_event_unref (event);
+      res = TRUE;
       break;
     default:
       break;
   }
-
-  /* now GstCollectPads can take care of the rest, e.g. EOS */
-  ret = adder->collect_event (pad, event);
-
-beach:
-  gst_object_unref (adder);
-  return ret;
+  return res;
 }
 
 static void
@@ -860,11 +872,13 @@ gst_adder_init (GstAdder * adder, GstAdderClass * klass)
   adder->filter_caps = NULL;
 
   /* keep track of the sinkpads requested */
-  adder->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (adder->collect,
+  adder->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (adder->collect,
       GST_DEBUG_FUNCPTR (gst_adder_collected), adder);
-  gst_collect_pads_set_clip_function (adder->collect,
+  gst_collect_pads2_set_clip_function (adder->collect,
       GST_DEBUG_FUNCPTR (gst_adder_do_clip), adder);
+  gst_collect_pads2_set_event_function (adder->collect,
+      GST_DEBUG_FUNCPTR (gst_adder_sink_event), adder);
 }
 
 static void
@@ -968,13 +982,7 @@ gst_adder_request_new_pad (GstElement * element, GstPadTemplate * templ,
   gst_pad_set_getcaps_function (newpad,
       GST_DEBUG_FUNCPTR (gst_adder_sink_getcaps));
   gst_pad_set_setcaps_function (newpad, GST_DEBUG_FUNCPTR (gst_adder_setcaps));
-  gst_collect_pads_add_pad (adder->collect, newpad, sizeof (GstCollectData));
-
-  /* FIXME: hacked way to override/extend the event function of
-   * GstCollectPads; because it sets its own event function giving the
-   * element no access to events */
-  adder->collect_event = (GstPadEventFunction) GST_PAD_EVENTFUNC (newpad);
-  gst_pad_set_event_function (newpad, GST_DEBUG_FUNCPTR (gst_adder_sink_event));
+  gst_collect_pads2_add_pad (adder->collect, newpad, sizeof (GstCollectData2));
 
   /* takes ownership of the pad */
   if (!gst_element_add_pad (GST_ELEMENT (adder), newpad))
@@ -991,7 +999,7 @@ not_sink:
 could_not_add:
   {
     GST_DEBUG_OBJECT (adder, "could not add pad");
-    gst_collect_pads_remove_pad (adder->collect, newpad);
+    gst_collect_pads2_remove_pad (adder->collect, newpad);
     gst_object_unref (newpad);
     return NULL;
   }
@@ -1006,13 +1014,13 @@ gst_adder_release_pad (GstElement * element, GstPad * pad)
 
   GST_DEBUG_OBJECT (adder, "release pad %s:%s", GST_DEBUG_PAD_NAME (pad));
 
-  gst_collect_pads_remove_pad (adder->collect, pad);
+  gst_collect_pads2_remove_pad (adder->collect, pad);
   gst_element_remove_pad (element, pad);
 }
 
-static GstBuffer *
-gst_adder_do_clip (GstCollectPads * pads, GstCollectData * data,
-    GstBuffer * buffer, gpointer user_data)
+static GstFlowReturn
+gst_adder_do_clip (GstCollectPads2 * pads, GstCollectData2 * data,
+    GstBuffer * buffer, GstBuffer ** out, gpointer user_data)
 {
   GstAdder *adder = GST_ADDER (user_data);
 
@@ -1025,11 +1033,12 @@ gst_adder_do_clip (GstCollectPads * pads, GstCollectData * data,
         adder->bps);
   }
 
-  return buffer;
+  *out = buffer;
+  return GST_FLOW_OK;
 }
 
 static GstFlowReturn
-gst_adder_collected (GstCollectPads * pads, gpointer user_data)
+gst_adder_collected (GstCollectPads2 * pads, gpointer user_data)
 {
   /*
    * combine streams by adding data values
@@ -1070,7 +1079,7 @@ gst_adder_collected (GstCollectPads * pads, gpointer user_data)
 
   /* get available bytes for reading, this can be 0 which could mean empty
    * buffers or EOS, which we will catch when we loop over the pads. */
-  outsize = gst_collect_pads_available (pads);
+  outsize = gst_collect_pads2_available (pads);
   /* can only happen when no pads to collect or all EOS */
   if (outsize == 0)
     goto eos;
@@ -1080,18 +1089,18 @@ gst_adder_collected (GstCollectPads * pads, gpointer user_data)
       outsize, adder->bps);
 
   for (collected = pads->data; collected; collected = next) {
-    GstCollectData *collect_data;
+    GstCollectData2 *collect_data;
     GstBuffer *inbuf;
     gboolean is_gap;
 
     /* take next to see if this is the last collectdata */
     next = g_slist_next (collected);
 
-    collect_data = (GstCollectData *) collected->data;
+    collect_data = (GstCollectData2 *) collected->data;
 
     /* get a buffer of size bytes, if we get a buffer, it is at least outsize
      * bytes big. */
-    inbuf = gst_collect_pads_take_buffer (pads, collect_data, outsize);
+    inbuf = gst_collect_pads2_take_buffer (pads, collect_data, outsize);
     /* NULL means EOS or an empty buffer so we still need to flush in
      * case of an empty buffer. */
     if (inbuf == NULL) {
@@ -1192,7 +1201,7 @@ gst_adder_collected (GstCollectPads * pads, gpointer user_data)
 
     if (event) {
       if (!gst_pad_push_event (adder->srcpad, event)) {
-        GST_WARNING_OBJECT (adder->srcpad, "Sending event failed");
+        GST_WARNING_OBJECT (adder->srcpad, "Sending new segment event failed");
       }
     } else {
       GST_WARNING_OBJECT (adder->srcpad, "Creating new segment event for "
@@ -1266,6 +1275,7 @@ eos:
   }
 }
 
+
 static GstStateChangeReturn
 gst_adder_change_state (GstElement * element, GstStateChange transition)
 {
@@ -1287,14 +1297,14 @@ gst_adder_change_state (GstElement * element, GstStateChange transition)
       adder->segment_end = GST_CLOCK_TIME_NONE;
       adder->segment_rate = 1.0;
       gst_segment_init (&adder->segment, GST_FORMAT_UNDEFINED);
-      gst_collect_pads_start (adder->collect);
+      gst_collect_pads2_start (adder->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      /* need to unblock the collectpads before calling the
+      /* need to unblock the collectpads2 before calling the
        * parent change_state so that streaming can finish */
-      gst_collect_pads_stop (adder->collect);
+      gst_collect_pads2_stop (adder->collect);
       break;
     default:
       break;
@@ -1310,7 +1320,6 @@ gst_adder_change_state (GstElement * element, GstStateChange transition)
   return ret;
 }
 
-
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
diff --git a/gst/adder/gstadder.h b/gst/adder/gstadder.h
index 7fbdde6..3895118 100644
--- a/gst/adder/gstadder.h
+++ b/gst/adder/gstadder.h
@@ -24,7 +24,7 @@
 #define __GST_ADDER_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 G_BEGIN_DECLS
 
@@ -56,7 +56,7 @@ struct _GstAdder {
   GstElement      element;
 
   GstPad         *srcpad;
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
   /* pad counter, used for creating unique request pads */
   gint            padcount;
 
diff --git a/gst/playback/gstplay-enum.c b/gst/playback/gstplay-enum.c
index e337fdf..4fe137d 100644
--- a/gst/playback/gstplay-enum.c
+++ b/gst/playback/gstplay-enum.c
@@ -65,6 +65,8 @@ gst_play_flags_get_type (void)
         "buffering"},
     {C_FLAGS (GST_PLAY_FLAG_DEINTERLACE), "Deinterlace video if necessary",
         "deinterlace"},
+    {C_FLAGS (GST_PLAY_FLAG_SOFT_COLORBALANCE), "Use software color balance",
+        "soft-colorbalance"},
     {0, NULL, NULL}
   };
   static volatile GType id = 0;
diff --git a/gst/playback/gstplay-enum.h b/gst/playback/gstplay-enum.h
index 77a34cf..457d90c 100644
--- a/gst/playback/gstplay-enum.h
+++ b/gst/playback/gstplay-enum.h
@@ -70,7 +70,8 @@ typedef enum {
   GST_PLAY_FLAG_NATIVE_VIDEO  = (1 << 6),
   GST_PLAY_FLAG_DOWNLOAD      = (1 << 7),
   GST_PLAY_FLAG_BUFFERING     = (1 << 8),
-  GST_PLAY_FLAG_DEINTERLACE   = (1 << 9)
+  GST_PLAY_FLAG_DEINTERLACE   = (1 << 9),
+  GST_PLAY_FLAG_SOFT_COLORBALANCE = (1 << 10)
 } GstPlayFlags;
 
 #define GST_TYPE_PLAY_FLAGS (gst_play_flags_get_type())
diff --git a/gst/playback/gstplaybasebin.c b/gst/playback/gstplaybasebin.c
index 7ab2c29..a89d649 100644
--- a/gst/playback/gstplaybasebin.c
+++ b/gst/playback/gstplaybasebin.c
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/gst/playback/gstplaybin2.c b/gst/playback/gstplaybin2.c
index e01ff6c..0074394 100644
--- a/gst/playback/gstplaybin2.c
+++ b/gst/playback/gstplaybin2.c
@@ -178,13 +178,15 @@
  * <refsect2>
  * <title>Specifying which CD/DVD device to use</title>
  * The device to use for CDs/DVDs needs to be set on the source element
- * playbin creates before it is opened. The only way to do this at the moment
- * is to connect to playbin's "notify::source" signal, which will be emitted
- * by playbin when it has created the source element for a particular URI.
- * In the signal callback you can check if the source element has a "device"
- * property and set it appropriately. In future ways might be added to specify
- * the device as part of the URI, but at the time of writing this is not
- * possible yet.
+ * playbin creates before it is opened. The most generic way of doing this
+ * is to connect to playbin's "source-setup" (or "notify::source") signal,
+ * which will be emitted by playbin2 when it has created the source element
+ * for a particular URI. In the signal callback you can check if the source
+ * element has a "device" property and set it appropriately. In some cases
+ * the device can also be set as part of the URI, but it depends on the
+ * elements involved if this will work or not. For example, for DVD menu
+ * playback, the following syntax might work (if the resindvd plugin is used):
+ * dvd://[/path/to/device]
  * </refsect2>
  * <refsect2>
  * <title>Handling redirects</title>
@@ -199,19 +201,19 @@
  * <refsect2>
  * <title>Examples</title>
  * |[
- * gst-launch -v playbin uri=file:///path/to/somefile.avi
+ * gst-launch -v playbin2 uri=file:///path/to/somefile.avi
  * ]| This will play back the given AVI video file, given that the video and
  * audio decoders required to decode the content are installed. Since no
  * special audio sink or video sink is supplied (not possible via gst-launch),
  * playbin will try to find a suitable audio and video sink automatically
  * using the autoaudiosink and autovideosink elements.
  * |[
- * gst-launch -v playbin uri=cdda://4
+ * gst-launch -v playbin2 uri=cdda://4
  * ]| This will play back track 4 on an audio CD in your disc drive (assuming
  * the drive is detected automatically by the plugin).
  * |[
- * gst-launch -v playbin uri=dvd://1
- * ]| This will play back title 1 of a DVD in your disc drive (assuming
+ * gst-launch -v playbin2 uri=dvd://
+ * ]| This will play back the DVD in your disc drive (assuming
  * the drive is detected automatically by the plugin).
  * </refsect2>
  */
@@ -230,6 +232,9 @@
 #include <gst/gst-i18n-plugin.h>
 #include <gst/pbutils/pbutils.h>
 #include <gst/interfaces/streamvolume.h>
+#include <gst/interfaces/xoverlay.h>
+#include <gst/interfaces/navigation.h>
+#include <gst/interfaces/colorbalance.h>
 
 #include "gstplay-enum.h"
 #include "gstplay-marshal.h"
@@ -456,7 +461,7 @@ struct _GstPlayBinClass
 #define DEFAULT_SUBURI            NULL
 #define DEFAULT_SOURCE            NULL
 #define DEFAULT_FLAGS             GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_TEXT | \
-                                  GST_PLAY_FLAG_SOFT_VOLUME
+                                  GST_PLAY_FLAG_SOFT_VOLUME | GST_PLAY_FLAG_SOFT_COLORBALANCE
 #define DEFAULT_N_VIDEO           0
 #define DEFAULT_CURRENT_VIDEO     -1
 #define DEFAULT_N_AUDIO           0
@@ -578,6 +583,15 @@ if (id) {                                \
   id = 0;                                \
 }
 
+static void gst_play_bin_implements_interface_init (gpointer g_iface,
+    gpointer g_iface_data);
+static void gst_play_bin_xoverlay_init (gpointer g_iface,
+    gpointer g_iface_data);
+static void gst_play_bin_navigation_init (gpointer g_iface,
+    gpointer g_iface_data);
+static void gst_play_bin_colorbalance_init (gpointer g_iface,
+    gpointer g_iface_data);
+
 static GType
 gst_play_bin_get_type (void)
 {
@@ -596,15 +610,39 @@ gst_play_bin_get_type (void)
       (GInstanceInitFunc) gst_play_bin_init,
       NULL
     };
+    static const GInterfaceInfo impl_info = {
+      gst_play_bin_implements_interface_init,
+      NULL, NULL
+    };
     static const GInterfaceInfo svol_info = {
       NULL, NULL, NULL
     };
+    static const GInterfaceInfo xov_info = {
+      gst_play_bin_xoverlay_init,
+      NULL, NULL
+    };
+    static const GInterfaceInfo nav_info = {
+      gst_play_bin_navigation_init,
+      NULL, NULL
+    };
+    static const GInterfaceInfo col_info = {
+      gst_play_bin_colorbalance_init,
+      NULL, NULL
+    };
 
     gst_play_bin_type = g_type_register_static (GST_TYPE_PIPELINE,
         "GstPlayBin2", &gst_play_bin_info, 0);
 
+    g_type_add_interface_static (gst_play_bin_type,
+        GST_TYPE_IMPLEMENTS_INTERFACE, &impl_info);
     g_type_add_interface_static (gst_play_bin_type, GST_TYPE_STREAM_VOLUME,
         &svol_info);
+    g_type_add_interface_static (gst_play_bin_type, GST_TYPE_X_OVERLAY,
+        &xov_info);
+    g_type_add_interface_static (gst_play_bin_type, GST_TYPE_NAVIGATION,
+        &nav_info);
+    g_type_add_interface_static (gst_play_bin_type, GST_TYPE_COLOR_BALANCE,
+        &col_info);
   }
 
   return gst_play_bin_type;
@@ -1214,6 +1252,13 @@ notify_mute_cb (GObject * selector, GParamSpec * pspec, GstPlayBin * playbin)
   g_object_notify (G_OBJECT (playbin), "mute");
 }
 
+static void
+colorbalance_value_changed_cb (GstColorBalance * balance,
+    GstColorBalanceChannel * channel, gint value, GstPlayBin * playbin)
+{
+  gst_color_balance_value_changed (GST_COLOR_BALANCE (playbin), channel, value);
+}
+
 /* Must be called with elements lock! */
 static void
 gst_play_bin_update_elements_list (GstPlayBin * playbin)
@@ -1257,7 +1302,9 @@ gst_play_bin_init (GstPlayBin * playbin)
   playbin->elements_lock = g_mutex_new ();
 
   /* add sink */
-  playbin->playsink = g_object_new (GST_TYPE_PLAY_SINK, NULL);
+  playbin->playsink =
+      g_object_new (GST_TYPE_PLAY_SINK, "name", "playsink", "send-event-mode",
+      1, NULL);
   gst_bin_add (GST_BIN_CAST (playbin), GST_ELEMENT_CAST (playbin->playsink));
   gst_play_sink_set_flags (playbin->playsink, DEFAULT_FLAGS);
   /* Connect to notify::volume and notify::mute signals for proxying */
@@ -1265,6 +1312,8 @@ gst_play_bin_init (GstPlayBin * playbin)
       G_CALLBACK (notify_volume_cb), playbin);
   g_signal_connect (playbin->playsink, "notify::mute",
       G_CALLBACK (notify_mute_cb), playbin);
+  g_signal_connect (playbin->playsink, "value-changed",
+      G_CALLBACK (colorbalance_value_changed_cb), playbin);
 
   playbin->current_video = DEFAULT_CURRENT_VIDEO;
   playbin->current_audio = DEFAULT_CURRENT_AUDIO;
@@ -3493,7 +3542,10 @@ activate_group (GstPlayBin * playbin, GstSourceGroup * group, GstState target)
     GST_DEBUG_OBJECT (playbin, "reusing existing uridecodebin");
     uridecodebin = group->uridecodebin;
     gst_element_set_state (uridecodebin, GST_STATE_READY);
-    gst_bin_add (GST_BIN_CAST (playbin), gst_object_ref (uridecodebin));
+    /* no need to take extra ref, we already have one
+     * and the bin will add one since it is no longer floating,
+     * as it was at least added once before (below) */
+    gst_bin_add (GST_BIN_CAST (playbin), uridecodebin);
   } else {
     GST_DEBUG_OBJECT (playbin, "making new uridecodebin");
     uridecodebin = gst_element_factory_make ("uridecodebin", NULL);
@@ -3556,7 +3608,10 @@ activate_group (GstPlayBin * playbin, GstSourceGroup * group, GstState target)
       GST_DEBUG_OBJECT (playbin, "reusing existing suburidecodebin");
       suburidecodebin = group->suburidecodebin;
       gst_element_set_state (suburidecodebin, GST_STATE_READY);
-      gst_bin_add (GST_BIN_CAST (playbin), gst_object_ref (suburidecodebin));
+      /* no need to take extra ref, we already have one
+       * and the bin will add one since it is no longer floating,
+       * as it was at least added once before (below) */
+      gst_bin_add (GST_BIN_CAST (playbin), suburidecodebin);
     } else {
       GST_DEBUG_OBJECT (playbin, "making new suburidecodebin");
       suburidecodebin = gst_element_factory_make ("uridecodebin", NULL);
@@ -4017,6 +4072,137 @@ failure:
   }
 }
 
+static void
+gst_play_bin_xoverlay_expose (GstXOverlay * overlay)
+{
+  GstPlayBin *playbin = GST_PLAY_BIN (overlay);
+
+  gst_x_overlay_expose (GST_X_OVERLAY (playbin->playsink));
+}
+
+static void
+gst_play_bin_xoverlay_handle_events (GstXOverlay * overlay,
+    gboolean handle_events)
+{
+  GstPlayBin *playbin = GST_PLAY_BIN (overlay);
+
+  gst_x_overlay_handle_events (GST_X_OVERLAY (playbin->playsink),
+      handle_events);
+}
+
+static void
+gst_play_bin_xoverlay_set_render_rectangle (GstXOverlay * overlay, gint x,
+    gint y, gint width, gint height)
+{
+  GstPlayBin *playbin = GST_PLAY_BIN (overlay);
+
+  gst_x_overlay_set_render_rectangle (GST_X_OVERLAY (playbin->playsink), x, y,
+      width, height);
+}
+
+static void
+gst_play_bin_xoverlay_set_window_handle (GstXOverlay * overlay, guintptr handle)
+{
+  GstPlayBin *playbin = GST_PLAY_BIN (overlay);
+
+  gst_x_overlay_set_window_handle (GST_X_OVERLAY (playbin->playsink), handle);
+}
+
+static void
+gst_play_bin_xoverlay_init (gpointer g_iface, gpointer g_iface_data)
+{
+  GstXOverlayClass *iface = (GstXOverlayClass *) g_iface;
+  iface->expose = gst_play_bin_xoverlay_expose;
+  iface->handle_events = gst_play_bin_xoverlay_handle_events;
+  iface->set_render_rectangle = gst_play_bin_xoverlay_set_render_rectangle;
+  iface->set_window_handle = gst_play_bin_xoverlay_set_window_handle;
+}
+
+static gboolean
+gst_play_bin_implements_interface_supported (GstImplementsInterface * iface,
+    GType type)
+{
+  if (type == GST_TYPE_X_OVERLAY || type == GST_TYPE_STREAM_VOLUME ||
+      type == GST_TYPE_NAVIGATION || type == GST_TYPE_COLOR_BALANCE)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+static void
+gst_play_bin_implements_interface_init (gpointer g_iface, gpointer g_iface_data)
+{
+  GstImplementsInterfaceClass *iface = (GstImplementsInterfaceClass *) g_iface;
+  iface->supported = gst_play_bin_implements_interface_supported;
+}
+
+static void
+gst_play_bin_navigation_send_event (GstNavigation * navigation,
+    GstStructure * structure)
+{
+  GstPlayBin *playbin = GST_PLAY_BIN (navigation);
+
+  gst_navigation_send_event (GST_NAVIGATION (playbin->playsink), structure);
+}
+
+static void
+gst_play_bin_navigation_init (gpointer g_iface, gpointer g_iface_data)
+{
+  GstNavigationInterface *iface = (GstNavigationInterface *) g_iface;
+
+  iface->send_event = gst_play_bin_navigation_send_event;
+}
+
+static const GList *
+gst_play_bin_colorbalance_list_channels (GstColorBalance * balance)
+{
+  GstPlayBin *playbin = GST_PLAY_BIN (balance);
+
+  return
+      gst_color_balance_list_channels (GST_COLOR_BALANCE (playbin->playsink));
+}
+
+static void
+gst_play_bin_colorbalance_set_value (GstColorBalance * balance,
+    GstColorBalanceChannel * channel, gint value)
+{
+  GstPlayBin *playbin = GST_PLAY_BIN (balance);
+
+  gst_color_balance_set_value (GST_COLOR_BALANCE (playbin->playsink), channel,
+      value);
+}
+
+static gint
+gst_play_bin_colorbalance_get_value (GstColorBalance * balance,
+    GstColorBalanceChannel * channel)
+{
+  GstPlayBin *playbin = GST_PLAY_BIN (balance);
+
+  return gst_color_balance_get_value (GST_COLOR_BALANCE (playbin->playsink),
+      channel);
+}
+
+static GstColorBalanceType
+gst_play_bin_colorbalance_get_balance_type (GstColorBalance * balance)
+{
+  GstPlayBin *playbin = GST_PLAY_BIN (balance);
+
+  return
+      gst_color_balance_get_balance_type (GST_COLOR_BALANCE
+      (playbin->playsink));
+}
+
+static void
+gst_play_bin_colorbalance_init (gpointer g_iface, gpointer g_iface_data)
+{
+  GstColorBalanceClass *iface = (GstColorBalanceClass *) g_iface;
+
+  iface->list_channels = gst_play_bin_colorbalance_list_channels;
+  iface->set_value = gst_play_bin_colorbalance_set_value;
+  iface->get_value = gst_play_bin_colorbalance_get_value;
+  iface->get_balance_type = gst_play_bin_colorbalance_get_balance_type;
+}
+
 gboolean
 gst_play_bin2_plugin_init (GstPlugin * plugin)
 {
diff --git a/gst/playback/gstplaysink.c b/gst/playback/gstplaysink.c
index d02ec60..7e2f0d8 100644
--- a/gst/playback/gstplaysink.c
+++ b/gst/playback/gstplaysink.c
@@ -32,6 +32,10 @@
 #include <gst/gst-i18n-plugin.h>
 #include <gst/pbutils/pbutils.h>
 #include <gst/video/video.h>
+#include <gst/interfaces/streamvolume.h>
+#include <gst/interfaces/colorbalance.h>
+#include <gst/interfaces/xoverlay.h>
+#include <gst/interfaces/navigation.h>
 
 #include "gstplaysink.h"
 #include "gststreamsynchronizer.h"
@@ -44,10 +48,45 @@ GST_DEBUG_CATEGORY_STATIC (gst_play_sink_debug);
 #define VOLUME_MAX_DOUBLE 10.0
 
 #define DEFAULT_FLAGS             GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_TEXT | \
-                                  GST_PLAY_FLAG_SOFT_VOLUME
+                                  GST_PLAY_FLAG_SOFT_VOLUME | GST_PLAY_FLAG_SOFT_COLORBALANCE
 
 #define GST_PLAY_CHAIN(c) ((GstPlayChain *)(c))
 
+/* enum types */
+/**
+ * GstPlaySinkSendEventMode:
+ * @MODE_DEFAULT: default GstBin's send_event handling
+ * @MODE_FIRST: send event only to the first sink that return true
+ *
+ * Send event handling to use
+ */
+typedef enum
+{
+  MODE_DEFAULT = 0,
+  MODE_FIRST = 1
+} GstPlaySinkSendEventMode;
+
+
+#define GST_TYPE_PLAY_SINK_SEND_EVENT_MODE (gst_play_sink_send_event_mode_get_type ())
+static GType
+gst_play_sink_send_event_mode_get_type (void)
+{
+  static GType gtype = 0;
+
+  if (gtype == 0) {
+    static const GEnumValue values[] = {
+      {MODE_DEFAULT, "Default GstBin's send_event handling (default)",
+          "default"},
+      {MODE_FIRST, "Sends the event to sinks until the first one handles it",
+          "first"},
+      {0, NULL, NULL}
+    };
+
+    gtype = g_enum_register_static ("GstPlaySinkSendEventMode", values);
+  }
+  return gtype;
+}
+
 /* holds the common data fields for the audio and video pipelines. We keep them
  * in a structure to more easily have all the info available. */
 typedef struct
@@ -203,6 +242,21 @@ struct _GstPlaySink
   gboolean volume_changed;      /* volume/mute changed while no audiochain */
   gboolean mute_changed;        /* ... has been created yet */
   gint64 av_offset;
+  GstPlaySinkSendEventMode send_event_mode;
+
+  /* xoverlay proxy interface */
+  GstXOverlay *xoverlay_element;        /* protected with LOCK */
+  gboolean xoverlay_handle_set;
+  guintptr xoverlay_handle;
+  gboolean xoverlay_render_rectangle_set;
+  gint xoverlay_x, xoverlay_y, xoverlay_width, xoverlay_height;
+  gboolean xoverlay_handle_events_set;
+  gboolean xoverlay_handle_events;
+
+  /* colorbalance proxy interface */
+  GstColorBalance *colorbalance_element;
+  GList *colorbalance_channels; /* CONTRAST, BRIGHTNESS, HUE, SATURATION */
+  gint colorbalance_values[4];
 };
 
 struct _GstPlaySinkClass
@@ -258,6 +312,7 @@ enum
   PROP_VIDEO_SINK,
   PROP_AUDIO_SINK,
   PROP_TEXT_SINK,
+  PROP_SEND_EVENT_MODE,
   PROP_LAST
 };
 
@@ -325,7 +380,47 @@ gst_play_marshal_BUFFER__BOXED (GClosure * closure,
 
 /* static guint gst_play_sink_signals[LAST_SIGNAL] = { 0 }; */
 
-G_DEFINE_TYPE (GstPlaySink, gst_play_sink, GST_TYPE_BIN);
+static void gst_play_sink_implements_interface_init (gpointer g_iface,
+    gpointer g_iface_data);
+static void gst_play_sink_xoverlay_init (gpointer g_iface,
+    gpointer g_iface_data);
+static void gst_play_sink_navigation_init (gpointer g_iface,
+    gpointer g_iface_data);
+static void gst_play_sink_colorbalance_init (gpointer g_iface,
+    gpointer g_iface_data);
+
+static void
+_do_init (GType type)
+{
+  static const GInterfaceInfo impl_info = {
+    gst_play_sink_implements_interface_init,
+    NULL, NULL
+  };
+  static const GInterfaceInfo svol_info = {
+    NULL, NULL, NULL
+  };
+  static const GInterfaceInfo xov_info = {
+    gst_play_sink_xoverlay_init,
+    NULL, NULL
+  };
+  static const GInterfaceInfo nav_info = {
+    gst_play_sink_navigation_init,
+    NULL, NULL
+  };
+  static const GInterfaceInfo col_info = {
+    gst_play_sink_colorbalance_init,
+    NULL, NULL
+  };
+
+  g_type_add_interface_static (type, GST_TYPE_IMPLEMENTS_INTERFACE, &impl_info);
+  g_type_add_interface_static (type, GST_TYPE_STREAM_VOLUME, &svol_info);
+  g_type_add_interface_static (type, GST_TYPE_X_OVERLAY, &xov_info);
+  g_type_add_interface_static (type, GST_TYPE_NAVIGATION, &nav_info);
+  g_type_add_interface_static (type, GST_TYPE_COLOR_BALANCE, &col_info);
+}
+
+G_DEFINE_TYPE_WITH_CODE (GstPlaySink, gst_play_sink, GST_TYPE_BIN,
+    _do_init (g_define_type_id));
 
 static void
 gst_play_sink_class_init (GstPlaySinkClass * klass)
@@ -437,6 +532,7 @@ gst_play_sink_class_init (GstPlaySinkClass * klass)
       g_param_spec_object ("audio-sink", "Audio Sink",
           "the audio output element to use (NULL = default sink)",
           GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstPlaySink:text-sink:
    *
@@ -450,6 +546,20 @@ gst_play_sink_class_init (GstPlaySinkClass * klass)
           "the text output element to use (NULL = default textoverlay)",
           GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstPlaySink::send-event-mode:
+   *
+   * Sets the handling method used for events received from send_event
+   * function. The default is %MODE_DEFAULT, that uses %GstBin's default
+   * handling (push the event to all internal sinks).
+   *
+   * Since: 0.10.37
+   */
+  g_object_class_install_property (gobject_klass, PROP_SEND_EVENT_MODE,
+      g_param_spec_enum ("send-event-mode", "Send event mode",
+          "How to send events received in send_event function",
+          GST_TYPE_PLAY_SINK_SEND_EVENT_MODE, MODE_DEFAULT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   g_signal_new ("reconfigure", G_TYPE_FROM_CLASS (klass),
       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (GstPlaySinkClass,
@@ -479,14 +589,11 @@ gst_play_sink_class_init (GstPlaySinkClass * klass)
 
   gst_element_class_add_static_pad_template (gstelement_klass,
       &audiorawtemplate);
-  gst_element_class_add_static_pad_template (gstelement_klass,
-      &audiotemplate);
+  gst_element_class_add_static_pad_template (gstelement_klass, &audiotemplate);
   gst_element_class_add_static_pad_template (gstelement_klass,
       &videorawtemplate);
-  gst_element_class_add_static_pad_template (gstelement_klass,
-      &videotemplate);
-  gst_element_class_add_static_pad_template (gstelement_klass,
-      &texttemplate);
+  gst_element_class_add_static_pad_template (gstelement_klass, &videotemplate);
+  gst_element_class_add_static_pad_template (gstelement_klass, &texttemplate);
   gst_element_class_set_details_simple (gstelement_klass, "Player Sink",
       "Generic/Bin/Sink",
       "Convenience sink for multiple streams",
@@ -510,6 +617,8 @@ gst_play_sink_class_init (GstPlaySinkClass * klass)
 static void
 gst_play_sink_init (GstPlaySink * playsink)
 {
+  GstColorBalanceChannel *channel;
+
   /* init groups */
   playsink->video_sink = NULL;
   playsink->audio_sink = NULL;
@@ -519,6 +628,7 @@ gst_play_sink_init (GstPlaySink * playsink)
   playsink->font_desc = NULL;
   playsink->subtitle_encoding = NULL;
   playsink->flags = DEFAULT_FLAGS;
+  playsink->send_event_mode = MODE_DEFAULT;
 
   playsink->stream_synchronizer =
       g_object_new (GST_TYPE_STREAM_SYNCHRONIZER, NULL);
@@ -527,6 +637,46 @@ gst_play_sink_init (GstPlaySink * playsink)
 
   g_static_rec_mutex_init (&playsink->lock);
   GST_OBJECT_FLAG_SET (playsink, GST_ELEMENT_IS_SINK);
+
+  channel =
+      GST_COLOR_BALANCE_CHANNEL (g_object_new (GST_TYPE_COLOR_BALANCE_CHANNEL,
+          NULL));
+  channel->label = g_strdup ("CONTRAST");
+  channel->min_value = -1000;
+  channel->max_value = 1000;
+  playsink->colorbalance_channels =
+      g_list_append (playsink->colorbalance_channels, channel);
+  playsink->colorbalance_values[0] = 0;
+
+  channel =
+      GST_COLOR_BALANCE_CHANNEL (g_object_new (GST_TYPE_COLOR_BALANCE_CHANNEL,
+          NULL));
+  channel->label = g_strdup ("BRIGHTNESS");
+  channel->min_value = -1000;
+  channel->max_value = 1000;
+  playsink->colorbalance_channels =
+      g_list_append (playsink->colorbalance_channels, channel);
+  playsink->colorbalance_values[1] = 0;
+
+  channel =
+      GST_COLOR_BALANCE_CHANNEL (g_object_new (GST_TYPE_COLOR_BALANCE_CHANNEL,
+          NULL));
+  channel->label = g_strdup ("HUE");
+  channel->min_value = -1000;
+  channel->max_value = 1000;
+  playsink->colorbalance_channels =
+      g_list_append (playsink->colorbalance_channels, channel);
+  playsink->colorbalance_values[2] = 0;
+
+  channel =
+      GST_COLOR_BALANCE_CHANNEL (g_object_new (GST_TYPE_COLOR_BALANCE_CHANNEL,
+          NULL));
+  channel->label = g_strdup ("SATURATION");
+  channel->min_value = -1000;
+  channel->max_value = 1000;
+  playsink->colorbalance_channels =
+      g_list_append (playsink->colorbalance_channels, channel);
+  playsink->colorbalance_values[3] = 0;
 }
 
 static void
@@ -618,6 +768,11 @@ gst_play_sink_dispose (GObject * object)
 
   playsink->stream_synchronizer = NULL;
 
+  g_list_foreach (playsink->colorbalance_channels, (GFunc) gst_object_unref,
+      NULL);
+  g_list_free (playsink->colorbalance_channels);
+  playsink->colorbalance_channels = NULL;
+
   G_OBJECT_CLASS (gst_play_sink_parent_class)->dispose (object);
 }
 
@@ -1240,6 +1395,150 @@ link_failed:
   }
 }
 
+static gboolean
+is_valid_color_balance_element (GstElement * element)
+{
+  GstColorBalance *bal = GST_COLOR_BALANCE (element);
+  gboolean have_brightness = FALSE;
+  gboolean have_contrast = FALSE;
+  gboolean have_hue = FALSE;
+  gboolean have_saturation = FALSE;
+  const GList *channels, *l;
+
+  channels = gst_color_balance_list_channels (bal);
+  for (l = channels; l; l = l->next) {
+    GstColorBalanceChannel *ch = l->data;
+
+    if (g_strrstr (ch->label, "BRIGHTNESS"))
+      have_brightness = TRUE;
+    else if (g_strrstr (ch->label, "CONTRAST"))
+      have_contrast = TRUE;
+    else if (g_strrstr (ch->label, "HUE"))
+      have_hue = TRUE;
+    else if (g_strrstr (ch->label, "SATURATION"))
+      have_saturation = TRUE;
+  }
+
+  return have_brightness && have_contrast && have_hue && have_saturation;
+}
+
+static void
+iterate_color_balance_elements (gpointer data, gpointer user_data)
+{
+  gboolean valid = is_valid_color_balance_element (data);
+  GstColorBalance **cb_out = user_data;
+
+  if (valid) {
+    if (*cb_out
+        && gst_color_balance_get_balance_type (*cb_out) ==
+        GST_COLOR_BALANCE_SOFTWARE) {
+      gst_object_unref (*cb_out);
+      *cb_out = GST_COLOR_BALANCE (gst_object_ref (data));
+    } else if (!*cb_out) {
+      *cb_out = GST_COLOR_BALANCE (gst_object_ref (data));
+    }
+  }
+
+  gst_object_unref (data);
+}
+
+static GstColorBalance *
+find_color_balance_element (GstElement * element)
+{
+  GstIterator *it;
+  GstColorBalance *cb = NULL;
+
+  if (GST_IS_COLOR_BALANCE (element)
+      && is_valid_color_balance_element (element))
+    return GST_COLOR_BALANCE (gst_object_ref (element));
+  else if (!GST_IS_BIN (element))
+    return FALSE;
+
+  it = gst_bin_iterate_all_by_interface (GST_BIN (element),
+      GST_TYPE_COLOR_BALANCE);
+  while (gst_iterator_foreach (it, iterate_color_balance_elements,
+          &cb) == GST_ITERATOR_RESYNC)
+    gst_iterator_resync (it);
+  gst_iterator_free (it);
+
+  return cb;
+}
+
+static void
+colorbalance_value_changed_cb (GstColorBalance * balance,
+    GstColorBalanceChannel * channel, gint value, GstPlaySink * playsink)
+{
+  GList *l;
+  gint i;
+
+  for (i = 0, l = playsink->colorbalance_channels; l; l = l->next, i++) {
+    GstColorBalanceChannel *proxy = l->data;
+
+    if (g_strrstr (channel->label, proxy->label)) {
+      gdouble new_val;
+
+      /* Convert to [0, 1] range */
+      new_val =
+          ((gdouble) value -
+          (gdouble) channel->min_value) / ((gdouble) channel->max_value -
+          (gdouble) channel->min_value);
+      /* Convert to proxy range */
+      new_val =
+          proxy->min_value + new_val * ((gdouble) proxy->max_value -
+          (gdouble) proxy->min_value);
+      playsink->colorbalance_values[i] = (gint) (0.5 + new_val);
+
+      gst_color_balance_value_changed (GST_COLOR_BALANCE (playsink), proxy,
+          playsink->colorbalance_values[i]);
+      break;
+    }
+  }
+}
+
+static void
+update_colorbalance (GstPlaySink * playsink)
+{
+  GstColorBalance *balance = NULL;
+  GList *l;
+  gint i;
+
+  GST_OBJECT_LOCK (playsink);
+  if (playsink->colorbalance_element) {
+    balance =
+        GST_COLOR_BALANCE (gst_object_ref (playsink->colorbalance_element));
+  }
+  GST_OBJECT_UNLOCK (playsink);
+  if (!balance)
+    return;
+
+  g_signal_handlers_block_by_func (balance,
+      G_CALLBACK (colorbalance_value_changed_cb), playsink);
+
+  for (i = 0, l = playsink->colorbalance_channels; l; l = l->next, i++) {
+    GstColorBalanceChannel *proxy = l->data;
+    GstColorBalanceChannel *channel = NULL;
+    const GList *channels, *k;
+
+    channels = gst_color_balance_list_channels (balance);
+    for (k = channels; k; k = k->next) {
+      GstColorBalanceChannel *tmp = k->data;
+
+      if (g_strrstr (tmp->label, proxy->label)) {
+        channel = tmp;
+        break;
+      }
+    }
+
+    g_assert (channel);
+
+    gst_color_balance_set_value (balance, channel,
+        playsink->colorbalance_values[i]);
+  }
+
+  g_signal_handlers_unblock_by_func (balance,
+      G_CALLBACK (colorbalance_value_changed_cb), playsink);
+}
+
 /* make the element (bin) that contains the elements needed to perform
  * video display.
  *
@@ -1307,6 +1606,13 @@ gen_video_chain (GstPlaySink * playsink, gboolean raw, gboolean async)
     chain->async = TRUE;
   }
 
+  /* Make sure the aspect ratio is kept */
+  elem =
+      gst_play_sink_find_property_sinks (playsink, chain->sink,
+      "force-aspect-ratio", G_TYPE_BOOLEAN);
+  if (elem)
+    g_object_set (elem, "force-aspect-ratio", TRUE, NULL);
+
   /* find ts-offset element */
   gst_object_replace ((GstObject **) & chain->ts_offset, (GstObject *)
       gst_play_sink_find_property_sinks (playsink, chain->sink, "ts-offset",
@@ -1319,6 +1625,34 @@ gen_video_chain (GstPlaySink * playsink, gboolean raw, gboolean async)
   gst_object_ref_sink (bin);
   gst_bin_add (bin, chain->sink);
 
+  /* Get the XOverlay element */
+  {
+    GstXOverlay *xoverlay = NULL;
+
+    GST_OBJECT_LOCK (playsink);
+    if (playsink->xoverlay_element)
+      gst_object_unref (playsink->xoverlay_element);
+    playsink->xoverlay_element =
+        GST_X_OVERLAY (gst_bin_get_by_interface (GST_BIN (chain->chain.bin),
+            GST_TYPE_X_OVERLAY));
+    if (playsink->xoverlay_element)
+      xoverlay = GST_X_OVERLAY (gst_object_ref (playsink->xoverlay_element));
+    GST_OBJECT_UNLOCK (playsink);
+
+    if (xoverlay) {
+      if (playsink->xoverlay_handle_set)
+        gst_x_overlay_set_window_handle (xoverlay, playsink->xoverlay_handle);
+      if (playsink->xoverlay_handle_events_set)
+        gst_x_overlay_handle_events (xoverlay,
+            playsink->xoverlay_handle_events);
+      if (playsink->xoverlay_render_rectangle_set)
+        gst_x_overlay_set_render_rectangle (xoverlay,
+            playsink->xoverlay_x, playsink->xoverlay_y,
+            playsink->xoverlay_width, playsink->xoverlay_height);
+      gst_object_unref (xoverlay);
+    }
+  }
+
   /* decouple decoder from sink, this improves playback quite a lot since the
    * decoder can continue while the sink blocks for synchronisation. We don't
    * need a lot of buffers as this consumes a lot of memory and we don't want
@@ -1338,10 +1672,34 @@ gen_video_chain (GstPlaySink * playsink, gboolean raw, gboolean async)
     head = prev = chain->queue;
   }
 
-  if (!(playsink->flags & GST_PLAY_FLAG_NATIVE_VIDEO)) {
+  GST_OBJECT_LOCK (playsink);
+  if (playsink->colorbalance_element) {
+    g_signal_handlers_disconnect_by_func (playsink->colorbalance_element,
+        G_CALLBACK (colorbalance_value_changed_cb), playsink);
+    gst_object_unref (playsink->colorbalance_element);
+  }
+  playsink->colorbalance_element = find_color_balance_element (chain->sink);
+  GST_OBJECT_UNLOCK (playsink);
+
+  if (!(playsink->flags & GST_PLAY_FLAG_NATIVE_VIDEO)
+      || (!playsink->colorbalance_element
+          && (playsink->flags & GST_PLAY_FLAG_SOFT_COLORBALANCE))) {
+    gboolean use_converters = !(playsink->flags & GST_PLAY_FLAG_NATIVE_VIDEO);
+    gboolean use_balance = !playsink->colorbalance_element
+        && (playsink->flags & GST_PLAY_FLAG_SOFT_COLORBALANCE);
+
     GST_DEBUG_OBJECT (playsink, "creating videoconverter");
     chain->conv =
-        g_object_new (GST_TYPE_PLAY_SINK_VIDEO_CONVERT, "name", "vconv", NULL);
+        g_object_new (GST_TYPE_PLAY_SINK_VIDEO_CONVERT, "name", "vconv",
+        "use-converters", use_converters, "use-balance", use_balance, NULL);
+
+    GST_OBJECT_LOCK (playsink);
+    if (use_balance && GST_PLAY_SINK_VIDEO_CONVERT (chain->conv)->balance)
+      playsink->colorbalance_element =
+          GST_COLOR_BALANCE (gst_object_ref (GST_PLAY_SINK_VIDEO_CONVERT
+              (chain->conv)->balance));
+    GST_OBJECT_UNLOCK (playsink);
+
     gst_bin_add (bin, chain->conv);
     if (prev) {
       if (!gst_element_link_pads_full (prev, "src", chain->conv, "sink",
@@ -1353,6 +1711,8 @@ gen_video_chain (GstPlaySink * playsink, gboolean raw, gboolean async)
     prev = chain->conv;
   }
 
+  update_colorbalance (playsink);
+
   if (prev) {
     GST_DEBUG_OBJECT (playsink, "linking to sink");
     if (!gst_element_link_pads_full (prev, "src", chain->sink, NULL,
@@ -1399,6 +1759,7 @@ no_sinks:
     free_chain ((GstPlayChain *) chain);
     return NULL;
   }
+
 link_failed:
   {
     GST_ELEMENT_ERROR (playsink, CORE, PAD,
@@ -1432,8 +1793,35 @@ setup_video_chain (GstPlaySink * playsink, gboolean raw, gboolean async)
   if (ret == GST_STATE_CHANGE_FAILURE)
     return FALSE;
 
-  /* find ts-offset element */
+  /* Get the XOverlay element */
+  {
+    GstXOverlay *xoverlay = NULL;
+
+    GST_OBJECT_LOCK (playsink);
+    if (playsink->xoverlay_element)
+      gst_object_unref (playsink->xoverlay_element);
+    playsink->xoverlay_element =
+        GST_X_OVERLAY (gst_bin_get_by_interface (GST_BIN (chain->chain.bin),
+            GST_TYPE_X_OVERLAY));
+    if (playsink->xoverlay_element)
+      xoverlay = GST_X_OVERLAY (gst_object_ref (playsink->xoverlay_element));
+    GST_OBJECT_UNLOCK (playsink);
+
+    if (xoverlay) {
+      if (playsink->xoverlay_handle_set)
+        gst_x_overlay_set_window_handle (xoverlay, playsink->xoverlay_handle);
+      if (playsink->xoverlay_handle_events_set)
+        gst_x_overlay_handle_events (xoverlay,
+            playsink->xoverlay_handle_events);
+      if (playsink->xoverlay_render_rectangle_set)
+        gst_x_overlay_set_render_rectangle (xoverlay,
+            playsink->xoverlay_x, playsink->xoverlay_y,
+            playsink->xoverlay_width, playsink->xoverlay_height);
+      gst_object_unref (xoverlay);
+    }
+  }
 
+  /* find ts-offset element */
   gst_object_replace ((GstObject **) & chain->ts_offset, (GstObject *)
       gst_play_sink_find_property_sinks (playsink, chain->sink, "ts-offset",
           G_TYPE_INT64));
@@ -1452,6 +1840,39 @@ setup_video_chain (GstPlaySink * playsink, gboolean raw, gboolean async)
     GST_DEBUG_OBJECT (playsink, "no async property on the sink");
     chain->async = TRUE;
   }
+
+  /* Make sure the aspect ratio is kept */
+  elem =
+      gst_play_sink_find_property_sinks (playsink, chain->sink,
+      "force-aspect-ratio", G_TYPE_BOOLEAN);
+  if (elem)
+    g_object_set (elem, "force-aspect-ratio", TRUE, NULL);
+
+  GST_OBJECT_LOCK (playsink);
+  if (playsink->colorbalance_element) {
+    g_signal_handlers_disconnect_by_func (playsink->colorbalance_element,
+        G_CALLBACK (colorbalance_value_changed_cb), playsink);
+    gst_object_unref (playsink->colorbalance_element);
+  }
+  playsink->colorbalance_element = find_color_balance_element (chain->sink);
+  GST_OBJECT_UNLOCK (playsink);
+
+  if (chain->conv) {
+    gboolean use_balance = !playsink->colorbalance_element
+        && (playsink->flags & GST_PLAY_FLAG_SOFT_COLORBALANCE);
+
+    g_object_set (chain->conv, "use-balance", use_balance, NULL);
+
+    GST_OBJECT_LOCK (playsink);
+    if (use_balance && GST_PLAY_SINK_VIDEO_CONVERT (chain->conv)->balance)
+      playsink->colorbalance_element =
+          GST_COLOR_BALANCE (gst_object_ref (GST_PLAY_SINK_VIDEO_CONVERT
+              (chain->conv)->balance));
+    GST_OBJECT_UNLOCK (playsink);
+  }
+
+  update_colorbalance (playsink);
+
   return TRUE;
 }
 
@@ -1810,10 +2231,10 @@ gen_audio_chain (GstPlaySink * playsink, gboolean raw)
   }
 
   if (!(playsink->flags & GST_PLAY_FLAG_NATIVE_AUDIO) || (!have_volume
-          && playsink->flags & GST_PLAY_FLAG_SOFT_VOLUME)) {
+          && (playsink->flags & GST_PLAY_FLAG_SOFT_VOLUME))) {
     gboolean use_converters = !(playsink->flags & GST_PLAY_FLAG_NATIVE_AUDIO);
     gboolean use_volume =
-        !have_volume && playsink->flags & GST_PLAY_FLAG_SOFT_VOLUME;
+        !have_volume && (playsink->flags & GST_PLAY_FLAG_SOFT_VOLUME);
     GST_DEBUG_OBJECT (playsink,
         "creating audioconvert with use-converters %d, use-volume %d",
         use_converters, use_volume);
@@ -1830,7 +2251,7 @@ gen_audio_chain (GstPlaySink * playsink, gboolean raw)
     }
     prev = chain->conv;
 
-    if (!have_volume && playsink->flags & GST_PLAY_FLAG_SOFT_VOLUME) {
+    if (!have_volume && (playsink->flags & GST_PLAY_FLAG_SOFT_VOLUME)) {
       GstPlaySinkAudioConvert *conv =
           GST_PLAY_SINK_AUDIO_CONVERT_CAST (chain->conv);
 
@@ -1928,8 +2349,10 @@ setup_audio_chain (GstPlaySink * playsink, gboolean raw)
   GstElement *elem;
   GstPlayAudioChain *chain;
   GstStateChangeReturn ret;
+  GstPlaySinkAudioConvert *conv;
 
   chain = playsink->audiochain;
+  conv = GST_PLAY_SINK_AUDIO_CONVERT_CAST (chain->conv);
 
   chain->chain.raw = raw;
 
@@ -1978,18 +2401,16 @@ setup_audio_chain (GstPlaySink * playsink, gboolean raw)
     }
 
     g_object_set (chain->conv, "use-volume", FALSE, NULL);
-  } else {
-    GstPlaySinkAudioConvert *conv =
-        GST_PLAY_SINK_AUDIO_CONVERT_CAST (chain->conv);
-
+  } else if (conv) {
     /* no volume, we need to add a volume element when we can */
-    g_object_set (chain->conv, "use-volume", TRUE, NULL);
+    g_object_set (chain->conv, "use-volume",
+        ! !(playsink->flags & GST_PLAY_FLAG_SOFT_VOLUME), NULL);
     GST_DEBUG_OBJECT (playsink, "the sink has no volume property");
 
     /* Disconnect signals */
     disconnect_chain (chain, playsink);
 
-    if (conv->volume) {
+    if (conv->volume && (playsink->flags & GST_PLAY_FLAG_SOFT_VOLUME)) {
       chain->volume = conv->volume;
       chain->mute = chain->volume;
 
@@ -2173,6 +2594,19 @@ gst_play_sink_reconfigure (GstPlaySink * playsink)
     need_text = TRUE;
   }
 
+  GST_OBJECT_LOCK (playsink);
+  if (playsink->xoverlay_element)
+    gst_object_unref (playsink->xoverlay_element);
+  playsink->xoverlay_element = NULL;
+
+  if (playsink->colorbalance_element) {
+    g_signal_handlers_disconnect_by_func (playsink->colorbalance_element,
+        G_CALLBACK (colorbalance_value_changed_cb), playsink);
+    gst_object_unref (playsink->colorbalance_element);
+  }
+  playsink->colorbalance_element = NULL;
+  GST_OBJECT_UNLOCK (playsink);
+
   if (((flags & GST_PLAY_FLAG_VIDEO)
           || (flags & GST_PLAY_FLAG_NATIVE_VIDEO)) && playsink->video_pad) {
     /* we have video and we are requested to show it */
@@ -2201,7 +2635,7 @@ gst_play_sink_reconfigure (GstPlaySink * playsink)
 
   /* we have a text_pad and we need text rendering, in this case we need a
    * video_pad to combine the video with the text or visualizations */
-  if (need_text && !need_video) {
+  if (need_text && !need_video && !playsink->text_sink) {
     if (playsink->video_pad) {
       need_video = TRUE;
     } else if (need_audio) {
@@ -2565,25 +2999,27 @@ gst_play_sink_reconfigure (GstPlaySink * playsink)
             playsink->textchain->textsinkpad, GST_PAD_LINK_CHECK_NOTHING);
       }
 
-      if (need_vis) {
-        GstPad *srcpad;
+      if (need_vis || need_video) {
+        if (need_vis) {
+          GstPad *srcpad;
 
-        srcpad =
-            gst_element_get_static_pad (playsink->vischain->chain.bin, "src");
-        gst_pad_unlink (srcpad, playsink->videochain->sinkpad);
-        gst_pad_link_full (srcpad, playsink->textchain->videosinkpad,
-            GST_PAD_LINK_CHECK_NOTHING);
-        gst_object_unref (srcpad);
-      } else {
-        if (need_deinterlace)
-          gst_pad_link_full (playsink->videodeinterlacechain->srcpad,
-              playsink->textchain->videosinkpad, GST_PAD_LINK_CHECK_NOTHING);
-        else
-          gst_pad_link_full (playsink->video_srcpad_stream_synchronizer,
-              playsink->textchain->videosinkpad, GST_PAD_LINK_CHECK_NOTHING);
+          srcpad =
+              gst_element_get_static_pad (playsink->vischain->chain.bin, "src");
+          gst_pad_unlink (srcpad, playsink->videochain->sinkpad);
+          gst_pad_link_full (srcpad, playsink->textchain->videosinkpad,
+              GST_PAD_LINK_CHECK_NOTHING);
+          gst_object_unref (srcpad);
+        } else {
+          if (need_deinterlace)
+            gst_pad_link_full (playsink->videodeinterlacechain->srcpad,
+                playsink->textchain->videosinkpad, GST_PAD_LINK_CHECK_NOTHING);
+          else
+            gst_pad_link_full (playsink->video_srcpad_stream_synchronizer,
+                playsink->textchain->videosinkpad, GST_PAD_LINK_CHECK_NOTHING);
+        }
+        gst_pad_link_full (playsink->textchain->srcpad,
+            playsink->videochain->sinkpad, GST_PAD_LINK_CHECK_NOTHING);
       }
-      gst_pad_link_full (playsink->textchain->srcpad,
-          playsink->videochain->sinkpad, GST_PAD_LINK_CHECK_NOTHING);
 
       activate_chain (GST_PLAY_CHAIN (playsink->textchain), TRUE);
     }
@@ -3000,8 +3436,7 @@ sinkpad_blocked_cb (GstPad * blockedpad, gboolean blocked, gpointer user_data)
       GstPad *opad =
           GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD
               (playsink->video_pad)));
-      gst_pad_set_blocked_async_full (opad, FALSE, sinkpad_blocked_cb,
-          gst_object_ref (playsink), (GDestroyNotify) gst_object_unref);
+      gst_pad_set_blocked_async (opad, FALSE, sinkpad_blocked_cb, playsink);
       gst_object_unref (opad);
     }
 
@@ -3009,8 +3444,7 @@ sinkpad_blocked_cb (GstPad * blockedpad, gboolean blocked, gpointer user_data)
       GstPad *opad =
           GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD
               (playsink->audio_pad)));
-      gst_pad_set_blocked_async_full (opad, FALSE, sinkpad_blocked_cb,
-          gst_object_ref (playsink), (GDestroyNotify) gst_object_unref);
+      gst_pad_set_blocked_async (opad, FALSE, sinkpad_blocked_cb, playsink);
       gst_object_unref (opad);
     }
 
@@ -3018,8 +3452,7 @@ sinkpad_blocked_cb (GstPad * blockedpad, gboolean blocked, gpointer user_data)
       GstPad *opad =
           GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD
               (playsink->text_pad)));
-      gst_pad_set_blocked_async_full (opad, FALSE, sinkpad_blocked_cb,
-          gst_object_ref (playsink), (GDestroyNotify) gst_object_unref);
+      gst_pad_set_blocked_async (opad, FALSE, sinkpad_blocked_cb, playsink);
       gst_object_unref (opad);
     }
   }
@@ -3042,14 +3475,14 @@ caps_notify_cb (GstPad * pad, GParamSpec * unused, GstPlaySink * playsink)
 
   if (pad == playsink->audio_pad) {
     raw = is_raw_pad (pad);
-    reconfigure = (!!playsink->audio_pad_raw != !!raw)
+    reconfigure = (! !playsink->audio_pad_raw != ! !raw)
         && playsink->audiochain;
     GST_DEBUG_OBJECT (pad,
         "Audio caps changed: raw %d reconfigure %d caps %" GST_PTR_FORMAT, raw,
         reconfigure, caps);
   } else if (pad == playsink->video_pad) {
     raw = is_raw_pad (pad);
-    reconfigure = (!!playsink->video_pad_raw != !!raw)
+    reconfigure = (! !playsink->video_pad_raw != ! !raw)
         && playsink->videochain;
     GST_DEBUG_OBJECT (pad,
         "Video caps changed: raw %d reconfigure %d caps %" GST_PTR_FORMAT, raw,
@@ -3064,8 +3497,7 @@ caps_notify_cb (GstPad * pad, GParamSpec * unused, GstPlaySink * playsink)
       GstPad *opad =
           GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD
               (playsink->video_pad)));
-      gst_pad_set_blocked_async_full (opad, TRUE, sinkpad_blocked_cb,
-          gst_object_ref (playsink), (GDestroyNotify) gst_object_unref);
+      gst_pad_set_blocked_async (opad, TRUE, sinkpad_blocked_cb, playsink);
       gst_object_unref (opad);
     }
 
@@ -3073,8 +3505,7 @@ caps_notify_cb (GstPad * pad, GParamSpec * unused, GstPlaySink * playsink)
       GstPad *opad =
           GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD
               (playsink->audio_pad)));
-      gst_pad_set_blocked_async_full (opad, TRUE, sinkpad_blocked_cb,
-          gst_object_ref (playsink), (GDestroyNotify) gst_object_unref);
+      gst_pad_set_blocked_async (opad, TRUE, sinkpad_blocked_cb, playsink);
       gst_object_unref (opad);
     }
 
@@ -3082,8 +3513,7 @@ caps_notify_cb (GstPad * pad, GParamSpec * unused, GstPlaySink * playsink)
       GstPad *opad =
           GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD
               (playsink->text_pad)));
-      gst_pad_set_blocked_async_full (opad, TRUE, sinkpad_blocked_cb,
-          gst_object_ref (playsink), (GDestroyNotify) gst_object_unref);
+      gst_pad_set_blocked_async (opad, TRUE, sinkpad_blocked_cb, playsink);
       gst_object_unref (opad);
     }
     GST_PLAY_SINK_UNLOCK (playsink);
@@ -3197,8 +3627,7 @@ gst_play_sink_request_pad (GstPlaySink * playsink, GstPlaySinkType type)
       GstPad *blockpad =
           GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD (res)));
 
-      gst_pad_set_blocked_async_full (blockpad, TRUE, sinkpad_blocked_cb,
-          gst_object_ref (playsink), (GDestroyNotify) gst_object_unref);
+      gst_pad_set_blocked_async (blockpad, TRUE, sinkpad_blocked_cb, playsink);
       PENDING_FLAG_SET (playsink, type);
       gst_object_unref (blockpad);
     }
@@ -3331,6 +3760,46 @@ gst_play_sink_handle_message (GstBin * bin, GstMessage * message)
       GST_BIN_CLASS (gst_play_sink_parent_class)->handle_message (bin, message);
       break;
     }
+    case GST_MESSAGE_ELEMENT:{
+      if (gst_structure_has_name (message->structure, "prepare-xwindow-id")) {
+        GstXOverlay *xoverlay;
+
+        GST_OBJECT_LOCK (playsink);
+        if (playsink->xoverlay_element
+            && GST_OBJECT_CAST (playsink->xoverlay_element) !=
+            GST_MESSAGE_SRC (message)) {
+          gst_object_unref (playsink->xoverlay_element);
+          playsink->xoverlay_element = NULL;
+        }
+
+        if (!playsink->xoverlay_element)
+          playsink->xoverlay_element =
+              GST_X_OVERLAY (gst_object_ref (GST_MESSAGE_SRC (message)));
+        xoverlay = GST_X_OVERLAY (gst_object_ref (playsink->xoverlay_element));
+        GST_OBJECT_UNLOCK (playsink);
+
+        GST_DEBUG_OBJECT (playsink, "Got prepare-xwindow-id message");
+
+        if (playsink->xoverlay_handle_set)
+          gst_x_overlay_set_window_handle (playsink->xoverlay_element,
+              playsink->xoverlay_handle);
+        if (playsink->xoverlay_handle_events_set)
+          gst_x_overlay_handle_events (playsink->xoverlay_element,
+              playsink->xoverlay_handle_events);
+        if (playsink->xoverlay_render_rectangle_set)
+          gst_x_overlay_set_render_rectangle (playsink->xoverlay_element,
+              playsink->xoverlay_x, playsink->xoverlay_y,
+              playsink->xoverlay_width, playsink->xoverlay_height);
+
+        gst_object_unref (xoverlay);
+        gst_message_unref (message);
+        gst_x_overlay_prepare_xwindow_id (GST_X_OVERLAY (playsink));
+      } else {
+        GST_BIN_CLASS (gst_play_sink_parent_class)->handle_message (bin,
+            message);
+      }
+      break;
+    }
     default:
       GST_BIN_CLASS (gst_play_sink_parent_class)->handle_message (bin, message);
       break;
@@ -3346,31 +3815,41 @@ static gboolean
 gst_play_sink_send_event_to_sink (GstPlaySink * playsink, GstEvent * event)
 {
   gboolean res = TRUE;
-
-  if (playsink->textchain && playsink->textchain->sink) {
-    gst_event_ref (event);
-    if ((res = gst_element_send_event (playsink->textchain->chain.bin, event))) {
-      GST_DEBUG_OBJECT (playsink, "Sent event successfully to text sink");
-    } else {
-      GST_DEBUG_OBJECT (playsink, "Event failed when sent to text sink");
+  if (playsink->send_event_mode == MODE_FIRST) {
+    if (playsink->textchain && playsink->textchain->sink) {
+      gst_event_ref (event);
+      if ((res =
+              gst_element_send_event (playsink->textchain->chain.bin, event))) {
+        GST_DEBUG_OBJECT (playsink, "Sent event successfully to text sink");
+      } else {
+        GST_DEBUG_OBJECT (playsink, "Event failed when sent to text sink");
+      }
     }
-  }
 
-  if (playsink->videochain) {
-    gst_event_ref (event);
-    if ((res = gst_element_send_event (playsink->videochain->chain.bin, event))) {
-      GST_DEBUG_OBJECT (playsink, "Sent event successfully to video sink");
-      goto done;
+    if (playsink->videochain) {
+      gst_event_ref (event);
+      if ((res =
+              gst_element_send_event (playsink->videochain->chain.bin,
+                  event))) {
+        GST_DEBUG_OBJECT (playsink, "Sent event successfully to video sink");
+        goto done;
+      }
+      GST_DEBUG_OBJECT (playsink, "Event failed when sent to video sink");
     }
-    GST_DEBUG_OBJECT (playsink, "Event failed when sent to video sink");
-  }
-  if (playsink->audiochain) {
-    gst_event_ref (event);
-    if ((res = gst_element_send_event (playsink->audiochain->chain.bin, event))) {
-      GST_DEBUG_OBJECT (playsink, "Sent event successfully to audio sink");
-      goto done;
+    if (playsink->audiochain) {
+      gst_event_ref (event);
+      if ((res =
+              gst_element_send_event (playsink->audiochain->chain.bin,
+                  event))) {
+        GST_DEBUG_OBJECT (playsink, "Sent event successfully to audio sink");
+        goto done;
+      }
+      GST_DEBUG_OBJECT (playsink, "Event failed when sent to audio sink");
     }
-    GST_DEBUG_OBJECT (playsink, "Event failed when sent to audio sink");
+  } else {
+    return
+        GST_ELEMENT_CLASS (gst_play_sink_parent_class)->send_event
+        (GST_ELEMENT_CAST (playsink), event);
   }
 
 done:
@@ -3387,9 +3866,7 @@ gst_play_sink_send_event (GstElement * element, GstEvent * event)
   gboolean res = FALSE;
   GstEventType event_type = GST_EVENT_TYPE (event);
   GstPlaySink *playsink;
-
   playsink = GST_PLAY_SINK_CAST (element);
-
   switch (event_type) {
     case GST_EVENT_SEEK:
       GST_DEBUG_OBJECT (element, "Sending event to a sink");
@@ -3401,10 +3878,8 @@ gst_play_sink_send_event (GstElement * element, GstEvent * event)
       guint64 amount;
       gdouble rate;
       gboolean flush, intermediate;
-
       gst_event_parse_step (event, &format, &amount, &rate, &flush,
           &intermediate);
-
       if (format == GST_FORMAT_BUFFERS) {
         /* for buffers, we will try to step video frames, for other formats we
          * send the step to all sinks */
@@ -3430,11 +3905,8 @@ gst_play_sink_change_state (GstElement * element, GstStateChange transition)
 {
   GstStateChangeReturn ret;
   GstStateChangeReturn bret;
-
   GstPlaySink *playsink;
-
   playsink = GST_PLAY_SINK (element);
-
   switch (transition) {
     case GST_STATE_CHANGE_READY_TO_PAUSED:
       playsink->need_async_start = TRUE;
@@ -3451,8 +3923,7 @@ gst_play_sink_change_state (GstElement * element, GstStateChange transition)
             GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD
                 (playsink->video_pad)));
         if (gst_pad_is_blocked (opad)) {
-          gst_pad_set_blocked_async_full (opad, FALSE, sinkpad_blocked_cb,
-              gst_object_ref (playsink), (GDestroyNotify) gst_object_unref);
+          gst_pad_set_blocked_async (opad, FALSE, sinkpad_blocked_cb, playsink);
         }
         gst_object_unref (opad);
         playsink->video_pad_blocked = FALSE;
@@ -3462,10 +3933,8 @@ gst_play_sink_change_state (GstElement * element, GstStateChange transition)
         GstPad *opad =
             GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD
                 (playsink->audio_pad)));
-
         if (gst_pad_is_blocked (opad)) {
-          gst_pad_set_blocked_async_full (opad, FALSE, sinkpad_blocked_cb,
-              gst_object_ref (playsink), (GDestroyNotify) gst_object_unref);
+          gst_pad_set_blocked_async (opad, FALSE, sinkpad_blocked_cb, playsink);
         }
         gst_object_unref (opad);
         playsink->audio_pad_blocked = FALSE;
@@ -3476,8 +3945,7 @@ gst_play_sink_change_state (GstElement * element, GstStateChange transition)
             GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD
                 (playsink->text_pad)));
         if (gst_pad_is_blocked (opad)) {
-          gst_pad_set_blocked_async_full (opad, FALSE, sinkpad_blocked_cb,
-              gst_object_ref (playsink), (GDestroyNotify) gst_object_unref);
+          gst_pad_set_blocked_async (opad, FALSE, sinkpad_blocked_cb, playsink);
         }
         gst_object_unref (opad);
         playsink->text_pad_blocked = FALSE;
@@ -3502,6 +3970,20 @@ gst_play_sink_change_state (GstElement * element, GstStateChange transition)
         gst_object_unref (playsink->videochain->ts_offset);
         playsink->videochain->ts_offset = NULL;
       }
+
+      GST_OBJECT_LOCK (playsink);
+      if (playsink->xoverlay_element)
+        gst_object_unref (playsink->xoverlay_element);
+      playsink->xoverlay_element = NULL;
+
+      if (playsink->colorbalance_element) {
+        g_signal_handlers_disconnect_by_func (playsink->colorbalance_element,
+            G_CALLBACK (colorbalance_value_changed_cb), playsink);
+        gst_object_unref (playsink->colorbalance_element);
+      }
+      playsink->colorbalance_element = NULL;
+      GST_OBJECT_UNLOCK (playsink);
+
       ret = GST_STATE_CHANGE_SUCCESS;
       break;
     default:
@@ -3611,7 +4093,6 @@ gst_play_sink_change_state (GstElement * element, GstStateChange transition)
         if (playsink->textchain && playsink->textchain->sink)
           gst_bin_remove (GST_BIN_CAST (playsink->textchain->chain.bin),
               playsink->textchain->sink);
-
         if (playsink->audio_sink != NULL)
           gst_element_set_state (playsink->audio_sink, GST_STATE_NULL);
         if (playsink->video_sink != NULL)
@@ -3620,7 +4101,6 @@ gst_play_sink_change_state (GstElement * element, GstStateChange transition)
           gst_element_set_state (playsink->visualisation, GST_STATE_NULL);
         if (playsink->text_sink != NULL)
           gst_element_set_state (playsink->text_sink, GST_STATE_NULL);
-
         free_chain ((GstPlayChain *) playsink->videodeinterlacechain);
         playsink->videodeinterlacechain = NULL;
         free_chain ((GstPlayChain *) playsink->videochain);
@@ -3637,7 +4117,6 @@ gst_play_sink_change_state (GstElement * element, GstStateChange transition)
       break;
   }
   return ret;
-
   /* ERRORS */
 activate_failed:
   {
@@ -3652,7 +4131,6 @@ gst_play_sink_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * spec)
 {
   GstPlaySink *playsink = GST_PLAY_SINK (object);
-
   switch (prop_id) {
     case PROP_FLAGS:
       gst_play_sink_set_flags (playsink, g_value_get_flags (value));
@@ -3688,6 +4166,9 @@ gst_play_sink_set_property (GObject * object, guint prop_id,
       gst_play_sink_set_sink (playsink, GST_PLAY_SINK_TYPE_TEXT,
           g_value_get_object (value));
       break;
+    case PROP_SEND_EVENT_MODE:
+      playsink->send_event_mode = g_value_get_enum (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, spec);
       break;
@@ -3699,7 +4180,6 @@ gst_play_sink_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * spec)
 {
   GstPlaySink *playsink = GST_PLAY_SINK (object);
-
   switch (prop_id) {
     case PROP_FLAGS:
       g_value_set_flags (value, gst_play_sink_get_flags (playsink));
@@ -3738,18 +4218,300 @@ gst_play_sink_get_property (GObject * object, guint prop_id,
       g_value_take_object (value, gst_play_sink_get_sink (playsink,
               GST_PLAY_SINK_TYPE_TEXT));
       break;
+    case PROP_SEND_EVENT_MODE:
+      g_value_set_enum (value, playsink->send_event_mode);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, spec);
       break;
   }
 }
 
+static void
+gst_play_sink_xoverlay_expose (GstXOverlay * overlay)
+{
+  GstPlaySink *playsink = GST_PLAY_SINK (overlay);
+  GstXOverlay *xoverlay;
+
+  GST_OBJECT_LOCK (playsink);
+  if (playsink->xoverlay_element)
+    xoverlay = GST_X_OVERLAY (gst_object_ref (playsink->xoverlay_element));
+  else
+    xoverlay = NULL;
+  GST_OBJECT_UNLOCK (playsink);
+
+  if (xoverlay) {
+    gst_x_overlay_expose (xoverlay);
+    gst_object_unref (xoverlay);
+  }
+}
+
+static void
+gst_play_sink_xoverlay_handle_events (GstXOverlay * overlay,
+    gboolean handle_events)
+{
+  GstPlaySink *playsink = GST_PLAY_SINK (overlay);
+  GstXOverlay *xoverlay;
+
+  GST_OBJECT_LOCK (playsink);
+  if (playsink->xoverlay_element)
+    xoverlay = GST_X_OVERLAY (gst_object_ref (playsink->xoverlay_element));
+  else
+    xoverlay = NULL;
+  GST_OBJECT_UNLOCK (playsink);
+
+  playsink->xoverlay_handle_events_set = TRUE;
+  playsink->xoverlay_handle_events = handle_events;
+
+  if (xoverlay) {
+    gst_x_overlay_handle_events (xoverlay, handle_events);
+    gst_object_unref (xoverlay);
+  }
+}
+
+static void
+gst_play_sink_xoverlay_set_render_rectangle (GstXOverlay * overlay, gint x,
+    gint y, gint width, gint height)
+{
+  GstPlaySink *playsink = GST_PLAY_SINK (overlay);
+  GstXOverlay *xoverlay;
+
+  GST_OBJECT_LOCK (playsink);
+  if (playsink->xoverlay_element)
+    xoverlay = GST_X_OVERLAY (gst_object_ref (playsink->xoverlay_element));
+  else
+    xoverlay = NULL;
+  GST_OBJECT_UNLOCK (playsink);
+
+  playsink->xoverlay_render_rectangle_set = TRUE;
+  playsink->xoverlay_x = x;
+  playsink->xoverlay_y = y;
+  playsink->xoverlay_width = width;
+  playsink->xoverlay_height = height;
+
+  if (xoverlay) {
+    gst_x_overlay_set_render_rectangle (xoverlay, x, y, width, height);
+    gst_object_unref (xoverlay);
+  }
+}
+
+static void
+gst_play_sink_xoverlay_set_window_handle (GstXOverlay * overlay,
+    guintptr handle)
+{
+  GstPlaySink *playsink = GST_PLAY_SINK (overlay);
+  GstXOverlay *xoverlay;
+
+  GST_OBJECT_LOCK (playsink);
+  if (playsink->xoverlay_element)
+    xoverlay = GST_X_OVERLAY (gst_object_ref (playsink->xoverlay_element));
+  else
+    xoverlay = NULL;
+  GST_OBJECT_UNLOCK (playsink);
+
+  playsink->xoverlay_handle_set = TRUE;
+  playsink->xoverlay_handle = handle;
+
+  if (xoverlay) {
+    gst_x_overlay_set_window_handle (xoverlay, handle);
+    gst_object_unref (xoverlay);
+  }
+}
+
+static void
+gst_play_sink_xoverlay_init (gpointer g_iface, gpointer g_iface_data)
+{
+  GstXOverlayClass *iface = (GstXOverlayClass *) g_iface;
+  iface->expose = gst_play_sink_xoverlay_expose;
+  iface->handle_events = gst_play_sink_xoverlay_handle_events;
+  iface->set_render_rectangle = gst_play_sink_xoverlay_set_render_rectangle;
+  iface->set_window_handle = gst_play_sink_xoverlay_set_window_handle;
+}
+
+static gboolean
+gst_play_sink_implements_interface_supported (GstImplementsInterface * iface,
+    GType type)
+{
+  if (type == GST_TYPE_X_OVERLAY || type == GST_TYPE_STREAM_VOLUME ||
+      type == GST_TYPE_NAVIGATION || type == GST_TYPE_COLOR_BALANCE)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+static void
+gst_play_sink_implements_interface_init (gpointer g_iface,
+    gpointer g_iface_data)
+{
+  GstImplementsInterfaceClass *iface = (GstImplementsInterfaceClass *) g_iface;
+  iface->supported = gst_play_sink_implements_interface_supported;
+}
+
+static void
+gst_play_sink_navigation_send_event (GstNavigation * navigation,
+    GstStructure * structure)
+{
+  GstPlaySink *playsink = GST_PLAY_SINK (navigation);
+  GstBin *bin = NULL;
+
+  GST_PLAY_SINK_LOCK (playsink);
+  if (playsink->videochain && playsink->videochain->chain.bin)
+    bin = GST_BIN (gst_object_ref (playsink->videochain->chain.bin));
+  GST_PLAY_SINK_UNLOCK (playsink);
+
+  if (bin) {
+    GstElement *nav = gst_bin_get_by_interface (bin, GST_TYPE_NAVIGATION);
+
+    if (nav) {
+      gst_navigation_send_event (GST_NAVIGATION (nav), structure);
+      structure = NULL;
+      gst_object_unref (nav);
+    } else {
+      GstEvent *event = gst_event_new_navigation (structure);
+      structure = NULL;
+      gst_element_send_event (GST_ELEMENT (bin), event);
+    }
+
+    gst_object_unref (bin);
+  }
+
+  if (structure)
+    gst_structure_free (structure);
+}
+
+static void
+gst_play_sink_navigation_init (gpointer g_iface, gpointer g_iface_data)
+{
+  GstNavigationInterface *iface = (GstNavigationInterface *) g_iface;
+
+  iface->send_event = gst_play_sink_navigation_send_event;
+}
+
+static const GList *
+gst_play_sink_colorbalance_list_channels (GstColorBalance * balance)
+{
+  GstPlaySink *playsink = GST_PLAY_SINK (balance);
+
+  return playsink->colorbalance_channels;
+}
+
+static void
+gst_play_sink_colorbalance_set_value (GstColorBalance * balance,
+    GstColorBalanceChannel * proxy, gint value)
+{
+  GstPlaySink *playsink = GST_PLAY_SINK (balance);
+  GList *l;
+  gint i;
+  GstColorBalance *balance_element = NULL;
+
+  GST_OBJECT_LOCK (playsink);
+  if (playsink->colorbalance_element)
+    balance_element =
+        GST_COLOR_BALANCE (gst_object_ref (playsink->colorbalance_element));
+  GST_OBJECT_UNLOCK (playsink);
+
+  for (i = 0, l = playsink->colorbalance_channels; l; l = l->next, i++) {
+    GstColorBalanceChannel *proxy_tmp = l->data;
+    gdouble new_val;
+
+    if (proxy_tmp != proxy)
+      continue;
+
+    playsink->colorbalance_values[i] = value;
+
+    if (balance_element) {
+      GstColorBalanceChannel *channel = NULL;
+      const GList *channels, *k;
+
+      channels = gst_color_balance_list_channels (balance_element);
+      for (k = channels; k; k = k->next) {
+        GstColorBalanceChannel *tmp = l->data;
+
+        if (g_strrstr (tmp->label, proxy->label)) {
+          channel = tmp;
+          break;
+        }
+      }
+
+      g_assert (channel);
+
+      /* Convert to [0, 1] range */
+      new_val =
+          ((gdouble) value -
+          (gdouble) proxy->min_value) / ((gdouble) proxy->max_value -
+          (gdouble) proxy->min_value);
+      /* Convert to channel range */
+      new_val =
+          channel->min_value + new_val * ((gdouble) channel->max_value -
+          (gdouble) channel->min_value);
+
+      gst_color_balance_set_value (balance_element, channel,
+          (gint) (new_val + 0.5));
+
+      gst_object_unref (balance_element);
+    }
+
+    gst_color_balance_value_changed (balance, proxy, value);
+    break;
+  }
+}
+
+static gint
+gst_play_sink_colorbalance_get_value (GstColorBalance * balance,
+    GstColorBalanceChannel * proxy)
+{
+  GstPlaySink *playsink = GST_PLAY_SINK (balance);
+  GList *l;
+  gint i;
+
+  for (i = 0, l = playsink->colorbalance_channels; l; l = l->next, i++) {
+    GstColorBalanceChannel *proxy_tmp = l->data;
+
+    if (proxy_tmp != proxy)
+      continue;
+
+    return playsink->colorbalance_values[i];
+  }
+
+  g_return_val_if_reached (0);
+}
+
+static GstColorBalanceType
+gst_play_sink_colorbalance_get_balance_type (GstColorBalance * balance)
+{
+  GstPlaySink *playsink = GST_PLAY_SINK (balance);
+  GstColorBalance *balance_element = NULL;
+  GstColorBalanceType t = GST_COLOR_BALANCE_SOFTWARE;
+
+  GST_OBJECT_LOCK (playsink);
+  if (playsink->colorbalance_element)
+    balance_element =
+        GST_COLOR_BALANCE (gst_object_ref (playsink->colorbalance_element));
+  GST_OBJECT_UNLOCK (playsink);
+
+  if (balance_element) {
+    t = gst_color_balance_get_balance_type (balance_element);
+    gst_object_unref (balance_element);
+  }
+
+  return t;
+}
+
+static void
+gst_play_sink_colorbalance_init (gpointer g_iface, gpointer g_iface_data)
+{
+  GstColorBalanceClass *iface = (GstColorBalanceClass *) g_iface;
+
+  iface->list_channels = gst_play_sink_colorbalance_list_channels;
+  iface->set_value = gst_play_sink_colorbalance_set_value;
+  iface->get_value = gst_play_sink_colorbalance_get_value;
+  iface->get_balance_type = gst_play_sink_colorbalance_get_balance_type;
+}
 
 gboolean
 gst_play_sink_plugin_init (GstPlugin * plugin)
 {
   GST_DEBUG_CATEGORY_INIT (gst_play_sink_debug, "playsink", 0, "play bin");
-
   return gst_element_register (plugin, "playsink", GST_RANK_NONE,
       GST_TYPE_PLAY_SINK);
 }
diff --git a/gst/playback/gstplaysinkaudioconvert.c b/gst/playback/gstplaysinkaudioconvert.c
index a0756bc..77504da 100644
--- a/gst/playback/gstplaysinkaudioconvert.c
+++ b/gst/playback/gstplaysinkaudioconvert.c
@@ -64,7 +64,6 @@ gst_play_sink_audio_convert_add_conversion_elements (GstPlaySinkAudioConvert *
     el = gst_play_sink_convert_bin_add_conversion_element_factory (cbin,
         "audioresample", "resample");
     if (el) {
-
       if (prev) {
         if (!gst_element_link_pads_full (prev, "src", el, "sink",
                 GST_PAD_LINK_CHECK_TEMPLATE_CAPS))
diff --git a/gst/playback/gstplaysinkconvertbin.c b/gst/playback/gstplaysinkconvertbin.c
index 51ede9b..67a6d74 100644
--- a/gst/playback/gstplaysinkconvertbin.c
+++ b/gst/playback/gstplaysinkconvertbin.c
@@ -194,6 +194,7 @@ gst_play_sink_convert_bin_remove_element (GstElement * element,
     GstPlaySinkConvertBin * self)
 {
   gst_element_set_state (element, GST_STATE_NULL);
+  gst_object_unref (element);
   gst_bin_remove (GST_BIN_CAST (self), element);
 }
 
@@ -253,8 +254,7 @@ pad_blocked_cb (GstPad * pad, gboolean blocked, GstPlaySinkConvertBin * self)
 
 unblock:
   gst_pad_set_blocked_async_full (self->sink_proxypad, FALSE,
-      (GstPadBlockCallback) pad_blocked_cb, gst_object_ref (self),
-      (GDestroyNotify) gst_object_unref);
+      (GstPadBlockCallback) pad_blocked_cb, self, NULL);
 
 done:
   GST_PLAY_SINK_CONVERT_BIN_UNLOCK (self);
@@ -337,8 +337,7 @@ gst_play_sink_convert_bin_sink_setcaps (GstPad * pad, GstCaps * caps)
 
         reconfigure = TRUE;
         gst_pad_set_blocked_async_full (self->sink_proxypad, TRUE,
-            (GstPadBlockCallback) pad_blocked_cb, gst_object_ref (self),
-            (GDestroyNotify) gst_object_unref);
+            (GstPadBlockCallback) pad_blocked_cb, self, NULL);
       }
 
       if (target)
@@ -349,8 +348,7 @@ gst_play_sink_convert_bin_sink_setcaps (GstPad * pad, GstCaps * caps)
       GST_DEBUG_OBJECT (self, "Changing caps from raw to non-raw");
       reconfigure = TRUE;
       gst_pad_set_blocked_async_full (self->sink_proxypad, TRUE,
-          (GstPadBlockCallback) pad_blocked_cb, gst_object_ref (self),
-          (GDestroyNotify) gst_object_unref);
+          (GstPadBlockCallback) pad_blocked_cb, self, NULL);
     }
   }
 
@@ -396,7 +394,7 @@ gst_play_sink_convert_bin_getcaps (GstPad * pad)
       gst_object_unref (peer);
       if (self->converter_caps && is_raw_caps (peer_caps, self->audio)) {
         peer_caps = gst_caps_make_writable (peer_caps);
-        gst_caps_merge (peer_caps, gst_caps_ref (self->converter_caps));
+        gst_caps_merge (peer_caps, gst_caps_copy (self->converter_caps));
         ret = peer_caps;
       } else {
         ret = peer_caps;
@@ -508,8 +506,7 @@ gst_play_sink_convert_bin_change_state (GstElement * element,
       GST_PLAY_SINK_CONVERT_BIN_LOCK (self);
       if (gst_pad_is_blocked (self->sink_proxypad))
         gst_pad_set_blocked_async_full (self->sink_proxypad, FALSE,
-            (GstPadBlockCallback) pad_blocked_cb, gst_object_ref (self),
-            (GDestroyNotify) gst_object_unref);
+            (GstPadBlockCallback) pad_blocked_cb, self, NULL);
       GST_PLAY_SINK_CONVERT_BIN_UNLOCK (self);
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
@@ -539,8 +536,7 @@ gst_play_sink_convert_bin_change_state (GstElement * element,
       GST_PLAY_SINK_CONVERT_BIN_LOCK (self);
       if (!gst_pad_is_blocked (self->sink_proxypad))
         gst_pad_set_blocked_async_full (self->sink_proxypad, TRUE,
-            (GstPadBlockCallback) pad_blocked_cb, gst_object_ref (self),
-            (GDestroyNotify) gst_object_unref);
+            (GstPadBlockCallback) pad_blocked_cb, self, NULL);
       GST_PLAY_SINK_CONVERT_BIN_UNLOCK (self);
       break;
     default:
diff --git a/gst/playback/gstplaysinkvideoconvert.c b/gst/playback/gstplaysinkvideoconvert.c
index 72a9aff..38c8878 100644
--- a/gst/playback/gstplaysinkvideoconvert.c
+++ b/gst/playback/gstplaysinkvideoconvert.c
@@ -34,6 +34,13 @@ GST_DEBUG_CATEGORY_STATIC (gst_play_sink_video_convert_debug);
 G_DEFINE_TYPE (GstPlaySinkVideoConvert, gst_play_sink_video_convert,
     GST_TYPE_PLAY_SINK_CONVERT_BIN);
 
+enum
+{
+  PROP_0,
+  PROP_USE_CONVERTERS,
+  PROP_USE_BALANCE,
+};
+
 static gboolean
 gst_play_sink_video_convert_add_conversion_elements (GstPlaySinkVideoConvert *
     self)
@@ -41,22 +48,51 @@ gst_play_sink_video_convert_add_conversion_elements (GstPlaySinkVideoConvert *
   GstPlaySinkConvertBin *cbin = GST_PLAY_SINK_CONVERT_BIN (self);
   GstElement *el, *prev = NULL;
 
-  el = gst_play_sink_convert_bin_add_conversion_element_factory (cbin,
-      COLORSPACE, "conv");
-  if (el)
-    prev = el;
+  g_assert (cbin->conversion_elements == NULL);
+
+  GST_DEBUG_OBJECT (self,
+      "Building video conversion with use-converters %d, use-balance %d",
+      self->use_converters, self->use_balance);
+
+  if (self->use_converters) {
+    el = gst_play_sink_convert_bin_add_conversion_element_factory (cbin,
+        COLORSPACE, "conv");
+    if (el)
+      prev = el;
+
+    el = gst_play_sink_convert_bin_add_conversion_element_factory (cbin,
+        "videoscale", "scale");
+    if (el) {
+      /* Add black borders if necessary to keep the DAR */
+      g_object_set (el, "add-borders", TRUE, NULL);
+      if (prev) {
+        if (!gst_element_link_pads_full (prev, "src", el, "sink",
+                GST_PAD_LINK_CHECK_TEMPLATE_CAPS))
+          goto link_failed;
+      }
+      prev = el;
+    }
+  }
 
-  el = gst_play_sink_convert_bin_add_conversion_element_factory (cbin,
-      "videoscale", "scale");
-  if (el) {
-    /* Add black borders if necessary to keep the DAR */
-    g_object_set (el, "add-borders", TRUE, NULL);
+  if (self->use_balance && self->balance) {
+    el = self->balance;
+    gst_play_sink_convert_bin_add_conversion_element (cbin, el);
     if (prev) {
       if (!gst_element_link_pads_full (prev, "src", el, "sink",
               GST_PAD_LINK_CHECK_TEMPLATE_CAPS))
         goto link_failed;
     }
     prev = el;
+
+    el = gst_play_sink_convert_bin_add_conversion_element_factory (cbin,
+        COLORSPACE, "conv2");
+    if (prev) {
+      if (!gst_element_link_pads_full (prev, "src", el, "sink",
+              GST_PAD_LINK_CHECK_TEMPLATE_CAPS))
+        goto link_failed;
+    }
+    if (el)
+      prev = el;
   }
 
   return TRUE;
@@ -66,15 +102,100 @@ link_failed:
 }
 
 static void
+gst_play_sink_video_convert_finalize (GObject * object)
+{
+  GstPlaySinkVideoConvert *self = GST_PLAY_SINK_VIDEO_CONVERT_CAST (object);
+
+  if (self->balance)
+    gst_object_unref (self->balance);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_play_sink_video_convert_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstPlaySinkVideoConvert *self = GST_PLAY_SINK_VIDEO_CONVERT_CAST (object);
+  gboolean v, changed = FALSE;
+
+  GST_PLAY_SINK_CONVERT_BIN_LOCK (self);
+  switch (prop_id) {
+    case PROP_USE_CONVERTERS:
+      v = g_value_get_boolean (value);
+      if (v != self->use_converters) {
+        self->use_converters = v;
+        changed = TRUE;
+      }
+      break;
+    case PROP_USE_BALANCE:
+      v = g_value_get_boolean (value);
+      if (v != self->use_balance) {
+        self->use_balance = v;
+        changed = TRUE;
+      }
+      break;
+    default:
+      break;
+  }
+
+  if (changed) {
+    GstPlaySinkConvertBin *cbin = GST_PLAY_SINK_CONVERT_BIN (self);
+    GST_DEBUG_OBJECT (self, "Rebuilding converter bin");
+    gst_play_sink_convert_bin_remove_elements (cbin);
+    gst_play_sink_video_convert_add_conversion_elements (self);
+    gst_play_sink_convert_bin_add_identity (cbin);
+    gst_play_sink_convert_bin_cache_converter_caps (cbin);
+  }
+  GST_PLAY_SINK_CONVERT_BIN_UNLOCK (self);
+}
+
+static void
+gst_play_sink_video_convert_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstPlaySinkVideoConvert *self = GST_PLAY_SINK_VIDEO_CONVERT_CAST (object);
+
+  GST_PLAY_SINK_CONVERT_BIN_LOCK (self);
+  switch (prop_id) {
+    case PROP_USE_CONVERTERS:
+      g_value_set_boolean (value, self->use_converters);
+      break;
+    case PROP_USE_BALANCE:
+      g_value_set_boolean (value, self->use_balance);
+      break;
+    default:
+      break;
+  }
+  GST_PLAY_SINK_CONVERT_BIN_UNLOCK (self);
+}
+
+static void
 gst_play_sink_video_convert_class_init (GstPlaySinkVideoConvertClass * klass)
 {
+  GObjectClass *gobject_class;
   GstElementClass *gstelement_class;
 
   GST_DEBUG_CATEGORY_INIT (gst_play_sink_video_convert_debug,
       "playsinkvideoconvert", 0, "play bin");
 
+  gobject_class = (GObjectClass *) klass;
   gstelement_class = (GstElementClass *) klass;
 
+  gobject_class->finalize = gst_play_sink_video_convert_finalize;
+  gobject_class->set_property = gst_play_sink_video_convert_set_property;
+  gobject_class->get_property = gst_play_sink_video_convert_get_property;
+
+  g_object_class_install_property (gobject_class, PROP_USE_CONVERTERS,
+      g_param_spec_boolean ("use-converters", "Use converters",
+          "Whether to use conversion elements", FALSE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_USE_BALANCE,
+      g_param_spec_boolean ("use-balance", "Use balance",
+          "Whether to use a videobalance element", FALSE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   gst_element_class_set_details_simple (gstelement_class,
       "Player Sink Video Converter", "Video/Bin/Converter",
       "Convenience bin for video conversion",
@@ -87,6 +208,14 @@ gst_play_sink_video_convert_init (GstPlaySinkVideoConvert * self)
   GstPlaySinkConvertBin *cbin = GST_PLAY_SINK_CONVERT_BIN (self);
   cbin->audio = FALSE;
 
+  /* FIXME: Only create this on demand but for now we need
+   * it to always exist because of playsink's color balance
+   * proxying logic.
+   */
+  self->balance = gst_element_factory_make ("videobalance", "videobalance");
+  if (self->balance)
+    gst_object_ref_sink (self->balance);
+
   gst_play_sink_video_convert_add_conversion_elements (self);
   gst_play_sink_convert_bin_cache_converter_caps (cbin);
 }
diff --git a/gst/playback/gstplaysinkvideoconvert.h b/gst/playback/gstplaysinkvideoconvert.h
index df56d97..5c50462 100644
--- a/gst/playback/gstplaysinkvideoconvert.h
+++ b/gst/playback/gstplaysinkvideoconvert.h
@@ -43,6 +43,10 @@ struct _GstPlaySinkVideoConvert
 {
   GstPlaySinkConvertBin parent;
 
+  /* < pseudo public > */
+  GstElement *balance;
+  gboolean use_converters;
+  gboolean use_balance;
 };
 
 struct _GstPlaySinkVideoConvertClass
diff --git a/gst/playback/gstsubtitleoverlay.c b/gst/playback/gstsubtitleoverlay.c
index a3e96c7..126ffd2 100644
--- a/gst/playback/gstsubtitleoverlay.c
+++ b/gst/playback/gstsubtitleoverlay.c
@@ -681,18 +681,25 @@ out:
 }
 
 /* Must be called with subtitleoverlay lock! */
-static void
-gst_subtitle_overlay_set_fps (GstSubtitleOverlay * self)
+static gboolean
+_has_property_with_type (GObject * object, const gchar * property, GType type)
 {
   GObjectClass *gobject_class;
   GParamSpec *pspec;
 
+  gobject_class = G_OBJECT_GET_CLASS (object);
+  pspec = g_object_class_find_property (gobject_class, property);
+  return (pspec && pspec->value_type == type);
+}
+
+static void
+gst_subtitle_overlay_set_fps (GstSubtitleOverlay * self)
+{
   if (!self->parser || self->fps_d == 0)
     return;
 
-  gobject_class = G_OBJECT_GET_CLASS (self->parser);
-  pspec = g_object_class_find_property (gobject_class, "video-fps");
-  if (!pspec || pspec->value_type != GST_TYPE_FRACTION)
+  if (!_has_property_with_type (G_OBJECT (self->parser), "video-fps",
+          GST_TYPE_FRACTION))
     return;
 
   GST_DEBUG_OBJECT (self, "Updating video-fps property in parser");
@@ -709,15 +716,11 @@ _get_silent_property (GstElement * element, gboolean * invert)
   } properties[] = { {
   "silent", FALSE}, {
   "enable", TRUE}};
-  GObjectClass *gobject_class;
-  GParamSpec *pspec;
   guint i;
 
-  gobject_class = G_OBJECT_GET_CLASS (element);
-
   for (i = 0; i < G_N_ELEMENTS (properties); i++) {
-    pspec = g_object_class_find_property (gobject_class, properties[i].name);
-    if (pspec && pspec->value_type == G_TYPE_BOOLEAN) {
+    if (_has_property_with_type (G_OBJECT (element), properties[i].name,
+            G_TYPE_BOOLEAN)) {
       *invert = properties[i].invert;
       return properties[i].name;
     }
@@ -726,24 +729,277 @@ _get_silent_property (GstElement * element, gboolean * invert)
 }
 
 static gboolean
-_has_subtitle_encoding_property (GstElement * element)
+_setup_parser (GstSubtitleOverlay * self)
 {
-  GParamSpec *pspec;
+  GstPad *video_peer;
+
+  /* Try to get the latest video framerate */
+  video_peer = gst_pad_get_peer (self->video_sinkpad);
+  if (video_peer) {
+    GstCaps *video_caps;
+    gint fps_n, fps_d;
+
+    video_caps = gst_pad_get_negotiated_caps (video_peer);
+    if (!video_caps) {
+      video_caps = gst_pad_get_caps_reffed (video_peer);
+      if (!gst_caps_is_fixed (video_caps)) {
+        gst_caps_unref (video_caps);
+        video_caps = NULL;
+      }
+    }
+
+    if (video_caps
+        && gst_video_parse_caps_framerate (video_caps, &fps_n, &fps_d)) {
+      if (self->fps_n != fps_n || self->fps_d != fps_d) {
+        GST_DEBUG_OBJECT (self, "New video fps: %d/%d", fps_n, fps_d);
+        self->fps_n = fps_n;
+        self->fps_d = fps_d;
+      }
+    }
+
+    if (video_caps)
+      gst_caps_unref (video_caps);
+    gst_object_unref (video_peer);
+  }
+
+  if (_has_property_with_type (G_OBJECT (self->parser), "subtitle-encoding",
+          G_TYPE_STRING))
+    g_object_set (self->parser, "subtitle-encoding", self->encoding, NULL);
+
+  /* Try to set video fps on the parser */
+  gst_subtitle_overlay_set_fps (self);
+
 
-  pspec =
-      g_object_class_find_property (G_OBJECT_GET_CLASS (element),
-      "subtitle-encoding");
-  return (pspec && pspec->value_type == G_TYPE_STRING);
+  return TRUE;
 }
 
 static gboolean
-_has_font_desc_property (GstElement * element)
+_setup_renderer (GstSubtitleOverlay * self, GstElement * renderer)
 {
-  GParamSpec *pspec;
+  GstElementFactory *factory = gst_element_get_factory (renderer);
+  const gchar *name =
+      gst_plugin_feature_get_name (GST_PLUGIN_FEATURE_CAST (factory));
+
+  if (strcmp (name, "textoverlay") == 0) {
+    /* Set some textoverlay specific properties */
+    g_object_set (G_OBJECT (renderer),
+        "halign", "center", "valign", "bottom", "wait-text", FALSE, NULL);
+    if (self->font_desc)
+      g_object_set (G_OBJECT (renderer), "font-desc", self->font_desc, NULL);
+    self->silent_property = "silent";
+    self->silent_property_invert = FALSE;
+  } else {
+    self->silent_property =
+        _get_silent_property (renderer, &self->silent_property_invert);
+    if (_has_property_with_type (G_OBJECT (renderer), "subtitle-encoding",
+            G_TYPE_STRING))
+      g_object_set (renderer, "subtitle-encoding", self->encoding, NULL);
+    if (_has_property_with_type (G_OBJECT (renderer), "font-desc",
+            G_TYPE_STRING))
+      g_object_set (renderer, "font-desc", self->font_desc, NULL);
+  }
+
+  return TRUE;
+}
+
+/* subtitle_src==NULL means: use subtitle_sink ghostpad */
+static gboolean
+_link_renderer (GstSubtitleOverlay * self, GstElement * renderer,
+    GstPad * subtitle_src)
+{
+  GstPad *sink, *src;
+  gboolean is_video, is_hw;
+
+  is_video = _is_video_pad (self->video_sinkpad, &is_hw);
+
+  if (is_video) {
+    gboolean render_is_hw;
+
+    /* First check that renderer also supports the video format */
+    sink = _get_video_pad (renderer);
+    if (G_UNLIKELY (!sink)) {
+      GST_WARNING_OBJECT (self, "Can't get video sink from renderer");
+      return FALSE;
+    }
+
+    if (is_video != _is_video_pad (sink, &render_is_hw) ||
+        is_hw != render_is_hw) {
+      GST_DEBUG_OBJECT (self, "Renderer doesn't support %s video",
+          is_hw ? "surface" : "raw");
+      gst_object_unref (sink);
+      return FALSE;
+    }
+    gst_object_unref (sink);
+
+    if (!is_hw) {
+      /* First link everything internally */
+      if (G_UNLIKELY (!_create_element (self, &self->post_colorspace,
+                  COLORSPACE, NULL, "post-colorspace", FALSE))) {
+        return FALSE;
+      }
+      src = gst_element_get_static_pad (renderer, "src");
+      if (G_UNLIKELY (!src)) {
+        GST_WARNING_OBJECT (self, "Can't get src pad from renderer");
+        return FALSE;
+      }
+
+      sink = gst_element_get_static_pad (self->post_colorspace, "sink");
+      if (G_UNLIKELY (!sink)) {
+        GST_WARNING_OBJECT (self, "Can't get sink pad from " COLORSPACE);
+        gst_object_unref (src);
+        return FALSE;
+      }
+
+      if (G_UNLIKELY (gst_pad_link (src, sink) != GST_PAD_LINK_OK)) {
+        GST_WARNING_OBJECT (self, "Can't link renderer with " COLORSPACE);
+        gst_object_unref (src);
+        gst_object_unref (sink);
+        return FALSE;
+      }
+      gst_object_unref (src);
+      gst_object_unref (sink);
+
+      if (G_UNLIKELY (!_create_element (self, &self->pre_colorspace,
+                  COLORSPACE, NULL, "pre-colorspace", FALSE))) {
+        return FALSE;
+      }
+
+      sink = _get_video_pad (renderer);
+      if (G_UNLIKELY (!sink)) {
+        GST_WARNING_OBJECT (self, "Can't get video sink from renderer");
+        return FALSE;
+      }
+
+      src = gst_element_get_static_pad (self->pre_colorspace, "src");
+      if (G_UNLIKELY (!src)) {
+        GST_WARNING_OBJECT (self, "Can't get srcpad from " COLORSPACE);
+        gst_object_unref (sink);
+        return FALSE;
+      }
+
+      if (G_UNLIKELY (gst_pad_link (src, sink) != GST_PAD_LINK_OK)) {
+        GST_WARNING_OBJECT (self, "Can't link " COLORSPACE " to renderer");
+        gst_object_unref (src);
+        gst_object_unref (sink);
+        return FALSE;
+      }
+      gst_object_unref (src);
+      gst_object_unref (sink);
+
+      /* Set src ghostpad target */
+      src = gst_element_get_static_pad (self->post_colorspace, "src");
+      if (G_UNLIKELY (!src)) {
+        GST_WARNING_OBJECT (self, "Can't get src pad from " COLORSPACE);
+        return FALSE;
+      }
+    } else {
+      /* Set src ghostpad target in the harware accelerated case */
+
+      src = gst_element_get_static_pad (renderer, "src");
+      if (G_UNLIKELY (!src)) {
+        GST_WARNING_OBJECT (self, "Can't get src pad from renderer");
+        return FALSE;
+      }
+    }
+  } else {                      /* No video pad */
+    GstCaps *allowed_caps, *video_caps = NULL;
+    GstPad *video_peer;
+    gboolean can_intersect = FALSE;
+
+    video_peer = gst_pad_get_peer (self->video_sinkpad);
+    if (video_peer) {
+      video_caps = gst_pad_get_negotiated_caps (video_peer);
+      if (!video_caps) {
+        video_caps = gst_pad_get_caps_reffed (video_peer);
+      }
+      gst_object_unref (video_peer);
+    }
+
+    sink = _get_video_pad (renderer);
+    if (G_UNLIKELY (!sink)) {
+      GST_WARNING_OBJECT (self, "Can't get video sink from renderer");
+      return FALSE;
+    }
+    allowed_caps = gst_pad_get_caps_reffed (sink);
+    gst_object_unref (sink);
 
-  pspec =
-      g_object_class_find_property (G_OBJECT_GET_CLASS (element), "font-desc");
-  return (pspec && pspec->value_type == G_TYPE_STRING);
+    if (allowed_caps && video_caps)
+      can_intersect = gst_caps_can_intersect (allowed_caps, video_caps);
+
+    if (allowed_caps)
+      gst_caps_unref (allowed_caps);
+
+    if (video_caps)
+      gst_caps_unref (video_caps);
+
+    if (G_UNLIKELY (!can_intersect)) {
+      GST_WARNING_OBJECT (self, "Renderer with custom caps is not "
+          "compatible with video stream");
+      return FALSE;
+    }
+
+    src = gst_element_get_static_pad (renderer, "src");
+    if (G_UNLIKELY (!src)) {
+      GST_WARNING_OBJECT (self, "Can't get src pad from renderer");
+      return FALSE;
+    }
+  }
+
+  if (G_UNLIKELY (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
+              (self->srcpad), src))) {
+    GST_WARNING_OBJECT (self, "Can't set srcpad target");
+    gst_object_unref (src);
+    return FALSE;
+  }
+  gst_object_unref (src);
+
+  /* Set the sink ghostpad targets */
+  if (self->pre_colorspace) {
+    sink = gst_element_get_static_pad (self->pre_colorspace, "sink");
+    if (G_UNLIKELY (!sink)) {
+      GST_WARNING_OBJECT (self, "Can't get sink pad from " COLORSPACE);
+      return FALSE;
+    }
+  } else {
+    sink = _get_video_pad (renderer);
+    if (G_UNLIKELY (!sink)) {
+      GST_WARNING_OBJECT (self, "Can't get sink pad from %" GST_PTR_FORMAT,
+          renderer);
+      return FALSE;
+    }
+  }
+
+  if (G_UNLIKELY (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
+              (self->video_sinkpad), sink))) {
+    GST_WARNING_OBJECT (self, "Can't set video sinkpad target");
+    gst_object_unref (sink);
+    return FALSE;
+  }
+  gst_object_unref (sink);
+
+  sink = _get_sub_pad (renderer);
+  if (G_UNLIKELY (!sink)) {
+    GST_WARNING_OBJECT (self, "Failed to get subpad");
+    return FALSE;
+  }
+
+  if (subtitle_src) {
+    if (G_UNLIKELY (gst_pad_link (subtitle_src, sink) != GST_PAD_LINK_OK)) {
+      GST_WARNING_OBJECT (self, "Failed to link subtitle srcpad with renderer");
+      gst_object_unref (sink);
+      return FALSE;
+    }
+  } else {
+    if (G_UNLIKELY (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
+                (self->subtitle_sinkpad), sink))) {
+      GST_WARNING_OBJECT (self, "Failed to set subtitle sink target");
+      gst_object_unref (sink);
+      return FALSE;
+    }
+  }
+  gst_object_unref (sink);
+
+  return TRUE;
 }
 
 static void
@@ -870,8 +1126,7 @@ _pad_blocked_cb (GstPad * pad, gboolean blocked, gpointer user_data)
 
   for (l = factories; l; l = l->next) {
     GstElementFactory *factory = l->data;
-    gboolean is_video, is_hw, is_renderer = _is_renderer (factory);
-    GstElement *element;
+    gboolean is_renderer = _is_renderer (factory);
     GstPad *sink, *src;
 
     /* Unlink & destroy everything */
@@ -899,519 +1154,114 @@ _pad_blocked_cb (GstPad * pad, gboolean blocked, gpointer user_data)
                     "parser", FALSE))))
       continue;
 
-    element = is_renderer ? self->renderer : self->parser;
-
-    is_video = _is_video_pad (self->video_sinkpad, &is_hw);
-    /* If this is a parser, create textoverlay and link video and the parser to it
-     * Else link the renderer to the output colorspace */
     if (!is_renderer) {
-      GstElement *overlay;
-      GstPad *video_peer;
-
-      /* Try to get the latest video framerate */
-      video_peer = gst_pad_get_peer (self->video_sinkpad);
-      if (video_peer) {
-        GstCaps *video_caps;
-        gint fps_n, fps_d;
-
-        video_caps = gst_pad_get_negotiated_caps (video_peer);
-        if (!video_caps) {
-          video_caps = gst_pad_get_caps_reffed (video_peer);
-          if (!gst_caps_is_fixed (video_caps)) {
-            gst_caps_unref (video_caps);
-            video_caps = NULL;
-          }
-        }
-
-        if (video_caps
-            && gst_video_parse_caps_framerate (video_caps, &fps_n, &fps_d)) {
-          if (self->fps_n != fps_n || self->fps_d != fps_d) {
-            GST_DEBUG_OBJECT (self, "New video fps: %d/%d", fps_n, fps_d);
-            self->fps_n = fps_n;
-            self->fps_d = fps_d;
-          }
-        }
-
-        if (video_caps)
-          gst_caps_unref (video_caps);
-        gst_object_unref (video_peer);
-      }
-
-      if (_has_subtitle_encoding_property (self->parser))
-        g_object_set (self->parser, "subtitle-encoding", self->encoding, NULL);
+      GstCaps *parser_caps;
+      GList *overlay_factories, *k;
 
-      /* Try to set video fps on the parser */
-      gst_subtitle_overlay_set_fps (self);
-
-      /* First link everything internally */
-      if (G_UNLIKELY (!_create_element (self, &self->overlay, "textoverlay",
-                  NULL, "overlay", FALSE))) {
+      if (!_setup_parser (self))
         continue;
-      }
-      overlay = self->overlay;
-      self->silent_property = "silent";
-      self->silent_property_invert = FALSE;
 
-      /* Set some properties */
-      g_object_set (G_OBJECT (overlay),
-          "halign", "center", "valign", "bottom", "wait-text", FALSE, NULL);
-      if (self->font_desc)
-        g_object_set (G_OBJECT (overlay), "font-desc", self->font_desc, NULL);
+      /* Find our factories */
+      src = gst_element_get_static_pad (self->parser, "src");
+      parser_caps = gst_pad_get_caps_reffed (src);
+      gst_object_unref (src);
 
-      src = gst_element_get_static_pad (element, "src");
-      if (G_UNLIKELY (!src)) {
-        continue;
-      }
+      g_assert (parser_caps != NULL);
 
-      sink = gst_element_get_static_pad (overlay, "text_sink");
-      if (G_UNLIKELY (!sink)) {
-        GST_WARNING_OBJECT (self, "Can't get text sink from textoverlay");
-        gst_object_unref (src);
-        continue;
-      }
+      g_mutex_lock (self->factories_lock);
+      gst_subtitle_overlay_update_factory_list (self);
+      GST_DEBUG_OBJECT (self,
+          "Searching overlay factories for caps %" GST_PTR_FORMAT, parser_caps);
+      overlay_factories =
+          gst_subtitle_overlay_get_factories_for_caps (self->factories,
+          parser_caps);
+      g_mutex_unlock (self->factories_lock);
 
-      if (G_UNLIKELY (gst_pad_link (src, sink) != GST_PAD_LINK_OK)) {
-        GST_WARNING_OBJECT (self, "Can't link parser to textoverlay");
-        gst_object_unref (sink);
-        gst_object_unref (src);
+      if (!overlay_factories) {
+        GST_WARNING_OBJECT (self,
+            "Found no suitable overlay factories for caps %" GST_PTR_FORMAT,
+            parser_caps);
+        gst_caps_unref (parser_caps);
         continue;
       }
-      gst_object_unref (sink);
-      gst_object_unref (src);
+      gst_caps_unref (parser_caps);
 
-      /* If we are working with video/x-surface, we do not add
-       * colorspace conversion elements */
-      if (is_video && !is_hw) {
-        if (G_UNLIKELY (!_create_element (self, &self->post_colorspace,
-                    COLORSPACE, NULL, "post-colorspace", FALSE))) {
-          continue;
-        }
+      /* Sort the factories by rank */
+      overlay_factories =
+          g_list_sort (overlay_factories, (GCompareFunc) _sort_by_ranks);
 
-        src = gst_element_get_static_pad (overlay, "src");
-        if (G_UNLIKELY (!src)) {
-          GST_WARNING_OBJECT (self, "Can't get src pad from overlay");
-          continue;
-        }
+      for (k = overlay_factories; k; k = k->next) {
+        GstElementFactory *overlay_factory = k->data;
 
-        sink = gst_element_get_static_pad (self->post_colorspace, "sink");
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Can't get sink pad from " COLORSPACE);
-          gst_object_unref (src);
-          continue;
-        }
+        GST_DEBUG_OBJECT (self, "Trying overlay factory '%s'",
+            GST_STR_NULL (gst_plugin_feature_get_name (GST_PLUGIN_FEATURE_CAST
+                    (overlay_factory))));
 
-        if (G_UNLIKELY (gst_pad_link (src, sink) != GST_PAD_LINK_OK)) {
-          GST_WARNING_OBJECT (self, "Can't link overlay with " COLORSPACE);
-          gst_object_unref (src);
-          gst_object_unref (sink);
-          continue;
-        }
-        gst_object_unref (src);
-        gst_object_unref (sink);
+        /* Try this factory and link it, otherwise unlink everything
+         * again and remove the overlay. Up to this point only the
+         * parser was instantiated and setup, nothing was linked
+         */
 
-        if (G_UNLIKELY (!_create_element (self, &self->pre_colorspace,
-                    "identity", NULL, "pre-colorspace", FALSE))) {
-          continue;
-        }
-
-        sink = gst_element_get_static_pad (overlay, "video_sink");
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Can't get video sink from textoverlay");
-          continue;
-        }
-
-        src = gst_element_get_static_pad (self->pre_colorspace, "src");
-        if (G_UNLIKELY (!src)) {
-          GST_WARNING_OBJECT (self, "Can't get srcpad from " COLORSPACE);
-          gst_object_unref (sink);
-          continue;
-        }
-
-        if (G_UNLIKELY (gst_pad_link (src, sink) != GST_PAD_LINK_OK)) {
-          GST_WARNING_OBJECT (self, "Can't link " COLORSPACE " to textoverlay");
-          gst_object_unref (src);
-          gst_object_unref (sink);
-          continue;
-        }
-        gst_object_unref (src);
-        gst_object_unref (sink);
+        gst_ghost_pad_set_target (GST_GHOST_PAD_CAST (self->srcpad), NULL);
+        gst_ghost_pad_set_target (GST_GHOST_PAD_CAST (self->video_sinkpad),
+            NULL);
+        gst_ghost_pad_set_target (GST_GHOST_PAD_CAST (self->subtitle_sinkpad),
+            NULL);
+        self->silent_property = NULL;
+        _remove_element (self, &self->post_colorspace);
+        _remove_element (self, &self->overlay);
+        _remove_element (self, &self->pre_colorspace);
 
-        /* Set src ghostpad target */
-        src = gst_element_get_static_pad (self->post_colorspace, "src");
-        if (G_UNLIKELY (!src)) {
-          GST_WARNING_OBJECT (self, "Can't get src pad from " COLORSPACE);
+        if (!_create_element (self, &self->overlay, NULL, overlay_factory,
+                "overlay", FALSE))
           continue;
-        }
 
-        if (G_UNLIKELY (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
-                    (self->srcpad), src))) {
-          GST_WARNING_OBJECT (self, "Can't set srcpad target");
-          gst_object_unref (src);
+        if (!_setup_renderer (self, self->overlay))
           continue;
-        }
-        gst_object_unref (src);
-      } else if (is_hw) {
-        GST_DEBUG_OBJECT (self,
-            "Is Hardware, not adding colorspace converters, ");
-        /* Set src ghostpad target */
-        src = gst_element_get_static_pad (self->overlay, "src");
-        if (G_UNLIKELY (!src)) {
-          GST_WARNING_OBJECT (self, "Can't get src pad from textoverlay");
-          continue;
-        }
 
-        if (G_UNLIKELY (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
-                    (self->srcpad), src))) {
-          GST_WARNING_OBJECT (self, "Can't set srcpad target");
+        src = gst_element_get_static_pad (self->parser, "src");
+        if (!_link_renderer (self, self->overlay, src)) {
           gst_object_unref (src);
           continue;
         }
         gst_object_unref (src);
-      }
-
-      /* Send segments to the parser/overlay if necessary. These are not sent
-       * outside this element because of the proxy pad event function */
-      if (self->video_segment.format != GST_FORMAT_UNDEFINED) {
-        GstEvent *event1, *event2;
 
-        if (is_video) {
-          sink = gst_element_get_static_pad (self->pre_colorspace, "sink");
-          if (G_UNLIKELY (!sink)) {
-            GST_WARNING_OBJECT (self, "Can't get sink pad from " COLORSPACE);
-            continue;
-          }
-        } else {
-          sink = gst_element_get_static_pad (self->overlay, "video_sink");
-          if (G_UNLIKELY (!sink)) {
-            GST_WARNING_OBJECT (self, "Can't get sink pad from textoverlay");
-            continue;
-          }
-        }
-
-        _generate_update_newsegment_event (&self->video_segment, &event1,
-            &event2);
-        GST_DEBUG_OBJECT (self,
-            "Pushing video accumulate newsegment event: %" GST_PTR_FORMAT,
-            event1->structure);
-        GST_DEBUG_OBJECT (self,
-            "Pushing video update newsegment event: %" GST_PTR_FORMAT,
-            event2->structure);
-        gst_pad_send_event (sink, event1);
-        gst_pad_send_event (sink, event2);
-
-        gst_object_unref (sink);
-      }
-
-      if (self->subtitle_segment.format != GST_FORMAT_UNDEFINED) {
-        GstEvent *event1, *event2;
-
-        sink = gst_element_get_static_pad (element, "sink");
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Failed to get subpad");
-          continue;
-        }
-
-        _generate_update_newsegment_event (&self->subtitle_segment, &event1,
-            &event2);
-        GST_DEBUG_OBJECT (self,
-            "Pushing subtitle accumulate newsegment event: %" GST_PTR_FORMAT,
-            event1->structure);
-        GST_DEBUG_OBJECT (self,
-            "Pushing subtitle update newsegment event: %" GST_PTR_FORMAT,
-            event2->structure);
-        gst_pad_send_event (sink, event1);
-        gst_pad_send_event (sink, event2);
-
-        gst_object_unref (sink);
+        /* Everything done here, go out of loop */
+        break;
       }
 
-      /* Set the sink ghostpad targets */
-      if (is_video && !is_hw) {
-        sink = gst_element_get_static_pad (self->pre_colorspace, "sink");
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Can't get sink pad from " COLORSPACE);
-          continue;
-        }
-      } else if (is_video && is_hw) {
-        GST_DEBUG_OBJECT (self, "Setting ghostpad to overlay video sink");
-        sink = gst_element_get_static_pad (self->overlay, "video_sink");
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Can't get sink pad from overlay");
-          continue;
-        }
-      }
-
-      if (G_UNLIKELY (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
-                  (self->video_sinkpad), sink))) {
-        GST_WARNING_OBJECT (self, "Can't set video sinkpad target");
-        gst_object_unref (sink);
-        continue;
-      }
-      gst_object_unref (sink);
+      if (overlay_factories)
+        gst_plugin_feature_list_free (overlay_factories);
 
-      /* Link subtitle identity to subtitle pad of our element */
-      sink = gst_element_get_static_pad (element, "sink");
-      if (G_UNLIKELY (!sink)) {
-        GST_WARNING_OBJECT (self, "Failed to get subpad");
+      if (G_UNLIKELY (k == NULL)) {
+        GST_WARNING_OBJECT (self, "Failed to find usable overlay factory");
         continue;
       }
 
-      if (G_UNLIKELY (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
-                  (self->subtitle_sinkpad), sink))) {
-        GST_WARNING_OBJECT (self, "Failed to set subtitle sink target");
+      /* Now link subtitle sinkpad of the bin and the parser */
+      sink = gst_element_get_static_pad (self->parser, "sink");
+      if (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
+              (self->subtitle_sinkpad), sink)) {
         gst_object_unref (sink);
         continue;
       }
       gst_object_unref (sink);
-    } else {
-      const gchar *name =
-          gst_plugin_feature_get_name (GST_PLUGIN_FEATURE_CAST (factory));
-
-      if (strcmp (name, "textoverlay") == 0) {
-        /* Set some textoverlay specific properties */
-        g_object_set (G_OBJECT (element),
-            "halign", "center", "valign", "bottom", "wait-text", FALSE, NULL);
-        if (self->font_desc)
-          g_object_set (G_OBJECT (element), "font-desc", self->font_desc, NULL);
-        self->silent_property = "silent";
-        self->silent_property_invert = FALSE;
-      } else {
-        self->silent_property =
-            _get_silent_property (element, &self->silent_property_invert);
-        if (_has_subtitle_encoding_property (self->renderer))
-          g_object_set (self->renderer, "subtitle-encoding", self->encoding,
-              NULL);
-        if (_has_font_desc_property (self->renderer))
-          g_object_set (self->renderer, "font-desc", self->font_desc, NULL);
-      }
-
-      if (is_video) {
-        gboolean render_is_hw;
-
-        /* First check that renderer also supports the video format */
-        sink = _get_video_pad (element);
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Can't get video sink from renderer");
-          continue;
-        }
-
-        if (is_video != _is_video_pad (sink, &render_is_hw) ||
-            is_hw != render_is_hw) {
-          GST_DEBUG_OBJECT (self, "Renderer doesn't support %s video",
-              is_hw ? "surface" : "raw");
-          gst_object_unref (sink);
-          continue;
-        }
-        gst_object_unref (sink);
-
-        if (!is_hw) {
-          /* First link everything internally */
-          if (G_UNLIKELY (!_create_element (self, &self->post_colorspace,
-                      COLORSPACE, NULL, "post-colorspace", FALSE))) {
-            continue;
-          }
-          src = gst_element_get_static_pad (element, "src");
-          if (G_UNLIKELY (!src)) {
-            GST_WARNING_OBJECT (self, "Can't get src pad from renderer");
-            continue;
-          }
-
-          sink = gst_element_get_static_pad (self->post_colorspace, "sink");
-          if (G_UNLIKELY (!sink)) {
-            GST_WARNING_OBJECT (self, "Can't get sink pad from " COLORSPACE);
-            gst_object_unref (src);
-            continue;
-          }
-
-          if (G_UNLIKELY (gst_pad_link (src, sink) != GST_PAD_LINK_OK)) {
-            GST_WARNING_OBJECT (self, "Can't link renderer with " COLORSPACE);
-            gst_object_unref (src);
-            gst_object_unref (sink);
-            continue;
-          }
-          gst_object_unref (src);
-          gst_object_unref (sink);
-
-          if (G_UNLIKELY (!_create_element (self, &self->pre_colorspace,
-                      COLORSPACE, NULL, "pre-colorspace", FALSE))) {
-            continue;
-          }
-
-          sink = _get_video_pad (element);
-          if (G_UNLIKELY (!sink)) {
-            GST_WARNING_OBJECT (self, "Can't get video sink from renderer");
-            continue;
-          }
-
-          src = gst_element_get_static_pad (self->pre_colorspace, "src");
-          if (G_UNLIKELY (!src)) {
-            GST_WARNING_OBJECT (self, "Can't get srcpad from " COLORSPACE);
-            gst_object_unref (sink);
-            continue;
-          }
-
-          if (G_UNLIKELY (gst_pad_link (src, sink) != GST_PAD_LINK_OK)) {
-            GST_WARNING_OBJECT (self, "Can't link " COLORSPACE " to renderer");
-            gst_object_unref (src);
-            gst_object_unref (sink);
-            continue;
-          }
-          gst_object_unref (src);
-          gst_object_unref (sink);
-
-          /* Set src ghostpad target */
-          src = gst_element_get_static_pad (self->post_colorspace, "src");
-          if (G_UNLIKELY (!src)) {
-            GST_WARNING_OBJECT (self, "Can't get src pad from " COLORSPACE);
-            continue;
-          }
-        } else {
-          /* Set src ghostpad target in the harware accelerated case */
-
-          src = gst_element_get_static_pad (self->renderer, "src");
-          if (G_UNLIKELY (!src)) {
-            GST_WARNING_OBJECT (self, "Can't get src pad from renderer");
-            continue;
-          }
-        }
-      } else {                  /* No video pad */
-        GstCaps *allowed_caps, *video_caps = NULL;
-        GstPad *video_peer;
-        gboolean can_intersect = FALSE;
-
-        video_peer = gst_pad_get_peer (self->video_sinkpad);
-        if (video_peer) {
-          video_caps = gst_pad_get_negotiated_caps (video_peer);
-          if (!video_caps) {
-            video_caps = gst_pad_get_caps_reffed (video_peer);
-          }
-          gst_object_unref (video_peer);
-        }
-
-        sink = _get_video_pad (element);
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Can't get video sink from renderer");
-          continue;
-        }
-        allowed_caps = gst_pad_get_caps_reffed (sink);
-        gst_object_unref (sink);
-
-        if (allowed_caps && video_caps)
-          can_intersect = gst_caps_can_intersect (allowed_caps, video_caps);
-
-        if (allowed_caps)
-          gst_caps_unref (allowed_caps);
 
-        if (video_caps)
-          gst_caps_unref (video_caps);
-
-        if (G_UNLIKELY (!can_intersect)) {
-          GST_WARNING_OBJECT (self, "Renderer with custom caps is not "
-              "compatible with video stream");
-          continue;
-        }
-
-        src = gst_element_get_static_pad (element, "src");
-        if (G_UNLIKELY (!src)) {
-          GST_WARNING_OBJECT (self, "Can't get src pad from renderer");
-          continue;
-        }
-      }
-
-      if (G_UNLIKELY (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
-                  (self->srcpad), src))) {
-        GST_WARNING_OBJECT (self, "Can't set srcpad target");
-        gst_object_unref (src);
-        continue;
-      }
-      gst_object_unref (src);
-
-      /* Send segments to the renderer if necessary. These are not sent
-       * outside this element because of the proxy pad event handler */
-      if (self->video_segment.format != GST_FORMAT_UNDEFINED) {
-        GstEvent *event1, *event2;
-
-        sink = gst_element_get_static_pad (self->pre_colorspace, "sink");
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Can't get sink pad from " COLORSPACE);
-          continue;
-        }
-
-        _generate_update_newsegment_event (&self->video_segment, &event1,
-            &event2);
-        GST_DEBUG_OBJECT (self,
-            "Pushing video accumulate newsegment event: %" GST_PTR_FORMAT,
-            event1->structure);
-        GST_DEBUG_OBJECT (self,
-            "Pushing video update newsegment event: %" GST_PTR_FORMAT,
-            event2->structure);
-        gst_pad_send_event (sink, event1);
-        gst_pad_send_event (sink, event2);
-        gst_object_unref (sink);
-      }
-
-      if (self->subtitle_segment.format != GST_FORMAT_UNDEFINED) {
-        GstEvent *event1, *event2;
-
-        sink = _get_sub_pad (element);
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Failed to get subpad");
-          continue;
-        }
-
-        _generate_update_newsegment_event (&self->subtitle_segment, &event1,
-            &event2);
-        GST_DEBUG_OBJECT (self,
-            "Pushing subtitle accumulate newsegment event: %" GST_PTR_FORMAT,
-            event1->structure);
-        GST_DEBUG_OBJECT (self,
-            "Pushing subtitle update newsegment event: %" GST_PTR_FORMAT,
-            event2->structure);
-        gst_pad_send_event (sink, event1);
-        gst_pad_send_event (sink, event2);
-        gst_object_unref (sink);
-      }
-
-      /* Set the sink ghostpad targets */
-      if (self->pre_colorspace) {
-        sink = gst_element_get_static_pad (self->pre_colorspace, "sink");
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Can't get sink pad from " COLORSPACE);
-          continue;
-        }
-      } else {
-        sink = _get_video_pad (element);
-        if (G_UNLIKELY (!sink)) {
-          GST_WARNING_OBJECT (self, "Can't get sink pad from %" GST_PTR_FORMAT,
-              element);
-          continue;
-        }
-      }
+      /* Everything done here, go out of loop */
+      break;
+    } else {
+      /* Is renderer factory */
 
-      if (G_UNLIKELY (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
-                  (self->video_sinkpad), sink))) {
-        GST_WARNING_OBJECT (self, "Can't set video sinkpad target");
-        gst_object_unref (sink);
+      if (!_setup_renderer (self, self->renderer))
         continue;
-      }
-      gst_object_unref (sink);
 
-      sink = _get_sub_pad (element);
-      if (G_UNLIKELY (!sink)) {
-        GST_WARNING_OBJECT (self, "Failed to get subpad");
+      /* subtitle_src==NULL means: use subtitle_sink ghostpad */
+      if (!_link_renderer (self, self->renderer, NULL))
         continue;
-      }
 
-      if (G_UNLIKELY (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST
-                  (self->subtitle_sinkpad), sink))) {
-        GST_WARNING_OBJECT (self, "Failed to set subtitle sink target");
-        gst_object_unref (sink);
-        continue;
-      }
-      gst_object_unref (sink);
+      /* Everything done here, go out of loop */
+      break;
     }
-
-    break;
   }
 
   if (G_UNLIKELY (l == NULL)) {
@@ -1420,15 +1270,62 @@ _pad_blocked_cb (GstPad * pad, gboolean blocked, gpointer user_data)
     self->subtitle_error = TRUE;
     _setup_passthrough (self);
     do_async_done (self);
-  } else {
-    GST_DEBUG_OBJECT (self, "Everything worked, unblocking pads");
-    gst_pad_set_blocked_async_full (self->video_block_pad, FALSE,
-        _pad_blocked_cb, self, NULL);
-    gst_pad_set_blocked_async_full (self->subtitle_block_pad, FALSE,
-        _pad_blocked_cb, self, NULL);
-    do_async_done (self);
+    goto out;
   }
 
+  /* Send segments to the renderer if necessary. These are not sent
+   * outside this element because of the proxy pad event handler */
+  if (self->video_segment.format != GST_FORMAT_UNDEFINED) {
+    GstEvent *event1, *event2;
+    GstPad *sink;
+
+    if (self->pre_colorspace) {
+      sink = gst_element_get_static_pad (self->pre_colorspace, "sink");
+    } else {
+      sink = _get_video_pad ((self->renderer) ? self->renderer : self->overlay);
+    }
+
+    _generate_update_newsegment_event (&self->video_segment, &event1, &event2);
+    GST_DEBUG_OBJECT (self,
+        "Pushing video accumulate newsegment event: %" GST_PTR_FORMAT,
+        event1->structure);
+    GST_DEBUG_OBJECT (self,
+        "Pushing video update newsegment event: %" GST_PTR_FORMAT,
+        event2->structure);
+    gst_pad_send_event (sink, event1);
+    gst_pad_send_event (sink, event2);
+    gst_object_unref (sink);
+  }
+
+  if (self->subtitle_segment.format != GST_FORMAT_UNDEFINED) {
+    GstEvent *event1, *event2;
+    GstPad *sink;
+
+    if (self->renderer)
+      sink = _get_sub_pad (self->renderer);
+    else
+      sink = gst_element_get_static_pad (self->parser, "sink");
+
+    _generate_update_newsegment_event (&self->subtitle_segment, &event1,
+        &event2);
+    GST_DEBUG_OBJECT (self,
+        "Pushing subtitle accumulate newsegment event: %" GST_PTR_FORMAT,
+        event1->structure);
+    GST_DEBUG_OBJECT (self,
+        "Pushing subtitle update newsegment event: %" GST_PTR_FORMAT,
+        event2->structure);
+    gst_pad_send_event (sink, event1);
+    gst_pad_send_event (sink, event2);
+    gst_object_unref (sink);
+  }
+
+  GST_DEBUG_OBJECT (self, "Everything worked, unblocking pads");
+  gst_pad_set_blocked_async_full (self->video_block_pad, FALSE,
+      _pad_blocked_cb, self, NULL);
+  gst_pad_set_blocked_async_full (self->subtitle_block_pad, FALSE,
+      _pad_blocked_cb, self, NULL);
+  do_async_done (self);
+
 out:
   if (factories)
     gst_plugin_feature_list_free (factories);
@@ -1669,9 +1566,13 @@ gst_subtitle_overlay_set_property (GObject * object, guint prop_id,
       GST_SUBTITLE_OVERLAY_LOCK (self);
       g_free (self->font_desc);
       self->font_desc = g_value_dup_string (value);
-      if (self->overlay)
+      if (self->overlay
+          && _has_property_with_type (G_OBJECT (self->overlay), "font-desc",
+              G_TYPE_STRING))
         g_object_set (self->overlay, "font-desc", self->font_desc, NULL);
-      else if (self->renderer && _has_font_desc_property (self->renderer))
+      else if (self->renderer
+          && _has_property_with_type (G_OBJECT (self->renderer), "font-desc",
+              G_TYPE_STRING))
         g_object_set (self->renderer, "font-desc", self->font_desc, NULL);
       GST_SUBTITLE_OVERLAY_UNLOCK (self);
       break;
@@ -1679,10 +1580,14 @@ gst_subtitle_overlay_set_property (GObject * object, guint prop_id,
       GST_SUBTITLE_OVERLAY_LOCK (self);
       g_free (self->encoding);
       self->encoding = g_value_dup_string (value);
-      if (self->renderer && _has_subtitle_encoding_property (self->renderer))
+      if (self->renderer
+          && _has_property_with_type (G_OBJECT (self->renderer),
+              "subtitle-encoding", G_TYPE_STRING))
         g_object_set (self->renderer, "subtitle-encoding", self->encoding,
             NULL);
-      if (self->parser && _has_subtitle_encoding_property (self->parser))
+      if (self->parser
+          && _has_property_with_type (G_OBJECT (self->parser),
+              "subtitle-encoding", G_TYPE_STRING))
         g_object_set (self->parser, "subtitle-encoding", self->encoding, NULL);
       GST_SUBTITLE_OVERLAY_UNLOCK (self);
       break;
@@ -1799,8 +1704,8 @@ gst_subtitle_overlay_src_proxy_event (GstPad * proxypad, GstEvent * event)
 
   s = gst_event_get_structure (event);
   if (s && gst_structure_id_has_field (s, _subtitle_overlay_event_marker_id)) {
-    GST_DEBUG_OBJECT (ghostpad, "Dropping event with marker: %" GST_PTR_FORMAT,
-        event->structure);
+    GST_DEBUG_OBJECT (ghostpad,
+        "Dropping event with marker: %" GST_PTR_FORMAT, event->structure);
     gst_event_unref (event);
     event = NULL;
     ret = TRUE;
@@ -2170,8 +2075,8 @@ gst_subtitle_overlay_subtitle_sink_event (GstPad * pad, GstEvent * event)
         gst_structure_set_parent_refcount (event->structure,
             &event->mini_object.refcount);
       }
-      gst_structure_id_set (event->structure, _subtitle_overlay_event_marker_id,
-          G_TYPE_BOOLEAN, TRUE, NULL);
+      gst_structure_id_set (event->structure,
+          _subtitle_overlay_event_marker_id, G_TYPE_BOOLEAN, TRUE, NULL);
       break;
     default:
       break;
diff --git a/gst/playback/gsturidecodebin.c b/gst/playback/gsturidecodebin.c
index 2a5026f..30f8028 100644
--- a/gst/playback/gsturidecodebin.c
+++ b/gst/playback/gsturidecodebin.c
@@ -24,6 +24,10 @@
  * handle the given #GstURIDecodeBin:uri scheme and connects it to a decodebin2.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
@@ -1509,6 +1513,8 @@ remove_decoders (GstURIDecodeBin * bin, gboolean force)
       caps = DEFAULT_CAPS;
       g_object_set (decoder, "caps", caps, NULL);
       gst_caps_unref (caps);
+      /* make it freshly floating again */
+      GST_OBJECT_FLAG_SET (decoder, GST_OBJECT_FLOATING);
 
       bin->pending_decodebins =
           g_slist_prepend (bin->pending_decodebins, decoder);
diff --git a/gst/typefind/gsttypefindfunctions.c b/gst/typefind/gsttypefindfunctions.c
index 27823b6..1bf32cb 100644
--- a/gst/typefind/gsttypefindfunctions.c
+++ b/gst/typefind/gsttypefindfunctions.c
@@ -2402,6 +2402,9 @@ h264_video_type_find (GstTypeFind * tf, gpointer unused)
   /* Stream consists of: a series of sync codes (00 00 00 01) followed 
    * by NALs
    */
+  gboolean seen_idr = FALSE;
+  gboolean seen_sps = FALSE;
+  gboolean seen_pps = FALSE;
   int nut, ref;
   int good = 0;
   int bad = 0;
@@ -2426,6 +2429,13 @@ h264_video_type_find (GstTypeFind * tf, gpointer unused)
             ((nut == 6 || (nut >= 9 && nut <= 12)) && ref != 0)) {
           bad++;
         } else {
+          if (nut == 7)
+            seen_sps = TRUE;
+          else if (nut == 8)
+            seen_pps = TRUE;
+          else if (nut == 5)
+            seen_idr = TRUE;
+
           good++;
         }
       } else if (nut >= 14 && nut <= 33) {
@@ -2439,9 +2449,10 @@ h264_video_type_find (GstTypeFind * tf, gpointer unused)
         /* don't consider these bad */
       }
 
-      GST_DEBUG ("good %d bad %d", good, bad);
+      GST_LOG ("good:%d, bad:%d, pps:%d, sps:%d, idr:%d", good, bad, seen_pps,
+          seen_sps, seen_idr);
 
-      if (good >= 10 && bad < 4) {
+      if (seen_sps && seen_pps && seen_idr && good >= 10 && bad < 4) {
         gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, H264_VIDEO_CAPS);
         return;
       }
@@ -2451,9 +2462,11 @@ h264_video_type_find (GstTypeFind * tf, gpointer unused)
     data_scan_ctx_advance (tf, &c, 1);
   }
 
-  if (good >= 2 && bad < 1) {
+  GST_LOG ("good:%d, bad:%d, pps:%d, sps:%d, idr:%d", good, bad, seen_pps,
+      seen_sps, seen_idr);
+
+  if (good >= 2 && bad == 0) {
     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, H264_VIDEO_CAPS);
-    return;
   }
 }
 
diff --git a/gst/videoscale/gstvideoscale.c b/gst/videoscale/gstvideoscale.c
index 7b44647..60dd5ff 100644
--- a/gst/videoscale/gstvideoscale.c
+++ b/gst/videoscale/gstvideoscale.c
@@ -1,6 +1,6 @@
 /* GStreamer
  * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
- * Copyright (C) 2005 David Schleef <ds@schleef.org>
+ * Copyright (C) 2005-2012 David Schleef <ds@schleef.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -140,7 +140,8 @@ static GstStaticCaps gst_video_scale_format_caps[] = {
   GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("Y8  ")),
   GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("GREY")),
   GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("AY64")),
-  GST_STATIC_CAPS (GST_VIDEO_CAPS_ARGB_64)
+  GST_STATIC_CAPS (GST_VIDEO_CAPS_ARGB_64),
+  GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("NV12"))
 };
 
 #define GST_TYPE_VIDEO_SCALE_METHOD (gst_video_scale_method_get_type())
@@ -423,10 +424,118 @@ gst_video_scale_get_property (GObject * object, guint prop_id, GValue * value,
   }
 }
 
+#define NEAREST  (1 << GST_VIDEO_SCALE_NEAREST)
+#define BILINEAR (1 << GST_VIDEO_SCALE_BILINEAR)
+#define FOURTAP  (1 << GST_VIDEO_SCALE_4TAP)
+#define LANCZOS  (1 << GST_VIDEO_SCALE_LANCZOS)
+
+/* or we could just do lookups via table[format] if we could be bothered..  */
+static const struct
+{
+  GstVideoFormat format;
+  guint8 methods;
+} formats_methods_table[] = {
+  {
+  GST_VIDEO_FORMAT_RGBx, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_xRGB, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_BGRx, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_xBGR, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_RGBA, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_ARGB, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_BGRA, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_ABGR, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_AYUV, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_ARGB64, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_AYUV64, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_RGB, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_BGR, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_v308, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_YUY2, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_YVYU, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_UYVY, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_Y800, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_GRAY8, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_GRAY16_LE, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_GRAY16_BE, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_Y16, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_I420, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_YV12, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_Y444, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_Y42B, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_Y41B, NEAREST | BILINEAR | FOURTAP | LANCZOS}, {
+  GST_VIDEO_FORMAT_NV12, NEAREST | BILINEAR}, {
+  GST_VIDEO_FORMAT_RGB16, NEAREST | BILINEAR | FOURTAP}, {
+  GST_VIDEO_FORMAT_RGB15, NEAREST | BILINEAR | FOURTAP}
+};
+
+static gboolean
+gst_video_scale_format_supported_for_method (GstVideoFormat format,
+    GstVideoScaleMethod method)
+{
+  int i;
+
+  for (i = 0; i < G_N_ELEMENTS (formats_methods_table); ++i) {
+    if (formats_methods_table[i].format == format)
+      return ((formats_methods_table[i].methods & (1 << method)) != 0);
+  }
+  return FALSE;
+}
+
+static gboolean
+gst_video_scale_transform_supported (GstVideoScale * videoscale,
+    GstVideoScaleMethod method, GstStructure * structure)
+{
+  const GValue *val;
+  GstVideoFormat fmt;
+  gboolean supported = TRUE;
+  GstStructure *s;
+  GstCaps *c;
+
+  /* we support these methods for all formats */
+  if (method == GST_VIDEO_SCALE_NEAREST || method == GST_VIDEO_SCALE_BILINEAR)
+    return TRUE;
+
+  /* we need fixed caps if we want to use gst_video_parse_caps() */
+  s = gst_structure_new (gst_structure_get_name (structure),
+      "width", G_TYPE_INT, 1, "height", G_TYPE_INT, 1, NULL);
+
+  if ((val = gst_structure_get_value (structure, "format"))) {
+    gst_structure_set_value (s, "format", val);
+  } else {
+    if ((val = gst_structure_get_value (structure, "endianness")))
+      gst_structure_set_value (s, "endianness", val);
+    if ((val = gst_structure_get_value (structure, "red_mask")))
+      gst_structure_set_value (s, "red_mask", val);
+    if ((val = gst_structure_get_value (structure, "blue_mask")))
+      gst_structure_set_value (s, "blue_mask", val);
+    if ((val = gst_structure_get_value (structure, "green_mask")))
+      gst_structure_set_value (s, "green_mask", val);
+    if ((val = gst_structure_get_value (structure, "alpha_mask")))
+      gst_structure_set_value (s, "alpha_mask", val);
+    if ((val = gst_structure_get_value (structure, "depth")))
+      gst_structure_set_value (s, "depth", val);
+    if ((val = gst_structure_get_value (structure, "bpp")))
+      gst_structure_set_value (s, "bpp", val);
+  }
+  c = gst_caps_new_full (s, NULL);
+  if (!gst_video_format_parse_caps (c, &fmt, NULL, NULL)) {
+    GST_ERROR_OBJECT (videoscale, "couldn't parse %" GST_PTR_FORMAT, c);
+  } else if (!gst_video_scale_format_supported_for_method (fmt, method)) {
+    supported = FALSE;
+  }
+  GST_LOG_OBJECT (videoscale, "method %d %ssupported for format %d",
+      method, (supported) ? "" : "not ", fmt);
+  gst_caps_unref (c);
+
+  return supported;
+}
+
 static GstCaps *
 gst_video_scale_transform_caps (GstBaseTransform * trans,
     GstPadDirection direction, GstCaps * caps)
 {
+  GstVideoScale *videoscale = GST_VIDEO_SCALE (trans);
+  GstVideoScaleMethod method;
   GstCaps *ret;
   GstStructure *structure;
 
@@ -440,6 +549,13 @@ gst_video_scale_transform_caps (GstBaseTransform * trans,
   ret = gst_caps_copy (caps);
   structure = gst_structure_copy (gst_caps_get_structure (ret, 0));
 
+  GST_OBJECT_LOCK (videoscale);
+  method = videoscale->method;
+  GST_OBJECT_UNLOCK (videoscale);
+
+  if (!gst_video_scale_transform_supported (videoscale, method, structure))
+    goto format_not_supported;
+
   gst_structure_set (structure,
       "width", GST_TYPE_INT_RANGE, 1, G_MAXINT,
       "height", GST_TYPE_INT_RANGE, 1, G_MAXINT, NULL);
@@ -451,9 +567,19 @@ gst_video_scale_transform_caps (GstBaseTransform * trans,
   }
   gst_caps_append_structure (ret, structure);
 
+done:
+
   GST_DEBUG_OBJECT (trans, "returning caps: %" GST_PTR_FORMAT, ret);
 
   return ret;
+
+format_not_supported:
+  {
+    gst_structure_free (structure);
+    gst_caps_unref (ret);
+    ret = gst_caps_new_empty ();
+    goto done;
+  }
 }
 
 static gboolean
@@ -1024,7 +1150,8 @@ gst_video_scale_setup_vs_image (VSImage * image, GstVideoFormat format,
   if (format == GST_VIDEO_FORMAT_I420
       || format == GST_VIDEO_FORMAT_YV12
       || format == GST_VIDEO_FORMAT_Y444
-      || format == GST_VIDEO_FORMAT_Y42B || format == GST_VIDEO_FORMAT_Y41B) {
+      || format == GST_VIDEO_FORMAT_Y42B || format == GST_VIDEO_FORMAT_Y41B
+      || format == GST_VIDEO_FORMAT_NV12) {
     image->real_pixels = data + gst_video_format_get_component_offset (format,
         component, width, height);
   } else {
@@ -1090,6 +1217,7 @@ _get_black_for_format (GstVideoFormat format)
     case GST_VIDEO_FORMAT_Y444:
     case GST_VIDEO_FORMAT_Y42B:
     case GST_VIDEO_FORMAT_Y41B:
+    case GST_VIDEO_FORMAT_NV12:
       return black[4];          /* Y, U, V, 0 */
     case GST_VIDEO_FORMAT_RGB16:
     case GST_VIDEO_FORMAT_RGB15:
@@ -1153,6 +1281,14 @@ gst_video_scale_transform (GstBaseTransform * trans, GstBuffer * in,
         videoscale->to_width, videoscale->to_height, videoscale->borders_w,
         videoscale->borders_h, GST_BUFFER_DATA (out));
   }
+  if (videoscale->format == GST_VIDEO_FORMAT_NV12) {
+    gst_video_scale_setup_vs_image (&src_u, videoscale->format, 1,
+        videoscale->from_width, videoscale->from_height, 0, 0,
+        GST_BUFFER_DATA (in));
+    gst_video_scale_setup_vs_image (&dest_u, videoscale->format, 1,
+        videoscale->to_width, videoscale->to_height, videoscale->borders_w,
+        videoscale->borders_h, GST_BUFFER_DATA (out));
+  }
 
   switch (videoscale->format) {
     case GST_VIDEO_FORMAT_RGBx:
@@ -1199,6 +1335,11 @@ gst_video_scale_transform (GstBaseTransform * trans, GstBuffer * in,
         case GST_VIDEO_SCALE_4TAP:
           vs_image_scale_4tap_AYUV64 (&dest, &src, videoscale->tmp_buf);
           break;
+        case GST_VIDEO_SCALE_LANCZOS:
+          vs_image_scale_lanczos_AYUV64 (&dest, &src, videoscale->tmp_buf,
+              videoscale->sharpness, videoscale->dither, videoscale->submethod,
+              videoscale->envelope, videoscale->sharpen);
+          break;
         default:
           goto unknown_mode;
       }
@@ -1335,6 +1476,20 @@ gst_video_scale_transform (GstBaseTransform * trans, GstBuffer * in,
           goto unknown_mode;
       }
       break;
+    case GST_VIDEO_FORMAT_NV12:
+      switch (method) {
+        case GST_VIDEO_SCALE_NEAREST:
+          vs_image_scale_nearest_Y (&dest, &src, videoscale->tmp_buf);
+          vs_image_scale_nearest_NV12 (&dest_u, &src_u, videoscale->tmp_buf);
+          break;
+        case GST_VIDEO_SCALE_BILINEAR:
+          vs_image_scale_linear_Y (&dest, &src, videoscale->tmp_buf);
+          vs_image_scale_linear_NV12 (&dest_u, &src_u, videoscale->tmp_buf);
+          break;
+        default:
+          goto unknown_mode;
+      }
+      break;
     case GST_VIDEO_FORMAT_RGB16:
       if (add_borders)
         vs_fill_borders_RGB565 (&dest, black);
diff --git a/gst/videoscale/vs_image.c b/gst/videoscale/vs_image.c
index c28b0d8..09ccf25 100644
--- a/gst/videoscale/vs_image.c
+++ b/gst/videoscale/vs_image.c
@@ -1,6 +1,6 @@
 /*
  * Image Scaling Functions
- * Copyright (c) 2005 David A. Schleef <ds@schleef.org>
+ * Copyright (c) 2005-2012 David A. Schleef <ds@schleef.org>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -522,6 +522,136 @@ vs_image_scale_linear_UYVY (const VSImage * dest, const VSImage * src,
   }
 }
 
+/* NV12 */
+
+void
+vs_image_scale_nearest_NV12 (const VSImage * dest, const VSImage * src,
+    uint8_t * tmpbuf)
+{
+  int acc;
+  int y_increment;
+  int x_increment;
+  int i;
+  int j;
+  int xacc;
+
+  if (dest->height == 1)
+    y_increment = 0;
+  else
+    y_increment = ((src->height - 1) << 16) / (dest->height - 1);
+
+  if (dest->width == 1)
+    x_increment = 0;
+  else
+    x_increment = ((src->width - 1) << 16) / (dest->width - 1);
+
+  acc = 0;
+  for (i = 0; i < dest->height; i++) {
+    j = acc >> 16;
+
+    xacc = 0;
+    vs_scanline_resample_nearest_NV12 (dest->pixels + i * dest->stride,
+        src->pixels + j * src->stride, src->width, dest->width, &xacc,
+        x_increment);
+
+    acc += y_increment;
+  }
+}
+
+void
+vs_image_scale_linear_NV12 (const VSImage * dest, const VSImage * src,
+    uint8_t * tmpbuf)
+{
+  int acc;
+  int y_increment;
+  int x_increment;
+  uint8_t *tmp1;
+  uint8_t *tmp2;
+  int y1;
+  int y2;
+  int i;
+  int j;
+  int x;
+  int dest_size;
+  int xacc;
+
+  if (dest->height == 1)
+    y_increment = 0;
+  else
+    y_increment = ((src->height - 1) << 16) / (dest->height - 1) - 1;
+
+  if (dest->width == 1)
+    x_increment = 0;
+  else
+    x_increment = ((src->width - 1) << 16) / (dest->width - 1) - 1;
+
+  dest_size = ROUND_UP_4 (dest->width * 2);
+
+  tmp1 = tmpbuf;
+  tmp2 = tmpbuf + dest_size;
+
+  acc = 0;
+  xacc = 0;
+  y2 = -1;
+  vs_scanline_resample_linear_NV12 (tmp1, src->pixels, src->width, dest->width,
+      &xacc, x_increment);
+  y1 = 0;
+  for (i = 0; i < dest->height; i++) {
+    j = acc >> 16;
+    x = acc & 0xffff;
+
+    if (x == 0) {
+      if (j == y1) {
+        memcpy (dest->pixels + i * dest->stride, tmp1, dest_size);
+      } else if (j == y2) {
+        memcpy (dest->pixels + i * dest->stride, tmp2, dest_size);
+      } else {
+        xacc = 0;
+        vs_scanline_resample_linear_NV12 (tmp1, src->pixels + j * src->stride,
+            src->width, dest->width, &xacc, x_increment);
+        y1 = j;
+        memcpy (dest->pixels + i * dest->stride, tmp1, dest_size);
+      }
+    } else {
+      if (j == y1) {
+        if (j + 1 != y2) {
+          xacc = 0;
+          vs_scanline_resample_linear_NV12 (tmp2,
+              src->pixels + (j + 1) * src->stride, src->width, dest->width,
+              &xacc, x_increment);
+          y2 = j + 1;
+        }
+        vs_scanline_merge_linear_NV12 (dest->pixels + i * dest->stride,
+            tmp1, tmp2, dest->width, x);
+      } else if (j == y2) {
+        if (j + 1 != y1) {
+          xacc = 0;
+          vs_scanline_resample_linear_NV12 (tmp1,
+              src->pixels + (j + 1) * src->stride, src->width, dest->width,
+              &xacc, x_increment);
+          y1 = j + 1;
+        }
+        vs_scanline_merge_linear_NV12 (dest->pixels + i * dest->stride,
+            tmp2, tmp1, dest->width, x);
+      } else {
+        xacc = 0;
+        vs_scanline_resample_linear_NV12 (tmp1, src->pixels + j * src->stride,
+            src->width, dest->width, &xacc, x_increment);
+        y1 = j;
+        xacc = 0;
+        vs_scanline_resample_linear_NV12 (tmp2,
+            src->pixels + (j + 1) * src->stride, src->width, dest->width,
+            &xacc, x_increment);
+        y2 = (j + 1);
+        vs_scanline_merge_linear_NV12 (dest->pixels + i * dest->stride,
+            tmp1, tmp2, dest->width, x);
+      }
+    }
+
+    acc += y_increment;
+  }
+}
+
 /* greyscale */
 
 void
diff --git a/gst/videoscale/vs_image.h b/gst/videoscale/vs_image.h
index 2312acc..d3cc31d 100644
--- a/gst/videoscale/vs_image.h
+++ b/gst/videoscale/vs_image.h
@@ -52,6 +52,9 @@ void vs_image_scale_linear_RGBA (const VSImage *dest, const VSImage *src,
 void vs_image_scale_lanczos_AYUV (const VSImage * dest, const VSImage * src,
     uint8_t * tmpbuf, double sharpness, gboolean dither, int submethod,
     double a, double sharpen);
+void vs_image_scale_lanczos_AYUV64 (const VSImage * dest, const VSImage * src,
+    uint8_t * tmpbuf, double sharpness, gboolean dither, int submethod,
+    double a, double sharpen);
 
 void vs_image_scale_nearest_RGB (const VSImage *dest, const VSImage *src,
     uint8_t *tmpbuf);
@@ -68,6 +71,11 @@ void vs_image_scale_nearest_UYVY (const VSImage *dest, const VSImage *src,
 void vs_image_scale_linear_UYVY (const VSImage *dest, const VSImage *src,
     uint8_t *tmpbuf);
 
+void vs_image_scale_nearest_NV12 (const VSImage *dest, const VSImage *src,
+    uint8_t *tmpbuf);
+void vs_image_scale_linear_NV12 (const VSImage *dest, const VSImage *src,
+    uint8_t *tmpbuf);
+
 void vs_image_scale_nearest_Y (const VSImage *dest, const VSImage *src,
     uint8_t *tmpbuf);
 void vs_image_scale_linear_Y (const VSImage *dest, const VSImage *src,
diff --git a/gst/videoscale/vs_lanczos.c b/gst/videoscale/vs_lanczos.c
index 1c87ba3..67cd401 100644
--- a/gst/videoscale/vs_lanczos.c
+++ b/gst/videoscale/vs_lanczos.c
@@ -204,6 +204,9 @@ static void vs_image_scale_lanczos_AYUV_float (const VSImage * dest,
 static void vs_image_scale_lanczos_AYUV_double (const VSImage * dest,
     const VSImage * src, uint8_t * tmpbuf, double sharpness, gboolean dither,
     double a, double sharpen);
+static void vs_image_scale_lanczos_AYUV64_double (const VSImage * dest,
+    const VSImage * src, uint8_t * tmpbuf, double sharpness, gboolean dither,
+    double a, double sharpen);
 
 static double
 sinc (double x)
@@ -590,6 +593,15 @@ vs_image_scale_lanczos_AYUV (const VSImage * dest, const VSImage * src,
   }
 }
 
+void
+vs_image_scale_lanczos_AYUV64 (const VSImage * dest, const VSImage * src,
+    uint8_t * tmpbuf, double sharpness, gboolean dither, int submethod,
+    double a, double sharpen)
+{
+  vs_image_scale_lanczos_AYUV64_double (dest, src, tmpbuf, sharpness, dither,
+      a, sharpen);
+}
+
 
 
 #define RESAMPLE_HORIZ_FLOAT(function, dest_type, tap_type, src_type, _n_taps) \
@@ -716,6 +728,9 @@ RESAMPLE_HORIZ_AYUV_FLOAT (resample_horiz_double_ayuv_generic, double, double,
 RESAMPLE_HORIZ_AYUV_FLOAT (resample_horiz_float_ayuv_generic, float, float,
     guint8, n_taps)
 
+RESAMPLE_HORIZ_AYUV_FLOAT (resample_horiz_double_ayuv_generic_s16, double, double,
+    guint16, n_taps)
+
 RESAMPLE_HORIZ (resample_horiz_int32_int32_u8_generic, gint32, gint32,
     guint8, n_taps, shift)
 RESAMPLE_HORIZ (resample_horiz_int16_int16_u8_generic, gint16, gint16,
@@ -813,9 +828,9 @@ RESAMPLE_VERT_DITHER (resample_vert_dither_int16_generic, gint16, gint16,
     n_taps, shift)
 /* *INDENT-ON* */
 
-#define RESAMPLE_VERT_FLOAT(function, tap_type, src_type, _n_taps, _shift) \
+#define RESAMPLE_VERT_FLOAT(function, dest_type, clamp, tap_type, src_type, _n_taps, _shift) \
 static void \
-function (guint8 *dest, \
+function (dest_type *dest, \
     const tap_type *taps, const src_type *src, int stride, int n_taps, \
     int shift, int n) \
 { \
@@ -828,13 +843,13 @@ function (guint8 *dest, \
       const src_type *line = PTR_OFFSET(src, stride * l); \
       sum_y += line[i] * taps[l]; \
     } \
-    dest[i] = CLAMP (floor(0.5 + sum_y), 0, 255); \
+    dest[i] = CLAMP (floor(0.5 + sum_y), 0, clamp); \
   } \
 }
 
-#define RESAMPLE_VERT_FLOAT_DITHER(function, tap_type, src_type, _n_taps, _shift) \
+#define RESAMPLE_VERT_FLOAT_DITHER(function, dest_type, clamp, tap_type, src_type, _n_taps, _shift) \
 static void \
-function (guint8 *dest, \
+function (dest_type *dest, \
     const tap_type *taps, const src_type *src, int stride, int n_taps, \
     int shift, int n) \
 { \
@@ -849,19 +864,24 @@ function (guint8 *dest, \
       sum_y += line[i] * taps[l]; \
     } \
     err_y += sum_y; \
-    dest[i] = CLAMP (floor (err_y), 0, 255); \
+    dest[i] = CLAMP (floor (err_y), 0, clamp); \
     err_y -= floor (err_y); \
   } \
 }
 
 /* *INDENT-OFF* */
-RESAMPLE_VERT_FLOAT (resample_vert_double_generic, double, double, n_taps,
+RESAMPLE_VERT_FLOAT (resample_vert_double_generic, guint8, 255, double, double, n_taps,
     shift)
-RESAMPLE_VERT_FLOAT_DITHER (resample_vert_dither_double_generic, double, double,
+RESAMPLE_VERT_FLOAT_DITHER (resample_vert_dither_double_generic, guint8, 255, double, double,
     n_taps, shift)
 
-RESAMPLE_VERT_FLOAT (resample_vert_float_generic, float, float, n_taps, shift)
-RESAMPLE_VERT_FLOAT_DITHER (resample_vert_dither_float_generic, float, float,
+RESAMPLE_VERT_FLOAT (resample_vert_double_generic_u16, guint16, 65535, double, double, n_taps,
+    shift)
+RESAMPLE_VERT_FLOAT_DITHER (resample_vert_dither_double_generic_u16, guint16, 65535, double, double,
+    n_taps, shift)
+
+RESAMPLE_VERT_FLOAT (resample_vert_float_generic, guint8, 255, float, float, n_taps, shift)
+RESAMPLE_VERT_FLOAT_DITHER (resample_vert_dither_float_generic, guint8, 255, float, float,
     n_taps, shift)
 /* *INDENT-ON* */
 
@@ -1556,3 +1576,77 @@ vs_image_scale_lanczos_AYUV_float (const VSImage * dest, const VSImage * src,
   scale1d_cleanup (&scale->y_scale1d);
   g_free (scale->tmpdata);
 }
+
+static void
+vs_scale_lanczos_AYUV64_double (Scale * scale)
+{
+  int j;
+  int yi;
+  int tmp_yi;
+
+  tmp_yi = 0;
+
+  for (j = 0; j < scale->dest->height; j++) {
+    guint16 *destline;
+    double *taps;
+
+    destline = (guint16 *) (scale->dest->pixels + scale->dest->stride * j);
+
+    yi = scale->y_scale1d.offsets[j];
+
+    while (tmp_yi < yi + scale->y_scale1d.n_taps) {
+      scale->horiz_resample_func (TMP_LINE_DOUBLE_AYUV (tmp_yi),
+          scale->x_scale1d.offsets, scale->x_scale1d.taps, SRC_LINE (tmp_yi),
+          scale->x_scale1d.n_taps, 0, scale->dest->width);
+      tmp_yi++;
+    }
+
+    taps = (double *) scale->y_scale1d.taps + j * scale->y_scale1d.n_taps;
+    if (scale->dither) {
+      resample_vert_dither_double_generic_u16 (destline,
+          taps, TMP_LINE_DOUBLE_AYUV (scale->y_scale1d.offsets[j]),
+          sizeof (double) * 4 * scale->dest->width,
+          scale->y_scale1d.n_taps, 0, scale->dest->width * 4);
+    } else {
+      resample_vert_double_generic_u16 (destline,
+          taps, TMP_LINE_DOUBLE_AYUV (scale->y_scale1d.offsets[j]),
+          sizeof (double) * 4 * scale->dest->width,
+          scale->y_scale1d.n_taps, 0, scale->dest->width * 4);
+    }
+  }
+}
+
+void
+vs_image_scale_lanczos_AYUV64_double (const VSImage * dest, const VSImage * src,
+    uint8_t * tmpbuf, double sharpness, gboolean dither, double a,
+    double sharpen)
+{
+  Scale s = { 0 };
+  Scale *scale = &s;
+  int n_taps;
+
+  scale->dest = dest;
+  scale->src = src;
+
+  n_taps = scale1d_get_n_taps (src->width, dest->width, a, sharpness);
+  scale1d_calculate_taps (&scale->x_scale1d,
+      src->width, dest->width, n_taps, a, sharpness, sharpen);
+
+  n_taps = scale1d_get_n_taps (src->height, dest->height, a, sharpness);
+  scale1d_calculate_taps (&scale->y_scale1d,
+      src->height, dest->height, n_taps, a, sharpness, sharpen);
+
+  scale->dither = dither;
+
+  scale->horiz_resample_func =
+      (HorizResampleFunc) resample_horiz_double_ayuv_generic_s16;
+
+  scale->tmpdata =
+      g_malloc (sizeof (double) * scale->dest->width * scale->src->height * 4);
+
+  vs_scale_lanczos_AYUV64_double (scale);
+
+  scale1d_cleanup (&scale->x_scale1d);
+  scale1d_cleanup (&scale->y_scale1d);
+  g_free (scale->tmpdata);
+}
diff --git a/gst/videoscale/vs_scanline.c b/gst/videoscale/vs_scanline.c
index 822a6b6..c9459c2 100644
--- a/gst/videoscale/vs_scanline.c
+++ b/gst/videoscale/vs_scanline.c
@@ -519,6 +519,88 @@ vs_scanline_merge_linear_UYVY (uint8_t * dest, uint8_t * src1,
 }
 
 
+/* NV12 */
+
+/* n is the number of bi-pixels */
+
+void
+vs_scanline_downsample_NV12 (uint8_t * dest, uint8_t * src, int n)
+{
+  int i;
+
+  for (i = 0; i < n; i++) {
+    dest[i * 2 + 0] = (src[i * 4 + 0] + src[i * 4 + 2]) / 2;
+    dest[i * 2 + 1] = (src[i * 4 + 1] + src[i * 4 + 3]) / 2;
+  }
+}
+
+void
+vs_scanline_resample_nearest_NV12 (uint8_t * dest, uint8_t * src, int src_width,
+    int n, int *accumulator, int increment)
+{
+  int acc = *accumulator;
+  int i;
+  int j;
+  int x;
+
+  for (i = 0; i < n; i++) {
+    j = acc >> 16;
+    x = acc & 0xffff;
+
+    dest[i * 2 + 0] = (x < 32768
+        || j + 1 >= src_width) ? src[j * 2 + 0] : src[j * 2 + 2];
+    dest[i * 2 + 1] = (x < 32768
+        || j + 1 >= src_width) ? src[j * 2 + 1] : src[j * 2 + 3];
+
+    acc += increment;
+  }
+
+  *accumulator = acc;
+}
+
+void
+vs_scanline_resample_linear_NV12 (uint8_t * dest, uint8_t * src, int src_width,
+    int n, int *accumulator, int increment)
+{
+  int acc = *accumulator;
+  int i;
+  int j;
+  int x;
+
+  for (i = 0; i < n; i++) {
+    j = acc >> 16;
+    x = acc & 0xffff;
+
+    if (j + 1 < src_width) {
+      dest[i * 2 + 0] =
+          (src[j * 2 + 0] * (65536 - x) + src[j * 2 + 2] * x) >> 16;
+      dest[i * 2 + 1] =
+          (src[j * 2 + 1] * (65536 - x) + src[j * 2 + 3] * x) >> 16;
+    } else {
+      dest[i * 4 + 0] = src[j * 2 + 0];
+      dest[i * 4 + 1] = src[j * 2 + 1];
+    }
+
+    acc += increment;
+  }
+
+  *accumulator = acc;
+}
+
+void
+vs_scanline_merge_linear_NV12 (uint8_t * dest, uint8_t * src1,
+    uint8_t * src2, int n, int x)
+{
+  uint32_t value = x >> 8;
+
+  if (value == 0) {
+    memcpy (dest, src1, n * 2);
+  } else {
+    orc_merge_linear_u8 (dest, src1, src2, value, n * 2);
+  }
+}
+
+
 /* RGB565 */
 
 /* note that src and dest are uint16_t, and thus endian dependent */
diff --git a/gst/videoscale/vs_scanline.h b/gst/videoscale/vs_scanline.h
index 387fc95..92d8f6f 100644
--- a/gst/videoscale/vs_scanline.h
+++ b/gst/videoscale/vs_scanline.h
@@ -55,6 +55,11 @@ void vs_scanline_resample_nearest_UYVY (uint8_t *dest, uint8_t *src, int src_wid
 void vs_scanline_resample_linear_UYVY (uint8_t *dest, uint8_t *src, int src_width, int n, int *accumulator, int increment);
 void vs_scanline_merge_linear_UYVY (uint8_t *dest, uint8_t *src1, uint8_t *src2, int n, int x);
 
+void vs_scanline_downsample_NV12 (uint8_t *dest, uint8_t *src, int n);
+void vs_scanline_resample_nearest_NV12 (uint8_t *dest, uint8_t *src, int src_width, int n, int *accumulator, int increment);
+void vs_scanline_resample_linear_NV12 (uint8_t *dest, uint8_t *src, int src_width, int n, int *accumulator, int increment);
+void vs_scanline_merge_linear_NV12 (uint8_t *dest, uint8_t *src1, uint8_t *src2, int n, int x);
+
 void vs_scanline_downsample_RGB565 (uint8_t *dest, uint8_t *src, int n);
 void vs_scanline_resample_nearest_RGB565 (uint8_t *dest, uint8_t *src, int src_width, int n, int *accumulator, int increment);
 void vs_scanline_resample_linear_RGB565 (uint8_t *dest, uint8_t *src, int src_width, int n, int *accumulator, int increment);
diff --git a/gst/videotestsrc/Makefile.am b/gst/videotestsrc/Makefile.am
index 91b6f63..de4ce26 100644
--- a/gst/videotestsrc/Makefile.am
+++ b/gst/videotestsrc/Makefile.am
@@ -15,7 +15,7 @@ libgstvideotestsrc_la_LIBTOOLFLAGS = --tag=disable-static
 
 noinst_HEADERS = gstvideotestsrc.h videotestsrc.h
 
-noinst_PROGRAMS = generate_sine_table
+EXTRA_PROGRAMS = generate_sine_table
 
 generate_sine_table_SOURCES = generate_sine_table.c
 generate_sine_table_CFLAGS = $(GST_CFLAGS)
diff --git a/sys/v4l/gstv4lxoverlay.c b/sys/v4l/gstv4lxoverlay.c
index 5867caf..c9a1c93 100644
--- a/sys/v4l/gstv4lxoverlay.c
+++ b/sys/v4l/gstv4lxoverlay.c
@@ -32,6 +32,7 @@
 #include <X11/extensions/Xv.h>
 #include <X11/extensions/Xvlib.h>
 
+#include <gst/glib-compat-private.h>
 #include "gstv4lxoverlay.h"
 #include "gstv4lelement.h"
 #include "v4l_calls.h"
diff --git a/sys/v4l/v4l_calls.c b/sys/v4l/v4l_calls.c
index b2b7573..3f8e16b 100644
--- a/sys/v4l/v4l_calls.c
+++ b/sys/v4l/v4l_calls.c
@@ -36,6 +36,7 @@
 #include <gst/gst.h>
 #include <gst/interfaces/tuner.h>
 #include <gst/interfaces/colorbalance.h>
+#include <gst/glib-compat-private.h>
 
 #include "v4l_calls.h"
 #include "gstv4ltuner.h"
diff --git a/sys/v4l/v4lsrc_calls.c b/sys/v4l/v4lsrc_calls.c
index 31bd6de..5428dea 100644
--- a/sys/v4l/v4lsrc_calls.c
+++ b/sys/v4l/v4lsrc_calls.c
@@ -34,6 +34,7 @@
 #include <errno.h>
 #include "v4lsrc_calls.h"
 #include <sys/time.h>
+#include <gst/glib-compat-private.h>
 
 /* number of buffers to be queued *at least* before syncing */
 #define MIN_BUFFERS_QUEUED 2
diff --git a/sys/ximage/ximagesink.c b/sys/ximage/ximagesink.c
index 2adcc73..7ef200a 100644
--- a/sys/ximage/ximagesink.c
+++ b/sys/ximage/ximagesink.c
@@ -115,6 +115,9 @@
 
 #include "gst/glib-compat-private.h"
 
+/* for XkbKeycodeToKeysym */
+#include <X11/XKBlib.h>
+
 GST_DEBUG_CATEGORY_EXTERN (gst_debug_ximagesink);
 #define GST_CAT_DEFAULT gst_debug_ximagesink
 
@@ -1024,6 +1027,7 @@ gst_ximagesink_handle_xevents (GstXImageSink * ximagesink)
           KeyPressMask | KeyReleaseMask |
           ButtonPressMask | ButtonReleaseMask, &e)) {
     KeySym keysym;
+    const char *key_str = NULL;
 
     /* We lock only for the X function call */
     g_mutex_unlock (ximagesink->x_lock);
@@ -1048,25 +1052,20 @@ gst_ximagesink_handle_xevents (GstXImageSink * ximagesink)
       case KeyRelease:
         /* Key pressed/released over our window. We send upstream
            events for interactivity/navigation */
-        GST_DEBUG ("ximagesink key %d pressed over window at %d,%d",
-            e.xkey.keycode, e.xkey.x, e.xkey.x);
         g_mutex_lock (ximagesink->x_lock);
-        keysym = XKeycodeToKeysym (ximagesink->xcontext->disp,
-            e.xkey.keycode, 0);
-        g_mutex_unlock (ximagesink->x_lock);
+        keysym = XkbKeycodeToKeysym (ximagesink->xcontext->disp,
+            e.xkey.keycode, 0, 0);
         if (keysym != NoSymbol) {
-          char *key_str = NULL;
-
-          g_mutex_lock (ximagesink->x_lock);
           key_str = XKeysymToString (keysym);
-          g_mutex_unlock (ximagesink->x_lock);
-          gst_navigation_send_key_event (GST_NAVIGATION (ximagesink),
-              e.type == KeyPress ? "key-press" : "key-release", key_str);
-
         } else {
-          gst_navigation_send_key_event (GST_NAVIGATION (ximagesink),
-              e.type == KeyPress ? "key-press" : "key-release", "unknown");
+          key_str = "unknown";
         }
+        g_mutex_unlock (ximagesink->x_lock);
+        GST_DEBUG_OBJECT (ximagesink,
+            "key %d pressed over window at %d,%d (%s)",
+            e.xkey.keycode, e.xkey.x, e.xkey.y, key_str);
+        gst_navigation_send_key_event (GST_NAVIGATION (ximagesink),
+            e.type == KeyPress ? "key-press" : "key-release", key_str);
         break;
       default:
         GST_DEBUG_OBJECT (ximagesink, "ximagesink unhandled X event (%d)",
diff --git a/sys/xvimage/xvimagesink.c b/sys/xvimage/xvimagesink.c
index 8a7913b..29fe98c 100644
--- a/sys/xvimage/xvimagesink.c
+++ b/sys/xvimage/xvimagesink.c
@@ -109,6 +109,10 @@
 
 /* for developers: there are two useful tools : xvinfo and xvattr */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -129,6 +133,9 @@
 
 #include "gst/glib-compat-private.h"
 
+/* for XkbKeycodeToKeysym */
+#include <X11/XKBlib.h>
+
 GST_DEBUG_CATEGORY_STATIC (gst_debug_xvimagesink);
 #define GST_CAT_DEFAULT gst_debug_xvimagesink
 GST_DEBUG_CATEGORY_STATIC (GST_CAT_PERFORMANCE);
@@ -244,6 +251,8 @@ gst_xvimage_buffer_destroy (GstXvImageBuffer * xvimage)
       shmdt (xvimage->SHMInfo.shmaddr);
     }
 #endif
+    if (xvimage->xvimage)
+      XFree (xvimage->xvimage);
     goto beach;
   }
 
@@ -1230,6 +1239,7 @@ gst_xvimagesink_handle_xevents (GstXvImageSink * xvimagesink)
           KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask,
           &e)) {
     KeySym keysym;
+    const char *key_str = NULL;
 
     /* We lock only for the X function call */
     g_mutex_unlock (xvimagesink->x_lock);
@@ -1256,24 +1266,20 @@ gst_xvimagesink_handle_xevents (GstXvImageSink * xvimagesink)
       case KeyRelease:
         /* Key pressed/released over our window. We send upstream
            events for interactivity/navigation */
-        GST_DEBUG ("xvimagesink key %d pressed over window at %d,%d",
-            e.xkey.keycode, e.xkey.x, e.xkey.y);
         g_mutex_lock (xvimagesink->x_lock);
-        keysym = XKeycodeToKeysym (xvimagesink->xcontext->disp,
-            e.xkey.keycode, 0);
-        g_mutex_unlock (xvimagesink->x_lock);
+        keysym = XkbKeycodeToKeysym (xvimagesink->xcontext->disp,
+            e.xkey.keycode, 0, 0);
         if (keysym != NoSymbol) {
-          char *key_str = NULL;
-
-          g_mutex_lock (xvimagesink->x_lock);
           key_str = XKeysymToString (keysym);
-          g_mutex_unlock (xvimagesink->x_lock);
-          gst_navigation_send_key_event (GST_NAVIGATION (xvimagesink),
-              e.type == KeyPress ? "key-press" : "key-release", key_str);
         } else {
-          gst_navigation_send_key_event (GST_NAVIGATION (xvimagesink),
-              e.type == KeyPress ? "key-press" : "key-release", "unknown");
+          key_str = "unknown";
         }
+        g_mutex_unlock (xvimagesink->x_lock);
+        GST_DEBUG_OBJECT (xvimagesink,
+            "key %d pressed over window at %d,%d (%s)",
+            e.xkey.keycode, e.xkey.x, e.xkey.y, key_str);
+        gst_navigation_send_key_event (GST_NAVIGATION (xvimagesink),
+            e.type == KeyPress ? "key-press" : "key-release", key_str);
         break;
       default:
         GST_DEBUG ("xvimagesink unhandled X event (%d)", e.type);
@@ -1420,7 +1426,7 @@ gst_xvimagesink_get_xv_support (GstXvImageSink * xvimagesink,
     xcontext->adaptors[i] = g_strdup (adaptors[i].name);
   }
 
-  if (xvimagesink->adaptor_no >= 0 &&
+  if (xvimagesink->adaptor_no != -1 &&
       xvimagesink->adaptor_no < xcontext->nb_adaptors) {
     /* Find xv port from user defined adaptor */
     gst_lookup_xv_port_from_adaptor (xcontext, adaptors,
diff --git a/tests/check/elements/adder.c b/tests/check/elements/adder.c
index a6cba90..fe3432c 100644
--- a/tests/check/elements/adder.c
+++ b/tests/check/elements/adder.c
@@ -101,8 +101,8 @@ GST_START_TEST (test_event)
   GstBus *bus;
   GstEvent *seek_event;
   gboolean res;
-  GstPad *srcpad;
-  GstStreamConsistency *consist;
+  GstPad *srcpad, *sinkpad;
+  GstStreamConsistency *chk_1, *chk_2, *chk_3;
 
   GST_INFO ("preparing test");
 
@@ -130,7 +130,22 @@ GST_START_TEST (test_event)
   fail_unless (res == TRUE, NULL);
 
   srcpad = gst_element_get_static_pad (adder, "src");
-  consist = gst_consistency_checker_new (srcpad);
+  chk_3 = gst_consistency_checker_new (srcpad);
+  gst_object_unref (srcpad);
+
+  /* create consistency checkers for the pads */
+  srcpad = gst_element_get_static_pad (src1, "src");
+  chk_1 = gst_consistency_checker_new (srcpad);
+  sinkpad = gst_pad_get_peer (srcpad);
+  gst_consistency_checker_add_pad (chk_3, sinkpad);
+  gst_object_unref (sinkpad);
+  gst_object_unref (srcpad);
+
+  srcpad = gst_element_get_static_pad (src2, "src");
+  chk_2 = gst_consistency_checker_new (srcpad);
+  sinkpad = gst_pad_get_peer (srcpad);
+  gst_consistency_checker_add_pad (chk_3, sinkpad);
+  gst_object_unref (sinkpad);
   gst_object_unref (srcpad);
 
   seek_event = gst_event_new_seek (1.0, GST_FORMAT_TIME,
@@ -174,7 +189,9 @@ GST_START_TEST (test_event)
 
   /* cleanup */
   g_main_loop_unref (main_loop);
-  gst_consistency_checker_free (consist);
+  gst_consistency_checker_free (chk_1);
+  gst_consistency_checker_free (chk_2);
+  gst_consistency_checker_free (chk_3);
   gst_object_unref (G_OBJECT (bus));
   gst_object_unref (G_OBJECT (bin));
 }
diff --git a/tests/check/elements/alsa.c b/tests/check/elements/alsa.c
index ddd95c7..feae0b5 100644
--- a/tests/check/elements/alsa.c
+++ b/tests/check/elements/alsa.c
@@ -20,6 +20,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <unistd.h>
 
 #include <gst/check/gstcheck.h>
diff --git a/tests/check/elements/playbin.c b/tests/check/elements/playbin.c
index c550571..cc0ecd6 100644
--- a/tests/check/elements/playbin.c
+++ b/tests/check/elements/playbin.c
@@ -18,6 +18,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
diff --git a/tests/check/elements/videoscale.c b/tests/check/elements/videoscale.c
index f297efc..9a39a0e 100644
--- a/tests/check/elements/videoscale.c
+++ b/tests/check/elements/videoscale.c
@@ -30,20 +30,20 @@
 #define LINK_CHECK_FLAGS GST_PAD_LINK_CHECK_NOTHING
 
 static GstCaps **
-videoscale_get_allowed_caps (void)
+videoscale_get_allowed_caps_for_method (int method)
 {
-  GstElement *scale = gst_element_factory_make ("videoscale", "scale");
-  GstPadTemplate *templ;
+  GstElement *scale;
   GstCaps *caps, **ret;
+  GstPad *pad;
   GstStructure *s;
   gint i, n;
 
-  templ =
-      gst_element_class_get_pad_template (GST_ELEMENT_GET_CLASS (scale),
-      "sink");
-  fail_unless (templ != NULL);
-
-  caps = gst_pad_template_get_caps (templ);
+  scale = gst_element_factory_make ("videoscale", "vscale");
+  g_object_set (scale, "method", method, NULL);
+  pad = gst_element_get_static_pad (scale, "sink");
+  caps = gst_pad_get_caps (pad);
+  gst_object_unref (pad);
+  gst_object_unref (scale);
 
   n = gst_caps_get_size (caps);
   ret = g_new0 (GstCaps *, n + 1);
@@ -52,10 +52,10 @@ videoscale_get_allowed_caps (void)
     s = gst_caps_get_structure (caps, i);
     ret[i] = gst_caps_new_empty ();
     gst_caps_append_structure (ret[i], gst_structure_copy (s));
+    GST_LOG ("method %d supports: %" GST_PTR_FORMAT, method, s);
   }
 
-  gst_object_unref (scale);
-
+  gst_caps_unref (caps);
   return ret;
 }
 
@@ -206,52 +206,52 @@ on_src_handoff_passthrough (GstElement * element, GstBuffer * buffer,
   *list = g_list_prepend (*list, gst_buffer_ref (buffer));
 }
 
-GST_START_TEST (test_passthrough)
+static void
+test_passthrough (int method)
 {
   GList *l1, *l2, *src_buffers = NULL, *sink_buffers = NULL;
   GstCaps **allowed_caps = NULL, **p;
-  gint method;
   static const gint src_width = 640, src_height = 480;
   static const gint dest_width = 640, dest_height = 480;
 
-  p = allowed_caps = videoscale_get_allowed_caps ();
+  p = allowed_caps = videoscale_get_allowed_caps_for_method (method);
 
   while (*p) {
     GstCaps *caps = *p;
 
-    for (method = 0; method < 3; method++) {
-      /* skip formats that ffmpegcolorspace can't handle */
-      if (caps_are_64bpp (caps))
-        continue;
-
-      GST_DEBUG ("Running test for caps '%" GST_PTR_FORMAT "'"
-          " from %dx%u to %dx%d with method %d", caps, src_width, src_height,
-          dest_width, dest_height, method);
-      run_test (caps, src_width, src_height,
-          dest_width, dest_height, method,
-          G_CALLBACK (on_src_handoff_passthrough), &src_buffers,
-          G_CALLBACK (on_sink_handoff_passthrough), &sink_buffers);
-
-      fail_unless (src_buffers && sink_buffers);
-      fail_unless_equals_int (g_list_length (src_buffers),
-          g_list_length (sink_buffers));
-
-      for (l1 = src_buffers, l2 = sink_buffers; l1 && l2;
-          l1 = l1->next, l2 = l2->next) {
-        GstBuffer *a = l1->data;
-        GstBuffer *b = l2->data;
-
-        fail_unless_equals_int (GST_BUFFER_SIZE (a), GST_BUFFER_SIZE (b));
-        fail_unless (GST_BUFFER_DATA (a) == GST_BUFFER_DATA (b));
-
-        gst_buffer_unref (a);
-        gst_buffer_unref (b);
-      }
-      g_list_free (src_buffers);
-      src_buffers = NULL;
-      g_list_free (sink_buffers);
-      sink_buffers = NULL;
+    /* skip formats that ffmpegcolorspace can't handle */
+    if (caps_are_64bpp (caps))
+      goto skip;
+
+    GST_DEBUG ("Running test for caps '%" GST_PTR_FORMAT "'"
+        " from %dx%u to %dx%d with method %d", caps, src_width, src_height,
+        dest_width, dest_height, method);
+    run_test (caps, src_width, src_height,
+        dest_width, dest_height, method,
+        G_CALLBACK (on_src_handoff_passthrough), &src_buffers,
+        G_CALLBACK (on_sink_handoff_passthrough), &sink_buffers);
+
+    fail_unless (src_buffers && sink_buffers);
+    fail_unless_equals_int (g_list_length (src_buffers),
+        g_list_length (sink_buffers));
+
+    for (l1 = src_buffers, l2 = sink_buffers; l1 && l2;
+        l1 = l1->next, l2 = l2->next) {
+      GstBuffer *a = l1->data;
+      GstBuffer *b = l2->data;
+
+      fail_unless_equals_int (GST_BUFFER_SIZE (a), GST_BUFFER_SIZE (b));
+      fail_unless (GST_BUFFER_DATA (a) == GST_BUFFER_DATA (b));
+
+      gst_buffer_unref (a);
+      gst_buffer_unref (b);
     }
+    g_list_free (src_buffers);
+    src_buffers = NULL;
+    g_list_free (sink_buffers);
+    sink_buffers = NULL;
+
+  skip:
 
     gst_caps_unref (caps);
     p++;
@@ -259,6 +259,32 @@ GST_START_TEST (test_passthrough)
   g_free (allowed_caps);
 }
 
+GST_START_TEST (test_passthrough_method_0)
+{
+  test_passthrough (0);
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_passthrough_method_1)
+{
+  test_passthrough (1);
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_passthrough_method_2)
+{
+  test_passthrough (2);
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_passthrough_method_3)
+{
+  test_passthrough (3);
+}
+
 GST_END_TEST;
 
 #define CREATE_TEST(name,method,src_width,src_height,dest_width,dest_height) \
@@ -266,7 +292,7 @@ GST_START_TEST (name) \
 { \
   GstCaps **allowed_caps = NULL, **p; \
   \
-  p = allowed_caps = videoscale_get_allowed_caps (); \
+  p = allowed_caps = videoscale_get_allowed_caps_for_method (method); \
   \
   while (*p) { \
     GstCaps *caps = *p; \
@@ -288,39 +314,51 @@ GST_END_TEST;
 CREATE_TEST (test_downscale_640x480_320x240_method_0, 0, 640, 480, 320, 240);
 CREATE_TEST (test_downscale_640x480_320x240_method_1, 1, 640, 480, 320, 240);
 CREATE_TEST (test_downscale_640x480_320x240_method_2, 2, 640, 480, 320, 240);
+CREATE_TEST (test_downscale_640x480_320x240_method_3, 3, 640, 480, 320, 240);
 CREATE_TEST (test_upscale_320x240_640x480_method_0, 0, 320, 240, 640, 480);
 CREATE_TEST (test_upscale_320x240_640x480_method_1, 1, 320, 240, 640, 480);
 CREATE_TEST (test_upscale_320x240_640x480_method_2, 2, 320, 240, 640, 480);
+CREATE_TEST (test_upscale_320x240_640x480_method_3, 3, 320, 240, 640, 480);
 CREATE_TEST (test_downscale_640x480_1x1_method_0, 0, 640, 480, 1, 1);
 CREATE_TEST (test_downscale_640x480_1x1_method_1, 1, 640, 480, 1, 1);
 CREATE_TEST (test_downscale_640x480_1x1_method_2, 2, 640, 480, 1, 1);
+CREATE_TEST (test_downscale_640x480_1x1_method_3, 3, 640, 480, 1, 1);
 CREATE_TEST (test_upscale_1x1_640x480_method_0, 0, 1, 1, 640, 480);
 CREATE_TEST (test_upscale_1x1_640x480_method_1, 1, 1, 1, 640, 480);
 CREATE_TEST (test_upscale_1x1_640x480_method_2, 2, 1, 1, 640, 480);
+CREATE_TEST (test_upscale_1x1_640x480_method_3, 3, 1, 1, 640, 480);
 CREATE_TEST (test_downscale_641x481_111x30_method_0, 0, 641, 481, 111, 30);
 CREATE_TEST (test_downscale_641x481_111x30_method_1, 1, 641, 481, 111, 30);
 CREATE_TEST (test_downscale_641x481_111x30_method_2, 2, 641, 481, 111, 30);
+CREATE_TEST (test_downscale_641x481_111x30_method_3, 3, 641, 481, 111, 30);
 CREATE_TEST (test_upscale_111x30_641x481_method_0, 0, 111, 30, 641, 481);
 CREATE_TEST (test_upscale_111x30_641x481_method_1, 1, 111, 30, 641, 481);
 CREATE_TEST (test_upscale_111x30_641x481_method_2, 2, 111, 30, 641, 481);
+CREATE_TEST (test_upscale_111x30_641x481_method_3, 2, 111, 30, 641, 481);
 CREATE_TEST (test_downscale_641x481_30x111_method_0, 0, 641, 481, 30, 111);
 CREATE_TEST (test_downscale_641x481_30x111_method_1, 1, 641, 481, 30, 111);
 CREATE_TEST (test_downscale_641x481_30x111_method_2, 2, 641, 481, 30, 111);
+CREATE_TEST (test_downscale_641x481_30x111_method_3, 3, 641, 481, 30, 111);
 CREATE_TEST (test_upscale_30x111_641x481_method_0, 0, 30, 111, 641, 481);
 CREATE_TEST (test_upscale_30x111_641x481_method_1, 1, 30, 111, 641, 481);
 CREATE_TEST (test_upscale_30x111_641x481_method_2, 2, 30, 111, 641, 481);
+CREATE_TEST (test_upscale_30x111_641x481_method_3, 3, 30, 111, 641, 481);
 CREATE_TEST (test_downscale_640x480_320x1_method_0, 0, 640, 480, 320, 1);
 CREATE_TEST (test_downscale_640x480_320x1_method_1, 1, 640, 480, 320, 1);
 CREATE_TEST (test_downscale_640x480_320x1_method_2, 2, 640, 480, 320, 1);
+CREATE_TEST (test_downscale_640x480_320x1_method_3, 3, 640, 480, 320, 1);
 CREATE_TEST (test_upscale_320x1_640x480_method_0, 0, 320, 1, 640, 480);
 CREATE_TEST (test_upscale_320x1_640x480_method_1, 1, 320, 1, 640, 480);
 CREATE_TEST (test_upscale_320x1_640x480_method_2, 2, 320, 1, 640, 480);
+CREATE_TEST (test_upscale_320x1_640x480_method_3, 3, 320, 1, 640, 480);
 CREATE_TEST (test_downscale_640x480_1x240_method_0, 0, 640, 480, 1, 240);
 CREATE_TEST (test_downscale_640x480_1x240_method_1, 1, 640, 480, 1, 240);
 CREATE_TEST (test_downscale_640x480_1x240_method_2, 2, 640, 480, 1, 240);
+CREATE_TEST (test_downscale_640x480_1x240_method_3, 3, 640, 480, 1, 240);
 CREATE_TEST (test_upscale_1x240_640x480_method_0, 0, 1, 240, 640, 480);
 CREATE_TEST (test_upscale_1x240_640x480_method_1, 1, 1, 240, 640, 480);
 CREATE_TEST (test_upscale_1x240_640x480_method_2, 2, 1, 240, 640, 480);
+CREATE_TEST (test_upscale_1x240_640x480_method_3, 3, 1, 240, 640, 480);
 
 typedef struct
 {
@@ -642,8 +680,7 @@ gst_test_reverse_negotiation_sink_base_init (gpointer g_class)
       "Test Reverse Negotiation Sink",
       "Sink",
       "Some test sink", "Sebastian Dröge <sebastian.droege@collabora.co.uk>");
-  gst_element_class_add_static_pad_template (gstelement_class,
-      &sinktemplate);
+  gst_element_class_add_static_pad_template (gstelement_class, &sinktemplate);
 }
 
 static void
@@ -810,6 +847,13 @@ GST_START_TEST (test_basetransform_negotiation)
 
 GST_END_TEST;
 
+#ifndef tcase_skip_broken_test
+#define tcase_skip_broken_test(chain,test_func) \
+  if (0) { tcase_add_test(chain,test_func); } else { \
+    GST_ERROR ("FIXME: skipping test %s because it's broken.", G_STRINGIFY (test_func)); \
+  }
+#endif
+
 static Suite *
 videoscale_suite (void)
 {
@@ -818,43 +862,58 @@ videoscale_suite (void)
 
   suite_add_tcase (s, tc_chain);
   tcase_set_timeout (tc_chain, 180);
-  tcase_add_test (tc_chain, test_passthrough);
+  tcase_add_test (tc_chain, test_passthrough_method_0);
+  tcase_add_test (tc_chain, test_passthrough_method_1);
+  tcase_add_test (tc_chain, test_passthrough_method_2);
+  tcase_add_test (tc_chain, test_passthrough_method_3);
   tcase_add_test (tc_chain, test_downscale_640x480_320x240_method_0);
   tcase_add_test (tc_chain, test_downscale_640x480_320x240_method_1);
   tcase_add_test (tc_chain, test_downscale_640x480_320x240_method_2);
+  tcase_add_test (tc_chain, test_downscale_640x480_320x240_method_3);
   tcase_add_test (tc_chain, test_upscale_320x240_640x480_method_0);
   tcase_add_test (tc_chain, test_upscale_320x240_640x480_method_1);
   tcase_add_test (tc_chain, test_upscale_320x240_640x480_method_2);
+  tcase_add_test (tc_chain, test_upscale_320x240_640x480_method_3);
   tcase_add_test (tc_chain, test_downscale_640x480_1x1_method_0);
   tcase_add_test (tc_chain, test_downscale_640x480_1x1_method_1);
   tcase_add_test (tc_chain, test_downscale_640x480_1x1_method_2);
+  tcase_skip_broken_test (tc_chain, test_downscale_640x480_1x1_method_3);
   tcase_add_test (tc_chain, test_upscale_1x1_640x480_method_0);
   tcase_add_test (tc_chain, test_upscale_1x1_640x480_method_1);
   tcase_add_test (tc_chain, test_upscale_1x1_640x480_method_2);
+  tcase_add_test (tc_chain, test_upscale_1x1_640x480_method_3);
   tcase_add_test (tc_chain, test_downscale_641x481_111x30_method_0);
   tcase_add_test (tc_chain, test_downscale_641x481_111x30_method_1);
   tcase_add_test (tc_chain, test_downscale_641x481_111x30_method_2);
+  tcase_add_test (tc_chain, test_downscale_641x481_111x30_method_3);
   tcase_add_test (tc_chain, test_upscale_111x30_641x481_method_0);
   tcase_add_test (tc_chain, test_upscale_111x30_641x481_method_1);
   tcase_add_test (tc_chain, test_upscale_111x30_641x481_method_2);
+  tcase_add_test (tc_chain, test_upscale_111x30_641x481_method_3);
   tcase_add_test (tc_chain, test_downscale_641x481_30x111_method_0);
   tcase_add_test (tc_chain, test_downscale_641x481_30x111_method_1);
   tcase_add_test (tc_chain, test_downscale_641x481_30x111_method_2);
+  tcase_add_test (tc_chain, test_downscale_641x481_30x111_method_3);
   tcase_add_test (tc_chain, test_upscale_30x111_641x481_method_0);
   tcase_add_test (tc_chain, test_upscale_30x111_641x481_method_1);
   tcase_add_test (tc_chain, test_upscale_30x111_641x481_method_2);
+  tcase_add_test (tc_chain, test_upscale_30x111_641x481_method_3);
   tcase_add_test (tc_chain, test_downscale_640x480_320x1_method_0);
   tcase_add_test (tc_chain, test_downscale_640x480_320x1_method_1);
   tcase_add_test (tc_chain, test_downscale_640x480_320x1_method_2);
+  tcase_skip_broken_test (tc_chain, test_downscale_640x480_320x1_method_3);
   tcase_add_test (tc_chain, test_upscale_320x1_640x480_method_0);
   tcase_add_test (tc_chain, test_upscale_320x1_640x480_method_1);
   tcase_add_test (tc_chain, test_upscale_320x1_640x480_method_2);
+  tcase_skip_broken_test (tc_chain, test_upscale_320x1_640x480_method_3);
   tcase_add_test (tc_chain, test_downscale_640x480_1x240_method_0);
   tcase_add_test (tc_chain, test_downscale_640x480_1x240_method_1);
   tcase_add_test (tc_chain, test_downscale_640x480_1x240_method_2);
+  tcase_skip_broken_test (tc_chain, test_downscale_640x480_1x240_method_3);
   tcase_add_test (tc_chain, test_upscale_1x240_640x480_method_0);
   tcase_add_test (tc_chain, test_upscale_1x240_640x480_method_1);
   tcase_add_test (tc_chain, test_upscale_1x240_640x480_method_2);
+  tcase_add_test (tc_chain, test_upscale_1x240_640x480_method_3);
   tcase_add_test (tc_chain, test_negotiation);
   tcase_add_test (tc_chain, test_reverse_negotiation);
   tcase_add_test (tc_chain, test_basetransform_negotiation);
diff --git a/tests/check/libs/discoverer.c b/tests/check/libs/discoverer.c
index 2d20576..f787d29 100644
--- a/tests/check/libs/discoverer.c
+++ b/tests/check/libs/discoverer.c
@@ -52,7 +52,8 @@ GST_START_TEST (test_disco_sync)
   GstDiscovererResult result;
   gchar *uri;
 
-  dc = gst_discoverer_new (GST_SECOND, &err);
+  /* high timeout, in case we're running under valgrind */
+  dc = gst_discoverer_new (5 * GST_SECOND, &err);
   fail_unless (dc != NULL);
   fail_unless (err == NULL);
 
@@ -78,6 +79,108 @@ GST_START_TEST (test_disco_sync)
 
 GST_END_TEST;
 
+static void
+test_disco_sync_reuse (const gchar * test_fn, guint num, GstClockTime timeout)
+{
+  GError *err = NULL;
+  GstDiscoverer *dc;
+  GstDiscovererInfo *info;
+  GstDiscovererResult result;
+  gchar *uri, *path;
+  int i;
+
+  dc = gst_discoverer_new (timeout, &err);
+  fail_unless (dc != NULL);
+  fail_unless (err == NULL);
+
+  /* GST_TEST_FILE comes from makefile CFLAGS */
+  path = g_build_filename (GST_TEST_FILES_PATH, test_fn, NULL);
+  uri = gst_filename_to_uri (path, &err);
+  g_free (path);
+  fail_unless (err == NULL);
+
+  for (i = 0; i < num; ++i) {
+    GST_INFO ("[%02d] discovering uri '%s'", i, uri);
+    info = gst_discoverer_discover_uri (dc, uri, &err);
+    if (info) {
+      result = gst_discoverer_info_get_result (info);
+      GST_INFO ("result: %d", result);
+      gst_discoverer_info_unref (info);
+    }
+    /* in case we don't have some of the elements needed */
+    if (err) {
+      g_error_free (err);
+      err = NULL;
+    }
+  }
+  g_free (uri);
+
+  g_object_unref (dc);
+}
+
+GST_START_TEST (test_disco_sync_reuse_ogg)
+{
+  test_disco_sync_reuse ("theora-vorbis.ogg", 2, 10 * GST_SECOND);
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_disco_sync_reuse_mp3)
+{
+  /* this will cause errors because -base doesn't do mp3 parsing or decoding */
+  test_disco_sync_reuse ("test.mp3", 3, 10 * GST_SECOND);
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_disco_sync_reuse_timeout)
+{
+  /* set minimum timeout to test that, esp. leakage under valgrind */
+  /* FIXME: should really be even shorter */
+  test_disco_sync_reuse ("theora-vorbis.ogg", 2, GST_SECOND);
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_disco_missing_plugins)
+{
+  const gchar *files[] = { "test.mkv", "test.mp3", "partialframe.mjpeg" };
+  GError *err = NULL;
+  GstDiscoverer *dc;
+  GstDiscovererInfo *info;
+  GstDiscovererResult result;
+  gchar *uri, *path;
+  int i;
+
+  for (i = 0; i < G_N_ELEMENTS (files); ++i) {
+    dc = gst_discoverer_new (5 * GST_SECOND, &err);
+    fail_unless (dc != NULL);
+    fail_unless (err == NULL);
+
+    /* GST_TEST_FILE comes from makefile CFLAGS */
+    path = g_build_filename (GST_TEST_FILES_PATH, files[i], NULL);
+    uri = gst_filename_to_uri (path, &err);
+    g_free (path);
+    fail_unless (err == NULL);
+
+    GST_INFO ("discovering uri '%s'", uri);
+    info = gst_discoverer_discover_uri (dc, uri, &err);
+    fail_unless (info != NULL);
+    fail_unless (err != NULL);
+    result = gst_discoverer_info_get_result (info);
+    GST_INFO ("result: %d, error message: %s", result, err->message);
+    fail_unless_equals_int (result, GST_DISCOVERER_MISSING_PLUGINS);
+    GST_INFO ("misc: %" GST_PTR_FORMAT, gst_discoverer_info_get_misc (info));
+
+    gst_discoverer_info_unref (info);
+    g_error_free (err);
+    err = NULL;
+    g_free (uri);
+    g_object_unref (dc);
+  }
+}
+
+GST_END_TEST;
 
 static Suite *
 discoverer_suite (void)
@@ -88,6 +191,10 @@ discoverer_suite (void)
   suite_add_tcase (s, tc_chain);
   tcase_add_test (tc_chain, test_disco_init);
   tcase_add_test (tc_chain, test_disco_sync);
+  tcase_add_test (tc_chain, test_disco_sync_reuse_ogg);
+  tcase_add_test (tc_chain, test_disco_sync_reuse_mp3);
+  tcase_add_test (tc_chain, test_disco_sync_reuse_timeout);
+  tcase_add_test (tc_chain, test_disco_missing_plugins);
   return s;
 }
 
diff --git a/tests/check/libs/tag.c b/tests/check/libs/tag.c
index 634cc3f..58748e0 100644
--- a/tests/check/libs/tag.c
+++ b/tests/check/libs/tag.c
@@ -748,6 +748,16 @@ GST_START_TEST (test_language_utils)
   ASSERT_STRINGS_EQUAL (gst_tag_get_language_code_iso_639_2B ("de"), "ger");
   ASSERT_STRINGS_EQUAL (gst_tag_get_language_code_iso_639_2B ("deu"), "ger");
   ASSERT_STRINGS_EQUAL (gst_tag_get_language_code_iso_639_2B ("ger"), "ger");
+
+  fail_unless (gst_tag_check_language_code ("de"));
+  fail_unless (gst_tag_check_language_code ("deu"));
+  fail_unless (gst_tag_check_language_code ("ger"));
+  fail_if (gst_tag_check_language_code ("xxx"));
+  fail_if (gst_tag_check_language_code ("und"));
+  fail_if (gst_tag_check_language_code ("un"));
+  fail_if (gst_tag_check_language_code (""));
+  fail_if (gst_tag_check_language_code ("\377"));
+  fail_if (gst_tag_check_language_code ("deutsch"));
 }
 
 GST_END_TEST;
diff --git a/tests/check/libs/video.c b/tests/check/libs/video.c
index fd3178d..4abd0b3 100644
--- a/tests/check/libs/video.c
+++ b/tests/check/libs/video.c
@@ -3,6 +3,7 @@
  * Copyright (C) <2003> David A. Schleef <ds@schleef.org>
  * Copyright (C) <2006> Jan Schmidt <thaytan@mad.scientist.com>
  * Copyright (C) <2008,2011> Tim-Philipp Müller <tim centricular net>
+ * Copyright (C) <2012> Collabora Ltd. <tim.muller@collabora.co.uk>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -24,6 +25,10 @@
 #include "config.h"
 #endif
 
+#ifdef HAVE_VALGRIND
+# include <valgrind/valgrind.h>
+#endif
+
 #include <unistd.h>
 
 #include <gst/check/gstcheck.h>
@@ -560,7 +565,13 @@ GST_START_TEST (test_parse_caps_rgb)
     GST_VIDEO_CAPS_RGBA, GST_VIDEO_FORMAT_RGBA}, {
     GST_VIDEO_CAPS_ARGB, GST_VIDEO_FORMAT_ARGB}, {
     GST_VIDEO_CAPS_BGRA, GST_VIDEO_FORMAT_BGRA}, {
-    GST_VIDEO_CAPS_ABGR, GST_VIDEO_FORMAT_ABGR}
+    GST_VIDEO_CAPS_ABGR, GST_VIDEO_FORMAT_ABGR},
+        /* 16 bit */
+    {
+    GST_VIDEO_CAPS_RGB_16, GST_VIDEO_FORMAT_RGB16}, {
+    GST_VIDEO_CAPS_BGR_16, GST_VIDEO_FORMAT_BGR16}, {
+    GST_VIDEO_CAPS_RGB_15, GST_VIDEO_FORMAT_RGB15}, {
+    GST_VIDEO_CAPS_BGR_15, GST_VIDEO_FORMAT_BGR15}
   };
   gint i;
 
@@ -775,9 +786,6 @@ GST_START_TEST (test_video_size_from_caps)
 
 GST_END_TEST;
 
-#undef ASSERT_CRITICAL
-#define ASSERT_CRITICAL(code) while(0){}        /* nothing */
-
 GST_START_TEST (test_overlay_composition)
 {
   GstVideoOverlayComposition *comp1, *comp2;
@@ -901,7 +909,13 @@ GST_START_TEST (test_overlay_composition)
   fail_unless (gst_video_buffer_get_overlay_composition (buf) == NULL);
 
   gst_buffer_ref (buf);
-  ASSERT_CRITICAL (gst_video_buffer_set_overlay_composition (buf, comp1));
+  /* buffer now has refcount of 2, so its metadata is not writable.
+   * only check this if we are not running in valgrind, as it leaks */
+#ifdef HAVE_VALGRIND
+  if (!RUNNING_ON_VALGRIND) {
+    ASSERT_CRITICAL (gst_video_buffer_set_overlay_composition (buf, comp1));
+  }
+#endif
   gst_buffer_unref (buf);
   gst_video_buffer_set_overlay_composition (buf, comp1);
   fail_unless (gst_video_buffer_get_overlay_composition (buf) == comp1);
@@ -920,6 +934,498 @@ GST_START_TEST (test_overlay_composition)
 
 GST_END_TEST;
 
+GST_START_TEST (test_overlay_composition_premultiplied_alpha)
+{
+  GstVideoOverlayRectangle *rect1;
+  GstBuffer *pix1, *pix2, *pix3, *pix4, *pix5;
+  GstBuffer *pix6, *pix7, *pix8, *pix9, *pix10;
+  guint8 *data5, *data7;
+  guint w, h, stride, w2, h2, stride2;
+
+  pix1 = gst_buffer_new_and_alloc (200 * sizeof (guint32) * 50);
+  memset (GST_BUFFER_DATA (pix1), 0x80, GST_BUFFER_SIZE (pix1));
+
+  rect1 = gst_video_overlay_rectangle_new_argb (pix1, 200, 50, 200 * 4,
+      600, 50, 300, 50, GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  gst_buffer_unref (pix1);
+
+  /* same flags, unscaled, should be the same buffer */
+  pix2 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w, &h,
+      &stride, GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  fail_unless (pix1 == pix2);
+
+  /* same flags, but scaled */
+  pix3 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  fail_if (pix3 == pix1 || pix3 == pix2);
+
+  /* same again, should hopefully get the same (cached) buffer as before */
+  pix4 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  fail_unless (pix4 == pix3);
+
+  /* just to update the vars */
+  pix2 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w, &h,
+      &stride, GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+
+  /* now, let's try to get premultiplied alpha from the unpremultiplied input */
+  pix5 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w2, &h2,
+      &stride2, GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+  fail_if (pix5 == pix1 || pix5 == pix2 || pix5 == pix3);
+  fail_unless_equals_int (stride, stride2);
+  fail_unless_equals_int (w, w2);
+  fail_unless_equals_int (h, h2);
+  fail_unless_equals_int (GST_BUFFER_SIZE (pix2), GST_BUFFER_SIZE (pix5));
+  data5 = GST_BUFFER_DATA (pix5);
+  fail_if (memcmp (data5, GST_BUFFER_DATA (pix2), GST_BUFFER_SIZE (pix5)) == 0);
+
+  /* make sure it actually did what we expected it to do (input=0x80808080) */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data5[0], 0x40);
+  fail_unless_equals_int (data5[1], 0x40);
+  fail_unless_equals_int (data5[2], 0x40);
+  fail_unless_equals_int (data5[3], 0x80);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data5[0], 0x40);
+  fail_unless_equals_int (data5[1], 0x40);
+  fail_unless_equals_int (data5[2], 0x40);
+  fail_unless_equals_int (data5[3], 0x80);
+#endif
+
+  /* same again, now we should be getting back the same buffer as before,
+   * as it should have been cached */
+  pix6 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w2, &h2,
+      &stride2, GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+  fail_unless (pix6 == pix5);
+
+  /* just to update the stride var */
+  pix3 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  fail_unless (pix3 == pix4);
+
+  /* now try to get scaled premultiplied alpha from unpremultiplied input */
+  pix7 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride2,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+  fail_if (pix7 == pix1 || pix7 == pix2 || pix7 == pix3 || pix7 == pix5);
+  fail_unless_equals_int (stride, stride2);
+
+  data7 = GST_BUFFER_DATA (pix7);
+  /* make sure it actually did what we expected it to do (input=0x80808080)
+   * hoping that the scaling didn't mess up our values */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data7[0], 0x40);
+  fail_unless_equals_int (data7[1], 0x40);
+  fail_unless_equals_int (data7[2], 0x40);
+  fail_unless_equals_int (data7[3], 0x80);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data7[0], 0x40);
+  fail_unless_equals_int (data7[1], 0x40);
+  fail_unless_equals_int (data7[2], 0x40);
+  fail_unless_equals_int (data7[3], 0x80);
+#endif
+
+  /* and the same again, it should be cached now */
+  pix8 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride2,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+  fail_unless (pix8 == pix7);
+
+  /* make sure other cached stuff is still there */
+  pix9 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  fail_unless (pix9 == pix3);
+  pix10 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w2, &h2,
+      &stride2, GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+  fail_unless (pix10 == pix5);
+
+  gst_video_overlay_rectangle_unref (rect1);
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_overlay_composition_global_alpha)
+{
+  GstVideoOverlayRectangle *rect1;
+  GstBuffer *pix1, *pix2, *pix3, *pix4, *pix5;
+  guint8 *data2, *data4, *data5;
+  guint w, h, stride, stride3, w4, h4, stride4, stride5;
+  guint seq1, seq2;
+  gfloat ga1, ga2;
+  GstVideoOverlayFormatFlags flags1;
+
+  pix1 = gst_buffer_new_and_alloc (200 * sizeof (guint32) * 50);
+  memset (GST_BUFFER_DATA (pix1), 0x80, GST_BUFFER_SIZE (pix1));
+
+  rect1 = gst_video_overlay_rectangle_new_argb (pix1, 200, 50, 200 * 4,
+      600, 50, 300, 50, GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  gst_buffer_unref (pix1);
+
+  /* same flags, unscaled, should be the same buffer */
+  pix2 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w, &h,
+      &stride, GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  fail_unless (pix1 == pix2);
+
+  /* same flags, but scaled */
+  pix3 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride3,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  fail_if (pix3 == pix1 || pix3 == pix2);
+
+  /* get unscaled premultiplied data, new cached rectangle should be created */
+  pix4 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w4, &h4,
+      &stride4, GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+  fail_if (pix4 == pix2 || pix4 == pix3);
+  fail_unless_equals_int (stride, stride4);
+  fail_unless_equals_int (w, w4);
+  fail_unless_equals_int (h, h4);
+  fail_unless_equals_int (GST_BUFFER_SIZE (pix2), GST_BUFFER_SIZE (pix4));
+  data4 = GST_BUFFER_DATA (pix4);
+  fail_if (memcmp (data4, GST_BUFFER_DATA (pix1), GST_BUFFER_SIZE (pix1)) == 0);
+  /* make sure it actually did what we expected it to do (input=0x80808080) */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data4[0], 0x40);
+  fail_unless_equals_int (data4[1], 0x40);
+  fail_unless_equals_int (data4[2], 0x40);
+  fail_unless_equals_int (data4[3], 0x80);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data4[0], 0x80);
+  fail_unless_equals_int (data4[1], 0x40);
+  fail_unless_equals_int (data4[2], 0x40);
+  fail_unless_equals_int (data4[3], 0x40);
+#endif
+
+  /* now premultiplied and scaled, again a new cached rectangle should be cached */
+  pix5 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride5,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+  fail_if (pix5 == pix2 || pix5 == pix3 || pix5 == pix4);
+  /* stride and size should be equal to the first scaled rect */
+  fail_unless_equals_int (stride5, stride3);
+  fail_unless_equals_int (GST_BUFFER_SIZE (pix3), GST_BUFFER_SIZE (pix3));
+  data5 = GST_BUFFER_DATA (pix5);
+  /* data should be different (premutliplied) though */
+  fail_if (memcmp (data5, GST_BUFFER_DATA (pix3), GST_BUFFER_SIZE (pix3)) == 0);
+  /* make sure it actually did what we expected it to do (input=0x80808080) */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data5[0], 0x40);
+  fail_unless_equals_int (data5[1], 0x40);
+  fail_unless_equals_int (data5[2], 0x40);
+  fail_unless_equals_int (data5[3], 0x80);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data5[0], 0x80);
+  fail_unless_equals_int (data5[1], 0x40);
+  fail_unless_equals_int (data5[2], 0x40);
+  fail_unless_equals_int (data5[3], 0x40);
+#endif
+
+  /* global_alpha should initially be 1.0 */
+  ga1 = gst_video_overlay_rectangle_get_global_alpha (rect1);
+  fail_unless_equals_float (ga1, 1.0);
+
+  /* now set global_alpha */
+  seq1 = gst_video_overlay_rectangle_get_seqnum (rect1);
+  gst_video_overlay_rectangle_set_global_alpha (rect1, 0.5);
+  ga2 = gst_video_overlay_rectangle_get_global_alpha (rect1);
+  fail_unless_equals_float (ga2, 0.5);
+
+  /* seqnum should have changed */
+  seq2 = gst_video_overlay_rectangle_get_seqnum (rect1);
+  fail_unless (seq1 < seq2);
+
+  /* internal flags should have been set */
+  flags1 = gst_video_overlay_rectangle_get_flags (rect1);
+  fail_unless_equals_int (flags1, GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA);
+
+  /* request unscaled pixel-data, global-alpha not applied */
+  pix2 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w, &h,
+      &stride, GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA);
+  /* this should just return the same buffer */
+  fail_unless (pix2 == pix1);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix1),
+          GST_BUFFER_SIZE (pix1)) == 0);
+  /* make sure we got the initial data (input=0x80808080) */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x80);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x80);
+#endif
+
+  /* unscaled pixel-data, global-alpha applied */
+  pix2 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w, &h,
+      &stride, GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  /* this should be the same buffer with on-the-fly modified alpha-channel */
+  fail_unless (pix2 == pix1);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix1),
+          GST_BUFFER_SIZE (pix1)) == 0);
+  /* make sure we got the initial data with adjusted alpha-channel */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x40);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x40);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x80);
+#endif
+
+  /* adjust global_alpha once more */
+  gst_video_overlay_rectangle_set_global_alpha (rect1, 0.25);
+  ga2 = gst_video_overlay_rectangle_get_global_alpha (rect1);
+  fail_unless_equals_float (ga2, 0.25);
+  /* and again request unscaled pixel-data, global-alpha applied */
+  pix2 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w, &h,
+      &stride, GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  fail_unless (pix2 == pix1);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix1),
+          GST_BUFFER_SIZE (pix1)) == 0);
+  /* make sure we got the initial data with adjusted alpha-channel */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x20);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x20);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x80);
+#endif
+
+  /* again: unscaled pixel-data, global-alpha not applied,
+   * this should revert alpha-channel to initial values */
+  pix2 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w, &h,
+      &stride, GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA);
+  fail_unless (pix2 == pix1);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix1),
+          GST_BUFFER_SIZE (pix1)) == 0);
+  /* make sure we got the initial data (input=0x80808080) */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x80);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x80);
+#endif
+
+  /* now scaled, global-alpha not applied */
+  pix2 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA);
+  /* this should just return the rect/buffer, that was cached for these
+   * scaling dimensions */
+  fail_unless (pix2 == pix3);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix3),
+          GST_BUFFER_SIZE (pix3)) == 0);
+  /* make sure we got the initial data (input=0x80808080) */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x80);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x80);
+#endif
+
+  /* scaled, global-alpha (0.25) applied */
+  pix2 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+  /* this should just return the rect/buffer, that was cached for these
+   * scaling dimensions with modified alpha channel */
+  fail_unless (pix2 == pix3);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix3),
+          GST_BUFFER_SIZE (pix3)) == 0);
+  /* make sure we got the data we expect for global-alpha=0.25 */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x20);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x20);
+  fail_unless_equals_int (data2[1], 0x80);
+  fail_unless_equals_int (data2[2], 0x80);
+  fail_unless_equals_int (data2[3], 0x80);
+#endif
+
+  /* now unscaled premultiplied data, global-alpha not applied,
+   * is this really a valid use case?*/
+  pix2 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w, &h,
+      &stride, GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA |
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA);
+  /* this should just return the rect/buffer, that was cached for the
+   * premultiplied data */
+  fail_unless (pix2 == pix4);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix4),
+          GST_BUFFER_SIZE (pix4)) == 0);
+  /* make sure we got what we expected */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x40);
+  fail_unless_equals_int (data2[1], 0x40);
+  fail_unless_equals_int (data2[2], 0x40);
+  fail_unless_equals_int (data2[3], 0x80);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x40);
+  fail_unless_equals_int (data2[2], 0x40);
+  fail_unless_equals_int (data2[3], 0x40);
+#endif
+
+  /* unscaled premultiplied data, global-alpha (0.25) applied */
+  pix2 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w, &h,
+      &stride, GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+  /* this should just return the rect/buffer, that was cached for the
+   * premultiplied data */
+  fail_unless (pix2 == pix4);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix4),
+          GST_BUFFER_SIZE (pix4)) == 0);
+  /* make sure we got what we expected:
+   * (0x40 / (0x80/0xFF) * (0x20/0xFF) = 0x10
+   * NOTE: unless we are using round() for the premultiplied case
+   * in gst_video_overlay_rectangle_apply_global_alpha() we get rounding
+   * error, i.e. 0x0F here */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x0F);
+  fail_unless_equals_int (data2[1], 0x0F);
+  fail_unless_equals_int (data2[2], 0x0F);
+  fail_unless_equals_int (data2[3], 0x20);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x20);
+  fail_unless_equals_int (data2[1], 0x0F);
+  fail_unless_equals_int (data2[2], 0x0F);
+  fail_unless_equals_int (data2[3], 0x0F);
+#endif
+
+  /* set global_alpha once more */
+  gst_video_overlay_rectangle_set_global_alpha (rect1, 0.75);
+  /* and verify that also premultiplied data is adjusted
+   * correspondingly (though with increasing rounding errors) */
+  pix2 = gst_video_overlay_rectangle_get_pixels_unscaled_argb (rect1, &w, &h,
+      &stride, GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+  /* this should just return the rect/buffer, that was cached for the
+   * premultiplied data */
+  fail_unless (pix2 == pix4);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix4),
+          GST_BUFFER_SIZE (pix4)) == 0);
+  /* make sure we got what we expected:
+   * (0x0F / (0x20/0xFF) * (0x60/0xFF) = 0x2D
+   * NOTE: using floats everywhere we would get 0x30
+   * here we will actually end up with 0x2C */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x2C);
+  fail_unless_equals_int (data2[1], 0x2C);
+  fail_unless_equals_int (data2[2], 0x2C);
+  fail_unless_equals_int (data2[3], 0x60);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x60);
+  fail_unless_equals_int (data2[1], 0x2C);
+  fail_unless_equals_int (data2[2], 0x2C);
+  fail_unless_equals_int (data2[3], 0x2C);
+#endif
+
+  /* now scaled and premultiplied data, global-alpha not applied,
+   * is this really a valid use case?*/
+  pix2 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA |
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA);
+  /* this should just return the rect/buffer, that was cached for the
+   * first premultiplied+scaled rect*/
+  fail_unless (pix2 == pix5);
+  fail_unless (stride == stride5);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix5),
+          GST_BUFFER_SIZE (pix5)) == 0);
+  /* make sure we got what we expected */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x40);
+  fail_unless_equals_int (data2[1], 0x40);
+  fail_unless_equals_int (data2[2], 0x40);
+  fail_unless_equals_int (data2[3], 0x80);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x80);
+  fail_unless_equals_int (data2[1], 0x40);
+  fail_unless_equals_int (data2[2], 0x40);
+  fail_unless_equals_int (data2[3], 0x40);
+#endif
+
+  /* scaled and premultiplied data, global-alpha applied */
+  pix2 = gst_video_overlay_rectangle_get_pixels_argb (rect1, &stride,
+      GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+  /* this should just return the rect/buffer, that was cached for the
+   * first premultiplied+scaled rect*/
+  fail_unless (pix2 == pix5);
+  fail_unless (stride == stride5);
+  data2 = GST_BUFFER_DATA (pix2);
+  fail_unless (memcmp (data2, GST_BUFFER_DATA (pix5),
+          GST_BUFFER_SIZE (pix5)) == 0);
+  /* make sure we got what we expected; see above note about rounding errors! */
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+  /* B - G - R - A */
+  fail_unless_equals_int (data2[0], 0x2F);
+  fail_unless_equals_int (data2[1], 0x2F);
+  fail_unless_equals_int (data2[2], 0x2F);
+  fail_unless_equals_int (data2[3], 0x60);
+#else
+  /* A - R - G - B */
+  fail_unless_equals_int (data2[0], 0x60);
+  fail_unless_equals_int (data2[1], 0x2F);
+  fail_unless_equals_int (data2[2], 0x2F);
+  fail_unless_equals_int (data2[3], 0x2F);
+#endif
+
+  gst_video_overlay_rectangle_unref (rect1);
+}
+
+GST_END_TEST;
+
 static Suite *
 video_suite (void)
 {
@@ -937,6 +1443,8 @@ video_suite (void)
   tcase_add_test (tc_chain, test_convert_frame_async);
   tcase_add_test (tc_chain, test_video_size_from_caps);
   tcase_add_test (tc_chain, test_overlay_composition);
+  tcase_add_test (tc_chain, test_overlay_composition_premultiplied_alpha);
+  tcase_add_test (tc_chain, test_overlay_composition_global_alpha);
 
   return s;
 }
diff --git a/tests/examples/Makefile.am b/tests/examples/Makefile.am
index d765419..f2ac27f 100644
--- a/tests/examples/Makefile.am
+++ b/tests/examples/Makefile.am
@@ -8,9 +8,13 @@ if USE_GIO
 GIO_SUBDIRS = gio
 endif
 
-SUBDIRS = app audio dynamic fft $(FT2_SUBDIRS) $(GIO_SUBDIRS) overlay playrec v4l encoding
+if HAVE_GTK
+GTK_SUBDIRS = playback
+endif
+
+SUBDIRS = app audio dynamic fft $(FT2_SUBDIRS) $(GIO_SUBDIRS) overlay $(GTK_SUBDIRS) playrec v4l encoding
 
-DIST_SUBDIRS = app audio dynamic fft gio overlay seek snapshot playrec v4l encoding
+DIST_SUBDIRS = app audio dynamic fft gio overlay seek snapshot playback playrec v4l encoding
 
 include $(top_srcdir)/common/parallel-subdirs.mak
 
diff --git a/tests/examples/audio/audiomix.c b/tests/examples/audio/audiomix.c
index 937f4db..4ad1894 100644
--- a/tests/examples/audio/audiomix.c
+++ b/tests/examples/audio/audiomix.c
@@ -23,6 +23,9 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GTK versions (>= 3.3.0) */
+#define GDK_DISABLE_DEPRECATION_WARNINGS
 
 #include <string.h>
 #include <gst/gst.h>
diff --git a/tests/examples/audio/volume.c b/tests/examples/audio/volume.c
index d5bf9ed..a5e13c4 100644
--- a/tests/examples/audio/volume.c
+++ b/tests/examples/audio/volume.c
@@ -23,6 +23,9 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GTK versions (>= 3.3.0) */
+#define GDK_DISABLE_DEPRECATION_WARNINGS
 
 #include <math.h>
 
diff --git a/tests/examples/playback/Makefile.am b/tests/examples/playback/Makefile.am
new file mode 100644
index 0000000..e28c512
--- /dev/null
+++ b/tests/examples/playback/Makefile.am
@@ -0,0 +1,7 @@
+noinst_PROGRAMS = playback-test
+
+LDADD = \
+	$(top_builddir)/gst-libs/gst/interfaces/libgstinterfaces-@GST_MAJORMINOR@.la \
+	$(GST_LIBS) $(GTK_LIBS) $(LIBM)
+
+AM_CFLAGS = -I$(top_builddir)/gst-libs $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(GST_CFLAGS) $(GTK_CFLAGS)
diff --git a/tests/examples/playback/playback-test.c b/tests/examples/playback/playback-test.c
new file mode 100644
index 0000000..720e54e
--- /dev/null
+++ b/tests/examples/playback/playback-test.c
@@ -0,0 +1,3351 @@
+/* GStreamer
+ *
+ * playback-test.c: playback sample application
+ *
+ * Copyright (C) 2005 Wim Taymans <wim@fluendo.com>
+ *               2006 Stefan Kost <ensonic@users.sf.net>
+ *               2012 Collabora Ltd.
+ *                 Author: Sebastian Dröge <sebastian.droege@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GTK versions (>= 3.3.0) */
+#define GDK_DISABLE_DEPRECATION_WARNINGS
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
+#include <stdlib.h>
+#include <math.h>
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <gst/gst.h>
+#include <string.h>
+
+#include <gdk/gdk.h>
+#if defined (GDK_WINDOWING_X11)
+#include <gdk/gdkx.h>
+#elif defined (GDK_WINDOWING_WIN32)
+#include <gdk/gdkwin32.h>
+#elif defined (GDK_WINDOWING_QUARTZ)
+#include <gdk/gdkquartzwindow.h>
+#endif
+
+#include <gst/interfaces/xoverlay.h>
+#include <gst/interfaces/navigation.h>
+#include <gst/interfaces/colorbalance.h>
+
+GST_DEBUG_CATEGORY_STATIC (playback_debug);
+#define GST_CAT_DEFAULT (playback_debug)
+
+/* Copied from gst-plugins-base/gst/playback/gstplay-enum.h */
+typedef enum
+{
+  GST_PLAY_FLAG_VIDEO = (1 << 0),
+  GST_PLAY_FLAG_AUDIO = (1 << 1),
+  GST_PLAY_FLAG_TEXT = (1 << 2),
+  GST_PLAY_FLAG_VIS = (1 << 3),
+  GST_PLAY_FLAG_SOFT_VOLUME = (1 << 4),
+  GST_PLAY_FLAG_NATIVE_AUDIO = (1 << 5),
+  GST_PLAY_FLAG_NATIVE_VIDEO = (1 << 6),
+  GST_PLAY_FLAG_DOWNLOAD = (1 << 7),
+  GST_PLAY_FLAG_BUFFERING = (1 << 8),
+  GST_PLAY_FLAG_DEINTERLACE = (1 << 9),
+  GST_PLAY_FLAG_SOFT_COLORBALANCE = (1 << 10)
+} GstPlayFlags;
+
+/* configuration */
+
+#define FILL_INTERVAL 100
+//#define UPDATE_INTERVAL 500
+//#define UPDATE_INTERVAL 100
+#define UPDATE_INTERVAL 40
+
+/* number of milliseconds to play for after a seek */
+#define SCRUB_TIME 100
+
+/* timeout for gst_element_get_state() after a seek */
+#define SEEK_TIMEOUT 40 * GST_MSECOND
+
+#define DEFAULT_VIDEO_HEIGHT 300
+
+/* the state to go to when stop is pressed */
+#define STOP_STATE      GST_STATE_READY
+
+#define N_GRAD 1000.0
+
+/* we keep an array of the visualisation entries so that we can easily switch
+ * with the combo box index. */
+typedef struct
+{
+  GstElementFactory *factory;
+} VisEntry;
+
+typedef struct
+{
+  /* GTK widgets */
+  GtkWidget *window;
+  GtkWidget *video_combo, *audio_combo, *text_combo, *vis_combo;
+  GtkWidget *video_window;
+
+  GtkWidget *vis_checkbox, *video_checkbox, *audio_checkbox;
+  GtkWidget *text_checkbox, *mute_checkbox, *volume_spinbutton;
+  GtkWidget *soft_volume_checkbox, *native_audio_checkbox,
+      *native_video_checkbox;
+  GtkWidget *download_checkbox, *buffering_checkbox, *deinterlace_checkbox;
+  GtkWidget *soft_colorbalance_checkbox;
+  GtkWidget *video_sink_entry, *audio_sink_entry, *text_sink_entry;
+  GtkWidget *buffer_size_entry, *buffer_duration_entry;
+  GtkWidget *ringbuffer_maxsize_entry, *connection_speed_entry;
+  GtkWidget *av_offset_entry, *subtitle_encoding_entry;
+  GtkWidget *subtitle_fontdesc_button;
+
+  GtkWidget *seek_format_combo, *seek_position_label, *seek_duration_label;
+  GtkWidget *seek_entry;
+
+  GtkWidget *seek_scale, *statusbar;
+  guint status_id;
+
+  GtkWidget *step_format_combo, *step_amount_spinbutton, *step_rate_spinbutton;
+  GtkWidget *shuttle_scale;
+
+  GtkWidget *contrast_scale, *brightness_scale, *hue_scale, *saturation_scale;
+
+  struct
+  {
+    GstNavigationCommand cmd;
+    GtkWidget *button;
+  } navigation_buttons[14];
+
+  guintptr embed_xid;
+
+  /* GStreamer pipeline */
+  GstElement *pipeline;
+
+  GstElement *navigation_element;
+  GstElement *colorbalance_element;
+  GstElement *xoverlay_element;
+
+  /* Settings */
+  gboolean accurate_seek;
+  gboolean keyframe_seek;
+  gboolean loop_seek;
+  gboolean flush_seek;
+  gboolean scrub;
+  gboolean play_scrub;
+  gboolean skip_seek;
+  gdouble rate;
+
+  /* From commandline parameters */
+  gboolean stats;
+  gboolean verbose;
+  const gchar *pipeline_spec;
+  gint pipeline_type;
+  GList *paths, *current_path;
+  GList *sub_paths, *current_sub_path;
+
+  gchar *audiosink_str, *videosink_str;
+
+  /* Internal state */
+  gint64 position, duration;
+
+  gboolean is_live;
+  gboolean buffering;
+  GstBufferingMode mode;
+  gint64 buffering_left;
+  GstState state;
+  guint update_id;
+  guint seek_timeout_id;
+  gulong changed_id;
+  guint fill_id;
+
+  gboolean need_streams;
+  gint n_video, n_audio, n_text;
+
+  GStaticMutex state_mutex;
+
+  GArray *vis_entries;          /* Array of VisEntry structs */
+
+  gboolean shuttling;
+  gdouble shuttle_rate;
+  gdouble play_rate;
+
+  const GstFormatDefinition *seek_format;
+  GList *formats;
+} PlaybackApp;
+
+static void clear_streams (PlaybackApp * app);
+static void find_interface_elements (PlaybackApp * app);
+static void volume_notify_cb (GstElement * pipeline, GParamSpec * arg,
+    PlaybackApp * app);
+static void mute_notify_cb (GstElement * pipeline, GParamSpec * arg,
+    PlaybackApp * app);
+
+static void video_sink_activate_cb (GtkEntry * entry, PlaybackApp * app);
+static void text_sink_activate_cb (GtkEntry * entry, PlaybackApp * app);
+static void audio_sink_activate_cb (GtkEntry * entry, PlaybackApp * app);
+static void buffer_size_activate_cb (GtkEntry * entry, PlaybackApp * app);
+static void buffer_duration_activate_cb (GtkEntry * entry, PlaybackApp * app);
+static void ringbuffer_maxsize_activate_cb (GtkEntry * entry,
+    PlaybackApp * app);
+static void connection_speed_activate_cb (GtkEntry * entry, PlaybackApp * app);
+static void av_offset_activate_cb (GtkEntry * entry, PlaybackApp * app);
+static void subtitle_encoding_activate_cb (GtkEntry * entry, PlaybackApp * app);
+
+/* pipeline construction */
+
+static GstElement *
+gst_element_factory_make_or_warn (const gchar * type, const gchar * name)
+{
+  GstElement *element = gst_element_factory_make (type, name);
+
+#ifndef GST_DISABLE_PARSE
+  if (!element) {
+    /* Try parsing it as a pipeline description */
+    element = gst_parse_bin_from_description (type, TRUE, NULL);
+    if (element) {
+      gst_element_set_name (element, name);
+    }
+  }
+#endif
+
+  if (!element) {
+    g_warning ("Failed to create element %s of type %s", name, type);
+  }
+
+  return element;
+}
+
+static void
+set_uri_property (GObject * object, const gchar * property,
+    const gchar * location)
+{
+  gchar *uri;
+
+  /* Add "file://" prefix for convenience */
+  if (location && (g_str_has_prefix (location, "/")
+          || !gst_uri_is_valid (location))) {
+    uri = gst_filename_to_uri (location, NULL);
+    g_print ("Setting URI: %s\n", uri);
+    g_object_set (object, property, uri, NULL);
+    g_free (uri);
+  } else {
+    g_print ("Setting URI: %s\n", location);
+    g_object_set (object, property, location, NULL);
+  }
+}
+
+static void
+playbin_set_uri (GstElement * playbin, const gchar * location,
+    const gchar * sub_location)
+{
+  set_uri_property (G_OBJECT (playbin), "uri", location);
+  set_uri_property (G_OBJECT (playbin), "suburi", sub_location);
+}
+
+static void
+make_playbin2_pipeline (PlaybackApp * app, const gchar * location)
+{
+  GstElement *pipeline;
+
+  app->pipeline = pipeline = gst_element_factory_make ("playbin2", "playbin2");
+  g_assert (pipeline);
+
+  playbin_set_uri (pipeline, location,
+      app->current_sub_path ? app->current_sub_path->data : NULL);
+
+  g_signal_connect (pipeline, "notify::volume", G_CALLBACK (volume_notify_cb),
+      app);
+  g_signal_connect (pipeline, "notify::mute", G_CALLBACK (mute_notify_cb), app);
+
+  app->navigation_element = GST_ELEMENT (gst_object_ref (pipeline));
+  app->colorbalance_element = GST_ELEMENT (gst_object_ref (pipeline));
+}
+
+#ifndef GST_DISABLE_PARSE
+static void
+make_parselaunch_pipeline (PlaybackApp * app, const gchar * description)
+{
+  app->pipeline = gst_parse_launch (description, NULL);
+}
+#endif
+
+typedef struct
+{
+  const gchar *name;
+  void (*func) (PlaybackApp * app, const gchar * location);
+}
+Pipeline;
+
+static const Pipeline pipelines[] = {
+  {"playbin2", make_playbin2_pipeline},
+#ifndef GST_DISABLE_PARSE
+  {"parse-launch", make_parselaunch_pipeline},
+#endif
+};
+
+/* ui callbacks and helpers */
+
+static gchar *
+format_value (GtkScale * scale, gdouble value, PlaybackApp * app)
+{
+  gint64 real;
+  gint64 seconds;
+  gint64 subseconds;
+
+  real = value * app->duration / N_GRAD;
+  seconds = (gint64) real / GST_SECOND;
+  subseconds = (gint64) real / (GST_SECOND / N_GRAD);
+
+  return g_strdup_printf ("%02" G_GINT64_FORMAT ":%02" G_GINT64_FORMAT ":%02"
+      G_GINT64_FORMAT, seconds / 60, seconds % 60, subseconds % 100);
+}
+
+static gchar *
+shuttle_format_value (GtkScale * scale, gdouble value)
+{
+  return g_strdup_printf ("%0.*g", gtk_scale_get_digits (scale), value);
+}
+
+typedef struct
+{
+  const gchar *name;
+  const GstFormat format;
+}
+seek_format;
+
+static seek_format seek_formats[] = {
+  {"tim", GST_FORMAT_TIME},
+  {"byt", GST_FORMAT_BYTES},
+  {"buf", GST_FORMAT_BUFFERS},
+  {"def", GST_FORMAT_DEFAULT},
+  {NULL, 0},
+};
+
+static void
+query_positions (PlaybackApp * app)
+{
+  gint i = 0;
+
+  g_print ("positions %8.8s: ", GST_ELEMENT_NAME (app->pipeline));
+  while (seek_formats[i].name) {
+    gint64 position, total;
+    GstFormat format;
+
+    format = seek_formats[i].format;
+
+    if (gst_element_query_position (app->pipeline, &format, &position) &&
+        gst_element_query_duration (app->pipeline, &format, &total)) {
+      g_print ("%s %13" G_GINT64_FORMAT " / %13" G_GINT64_FORMAT " | ",
+          seek_formats[i].name, position, total);
+    } else {
+      g_print ("%s %13.13s / %13.13s | ", seek_formats[i].name, "*NA*", "*NA*");
+    }
+    i++;
+  }
+  g_print (" %s\n", GST_ELEMENT_NAME (app->pipeline));
+}
+
+static gboolean start_seek (GtkRange * range, GdkEventButton * event,
+    PlaybackApp * app);
+static gboolean stop_seek (GtkRange * range, GdkEventButton * event,
+    PlaybackApp * app);
+static void seek_cb (GtkRange * range, PlaybackApp * app);
+
+static void
+set_scale (PlaybackApp * app, gdouble value)
+{
+  g_signal_handlers_block_by_func (app->seek_scale, start_seek, app);
+  g_signal_handlers_block_by_func (app->seek_scale, stop_seek, app);
+  g_signal_handlers_block_by_func (app->seek_scale, seek_cb, app);
+  gtk_range_set_value (GTK_RANGE (app->seek_scale), value);
+  g_signal_handlers_unblock_by_func (app->seek_scale, start_seek, app);
+  g_signal_handlers_unblock_by_func (app->seek_scale, stop_seek, app);
+  g_signal_handlers_unblock_by_func (app->seek_scale, seek_cb, app);
+  gtk_widget_queue_draw (app->seek_scale);
+}
+
+static gboolean
+update_fill (PlaybackApp * app)
+{
+  GstQuery *query;
+
+  query = gst_query_new_buffering (GST_FORMAT_PERCENT);
+  if (gst_element_query (app->pipeline, query)) {
+    gint64 start, stop, buffering_total;
+    GstFormat format;
+    gdouble fill;
+    gboolean busy;
+    gint percent;
+    GstBufferingMode mode;
+    gint avg_in, avg_out;
+    gint64 buffering_left;
+
+    gst_query_parse_buffering_percent (query, &busy, &percent);
+    gst_query_parse_buffering_range (query, &format, &start, &stop,
+        &buffering_total);
+    gst_query_parse_buffering_stats (query, &mode, &avg_in, &avg_out,
+        &buffering_left);
+
+    /* note that we could start the playback when buffering_left < remaining
+     * playback time */
+    GST_DEBUG ("buffering total %" G_GINT64_FORMAT " ms, left %"
+        G_GINT64_FORMAT " ms", buffering_total, buffering_left);
+    GST_DEBUG ("start %" G_GINT64_FORMAT ", stop %" G_GINT64_FORMAT,
+        start, stop);
+
+    if (stop != -1)
+      fill = N_GRAD * stop / GST_FORMAT_PERCENT_MAX;
+    else
+      fill = N_GRAD;
+
+    gtk_range_set_fill_level (GTK_RANGE (app->seek_scale), fill);
+  }
+  gst_query_unref (query);
+
+  return TRUE;
+}
+
+static gboolean
+update_scale (PlaybackApp * app)
+{
+  GstFormat format = GST_FORMAT_TIME;
+  gint64 seek_pos, seek_dur;
+  gchar *str;
+
+  //position = 0;
+  //duration = 0;
+
+  gst_element_query_position (app->pipeline, &format, &app->position);
+  gst_element_query_duration (app->pipeline, &format, &app->duration);
+
+  if (app->stats)
+    query_positions (app);
+
+  if (app->position >= app->duration)
+    app->duration = app->position;
+
+  if (app->duration > 0) {
+    set_scale (app, app->position * N_GRAD / app->duration);
+  }
+
+  if (app->seek_format) {
+    format = app->seek_format->value;
+    seek_pos = seek_dur = -1;
+    gst_element_query_position (app->pipeline, &format, &seek_pos);
+    gst_element_query_duration (app->pipeline, &format, &seek_dur);
+
+    str = g_strdup_printf ("%" G_GINT64_FORMAT, seek_pos);
+    gtk_label_set_text (GTK_LABEL (app->seek_position_label), str);
+    g_free (str);
+
+    str = g_strdup_printf ("%" G_GINT64_FORMAT, seek_dur);
+    gtk_label_set_text (GTK_LABEL (app->seek_duration_label), str);
+    g_free (str);
+  }
+
+  return TRUE;
+}
+
+static void set_update_scale (PlaybackApp * app, gboolean active);
+static void set_update_fill (PlaybackApp * app, gboolean active);
+
+static gboolean
+end_scrub (PlaybackApp * app)
+{
+  GST_DEBUG ("end scrub, PAUSE");
+  gst_element_set_state (app->pipeline, GST_STATE_PAUSED);
+  app->seek_timeout_id = 0;
+
+  return FALSE;
+}
+
+static gboolean
+send_event (PlaybackApp * app, GstEvent * event)
+{
+  gboolean res = FALSE;
+
+  GST_DEBUG ("send event on element %s", GST_ELEMENT_NAME (app->pipeline));
+  res = gst_element_send_event (app->pipeline, event);
+
+  return res;
+}
+
+static void
+do_seek (PlaybackApp * app, GstFormat format, gint64 position)
+{
+  gboolean res = FALSE;
+  GstEvent *s_event;
+  GstSeekFlags flags;
+
+  flags = 0;
+  if (app->flush_seek)
+    flags |= GST_SEEK_FLAG_FLUSH;
+  if (app->accurate_seek)
+    flags |= GST_SEEK_FLAG_ACCURATE;
+  if (app->keyframe_seek)
+    flags |= GST_SEEK_FLAG_KEY_UNIT;
+  if (app->loop_seek)
+    flags |= GST_SEEK_FLAG_SEGMENT;
+  if (app->skip_seek)
+    flags |= GST_SEEK_FLAG_SKIP;
+
+  if (app->rate >= 0) {
+    s_event = gst_event_new_seek (app->rate,
+        format, flags, GST_SEEK_TYPE_SET, position, GST_SEEK_TYPE_SET,
+        GST_CLOCK_TIME_NONE);
+    GST_DEBUG ("seek with rate %lf to %" GST_TIME_FORMAT " / %" GST_TIME_FORMAT,
+        app->rate, GST_TIME_ARGS (position), GST_TIME_ARGS (app->duration));
+  } else {
+    s_event = gst_event_new_seek (app->rate,
+        format, flags, GST_SEEK_TYPE_SET, G_GINT64_CONSTANT (0),
+        GST_SEEK_TYPE_SET, position);
+    GST_DEBUG ("seek with rate %lf to %" GST_TIME_FORMAT " / %" GST_TIME_FORMAT,
+        app->rate, GST_TIME_ARGS (0), GST_TIME_ARGS (position));
+  }
+
+  res = send_event (app, s_event);
+
+  if (res) {
+    if (app->flush_seek) {
+      gst_element_get_state (GST_ELEMENT (app->pipeline), NULL, NULL,
+          SEEK_TIMEOUT);
+    } else {
+      set_update_scale (app, TRUE);
+    }
+  } else {
+    g_print ("seek failed\n");
+    set_update_scale (app, TRUE);
+  }
+}
+
+static void
+seek_cb (GtkRange * range, PlaybackApp * app)
+{
+  gint64 real;
+  /* If the timer hasn't expired yet, then the pipeline is running */
+  if (app->play_scrub && app->seek_timeout_id != 0) {
+    GST_DEBUG ("do scrub seek, PAUSED");
+    gst_element_set_state (app->pipeline, GST_STATE_PAUSED);
+  }
+
+  real =
+      gtk_range_get_value (GTK_RANGE (app->seek_scale)) * app->duration /
+      N_GRAD;
+
+  GST_DEBUG ("value=%f, real=%" G_GINT64_FORMAT,
+      gtk_range_get_value (GTK_RANGE (app->seek_scale)), real);
+
+  GST_DEBUG ("do seek");
+  do_seek (app, GST_FORMAT_TIME, real);
+
+  if (app->play_scrub) {
+    GST_DEBUG ("do scrub seek, PLAYING");
+    gst_element_set_state (app->pipeline, GST_STATE_PLAYING);
+
+    if (app->seek_timeout_id == 0) {
+      app->seek_timeout_id =
+          g_timeout_add (SCRUB_TIME, (GSourceFunc) end_scrub, app);
+    }
+  }
+}
+
+static void
+advanced_seek_button_cb (GtkButton * button, PlaybackApp * app)
+{
+  GstFormat fmt;
+  gint64 pos;
+  const gchar *text;
+  gchar *endptr;
+
+  fmt = app->seek_format->value;
+
+  text = gtk_entry_get_text (GTK_ENTRY (app->seek_entry));
+
+  pos = g_ascii_strtoll (text, &endptr, 10);
+  if (endptr != text && pos != G_MAXINT64 && pos != G_MININT64) {
+    do_seek (app, fmt, pos);
+  }
+}
+
+static void
+set_update_fill (PlaybackApp * app, gboolean active)
+{
+  GST_DEBUG ("fill scale is %d", active);
+
+  if (active) {
+    if (app->fill_id == 0) {
+      app->fill_id =
+          g_timeout_add (FILL_INTERVAL, (GSourceFunc) update_fill, app);
+    }
+  } else {
+    if (app->fill_id) {
+      g_source_remove (app->fill_id);
+      app->fill_id = 0;
+    }
+  }
+}
+
+static void
+set_update_scale (PlaybackApp * app, gboolean active)
+{
+  GST_DEBUG ("update scale is %d", active);
+
+  if (active) {
+    if (app->update_id == 0) {
+      app->update_id =
+          g_timeout_add (UPDATE_INTERVAL, (GSourceFunc) update_scale, app);
+    }
+  } else {
+    if (app->update_id) {
+      g_source_remove (app->update_id);
+      app->update_id = 0;
+    }
+  }
+}
+
+static gboolean
+start_seek (GtkRange * range, GdkEventButton * event, PlaybackApp * app)
+{
+  if (event->type != GDK_BUTTON_PRESS)
+    return FALSE;
+
+  set_update_scale (app, FALSE);
+
+  if (app->state == GST_STATE_PLAYING && app->flush_seek && app->scrub) {
+    GST_DEBUG ("start scrub seek, PAUSE");
+    gst_element_set_state (app->pipeline, GST_STATE_PAUSED);
+  }
+
+  if (app->changed_id == 0 && app->flush_seek && app->scrub) {
+    app->changed_id =
+        g_signal_connect (app->seek_scale, "value-changed",
+        G_CALLBACK (seek_cb), app);
+  }
+
+  return FALSE;
+}
+
+static gboolean
+stop_seek (GtkRange * range, GdkEventButton * event, PlaybackApp * app)
+{
+  if (app->changed_id) {
+    g_signal_handler_disconnect (app->seek_scale, app->changed_id);
+    app->changed_id = 0;
+  }
+
+  if (!app->flush_seek || !app->scrub) {
+    gint64 real;
+
+    GST_DEBUG ("do final seek");
+    real =
+        gtk_range_get_value (GTK_RANGE (app->seek_scale)) * app->duration /
+        N_GRAD;
+    do_seek (app, GST_FORMAT_TIME, real);
+  }
+
+  if (app->seek_timeout_id != 0) {
+    g_source_remove (app->seek_timeout_id);
+    app->seek_timeout_id = 0;
+    /* Still scrubbing, so the pipeline is playing, see if we need PAUSED
+     * instead. */
+    if (app->state == GST_STATE_PAUSED) {
+      GST_DEBUG ("stop scrub seek, PAUSED");
+      gst_element_set_state (app->pipeline, GST_STATE_PAUSED);
+    }
+  } else {
+    if (app->state == GST_STATE_PLAYING) {
+      GST_DEBUG ("stop scrub seek, PLAYING");
+      gst_element_set_state (app->pipeline, GST_STATE_PLAYING);
+    }
+  }
+
+  return FALSE;
+}
+
+static void
+play_cb (GtkButton * button, PlaybackApp * app)
+{
+  GstStateChangeReturn ret;
+
+  if (app->state != GST_STATE_PLAYING) {
+    g_print ("PLAY pipeline\n");
+    gtk_statusbar_pop (GTK_STATUSBAR (app->statusbar), app->status_id);
+
+    if (app->pipeline_type == 0) {
+      video_sink_activate_cb (GTK_ENTRY (app->video_sink_entry), app);
+      audio_sink_activate_cb (GTK_ENTRY (app->audio_sink_entry), app);
+      text_sink_activate_cb (GTK_ENTRY (app->text_sink_entry), app);
+      buffer_size_activate_cb (GTK_ENTRY (app->buffer_size_entry), app);
+      buffer_duration_activate_cb (GTK_ENTRY (app->buffer_duration_entry), app);
+      ringbuffer_maxsize_activate_cb (GTK_ENTRY (app->ringbuffer_maxsize_entry),
+          app);
+      connection_speed_activate_cb (GTK_ENTRY (app->connection_speed_entry),
+          app);
+      av_offset_activate_cb (GTK_ENTRY (app->av_offset_entry), app);
+      subtitle_encoding_activate_cb (GTK_ENTRY (app->subtitle_encoding_entry),
+          app);
+    }
+
+    ret = gst_element_set_state (app->pipeline, GST_STATE_PLAYING);
+    switch (ret) {
+      case GST_STATE_CHANGE_FAILURE:
+        goto failed;
+      case GST_STATE_CHANGE_NO_PREROLL:
+        app->is_live = TRUE;
+        break;
+      default:
+        break;
+    }
+    app->state = GST_STATE_PLAYING;
+    gtk_statusbar_push (GTK_STATUSBAR (app->statusbar), app->status_id,
+        "Playing");
+  }
+
+  return;
+
+failed:
+  {
+    g_print ("PLAY failed\n");
+    gtk_statusbar_push (GTK_STATUSBAR (app->statusbar), app->status_id,
+        "Play failed");
+  }
+}
+
+static void
+pause_cb (GtkButton * button, PlaybackApp * app)
+{
+  g_static_mutex_lock (&app->state_mutex);
+  if (app->state != GST_STATE_PAUSED) {
+    GstStateChangeReturn ret;
+
+    gtk_statusbar_pop (GTK_STATUSBAR (app->statusbar), app->status_id);
+    g_print ("PAUSE pipeline\n");
+    ret = gst_element_set_state (app->pipeline, GST_STATE_PAUSED);
+    switch (ret) {
+      case GST_STATE_CHANGE_FAILURE:
+        goto failed;
+      case GST_STATE_CHANGE_NO_PREROLL:
+        app->is_live = TRUE;
+        break;
+      default:
+        break;
+    }
+
+    app->state = GST_STATE_PAUSED;
+    gtk_statusbar_push (GTK_STATUSBAR (app->statusbar), app->status_id,
+        "Paused");
+  }
+  g_static_mutex_unlock (&app->state_mutex);
+
+  return;
+
+failed:
+  {
+    g_static_mutex_unlock (&app->state_mutex);
+    g_print ("PAUSE failed\n");
+    gtk_statusbar_push (GTK_STATUSBAR (app->statusbar), app->status_id,
+        "Pause failed");
+  }
+}
+
+static void
+stop_cb (GtkButton * button, PlaybackApp * app)
+{
+  if (app->state != STOP_STATE) {
+    GstStateChangeReturn ret;
+    gint i;
+
+    g_print ("READY pipeline\n");
+    gtk_statusbar_pop (GTK_STATUSBAR (app->statusbar), app->status_id);
+
+    g_static_mutex_lock (&app->state_mutex);
+    ret = gst_element_set_state (app->pipeline, STOP_STATE);
+    if (ret == GST_STATE_CHANGE_FAILURE)
+      goto failed;
+
+    app->state = STOP_STATE;
+    gtk_statusbar_push (GTK_STATUSBAR (app->statusbar), app->status_id,
+        "Stopped");
+    gtk_widget_queue_draw (app->video_window);
+
+    app->is_live = FALSE;
+    app->buffering = FALSE;
+    set_update_scale (app, FALSE);
+    set_scale (app, 0.0);
+    set_update_fill (app, FALSE);
+
+    if (app->pipeline_type == 0)
+      clear_streams (app);
+    g_static_mutex_unlock (&app->state_mutex);
+
+    gtk_widget_set_sensitive (GTK_WIDGET (app->seek_scale), TRUE);
+    for (i = 0; i < G_N_ELEMENTS (app->navigation_buttons); i++)
+      gtk_widget_set_sensitive (app->navigation_buttons[i].button, FALSE);
+  }
+  return;
+
+failed:
+  {
+    g_static_mutex_unlock (&app->state_mutex);
+    g_print ("STOP failed\n");
+    gtk_statusbar_push (GTK_STATUSBAR (app->statusbar), app->status_id,
+        "Stop failed");
+  }
+}
+
+static void
+accurate_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  app->accurate_seek = gtk_toggle_button_get_active (button);
+}
+
+static void
+key_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  app->keyframe_seek = gtk_toggle_button_get_active (button);
+}
+
+static void
+loop_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  app->loop_seek = gtk_toggle_button_get_active (button);
+  if (app->state == GST_STATE_PLAYING) {
+    gint64 real;
+
+    real =
+        gtk_range_get_value (GTK_RANGE (app->seek_scale)) * app->duration /
+        N_GRAD;
+    do_seek (app, GST_FORMAT_TIME, real);
+  }
+}
+
+static void
+flush_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  app->flush_seek = gtk_toggle_button_get_active (button);
+}
+
+static void
+scrub_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  app->scrub = gtk_toggle_button_get_active (button);
+}
+
+static void
+play_scrub_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  app->play_scrub = gtk_toggle_button_get_active (button);
+}
+
+static void
+skip_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  app->skip_seek = gtk_toggle_button_get_active (button);
+  if (app->state == GST_STATE_PLAYING) {
+    gint64 real;
+
+    real =
+        gtk_range_get_value (GTK_RANGE (app->seek_scale)) * app->duration /
+        N_GRAD;
+    do_seek (app, GST_FORMAT_TIME, real);
+  }
+}
+
+static void
+rate_spinbutton_changed_cb (GtkSpinButton * button, PlaybackApp * app)
+{
+  gboolean res = FALSE;
+  GstEvent *s_event;
+  GstSeekFlags flags;
+
+  app->rate = gtk_spin_button_get_value (button);
+
+  GST_DEBUG ("rate changed to %lf", app->rate);
+
+  flags = 0;
+  if (app->flush_seek)
+    flags |= GST_SEEK_FLAG_FLUSH;
+  if (app->loop_seek)
+    flags |= GST_SEEK_FLAG_SEGMENT;
+  if (app->accurate_seek)
+    flags |= GST_SEEK_FLAG_ACCURATE;
+  if (app->keyframe_seek)
+    flags |= GST_SEEK_FLAG_KEY_UNIT;
+  if (app->skip_seek)
+    flags |= GST_SEEK_FLAG_SKIP;
+
+  if (app->rate >= 0.0) {
+    s_event = gst_event_new_seek (app->rate,
+        GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, app->position,
+        GST_SEEK_TYPE_SET, GST_CLOCK_TIME_NONE);
+  } else {
+    s_event = gst_event_new_seek (app->rate,
+        GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, G_GINT64_CONSTANT (0),
+        GST_SEEK_TYPE_SET, app->position);
+  }
+
+  res = send_event (app, s_event);
+
+  if (res) {
+    if (app->flush_seek) {
+      gst_element_get_state (GST_ELEMENT (app->pipeline), NULL, NULL,
+          SEEK_TIMEOUT);
+    }
+  } else
+    g_print ("seek failed\n");
+}
+
+static void
+update_flag (GstElement * pipeline, GstPlayFlags flag, gboolean state)
+{
+  gint flags;
+
+  g_print ("%ssetting flag 0x%08x\n", (state ? "" : "un"), flag);
+
+  g_object_get (pipeline, "flags", &flags, NULL);
+  if (state)
+    flags |= flag;
+  else
+    flags &= ~(flag);
+  g_object_set (pipeline, "flags", flags, NULL);
+}
+
+static void
+vis_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_VIS, state);
+  gtk_widget_set_sensitive (app->vis_combo, state);
+}
+
+static void
+audio_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_AUDIO, state);
+  gtk_widget_set_sensitive (app->audio_combo, state);
+}
+
+static void
+video_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_VIDEO, state);
+  gtk_widget_set_sensitive (app->video_combo, state);
+}
+
+static void
+text_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_TEXT, state);
+  gtk_widget_set_sensitive (app->text_combo, state);
+}
+
+static void
+mute_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean mute;
+
+  mute = gtk_toggle_button_get_active (button);
+  g_object_set (app->pipeline, "mute", mute, NULL);
+}
+
+static void
+download_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_DOWNLOAD, state);
+}
+
+static void
+buffering_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_BUFFERING, state);
+}
+
+static void
+soft_volume_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_SOFT_VOLUME, state);
+}
+
+static void
+native_audio_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_NATIVE_AUDIO, state);
+}
+
+static void
+native_video_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_NATIVE_VIDEO, state);
+}
+
+static void
+deinterlace_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_DEINTERLACE, state);
+}
+
+static void
+soft_colorbalance_toggle_cb (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean state;
+
+  state = gtk_toggle_button_get_active (button);
+  update_flag (app->pipeline, GST_PLAY_FLAG_SOFT_COLORBALANCE, state);
+}
+
+static void
+clear_streams (PlaybackApp * app)
+{
+  gint i;
+
+  /* remove previous info */
+  for (i = 0; i < app->n_video; i++)
+    gtk_combo_box_text_remove (GTK_COMBO_BOX_TEXT (app->video_combo), 0);
+  for (i = 0; i < app->n_audio; i++)
+    gtk_combo_box_text_remove (GTK_COMBO_BOX_TEXT (app->audio_combo), 0);
+  for (i = 0; i < app->n_text; i++)
+    gtk_combo_box_text_remove (GTK_COMBO_BOX_TEXT (app->text_combo), 0);
+
+  app->n_audio = app->n_video = app->n_text = 0;
+  gtk_widget_set_sensitive (app->video_combo, FALSE);
+  gtk_widget_set_sensitive (app->audio_combo, FALSE);
+  gtk_widget_set_sensitive (app->text_combo, FALSE);
+
+  app->need_streams = TRUE;
+}
+
+static void
+update_streams (PlaybackApp * app)
+{
+  gint i;
+
+  if (app->pipeline_type == 0 && app->need_streams) {
+    GstTagList *tags;
+    gchar *name, *str;
+    gint active_idx;
+    gboolean state;
+
+    /* remove previous info */
+    clear_streams (app);
+
+    /* here we get and update the different streams detected by playbin2 */
+    g_object_get (app->pipeline, "n-video", &app->n_video, NULL);
+    g_object_get (app->pipeline, "n-audio", &app->n_audio, NULL);
+    g_object_get (app->pipeline, "n-text", &app->n_text, NULL);
+
+    g_print ("video %d, audio %d, text %d\n", app->n_video, app->n_audio,
+        app->n_text);
+
+    active_idx = 0;
+    for (i = 0; i < app->n_video; i++) {
+      g_signal_emit_by_name (app->pipeline, "get-video-tags", i, &tags);
+      if (tags) {
+        str = gst_structure_to_string ((GstStructure *) tags);
+        g_print ("video %d: %s\n", i, str);
+        g_free (str);
+      }
+      /* find good name for the label */
+      name = g_strdup_printf ("video %d", i + 1);
+      gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (app->video_combo),
+          name);
+      g_free (name);
+    }
+    state =
+        gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (app->video_checkbox));
+    gtk_widget_set_sensitive (app->video_combo, state && app->n_video > 0);
+    gtk_combo_box_set_active (GTK_COMBO_BOX (app->video_combo), active_idx);
+
+    active_idx = 0;
+    for (i = 0; i < app->n_audio; i++) {
+      g_signal_emit_by_name (app->pipeline, "get-audio-tags", i, &tags);
+      if (tags) {
+        str = gst_structure_to_string ((GstStructure *) tags);
+        g_print ("audio %d: %s\n", i, str);
+        g_free (str);
+      }
+      /* find good name for the label */
+      name = g_strdup_printf ("audio %d", i + 1);
+      gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (app->audio_combo),
+          name);
+      g_free (name);
+    }
+    state =
+        gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (app->audio_checkbox));
+    gtk_widget_set_sensitive (app->audio_combo, state && app->n_audio > 0);
+    gtk_combo_box_set_active (GTK_COMBO_BOX (app->audio_combo), active_idx);
+
+    active_idx = 0;
+    for (i = 0; i < app->n_text; i++) {
+      g_signal_emit_by_name (app->pipeline, "get-text-tags", i, &tags);
+
+      name = NULL;
+      if (tags) {
+        const GValue *value;
+
+        str = gst_structure_to_string ((GstStructure *) tags);
+        g_print ("text %d: %s\n", i, str);
+        g_free (str);
+
+        /* get the language code if we can */
+        value = gst_tag_list_get_value_index (tags, GST_TAG_LANGUAGE_CODE, 0);
+        if (value && G_VALUE_HOLDS_STRING (value)) {
+          name = g_strdup_printf ("text %s", g_value_get_string (value));
+        }
+      }
+      /* find good name for the label if we didn't use a tag */
+      if (name == NULL)
+        name = g_strdup_printf ("text %d", i + 1);
+
+      gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (app->text_combo),
+          name);
+      g_free (name);
+    }
+    state =
+        gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (app->text_checkbox));
+    gtk_widget_set_sensitive (app->text_combo, state && app->n_text > 0);
+    gtk_combo_box_set_active (GTK_COMBO_BOX (app->text_combo), active_idx);
+
+    app->need_streams = FALSE;
+  }
+}
+
+static void
+video_combo_cb (GtkComboBox * combo, PlaybackApp * app)
+{
+  gint active;
+
+  active = gtk_combo_box_get_active (combo);
+
+  g_print ("setting current video track %d\n", active);
+  g_object_set (app->pipeline, "current-video", active, NULL);
+}
+
+static void
+audio_combo_cb (GtkComboBox * combo, PlaybackApp * app)
+{
+  gint active;
+
+  active = gtk_combo_box_get_active (combo);
+
+  g_print ("setting current audio track %d\n", active);
+  g_object_set (app->pipeline, "current-audio", active, NULL);
+}
+
+static void
+text_combo_cb (GtkComboBox * combo, PlaybackApp * app)
+{
+  gint active;
+
+  active = gtk_combo_box_get_active (combo);
+
+  g_print ("setting current text track %d\n", active);
+  g_object_set (app->pipeline, "current-text", active, NULL);
+}
+
+static gboolean
+filter_vis_features (GstPluginFeature * feature, gpointer data)
+{
+  GstElementFactory *f;
+
+  if (!GST_IS_ELEMENT_FACTORY (feature))
+    return FALSE;
+  f = GST_ELEMENT_FACTORY (feature);
+  if (!g_strrstr (gst_element_factory_get_klass (f), "Visualization"))
+    return FALSE;
+
+  return TRUE;
+}
+
+static void
+init_visualization_features (PlaybackApp * app)
+{
+  GList *list, *walk;
+
+  app->vis_entries = g_array_new (FALSE, FALSE, sizeof (VisEntry));
+
+  list = gst_registry_feature_filter (gst_registry_get_default (),
+      filter_vis_features, FALSE, NULL);
+
+  for (walk = list; walk; walk = g_list_next (walk)) {
+    VisEntry entry;
+    const gchar *name;
+
+    entry.factory = GST_ELEMENT_FACTORY (walk->data);
+    name = gst_element_factory_get_longname (entry.factory);
+
+    g_array_append_val (app->vis_entries, entry);
+    gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (app->vis_combo), name);
+  }
+  gtk_combo_box_set_active (GTK_COMBO_BOX (app->vis_combo), 0);
+}
+
+static void
+vis_combo_cb (GtkComboBox * combo, PlaybackApp * app)
+{
+  guint index;
+  VisEntry *entry;
+  GstElement *element;
+
+  /* get the selected index and get the factory for this index */
+  index = gtk_combo_box_get_active (GTK_COMBO_BOX (app->vis_combo));
+  if (app->vis_entries->len > 0) {
+    entry = &g_array_index (app->vis_entries, VisEntry, index);
+
+    /* create an instance of the element from the factory */
+    element = gst_element_factory_create (entry->factory, NULL);
+    if (!element)
+      return;
+
+    /* set vis plugin for playbin2 */
+    g_object_set (app->pipeline, "vis-plugin", element, NULL);
+  }
+}
+
+static void
+volume_spinbutton_changed_cb (GtkSpinButton * button, PlaybackApp * app)
+{
+  gdouble volume;
+
+  volume = gtk_spin_button_get_value (button);
+
+  g_object_set (app->pipeline, "volume", volume, NULL);
+}
+
+static gboolean
+volume_notify_idle_cb (PlaybackApp * app)
+{
+  gdouble cur_volume, new_volume;
+
+  g_object_get (app->pipeline, "volume", &new_volume, NULL);
+  cur_volume =
+      gtk_spin_button_get_value (GTK_SPIN_BUTTON (app->volume_spinbutton));
+  if (fabs (cur_volume - new_volume) > 0.001) {
+    g_signal_handlers_block_by_func (app->volume_spinbutton,
+        volume_spinbutton_changed_cb, app);
+    gtk_spin_button_set_value (GTK_SPIN_BUTTON (app->volume_spinbutton),
+        new_volume);
+    g_signal_handlers_unblock_by_func (app->volume_spinbutton,
+        volume_spinbutton_changed_cb, app);
+  }
+
+  return FALSE;
+}
+
+static void
+volume_notify_cb (GstElement * pipeline, GParamSpec * arg, PlaybackApp * app)
+{
+  /* Do this from the main thread */
+  g_idle_add ((GSourceFunc) volume_notify_idle_cb, app);
+}
+
+static gboolean
+mute_notify_idle_cb (PlaybackApp * app)
+{
+  gboolean cur_mute, new_mute;
+
+  g_object_get (app->pipeline, "mute", &new_mute, NULL);
+  cur_mute =
+      gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (app->mute_checkbox));
+  if (cur_mute != new_mute) {
+    g_signal_handlers_block_by_func (app->mute_checkbox, mute_toggle_cb, app);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (app->mute_checkbox),
+        new_mute);
+    g_signal_handlers_unblock_by_func (app->mute_checkbox, mute_toggle_cb, app);
+  }
+
+  return FALSE;
+}
+
+static void
+mute_notify_cb (GstElement * pipeline, GParamSpec * arg, PlaybackApp * app)
+{
+  /* Do this from the main thread */
+  g_idle_add ((GSourceFunc) mute_notify_idle_cb, app);
+}
+
+static void
+shot_cb (GtkButton * button, PlaybackApp * app)
+{
+  GstBuffer *buffer;
+  GstCaps *caps;
+
+  /* convert to our desired format (RGB24) */
+  caps = gst_caps_new_simple ("video/x-raw-rgb",
+      "bpp", G_TYPE_INT, 24, "depth", G_TYPE_INT, 24,
+      /* Note: we don't ask for a specific width/height here, so that
+       * videoscale can adjust dimensions from a non-1/1 pixel aspect
+       * ratio to a 1/1 pixel-aspect-ratio */
+      "pixel-aspect-ratio", GST_TYPE_FRACTION, 1, 1,
+      "endianness", G_TYPE_INT, G_BIG_ENDIAN,
+      "red_mask", G_TYPE_INT, 0xff0000,
+      "green_mask", G_TYPE_INT, 0x00ff00,
+      "blue_mask", G_TYPE_INT, 0x0000ff, NULL);
+
+  /* convert the latest frame to the requested format */
+  g_signal_emit_by_name (app->pipeline, "convert-frame", caps, &buffer);
+  gst_caps_unref (caps);
+
+  if (buffer) {
+    GstCaps *caps;
+    GstStructure *s;
+    gboolean res;
+    gint width, height;
+    GdkPixbuf *pixbuf;
+    GError *error = NULL;
+
+    /* get the snapshot buffer format now. We set the caps on the appsink so
+     * that it can only be an rgb buffer. The only thing we have not specified
+     * on the caps is the height, which is dependant on the pixel-aspect-ratio
+     * of the source material */
+    caps = GST_BUFFER_CAPS (buffer);
+    if (!caps) {
+      g_warning ("could not get snapshot format\n");
+      goto done;
+    }
+    s = gst_caps_get_structure (caps, 0);
+
+    /* we need to get the final caps on the buffer to get the size */
+    res = gst_structure_get_int (s, "width", &width);
+    res |= gst_structure_get_int (s, "height", &height);
+    if (!res) {
+      g_warning ("could not get snapshot dimension\n");
+      goto done;
+    }
+
+    /* create pixmap from buffer and save, gstreamer video buffers have a stride
+     * that is rounded up to the nearest multiple of 4 */
+    pixbuf = gdk_pixbuf_new_from_data (GST_BUFFER_DATA (buffer),
+        GDK_COLORSPACE_RGB, FALSE, 8, width, height,
+        GST_ROUND_UP_4 (width * 3), NULL, NULL);
+
+    /* save the pixbuf */
+    gdk_pixbuf_save (pixbuf, "snapshot.png", "png", &error, NULL);
+
+  done:
+    gst_buffer_unref (buffer);
+  }
+}
+
+/* called when the Step button is pressed */
+static void
+step_cb (GtkButton * button, PlaybackApp * app)
+{
+  GstEvent *event;
+  GstFormat format;
+  guint64 amount;
+  gdouble rate;
+  gboolean flush, res;
+  gint active;
+
+  active = gtk_combo_box_get_active (GTK_COMBO_BOX (app->step_format_combo));
+  amount =
+      gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON
+      (app->step_amount_spinbutton));
+  rate =
+      gtk_spin_button_get_value (GTK_SPIN_BUTTON (app->step_rate_spinbutton));
+  flush = TRUE;
+
+  switch (active) {
+    case 0:
+      format = GST_FORMAT_BUFFERS;
+      break;
+    case 1:
+      format = GST_FORMAT_TIME;
+      amount *= GST_MSECOND;
+      break;
+    default:
+      format = GST_FORMAT_UNDEFINED;
+      break;
+  }
+
+  event = gst_event_new_step (format, amount, rate, flush, FALSE);
+
+  res = send_event (app, event);
+
+  if (!res) {
+    g_print ("Sending step event failed\n");
+  }
+}
+
+static void
+message_received (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  const GstStructure *s;
+
+  switch (GST_MESSAGE_TYPE (message)) {
+    case GST_MESSAGE_ERROR:
+      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (app->pipeline),
+          GST_DEBUG_GRAPH_SHOW_ALL, "seek.error");
+      break;
+    case GST_MESSAGE_WARNING:
+      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (app->pipeline),
+          GST_DEBUG_GRAPH_SHOW_ALL, "seek.warning");
+      break;
+    default:
+      break;
+  }
+
+  s = gst_message_get_structure (message);
+  g_print ("message from \"%s\" (%s): ",
+      GST_STR_NULL (GST_ELEMENT_NAME (GST_MESSAGE_SRC (message))),
+      gst_message_type_get_name (GST_MESSAGE_TYPE (message)));
+  if (s) {
+    gchar *sstr;
+
+    sstr = gst_structure_to_string (s);
+    g_print ("%s\n", sstr);
+    g_free (sstr);
+  } else {
+    g_print ("no message details\n");
+  }
+}
+
+static void
+do_shuttle (PlaybackApp * app)
+{
+  guint64 duration;
+
+  if (app->shuttling)
+    duration = 40 * GST_MSECOND;
+  else
+    duration = -1;
+
+  gst_element_send_event (app->pipeline,
+      gst_event_new_step (GST_FORMAT_TIME, duration, app->shuttle_rate, FALSE,
+          FALSE));
+}
+
+static void
+msg_sync_step_done (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  GstFormat format;
+  guint64 amount;
+  gdouble rate;
+  gboolean flush;
+  gboolean intermediate;
+  guint64 duration;
+  gboolean eos;
+
+  gst_message_parse_step_done (message, &format, &amount, &rate, &flush,
+      &intermediate, &duration, &eos);
+
+  if (eos) {
+    g_print ("stepped till EOS\n");
+    return;
+  }
+
+  if (g_static_mutex_trylock (&app->state_mutex)) {
+    if (app->shuttling)
+      do_shuttle (app);
+    g_static_mutex_unlock (&app->state_mutex);
+  } else {
+    /* ignore step messages that come while we are doing a state change */
+    g_print ("state change is busy\n");
+  }
+}
+
+static void
+shuttle_toggled (GtkToggleButton * button, PlaybackApp * app)
+{
+  gboolean active;
+
+  active = gtk_toggle_button_get_active (button);
+
+  if (active != app->shuttling) {
+    app->shuttling = active;
+    g_print ("shuttling %s\n", app->shuttling ? "active" : "inactive");
+    if (active) {
+      app->shuttle_rate = 0.0;
+      app->play_rate = 1.0;
+      pause_cb (NULL, app);
+      gst_element_get_state (app->pipeline, NULL, NULL, -1);
+    }
+  }
+}
+
+static void
+shuttle_rate_switch (PlaybackApp * app)
+{
+  GstSeekFlags flags;
+  GstEvent *s_event;
+  gboolean res;
+
+  if (app->state == GST_STATE_PLAYING) {
+    /* pause when we need to */
+    pause_cb (NULL, app);
+    gst_element_get_state (app->pipeline, NULL, NULL, -1);
+  }
+
+  if (app->play_rate == 1.0)
+    app->play_rate = -1.0;
+  else
+    app->play_rate = 1.0;
+
+  g_print ("rate changed to %lf %" GST_TIME_FORMAT "\n", app->play_rate,
+      GST_TIME_ARGS (app->position));
+
+  flags = GST_SEEK_FLAG_FLUSH;
+  flags |= GST_SEEK_FLAG_ACCURATE;
+
+  if (app->play_rate >= 0.0) {
+    s_event = gst_event_new_seek (app->play_rate,
+        GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, app->position,
+        GST_SEEK_TYPE_SET, GST_CLOCK_TIME_NONE);
+  } else {
+    s_event = gst_event_new_seek (app->play_rate,
+        GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, G_GINT64_CONSTANT (0),
+        GST_SEEK_TYPE_SET, app->position);
+  }
+  res = send_event (app, s_event);
+  if (res) {
+    gst_element_get_state (app->pipeline, NULL, NULL, SEEK_TIMEOUT);
+  } else {
+    g_print ("seek failed\n");
+  }
+}
+
+static void
+shuttle_value_changed (GtkRange * range, PlaybackApp * app)
+{
+  gdouble rate;
+
+  rate = gtk_range_get_value (range);
+
+  if (rate == 0.0) {
+    g_print ("rate 0.0, pause\n");
+    pause_cb (NULL, app);
+    gst_element_get_state (app->pipeline, NULL, NULL, -1);
+  } else {
+    g_print ("rate changed %0.3g\n", rate);
+
+    if ((rate < 0.0 && app->play_rate > 0.0) || (rate > 0.0
+            && app->play_rate < 0.0)) {
+      shuttle_rate_switch (app);
+    }
+
+    app->shuttle_rate = ABS (rate);
+    if (app->state != GST_STATE_PLAYING) {
+      do_shuttle (app);
+      play_cb (NULL, app);
+    }
+  }
+}
+
+static void
+colorbalance_value_changed (GtkRange * range, PlaybackApp * app)
+{
+  const gchar *label;
+  gdouble val;
+  gint ival;
+  GstColorBalanceChannel *channel = NULL;
+  const GList *channels, *l;
+
+  if (range == GTK_RANGE (app->contrast_scale))
+    label = "CONTRAST";
+  else if (range == GTK_RANGE (app->brightness_scale))
+    label = "BRIGHTNESS";
+  else if (range == GTK_RANGE (app->hue_scale))
+    label = "HUE";
+  else if (range == GTK_RANGE (app->saturation_scale))
+    label = "SATURATION";
+  else
+    g_assert_not_reached ();
+
+  val = gtk_range_get_value (range);
+
+  g_print ("colorbalance %s value changed %lf\n", label, val / N_GRAD);
+
+  if (!app->colorbalance_element) {
+    find_interface_elements (app);
+    if (!app->colorbalance_element)
+      return;
+  }
+
+  channels =
+      gst_color_balance_list_channels (GST_COLOR_BALANCE
+      (app->colorbalance_element));
+  for (l = channels; l; l = l->next) {
+    GstColorBalanceChannel *tmp = l->data;
+
+    if (g_strrstr (tmp->label, label)) {
+      channel = tmp;
+      break;
+    }
+  }
+
+  if (!channel)
+    return;
+
+  ival =
+      (gint) (0.5 + channel->min_value +
+      (val / N_GRAD) * ((gdouble) channel->max_value -
+          (gdouble) channel->min_value));
+  gst_color_balance_set_value (GST_COLOR_BALANCE (app->colorbalance_element),
+      channel, ival);
+}
+
+static void
+seek_format_changed_cb (GtkComboBox * box, PlaybackApp * app)
+{
+  gchar *format_str;
+  GList *l;
+  const GstFormatDefinition *format = NULL;
+
+  format_str = gtk_combo_box_text_get_active_text (GTK_COMBO_BOX_TEXT (box));
+
+  for (l = app->formats; l; l = l->next) {
+    const GstFormatDefinition *tmp = l->data;
+
+    if (g_strcmp0 (tmp->nick, format_str) == 0) {
+      format = tmp;
+      break;
+    }
+  }
+
+  if (!format)
+    goto done;
+
+  app->seek_format = format;
+  update_scale (app);
+
+done:
+  g_free (format_str);
+}
+
+static void
+update_formats (PlaybackApp * app)
+{
+  GstIterator *it;
+  gboolean done;
+  GList *l;
+  gpointer item;
+  gchar *selected;
+  gint selected_idx = 0, i;
+
+  selected =
+      gtk_combo_box_text_get_active_text (GTK_COMBO_BOX_TEXT
+      (app->seek_format_combo));
+  if (selected == NULL)
+    selected = g_strdup ("time");
+
+  it = gst_format_iterate_definitions ();
+  done = FALSE;
+
+  g_list_free (app->formats);
+  app->formats = NULL;
+
+  while (!done) {
+    switch (gst_iterator_next (it, &item)) {
+      case GST_ITERATOR_OK:
+        app->formats = g_list_prepend (app->formats, item);
+        break;
+      case GST_ITERATOR_RESYNC:
+        g_list_free (app->formats);
+        app->formats = NULL;
+        gst_iterator_resync (it);
+        break;
+      case GST_ITERATOR_ERROR:
+      case GST_ITERATOR_DONE:
+      default:
+        done = TRUE;
+        break;
+    }
+  }
+
+  app->formats = g_list_reverse (app->formats);
+  gst_iterator_free (it);
+
+  g_signal_handlers_block_by_func (app->seek_format_combo,
+      seek_format_changed_cb, app);
+  gtk_combo_box_text_remove_all (GTK_COMBO_BOX_TEXT (app->seek_format_combo));
+
+  for (i = 0, l = app->formats; l; l = l->next, i++) {
+    const GstFormatDefinition *def = l->data;
+
+    gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (app->seek_format_combo),
+        def->nick);
+    if (g_strcmp0 (def->nick, selected) == 0)
+      selected_idx = i;
+  }
+  g_signal_handlers_unblock_by_func (app->seek_format_combo,
+      seek_format_changed_cb, app);
+
+  gtk_combo_box_set_active (GTK_COMBO_BOX (app->seek_format_combo),
+      selected_idx);
+
+  g_free (selected);
+}
+
+static void
+msg_async_done (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  GST_DEBUG ("async done");
+
+  /* Now query all available GstFormats */
+  update_formats (app);
+
+  /* when we get ASYNC_DONE we can query position, duration and other
+   * properties */
+  update_scale (app);
+
+  /* update the available streams */
+  update_streams (app);
+
+  find_interface_elements (app);
+}
+
+static void
+msg_state_changed (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  const GstStructure *s;
+
+  s = gst_message_get_structure (message);
+
+  /* We only care about state changed on the pipeline */
+  if (s && GST_MESSAGE_SRC (message) == GST_OBJECT_CAST (app->pipeline)) {
+    GstState old, new, pending;
+
+    gst_message_parse_state_changed (message, &old, &new, &pending);
+
+    /* When state of the pipeline changes to paused or playing we start updating scale */
+    if (new == GST_STATE_PLAYING) {
+      set_update_scale (app, TRUE);
+    } else {
+      set_update_scale (app, FALSE);
+    }
+
+    /* dump graph for (some) pipeline state changes */
+    {
+      gchar *dump_name;
+
+      dump_name = g_strdup_printf ("seek.%s_%s",
+          gst_element_state_get_name (old), gst_element_state_get_name (new));
+
+      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (app->pipeline),
+          GST_DEBUG_GRAPH_SHOW_ALL, dump_name);
+
+      g_free (dump_name);
+    }
+  }
+}
+
+static void
+msg_segment_done (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  GstEvent *s_event;
+  GstSeekFlags flags;
+  gboolean res;
+  GstFormat format;
+
+  GST_DEBUG ("position is %" GST_TIME_FORMAT, GST_TIME_ARGS (app->position));
+  gst_message_parse_segment_done (message, &format, &app->position);
+  GST_DEBUG ("end of segment at %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (app->position));
+
+  flags = 0;
+  /* in the segment-done callback we never flush as this would not make sense
+   * for seamless playback. */
+  if (app->loop_seek)
+    flags |= GST_SEEK_FLAG_SEGMENT;
+  if (app->skip_seek)
+    flags |= GST_SEEK_FLAG_SKIP;
+
+  s_event = gst_event_new_seek (app->rate,
+      GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, G_GINT64_CONSTANT (0),
+      GST_SEEK_TYPE_SET, app->duration);
+
+  GST_DEBUG ("restart loop with rate %lf to 0 / %" GST_TIME_FORMAT,
+      app->rate, GST_TIME_ARGS (app->duration));
+
+  res = send_event (app, s_event);
+  if (!res)
+    g_print ("segment seek failed\n");
+}
+
+/* in stream buffering mode we PAUSE the pipeline until we receive a 100%
+ * message */
+static void
+do_stream_buffering (PlaybackApp * app, gint percent)
+{
+  gchar *bufstr;
+
+  gtk_statusbar_pop (GTK_STATUSBAR (app->statusbar), app->status_id);
+  bufstr = g_strdup_printf ("Buffering...%d", percent);
+  gtk_statusbar_push (GTK_STATUSBAR (app->statusbar), app->status_id, bufstr);
+  g_free (bufstr);
+
+  if (percent == 100) {
+    /* a 100% message means buffering is done */
+    app->buffering = FALSE;
+    /* if the desired state is playing, go back */
+    if (app->state == GST_STATE_PLAYING) {
+      /* no state management needed for live pipelines */
+      if (!app->is_live) {
+        fprintf (stderr, "Done buffering, setting pipeline to PLAYING ...\n");
+        gst_element_set_state (app->pipeline, GST_STATE_PLAYING);
+      }
+      gtk_statusbar_pop (GTK_STATUSBAR (app->statusbar), app->status_id);
+      gtk_statusbar_push (GTK_STATUSBAR (app->statusbar), app->status_id,
+          "Playing");
+    }
+  } else {
+    /* buffering busy */
+    if (app->buffering == FALSE && app->state == GST_STATE_PLAYING) {
+      /* we were not buffering but PLAYING, PAUSE  the pipeline. */
+      if (!app->is_live) {
+        fprintf (stderr, "Buffering, setting pipeline to PAUSED ...\n");
+        gst_element_set_state (app->pipeline, GST_STATE_PAUSED);
+      }
+    }
+    app->buffering = TRUE;
+  }
+}
+
+static void
+do_download_buffering (PlaybackApp * app, gint percent)
+{
+  if (!app->buffering && percent < 100) {
+    gchar *bufstr;
+
+    app->buffering = TRUE;
+
+    bufstr = g_strdup_printf ("Downloading...");
+    gtk_statusbar_push (GTK_STATUSBAR (app->statusbar), app->status_id, bufstr);
+    g_free (bufstr);
+
+    /* once we get a buffering message, we'll do the fill update */
+    set_update_fill (app, TRUE);
+
+    if (app->state == GST_STATE_PLAYING && !app->is_live) {
+      fprintf (stderr, "Downloading, setting pipeline to PAUSED ...\n");
+      gst_element_set_state (app->pipeline, GST_STATE_PAUSED);
+      /* user has to manually start the playback */
+      app->state = GST_STATE_PAUSED;
+    }
+  }
+}
+
+static void
+msg_buffering (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  gint percent;
+
+  gst_message_parse_buffering (message, &percent);
+
+  /* get more stats */
+  gst_message_parse_buffering_stats (message, &app->mode, NULL, NULL,
+      &app->buffering_left);
+
+  switch (app->mode) {
+    case GST_BUFFERING_DOWNLOAD:
+      do_download_buffering (app, percent);
+      break;
+    case GST_BUFFERING_LIVE:
+      app->is_live = TRUE;
+    case GST_BUFFERING_TIMESHIFT:
+    case GST_BUFFERING_STREAM:
+      do_stream_buffering (app, percent);
+      break;
+  }
+}
+
+static void
+msg_clock_lost (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  g_print ("clock lost! PAUSE and PLAY to select a new clock\n");
+  if (app->state == GST_STATE_PLAYING) {
+    gst_element_set_state (app->pipeline, GST_STATE_PAUSED);
+    gst_element_set_state (app->pipeline, GST_STATE_PLAYING);
+  }
+}
+
+static gboolean
+is_valid_color_balance_element (GstElement * element)
+{
+  GstColorBalance *bal = GST_COLOR_BALANCE (element);
+  gboolean have_brightness = FALSE;
+  gboolean have_contrast = FALSE;
+  gboolean have_hue = FALSE;
+  gboolean have_saturation = FALSE;
+  const GList *channels, *l;
+
+  channels = gst_color_balance_list_channels (bal);
+  for (l = channels; l; l = l->next) {
+    GstColorBalanceChannel *ch = l->data;
+
+    if (g_strrstr (ch->label, "BRIGHTNESS"))
+      have_brightness = TRUE;
+    else if (g_strrstr (ch->label, "CONTRAST"))
+      have_contrast = TRUE;
+    else if (g_strrstr (ch->label, "HUE"))
+      have_hue = TRUE;
+    else if (g_strrstr (ch->label, "SATURATION"))
+      have_saturation = TRUE;
+  }
+
+  return have_brightness && have_contrast && have_hue && have_saturation;
+}
+
+static void
+find_interface_elements (PlaybackApp * app)
+{
+  GstIterator *it;
+  gpointer item;
+  gboolean done = FALSE, hardware = FALSE;
+
+  if (app->pipeline_type == 0)
+    return;
+
+  if (app->navigation_element)
+    gst_object_unref (app->navigation_element);
+  app->navigation_element = NULL;
+
+  if (app->colorbalance_element)
+    gst_object_unref (app->colorbalance_element);
+  app->colorbalance_element = NULL;
+
+  app->navigation_element =
+      gst_bin_get_by_interface (GST_BIN (app->pipeline), GST_TYPE_NAVIGATION);
+
+  it = gst_bin_iterate_all_by_interface (GST_BIN (app->pipeline),
+      GST_TYPE_COLOR_BALANCE);
+  while (!done) {
+    switch (gst_iterator_next (it, &item)) {
+      case GST_ITERATOR_OK:{
+        GstElement *element = GST_ELEMENT (item);
+
+        if (is_valid_color_balance_element (element)) {
+          if (!app->colorbalance_element) {
+            app->colorbalance_element =
+                GST_ELEMENT_CAST (gst_object_ref (element));
+            hardware =
+                (gst_color_balance_get_balance_type (GST_COLOR_BALANCE
+                    (element)) == GST_COLOR_BALANCE_HARDWARE);
+          } else if (!hardware) {
+            gboolean tmp =
+                (gst_color_balance_get_balance_type (GST_COLOR_BALANCE
+                    (element)) == GST_COLOR_BALANCE_HARDWARE);
+
+            if (tmp) {
+              if (app->colorbalance_element)
+                gst_object_unref (app->colorbalance_element);
+              app->colorbalance_element =
+                  GST_ELEMENT_CAST (gst_object_ref (element));
+              hardware = TRUE;
+            }
+          }
+        }
+
+        gst_object_unref (element);
+
+        if (hardware && app->colorbalance_element)
+          done = TRUE;
+        break;
+      }
+      case GST_ITERATOR_RESYNC:
+        gst_iterator_resync (it);
+        done = FALSE;
+        hardware = FALSE;
+        if (app->colorbalance_element)
+          gst_object_unref (app->colorbalance_element);
+        app->colorbalance_element = NULL;
+        break;
+      case GST_ITERATOR_DONE:
+      case GST_ITERATOR_ERROR:
+      default:
+        done = TRUE;
+    }
+  }
+
+  gst_iterator_free (it);
+}
+
+/* called when Navigation command button is pressed */
+static void
+navigation_cmd_cb (GtkButton * button, PlaybackApp * app)
+{
+  GstNavigationCommand cmd = GST_NAVIGATION_COMMAND_INVALID;
+  gint i;
+
+  if (!app->navigation_element) {
+    find_interface_elements (app);
+    if (!app->navigation_element)
+      return;
+  }
+
+  for (i = 0; i < G_N_ELEMENTS (app->navigation_buttons); i++) {
+    if (app->navigation_buttons[i].button == GTK_WIDGET (button)) {
+      cmd = app->navigation_buttons[i].cmd;
+      break;
+    }
+  }
+
+  if (cmd != GST_NAVIGATION_COMMAND_INVALID)
+    gst_navigation_send_command (GST_NAVIGATION (app->navigation_element), cmd);
+}
+
+#if defined (GDK_WINDOWING_X11) || defined (GDK_WINDOWING_WIN32) || defined (GDK_WINDOWING_QUARTZ)
+/* We set the xid here in response to the prepare-xwindow-id message via a
+ * bus sync handler because we don't know the actual videosink used from the
+ * start (as we don't know the pipeline, or bin elements such as autovideosink
+ * or gconfvideosink may be used which create the actual videosink only once
+ * the pipeline is started) */
+static GstBusSyncReply
+bus_sync_handler (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  if ((GST_MESSAGE_TYPE (message) == GST_MESSAGE_ELEMENT) &&
+      gst_structure_has_name (message->structure, "prepare-xwindow-id")) {
+    GstElement *element = GST_ELEMENT (GST_MESSAGE_SRC (message));
+
+    if (app->xoverlay_element)
+      gst_object_unref (app->xoverlay_element);
+    app->xoverlay_element = GST_ELEMENT (gst_object_ref (element));
+
+    g_print ("got prepare-xwindow-id, setting XID %" G_GUINTPTR_FORMAT "\n",
+        app->embed_xid);
+
+    if (g_object_class_find_property (G_OBJECT_GET_CLASS (element),
+            "force-aspect-ratio")) {
+      g_object_set (element, "force-aspect-ratio", TRUE, NULL);
+    }
+
+    /* Should have been initialised from main thread before (can't use
+     * GDK_WINDOW_XID here with Gtk+ >= 2.18, because the sync handler will
+     * be called from a streaming thread and GDK_WINDOW_XID maps to more than
+     * a simple structure lookup with Gtk+ >= 2.18, where 'more' is stuff that
+     * shouldn't be done from a non-GUI thread without explicit locking).  */
+    g_assert (app->embed_xid != 0);
+
+    gst_x_overlay_set_window_handle (GST_X_OVERLAY (element), app->embed_xid);
+
+    find_interface_elements (app);
+  }
+  return GST_BUS_PASS;
+}
+#endif
+
+static gboolean
+draw_cb (GtkWidget * widget, cairo_t * cr, PlaybackApp * app)
+{
+  if (app->state < GST_STATE_PAUSED) {
+    int width, height;
+
+    width = gtk_widget_get_allocated_width (widget);
+    height = gtk_widget_get_allocated_height (widget);
+    cairo_set_source_rgb (cr, 0, 0, 0);
+    cairo_rectangle (cr, 0, 0, width, height);
+    cairo_fill (cr);
+    return TRUE;
+  }
+
+  if (app->xoverlay_element)
+    gst_x_overlay_expose (GST_X_OVERLAY (app->xoverlay_element));
+
+  return FALSE;
+}
+
+static void
+realize_cb (GtkWidget * widget, PlaybackApp * app)
+{
+  GdkWindow *window = gtk_widget_get_window (widget);
+
+  /* This is here just for pedagogical purposes, GDK_WINDOW_XID will call it
+   * as well */
+  if (!gdk_window_ensure_native (window))
+    g_error ("Couldn't create native window needed for GstXOverlay!");
+
+#if defined (GDK_WINDOWING_WIN32)
+  app->embed_xid = GDK_WINDOW_HWND (window);
+  g_print ("Window realize: video window HWND = %lu\n", app->embed_xid);
+#elif defined (GDK_WINDOWING_QUARTZ)
+  app->embed_xid = gdk_quartz_window_get_nsview (window);
+  g_print ("Window realize: video window NSView = %p\n", app->embed_xid);
+#elif defined (GDK_WINDOWING_X11)
+  app->embed_xid = GDK_WINDOW_XID (window);
+  g_print ("Window realize: video window XID = %" G_GUINTPTR_FORMAT "\n",
+      app->embed_xid);
+#endif
+}
+
+static gboolean
+button_press_cb (GtkWidget * widget, GdkEventButton * event, PlaybackApp * app)
+{
+  gtk_widget_grab_focus (widget);
+
+  if (app->navigation_element)
+    gst_navigation_send_mouse_event (GST_NAVIGATION (app->navigation_element),
+        "mouse-button-press", event->button, event->x, event->y);
+
+  return FALSE;
+}
+
+static gboolean
+button_release_cb (GtkWidget * widget, GdkEventButton * event,
+    PlaybackApp * app)
+{
+  if (app->navigation_element)
+    gst_navigation_send_mouse_event (GST_NAVIGATION (app->navigation_element),
+        "mouse-button-release", event->button, event->x, event->y);
+
+  return FALSE;
+}
+
+static gboolean
+key_press_cb (GtkWidget * widget, GdkEventKey * event, PlaybackApp * app)
+{
+  if (app->navigation_element)
+    gst_navigation_send_key_event (GST_NAVIGATION (app->navigation_element),
+        "key-press", gdk_keyval_name (event->keyval));
+
+  return FALSE;
+}
+
+static gboolean
+key_release_cb (GtkWidget * widget, GdkEventKey * event, PlaybackApp * app)
+{
+  if (app->navigation_element)
+    gst_navigation_send_key_event (GST_NAVIGATION (app->navigation_element),
+        "key-release", gdk_keyval_name (event->keyval));
+
+  return FALSE;
+}
+
+static gboolean
+motion_notify_cb (GtkWidget * widget, GdkEventMotion * event, PlaybackApp * app)
+{
+  if (app->navigation_element)
+    gst_navigation_send_mouse_event (GST_NAVIGATION (app->navigation_element),
+        "mouse-move", 0, event->x, event->y);
+
+  return FALSE;
+}
+
+static void
+msg_eos (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  message_received (bus, message, app);
+
+  /* Set new uri for playerbins and continue playback */
+  if (app->current_path && app->pipeline_type == 0) {
+    stop_cb (NULL, app);
+    app->current_path = g_list_next (app->current_path);
+    app->current_sub_path = g_list_next (app->current_sub_path);
+    if (app->current_path) {
+      playbin_set_uri (app->pipeline, app->current_path->data,
+          app->current_sub_path ? app->current_sub_path->data : NULL);
+      play_cb (NULL, app);
+    }
+  }
+}
+
+static void
+msg_step_done (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  if (!app->shuttling)
+    message_received (bus, message, app);
+}
+
+static void
+msg (GstBus * bus, GstMessage * message, PlaybackApp * app)
+{
+  GstNavigationMessageType nav_type;
+
+  nav_type = gst_navigation_message_get_type (message);
+  switch (nav_type) {
+    case GST_NAVIGATION_MESSAGE_COMMANDS_CHANGED:{
+      GstQuery *query;
+      gboolean res, j;
+
+      /* Heuristic to detect if we're dealing with a DVD menu */
+      query = gst_navigation_query_new_commands ();
+      res = gst_element_query (GST_ELEMENT (GST_MESSAGE_SRC (message)), query);
+
+      for (j = 0; j < G_N_ELEMENTS (app->navigation_buttons); j++)
+        gtk_widget_set_sensitive (app->navigation_buttons[j].button, FALSE);
+
+      if (res) {
+        gboolean is_menu = FALSE;
+        guint i, n;
+
+        if (gst_navigation_query_parse_commands_length (query, &n)) {
+          for (i = 0; i < n; i++) {
+            GstNavigationCommand cmd;
+
+            if (!gst_navigation_query_parse_commands_nth (query, i, &cmd))
+              break;
+
+            is_menu |= (cmd == GST_NAVIGATION_COMMAND_ACTIVATE);
+            is_menu |= (cmd == GST_NAVIGATION_COMMAND_LEFT);
+            is_menu |= (cmd == GST_NAVIGATION_COMMAND_RIGHT);
+            is_menu |= (cmd == GST_NAVIGATION_COMMAND_UP);
+            is_menu |= (cmd == GST_NAVIGATION_COMMAND_DOWN);
+
+            for (j = 0; j < G_N_ELEMENTS (app->navigation_buttons); j++) {
+              if (app->navigation_buttons[j].cmd != cmd)
+                continue;
+
+              gtk_widget_set_sensitive (app->navigation_buttons[j].button,
+                  TRUE);
+            }
+          }
+        }
+
+        gtk_widget_set_sensitive (GTK_WIDGET (app->seek_scale), !is_menu);
+      } else {
+        g_assert_not_reached ();
+      }
+
+      gst_query_unref (query);
+      message_received (bus, message, app);
+      break;
+    }
+    default:
+      break;
+  }
+}
+
+static void
+connect_bus_signals (PlaybackApp * app)
+{
+  GstBus *bus = gst_pipeline_get_bus (GST_PIPELINE (app->pipeline));
+
+#if defined (GDK_WINDOWING_X11) || defined (GDK_WINDOWING_WIN32) || defined (GDK_WINDOWING_QUARTZ)
+  if (app->pipeline_type != 0) {
+    /* handle prepare-xwindow-id element message synchronously, but only for non-playbin2 */
+    gst_bus_set_sync_handler (bus, (GstBusSyncHandler) bus_sync_handler, app);
+  }
+#endif
+
+  gst_bus_add_signal_watch_full (bus, G_PRIORITY_HIGH);
+  gst_bus_enable_sync_message_emission (bus);
+
+  g_signal_connect (bus, "message::state-changed",
+      G_CALLBACK (msg_state_changed), app);
+  g_signal_connect (bus, "message::segment-done", G_CALLBACK (msg_segment_done),
+      app);
+  g_signal_connect (bus, "message::async-done", G_CALLBACK (msg_async_done),
+      app);
+
+  g_signal_connect (bus, "message::new-clock", G_CALLBACK (message_received),
+      app);
+  g_signal_connect (bus, "message::clock-lost", G_CALLBACK (msg_clock_lost),
+      app);
+  g_signal_connect (bus, "message::error", G_CALLBACK (message_received), app);
+  g_signal_connect (bus, "message::warning", G_CALLBACK (message_received),
+      app);
+  g_signal_connect (bus, "message::eos", G_CALLBACK (msg_eos), app);
+  g_signal_connect (bus, "message::tag", G_CALLBACK (message_received), app);
+  g_signal_connect (bus, "message::element", G_CALLBACK (message_received),
+      app);
+  g_signal_connect (bus, "message::segment-done", G_CALLBACK (message_received),
+      app);
+  g_signal_connect (bus, "message::buffering", G_CALLBACK (msg_buffering), app);
+//  g_signal_connect (bus, "message::step-done", G_CALLBACK (msg_step_done),
+//      app);
+  g_signal_connect (bus, "message::step-start", G_CALLBACK (msg_step_done),
+      app);
+  g_signal_connect (bus, "sync-message::step-done",
+      G_CALLBACK (msg_sync_step_done), app);
+  g_signal_connect (bus, "message", G_CALLBACK (msg), app);
+
+  gst_object_unref (bus);
+}
+
+/* Return GList of paths described in location string */
+static GList *
+handle_wildcards (const gchar * location)
+{
+  GList *res = NULL;
+  gchar *path = g_path_get_dirname (location);
+  gchar *pattern = g_path_get_basename (location);
+  GPatternSpec *pspec = g_pattern_spec_new (pattern);
+  GDir *dir = g_dir_open (path, 0, NULL);
+  const gchar *name;
+
+  g_print ("matching %s from %s\n", pattern, path);
+
+  if (!dir) {
+    g_print ("opening directory %s failed\n", path);
+    goto out;
+  }
+
+  while ((name = g_dir_read_name (dir)) != NULL) {
+    if (g_pattern_match_string (pspec, name)) {
+      res = g_list_append (res, g_strjoin ("/", path, name, NULL));
+      g_print ("  found clip %s\n", name);
+    }
+  }
+
+  g_dir_close (dir);
+out:
+  g_pattern_spec_free (pspec);
+  g_free (pattern);
+  g_free (path);
+
+  return res;
+}
+
+static void
+delete_event_cb (GtkWidget * widget, GdkEvent * event, PlaybackApp * app)
+{
+  stop_cb (NULL, app);
+  gtk_main_quit ();
+}
+
+static void
+video_sink_activate_cb (GtkEntry * entry, PlaybackApp * app)
+{
+  GstElement *sink = NULL;
+  const gchar *text;
+
+  text = gtk_entry_get_text (entry);
+  if (text != NULL && *text != '\0') {
+    sink = gst_element_factory_make_or_warn (text, NULL);
+  }
+
+  g_object_set (app->pipeline, "video-sink", sink, NULL);
+}
+
+static void
+audio_sink_activate_cb (GtkEntry * entry, PlaybackApp * app)
+{
+  GstElement *sink = NULL;
+  const gchar *text;
+
+  text = gtk_entry_get_text (entry);
+  if (text != NULL && *text != '\0') {
+    sink = gst_element_factory_make_or_warn (text, NULL);
+  }
+
+  g_object_set (app->pipeline, "audio-sink", sink, NULL);
+}
+
+static void
+text_sink_activate_cb (GtkEntry * entry, PlaybackApp * app)
+{
+  GstElement *sink = NULL;
+  const gchar *text;
+
+  text = gtk_entry_get_text (entry);
+  if (text != NULL && *text != '\0') {
+    sink = gst_element_factory_make_or_warn (text, NULL);
+  }
+
+  g_object_set (app->pipeline, "text-sink", sink, NULL);
+}
+
+static void
+buffer_size_activate_cb (GtkEntry * entry, PlaybackApp * app)
+{
+  const gchar *text;
+
+  text = gtk_entry_get_text (entry);
+  if (text != NULL && *text != '\0') {
+    gint v;
+    gchar *endptr;
+
+    v = g_ascii_strtoll (text, &endptr, 10);
+    if (endptr != text && v != G_MAXINT64 && v != G_MININT64) {
+      g_object_set (app->pipeline, "buffer-size", v, NULL);
+    }
+  }
+}
+
+static void
+buffer_duration_activate_cb (GtkEntry * entry, PlaybackApp * app)
+{
+  const gchar *text;
+
+  text = gtk_entry_get_text (entry);
+  if (text != NULL && *text != '\0') {
+    gint64 v;
+    gchar *endptr;
+
+    v = g_ascii_strtoll (text, &endptr, 10);
+    if (endptr != text && v != G_MAXINT64 && v != G_MININT64) {
+      g_object_set (app->pipeline, "buffer-duration", v, NULL);
+    }
+  }
+}
+
+static void
+ringbuffer_maxsize_activate_cb (GtkEntry * entry, PlaybackApp * app)
+{
+  const gchar *text;
+
+  text = gtk_entry_get_text (entry);
+  if (text != NULL && *text != '\0') {
+    guint64 v;
+    gchar *endptr;
+
+    v = g_ascii_strtoull (text, &endptr, 10);
+    if (endptr != text && v != G_MAXUINT64) {
+      g_object_set (app->pipeline, "ring-buffer-max-size", v, NULL);
+    }
+  }
+}
+
+static void
+connection_speed_activate_cb (GtkEntry * entry, PlaybackApp * app)
+{
+  const gchar *text;
+
+  text = gtk_entry_get_text (entry);
+  if (text != NULL && *text != '\0') {
+    guint v;
+    gchar *endptr;
+
+    v = g_ascii_strtoll (text, &endptr, 10);
+    if (endptr != text && v != G_MAXINT64 && v != G_MININT64) {
+      g_object_set (app->pipeline, "connection-speed", v, NULL);
+    }
+  }
+}
+
+static void
+subtitle_encoding_activate_cb (GtkEntry * entry, PlaybackApp * app)
+{
+  const gchar *text;
+
+  text = gtk_entry_get_text (entry);
+  g_object_set (app->pipeline, "subtitle-encoding", text, NULL);
+}
+
+static void
+subtitle_fontdesc_cb (GtkFontButton * button, PlaybackApp * app)
+{
+  const gchar *text;
+
+  text = gtk_font_button_get_font_name (button);
+  g_object_set (app->pipeline, "subtitle-font-desc", text, NULL);
+}
+
+static void
+av_offset_activate_cb (GtkEntry * entry, PlaybackApp * app)
+{
+  const gchar *text;
+
+  text = gtk_entry_get_text (entry);
+  if (text != NULL && *text != '\0') {
+    gint64 v;
+    gchar *endptr;
+
+    v = g_ascii_strtoll (text, &endptr, 10);
+    if (endptr != text && v != G_MAXINT64 && v != G_MININT64) {
+      g_object_set (app->pipeline, "av-offset", v, NULL);
+    }
+  }
+}
+
+static void
+print_usage (int argc, char **argv)
+{
+  gint i;
+
+  g_print ("usage: %s <type> <filename>\n", argv[0]);
+  g_print ("   possible types:\n");
+
+  for (i = 0; i < G_N_ELEMENTS (pipelines); i++) {
+    g_print ("     %d = %s\n", i, pipelines[i].name);
+  }
+}
+
+static void
+create_ui (PlaybackApp * app)
+{
+  GtkWidget *hbox, *vbox, *seek, *playbin, *step, *navigation, *colorbalance;
+  GtkWidget *play_button, *pause_button, *stop_button;
+  GtkAdjustment *adjustment;
+
+  /* initialize gui elements ... */
+  app->window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+  app->video_window = gtk_drawing_area_new ();
+  g_signal_connect (app->video_window, "draw", G_CALLBACK (draw_cb), app);
+  g_signal_connect (app->video_window, "realize", G_CALLBACK (realize_cb), app);
+  g_signal_connect (app->video_window, "button-press-event",
+      G_CALLBACK (button_press_cb), app);
+  g_signal_connect (app->video_window, "button-release-event",
+      G_CALLBACK (button_release_cb), app);
+  g_signal_connect (app->video_window, "key-press-event",
+      G_CALLBACK (key_press_cb), app);
+  g_signal_connect (app->video_window, "key-release-event",
+      G_CALLBACK (key_release_cb), app);
+  g_signal_connect (app->video_window, "motion-notify-event",
+      G_CALLBACK (motion_notify_cb), app);
+  gtk_widget_set_can_focus (app->video_window, TRUE);
+  gtk_widget_set_double_buffered (app->video_window, FALSE);
+  gtk_widget_add_events (app->video_window,
+      GDK_POINTER_MOTION_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK
+      | GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK);
+
+  app->statusbar = gtk_statusbar_new ();
+  app->status_id =
+      gtk_statusbar_get_context_id (GTK_STATUSBAR (app->statusbar),
+      "playback-test");
+  gtk_statusbar_push (GTK_STATUSBAR (app->statusbar), app->status_id,
+      "Stopped");
+  hbox = gtk_hbox_new (FALSE, 0);
+  vbox = gtk_vbox_new (FALSE, 0);
+  gtk_container_set_border_width (GTK_CONTAINER (vbox), 3);
+
+  /* media controls */
+  play_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_PLAY);
+  pause_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_PAUSE);
+  stop_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_STOP);
+
+  /* seek expander */
+  {
+    GtkWidget *accurate_checkbox, *key_checkbox, *loop_checkbox,
+        *flush_checkbox;
+    GtkWidget *scrub_checkbox, *play_scrub_checkbox, *rate_label;
+    GtkWidget *skip_checkbox, *rate_spinbutton;
+    GtkWidget *flagtable, *advanced_seek, *advanced_seek_grid;
+    GtkWidget *duration_label, *position_label, *seek_button;
+
+    seek = gtk_expander_new ("seek options");
+    flagtable = gtk_grid_new ();
+    gtk_grid_set_row_spacing (GTK_GRID (flagtable), 2);
+    gtk_grid_set_row_homogeneous (GTK_GRID (flagtable), FALSE);
+    gtk_grid_set_column_spacing (GTK_GRID (flagtable), 2);
+    gtk_grid_set_column_homogeneous (GTK_GRID (flagtable), FALSE);
+
+    accurate_checkbox = gtk_check_button_new_with_label ("Accurate Playback");
+    key_checkbox = gtk_check_button_new_with_label ("Key-unit Playback");
+    loop_checkbox = gtk_check_button_new_with_label ("Loop");
+    flush_checkbox = gtk_check_button_new_with_label ("Flush");
+    scrub_checkbox = gtk_check_button_new_with_label ("Scrub");
+    play_scrub_checkbox = gtk_check_button_new_with_label ("Play Scrub");
+    skip_checkbox = gtk_check_button_new_with_label ("Play Skip");
+    rate_spinbutton = gtk_spin_button_new_with_range (-100, 100, 0.1);
+    gtk_spin_button_set_digits (GTK_SPIN_BUTTON (rate_spinbutton), 3);
+    rate_label = gtk_label_new ("Rate");
+
+    gtk_widget_set_tooltip_text (accurate_checkbox,
+        "accurate position is requested, this might be considerably slower for some formats");
+    gtk_widget_set_tooltip_text (key_checkbox,
+        "seek to the nearest keyframe. This might be faster but less accurate");
+    gtk_widget_set_tooltip_text (loop_checkbox, "loop playback");
+    gtk_widget_set_tooltip_text (flush_checkbox,
+        "flush pipeline after seeking");
+    gtk_widget_set_tooltip_text (rate_spinbutton,
+        "define the playback rate, " "negative value trigger reverse playback");
+    gtk_widget_set_tooltip_text (scrub_checkbox, "show images while seeking");
+    gtk_widget_set_tooltip_text (play_scrub_checkbox,
+        "play video while seeking");
+    gtk_widget_set_tooltip_text (skip_checkbox,
+        "Skip frames while playing at high frame rates");
+
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (flush_checkbox), TRUE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (scrub_checkbox), TRUE);
+
+    gtk_spin_button_set_value (GTK_SPIN_BUTTON (rate_spinbutton), app->rate);
+
+    g_signal_connect (G_OBJECT (accurate_checkbox), "toggled",
+        G_CALLBACK (accurate_toggle_cb), app);
+    g_signal_connect (G_OBJECT (key_checkbox), "toggled",
+        G_CALLBACK (key_toggle_cb), app);
+    g_signal_connect (G_OBJECT (loop_checkbox), "toggled",
+        G_CALLBACK (loop_toggle_cb), app);
+    g_signal_connect (G_OBJECT (flush_checkbox), "toggled",
+        G_CALLBACK (flush_toggle_cb), app);
+    g_signal_connect (G_OBJECT (scrub_checkbox), "toggled",
+        G_CALLBACK (scrub_toggle_cb), app);
+    g_signal_connect (G_OBJECT (play_scrub_checkbox), "toggled",
+        G_CALLBACK (play_scrub_toggle_cb), app);
+    g_signal_connect (G_OBJECT (skip_checkbox), "toggled",
+        G_CALLBACK (skip_toggle_cb), app);
+    g_signal_connect (G_OBJECT (rate_spinbutton), "value-changed",
+        G_CALLBACK (rate_spinbutton_changed_cb), app);
+
+    gtk_grid_attach (GTK_GRID (flagtable), accurate_checkbox, 0, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (flagtable), flush_checkbox, 1, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (flagtable), loop_checkbox, 2, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (flagtable), key_checkbox, 0, 1, 1, 1);
+    gtk_grid_attach (GTK_GRID (flagtable), scrub_checkbox, 1, 1, 1, 1);
+    gtk_grid_attach (GTK_GRID (flagtable), play_scrub_checkbox, 2, 1, 1, 1);
+    gtk_grid_attach (GTK_GRID (flagtable), skip_checkbox, 3, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (flagtable), rate_label, 4, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (flagtable), rate_spinbutton, 4, 1, 1, 1);
+
+    advanced_seek = gtk_frame_new ("Advanced Seeking");
+    advanced_seek_grid = gtk_grid_new ();
+    gtk_grid_set_row_spacing (GTK_GRID (advanced_seek_grid), 2);
+    gtk_grid_set_row_homogeneous (GTK_GRID (advanced_seek_grid), FALSE);
+    gtk_grid_set_column_spacing (GTK_GRID (advanced_seek_grid), 5);
+    gtk_grid_set_column_homogeneous (GTK_GRID (advanced_seek_grid), FALSE);
+
+    app->seek_format_combo = gtk_combo_box_text_new ();
+    g_signal_connect (app->seek_format_combo, "changed",
+        G_CALLBACK (seek_format_changed_cb), app);
+    gtk_grid_attach (GTK_GRID (advanced_seek_grid), app->seek_format_combo, 0,
+        0, 1, 1);
+
+    app->seek_entry = gtk_entry_new ();
+    gtk_entry_set_width_chars (GTK_ENTRY (app->seek_entry), 12);
+    gtk_grid_attach (GTK_GRID (advanced_seek_grid), app->seek_entry, 0, 1, 1,
+        1);
+
+    seek_button = gtk_button_new_with_label ("Seek");
+    g_signal_connect (G_OBJECT (seek_button), "clicked",
+        G_CALLBACK (advanced_seek_button_cb), app);
+    gtk_grid_attach (GTK_GRID (advanced_seek_grid), seek_button, 1, 0, 1, 1);
+
+    position_label = gtk_label_new ("Position:");
+    gtk_grid_attach (GTK_GRID (advanced_seek_grid), position_label, 2, 0, 1, 1);
+    duration_label = gtk_label_new ("Duration:");
+    gtk_grid_attach (GTK_GRID (advanced_seek_grid), duration_label, 2, 1, 1, 1);
+
+    app->seek_position_label = gtk_label_new ("-1");
+    gtk_grid_attach (GTK_GRID (advanced_seek_grid), app->seek_position_label, 3,
+        0, 1, 1);
+    app->seek_duration_label = gtk_label_new ("-1");
+    gtk_grid_attach (GTK_GRID (advanced_seek_grid), app->seek_duration_label, 3,
+        1, 1, 1);
+
+    gtk_container_add (GTK_CONTAINER (advanced_seek), advanced_seek_grid);
+    gtk_grid_attach (GTK_GRID (flagtable), advanced_seek, 0, 2, 3, 2);
+    gtk_container_add (GTK_CONTAINER (seek), flagtable);
+  }
+
+  /* step expander */
+  {
+    GtkWidget *hbox;
+    GtkWidget *step_button, *shuttle_checkbox;
+
+    step = gtk_expander_new ("step options");
+    hbox = gtk_hbox_new (FALSE, 0);
+
+    app->step_format_combo = gtk_combo_box_text_new ();
+    gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (app->step_format_combo),
+        "frames");
+    gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (app->step_format_combo),
+        "time (ms)");
+    gtk_combo_box_set_active (GTK_COMBO_BOX (app->step_format_combo), 0);
+    gtk_box_pack_start (GTK_BOX (hbox), app->step_format_combo, FALSE, FALSE,
+        2);
+
+    app->step_amount_spinbutton = gtk_spin_button_new_with_range (1, 1000, 1);
+    gtk_spin_button_set_digits (GTK_SPIN_BUTTON (app->step_amount_spinbutton),
+        0);
+    gtk_spin_button_set_value (GTK_SPIN_BUTTON (app->step_amount_spinbutton),
+        1.0);
+    gtk_box_pack_start (GTK_BOX (hbox), app->step_amount_spinbutton, FALSE,
+        FALSE, 2);
+
+    app->step_rate_spinbutton = gtk_spin_button_new_with_range (0.0, 100, 0.1);
+    gtk_spin_button_set_digits (GTK_SPIN_BUTTON (app->step_rate_spinbutton), 3);
+    gtk_spin_button_set_value (GTK_SPIN_BUTTON (app->step_rate_spinbutton),
+        1.0);
+    gtk_box_pack_start (GTK_BOX (hbox), app->step_rate_spinbutton, FALSE, FALSE,
+        2);
+
+    step_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_FORWARD);
+    gtk_button_set_label (GTK_BUTTON (step_button), "Step");
+    gtk_box_pack_start (GTK_BOX (hbox), step_button, FALSE, FALSE, 2);
+
+    g_signal_connect (G_OBJECT (step_button), "clicked", G_CALLBACK (step_cb),
+        app);
+
+    /* shuttle scale */
+    shuttle_checkbox = gtk_check_button_new_with_label ("Shuttle");
+    gtk_box_pack_start (GTK_BOX (hbox), shuttle_checkbox, FALSE, FALSE, 2);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (shuttle_checkbox), FALSE);
+    g_signal_connect (shuttle_checkbox, "toggled", G_CALLBACK (shuttle_toggled),
+        app);
+
+    adjustment =
+        GTK_ADJUSTMENT (gtk_adjustment_new (0.0, -3.00, 4.0, 0.1, 1.0, 1.0));
+    app->shuttle_scale = gtk_hscale_new (adjustment);
+    gtk_scale_set_digits (GTK_SCALE (app->shuttle_scale), 2);
+    gtk_scale_set_value_pos (GTK_SCALE (app->shuttle_scale), GTK_POS_TOP);
+    g_signal_connect (app->shuttle_scale, "value-changed",
+        G_CALLBACK (shuttle_value_changed), app);
+    g_signal_connect (app->shuttle_scale, "format_value",
+        G_CALLBACK (shuttle_format_value), app);
+
+    gtk_box_pack_start (GTK_BOX (hbox), app->shuttle_scale, TRUE, TRUE, 2);
+
+    gtk_container_add (GTK_CONTAINER (step), hbox);
+  }
+
+  /* navigation command expander */
+  {
+    GtkWidget *navigation_button;
+    GtkWidget *grid;
+    gint i = 0;
+
+    navigation = gtk_expander_new ("navigation commands");
+    grid = gtk_grid_new ();
+    gtk_grid_set_row_spacing (GTK_GRID (grid), 2);
+    gtk_grid_set_row_homogeneous (GTK_GRID (grid), FALSE);
+    gtk_grid_set_column_spacing (GTK_GRID (grid), 2);
+    gtk_grid_set_column_homogeneous (GTK_GRID (grid), FALSE);
+
+    navigation_button = gtk_button_new_with_label ("Menu 1");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i, 0, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    gtk_widget_set_tooltip_text (navigation_button, "DVD Menu");
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_MENU1;
+
+    navigation_button = gtk_button_new_with_label ("Menu 2");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i, 0, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    gtk_widget_set_tooltip_text (navigation_button, "DVD Title Menu");
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_MENU2;
+
+    navigation_button = gtk_button_new_with_label ("Menu 3");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i, 0, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    gtk_widget_set_tooltip_text (navigation_button, "DVD Root Menu");
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_MENU3;
+
+    navigation_button = gtk_button_new_with_label ("Menu 4");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i, 0, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    gtk_widget_set_tooltip_text (navigation_button, "DVD Subpicture Menu");
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_MENU4;
+
+    navigation_button = gtk_button_new_with_label ("Menu 5");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i, 0, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    gtk_widget_set_tooltip_text (navigation_button, "DVD Audio Menu");
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_MENU5;
+
+    navigation_button = gtk_button_new_with_label ("Menu 6");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i, 0, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    gtk_widget_set_tooltip_text (navigation_button, "DVD Angle Menu");
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_MENU6;
+
+    navigation_button = gtk_button_new_with_label ("Menu 7");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i, 0, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    gtk_widget_set_tooltip_text (navigation_button, "DVD Chapter Menu");
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_MENU7;
+
+    navigation_button = gtk_button_new_with_label ("Left");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i - 7, 1, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_LEFT;
+
+    navigation_button = gtk_button_new_with_label ("Right");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i - 7, 1, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_RIGHT;
+
+    navigation_button = gtk_button_new_with_label ("Up");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i - 7, 1, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_UP;
+
+    navigation_button = gtk_button_new_with_label ("Down");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i - 7, 1, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_DOWN;
+
+    navigation_button = gtk_button_new_with_label ("Activate");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i - 7, 1, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_ACTIVATE;
+
+    navigation_button = gtk_button_new_with_label ("Prev. Angle");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i - 7, 1, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_PREV_ANGLE;
+
+    navigation_button = gtk_button_new_with_label ("Next. Angle");
+    g_signal_connect (G_OBJECT (navigation_button), "clicked",
+        G_CALLBACK (navigation_cmd_cb), app);
+    gtk_grid_attach (GTK_GRID (grid), navigation_button, i - 7, 1, 1, 1);
+    gtk_widget_set_sensitive (navigation_button, FALSE);
+    app->navigation_buttons[i].button = navigation_button;
+    app->navigation_buttons[i++].cmd = GST_NAVIGATION_COMMAND_NEXT_ANGLE;
+
+    gtk_container_add (GTK_CONTAINER (navigation), grid);
+  }
+
+  /* colorbalance expander */
+  {
+    GtkWidget *vbox, *frame;
+
+    colorbalance = gtk_expander_new ("color balance options");
+    vbox = gtk_vbox_new (FALSE, 0);
+
+    /* contrast scale */
+    frame = gtk_frame_new ("Contrast");
+    adjustment =
+        GTK_ADJUSTMENT (gtk_adjustment_new (N_GRAD / 2.0, 0.00, N_GRAD, 0.1,
+            1.0, 1.0));
+    app->contrast_scale = gtk_hscale_new (adjustment);
+    gtk_scale_set_draw_value (GTK_SCALE (app->contrast_scale), FALSE);
+    g_signal_connect (app->contrast_scale, "value-changed",
+        G_CALLBACK (colorbalance_value_changed), app);
+    gtk_container_add (GTK_CONTAINER (frame), app->contrast_scale);
+    gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 2);
+
+    /* brightness scale */
+    frame = gtk_frame_new ("Brightness");
+    adjustment =
+        GTK_ADJUSTMENT (gtk_adjustment_new (N_GRAD / 2.0, 0.00, N_GRAD, 0.1,
+            1.0, 1.0));
+    app->brightness_scale = gtk_hscale_new (adjustment);
+    gtk_scale_set_draw_value (GTK_SCALE (app->brightness_scale), FALSE);
+    g_signal_connect (app->brightness_scale, "value-changed",
+        G_CALLBACK (colorbalance_value_changed), app);
+    gtk_container_add (GTK_CONTAINER (frame), app->brightness_scale);
+    gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 2);
+
+    /* hue scale */
+    frame = gtk_frame_new ("Hue");
+    adjustment =
+        GTK_ADJUSTMENT (gtk_adjustment_new (N_GRAD / 2.0, 0.00, N_GRAD, 0.1,
+            1.0, 1.0));
+    app->hue_scale = gtk_hscale_new (adjustment);
+    gtk_scale_set_draw_value (GTK_SCALE (app->hue_scale), FALSE);
+    g_signal_connect (app->hue_scale, "value-changed",
+        G_CALLBACK (colorbalance_value_changed), app);
+    gtk_container_add (GTK_CONTAINER (frame), app->hue_scale);
+    gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 2);
+
+    /* saturation scale */
+    frame = gtk_frame_new ("Saturation");
+    adjustment =
+        GTK_ADJUSTMENT (gtk_adjustment_new (N_GRAD / 2.0, 0.00, N_GRAD, 0.1,
+            1.0, 1.0));
+    app->saturation_scale = gtk_hscale_new (adjustment);
+    gtk_scale_set_draw_value (GTK_SCALE (app->saturation_scale), FALSE);
+    g_signal_connect (app->saturation_scale, "value-changed",
+        G_CALLBACK (colorbalance_value_changed), app);
+    gtk_container_add (GTK_CONTAINER (frame), app->saturation_scale);
+    gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 2);
+
+    gtk_container_add (GTK_CONTAINER (colorbalance), vbox);
+  }
+
+  /* seek bar */
+  adjustment =
+      GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.00, N_GRAD, 0.1, 1.0, 1.0));
+  app->seek_scale = gtk_hscale_new (adjustment);
+  gtk_scale_set_digits (GTK_SCALE (app->seek_scale), 2);
+  gtk_scale_set_value_pos (GTK_SCALE (app->seek_scale), GTK_POS_RIGHT);
+  gtk_range_set_show_fill_level (GTK_RANGE (app->seek_scale), TRUE);
+  gtk_range_set_fill_level (GTK_RANGE (app->seek_scale), N_GRAD);
+
+  g_signal_connect (app->seek_scale, "button_press_event",
+      G_CALLBACK (start_seek), app);
+  g_signal_connect (app->seek_scale, "button_release_event",
+      G_CALLBACK (stop_seek), app);
+  g_signal_connect (app->seek_scale, "format_value", G_CALLBACK (format_value),
+      app);
+
+  if (app->pipeline_type == 0) {
+    GtkWidget *pb2vbox, *boxes, *boxes2, *panel, *boxes3;
+    GtkWidget *volume_label, *shot_button;
+    GtkWidget *label;
+
+    playbin = gtk_expander_new ("playbin2 options");
+    /* the playbin2 panel controls for the video/audio/subtitle tracks */
+    panel = gtk_hbox_new (FALSE, 0);
+    app->video_combo = gtk_combo_box_text_new ();
+    app->audio_combo = gtk_combo_box_text_new ();
+    app->text_combo = gtk_combo_box_text_new ();
+    gtk_widget_set_sensitive (app->video_combo, FALSE);
+    gtk_widget_set_sensitive (app->audio_combo, FALSE);
+    gtk_widget_set_sensitive (app->text_combo, FALSE);
+    gtk_box_pack_start (GTK_BOX (panel), app->video_combo, TRUE, TRUE, 2);
+    gtk_box_pack_start (GTK_BOX (panel), app->audio_combo, TRUE, TRUE, 2);
+    gtk_box_pack_start (GTK_BOX (panel), app->text_combo, TRUE, TRUE, 2);
+    g_signal_connect (G_OBJECT (app->video_combo), "changed",
+        G_CALLBACK (video_combo_cb), app);
+    g_signal_connect (G_OBJECT (app->audio_combo), "changed",
+        G_CALLBACK (audio_combo_cb), app);
+    g_signal_connect (G_OBJECT (app->text_combo), "changed",
+        G_CALLBACK (text_combo_cb), app);
+    /* playbin2 panel for flag checkboxes and volume/mute */
+    boxes = gtk_grid_new ();
+    gtk_grid_set_row_spacing (GTK_GRID (boxes), 2);
+    gtk_grid_set_row_homogeneous (GTK_GRID (boxes), FALSE);
+    gtk_grid_set_column_spacing (GTK_GRID (boxes), 2);
+    gtk_grid_set_column_homogeneous (GTK_GRID (boxes), FALSE);
+
+    app->video_checkbox = gtk_check_button_new_with_label ("Video");
+    app->audio_checkbox = gtk_check_button_new_with_label ("Audio");
+    app->text_checkbox = gtk_check_button_new_with_label ("Text");
+    app->vis_checkbox = gtk_check_button_new_with_label ("Vis");
+    app->soft_volume_checkbox = gtk_check_button_new_with_label ("Soft Volume");
+    app->native_audio_checkbox =
+        gtk_check_button_new_with_label ("Native Audio");
+    app->native_video_checkbox =
+        gtk_check_button_new_with_label ("Native Video");
+    app->download_checkbox = gtk_check_button_new_with_label ("Download");
+    app->buffering_checkbox = gtk_check_button_new_with_label ("Buffering");
+    app->deinterlace_checkbox = gtk_check_button_new_with_label ("Deinterlace");
+    app->soft_colorbalance_checkbox =
+        gtk_check_button_new_with_label ("Soft Colorbalance");
+    app->mute_checkbox = gtk_check_button_new_with_label ("Mute");
+    volume_label = gtk_label_new ("Volume");
+    app->volume_spinbutton = gtk_spin_button_new_with_range (0, 10.0, 0.1);
+
+    gtk_grid_attach (GTK_GRID (boxes), app->video_checkbox, 0, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->audio_checkbox, 1, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->text_checkbox, 2, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->vis_checkbox, 3, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->soft_volume_checkbox, 4, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->native_audio_checkbox, 5, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->native_video_checkbox, 0, 1, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->download_checkbox, 1, 1, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->buffering_checkbox, 2, 1, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->deinterlace_checkbox, 3, 1, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->soft_colorbalance_checkbox, 4, 1, 1,
+        1);
+
+    gtk_grid_attach (GTK_GRID (boxes), app->mute_checkbox, 6, 0, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), volume_label, 5, 1, 1, 1);
+    gtk_grid_attach (GTK_GRID (boxes), app->volume_spinbutton, 6, 1, 1, 1);
+
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (app->video_checkbox),
+        TRUE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (app->audio_checkbox),
+        TRUE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (app->text_checkbox), TRUE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (app->vis_checkbox), FALSE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (app->soft_volume_checkbox),
+        TRUE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON
+        (app->native_audio_checkbox), FALSE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON
+        (app->native_video_checkbox), FALSE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (app->download_checkbox),
+        FALSE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (app->buffering_checkbox),
+        FALSE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (app->deinterlace_checkbox),
+        FALSE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON
+        (app->soft_colorbalance_checkbox), TRUE);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (app->mute_checkbox),
+        FALSE);
+    gtk_spin_button_set_value (GTK_SPIN_BUTTON (app->volume_spinbutton), 1.0);
+
+    g_signal_connect (G_OBJECT (app->video_checkbox), "toggled",
+        G_CALLBACK (video_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->audio_checkbox), "toggled",
+        G_CALLBACK (audio_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->text_checkbox), "toggled",
+        G_CALLBACK (text_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->vis_checkbox), "toggled",
+        G_CALLBACK (vis_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->soft_volume_checkbox), "toggled",
+        G_CALLBACK (soft_volume_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->native_audio_checkbox), "toggled",
+        G_CALLBACK (native_audio_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->native_video_checkbox), "toggled",
+        G_CALLBACK (native_video_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->download_checkbox), "toggled",
+        G_CALLBACK (download_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->buffering_checkbox), "toggled",
+        G_CALLBACK (buffering_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->deinterlace_checkbox), "toggled",
+        G_CALLBACK (deinterlace_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->soft_colorbalance_checkbox), "toggled",
+        G_CALLBACK (soft_colorbalance_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->mute_checkbox), "toggled",
+        G_CALLBACK (mute_toggle_cb), app);
+    g_signal_connect (G_OBJECT (app->volume_spinbutton), "value-changed",
+        G_CALLBACK (volume_spinbutton_changed_cb), app);
+    /* playbin2 panel for snapshot */
+    boxes2 = gtk_hbox_new (FALSE, 0);
+    shot_button = gtk_button_new_from_stock (GTK_STOCK_SAVE);
+    gtk_widget_set_tooltip_text (shot_button,
+        "save a screenshot .png in the current directory");
+    g_signal_connect (G_OBJECT (shot_button), "clicked", G_CALLBACK (shot_cb),
+        app);
+    app->vis_combo = gtk_combo_box_text_new ();
+    g_signal_connect (G_OBJECT (app->vis_combo), "changed",
+        G_CALLBACK (vis_combo_cb), app);
+    gtk_widget_set_sensitive (app->vis_combo, FALSE);
+    gtk_box_pack_start (GTK_BOX (boxes2), shot_button, TRUE, TRUE, 2);
+    gtk_box_pack_start (GTK_BOX (boxes2), app->vis_combo, TRUE, TRUE, 2);
+
+    /* fill the vis combo box and the array of factories */
+    init_visualization_features (app);
+
+    /* Grid with other properties */
+    boxes3 = gtk_grid_new ();
+    gtk_grid_set_row_spacing (GTK_GRID (boxes3), 2);
+    gtk_grid_set_row_homogeneous (GTK_GRID (boxes3), FALSE);
+    gtk_grid_set_column_spacing (GTK_GRID (boxes3), 2);
+    gtk_grid_set_column_homogeneous (GTK_GRID (boxes3), FALSE);
+
+    label = gtk_label_new ("Video sink");
+    gtk_grid_attach (GTK_GRID (boxes3), label, 0, 0, 1, 1);
+    app->video_sink_entry = gtk_entry_new ();
+    g_signal_connect (app->video_sink_entry, "activate",
+        G_CALLBACK (video_sink_activate_cb), app);
+    gtk_grid_attach (GTK_GRID (boxes3), app->video_sink_entry, 0, 1, 1, 1);
+
+    label = gtk_label_new ("Audio sink");
+    gtk_grid_attach (GTK_GRID (boxes3), label, 1, 0, 1, 1);
+    app->audio_sink_entry = gtk_entry_new ();
+    g_signal_connect (app->audio_sink_entry, "activate",
+        G_CALLBACK (audio_sink_activate_cb), app);
+    gtk_grid_attach (GTK_GRID (boxes3), app->audio_sink_entry, 1, 1, 1, 1);
+
+    label = gtk_label_new ("Text sink");
+    gtk_grid_attach (GTK_GRID (boxes3), label, 2, 0, 1, 1);
+    app->text_sink_entry = gtk_entry_new ();
+    g_signal_connect (app->text_sink_entry, "activate",
+        G_CALLBACK (text_sink_activate_cb), app);
+    gtk_grid_attach (GTK_GRID (boxes3), app->text_sink_entry, 2, 1, 1, 1);
+
+    label = gtk_label_new ("Buffer Size");
+    gtk_grid_attach (GTK_GRID (boxes3), label, 0, 2, 1, 1);
+    app->buffer_size_entry = gtk_entry_new ();
+    gtk_entry_set_text (GTK_ENTRY (app->buffer_size_entry), "-1");
+    g_signal_connect (app->buffer_size_entry, "activate",
+        G_CALLBACK (buffer_size_activate_cb), app);
+    gtk_grid_attach (GTK_GRID (boxes3), app->buffer_size_entry, 0, 3, 1, 1);
+
+    label = gtk_label_new ("Buffer Duration");
+    gtk_grid_attach (GTK_GRID (boxes3), label, 1, 2, 1, 1);
+    app->buffer_duration_entry = gtk_entry_new ();
+    gtk_entry_set_text (GTK_ENTRY (app->buffer_duration_entry), "-1");
+    g_signal_connect (app->buffer_duration_entry, "activate",
+        G_CALLBACK (buffer_duration_activate_cb), app);
+    gtk_grid_attach (GTK_GRID (boxes3), app->buffer_duration_entry, 1, 3, 1, 1);
+
+    label = gtk_label_new ("Ringbuffer Max Size");
+    gtk_grid_attach (GTK_GRID (boxes3), label, 2, 2, 1, 1);
+    app->ringbuffer_maxsize_entry = gtk_entry_new ();
+    gtk_entry_set_text (GTK_ENTRY (app->ringbuffer_maxsize_entry), "0");
+    g_signal_connect (app->ringbuffer_maxsize_entry, "activate",
+        G_CALLBACK (ringbuffer_maxsize_activate_cb), app);
+    gtk_grid_attach (GTK_GRID (boxes3), app->ringbuffer_maxsize_entry, 2, 3, 1,
+        1);
+
+    label = gtk_label_new ("Connection Speed");
+    gtk_grid_attach (GTK_GRID (boxes3), label, 3, 2, 1, 1);
+    app->connection_speed_entry = gtk_entry_new ();
+    gtk_entry_set_text (GTK_ENTRY (app->connection_speed_entry), "0");
+    g_signal_connect (app->connection_speed_entry, "activate",
+        G_CALLBACK (connection_speed_activate_cb), app);
+    gtk_grid_attach (GTK_GRID (boxes3), app->connection_speed_entry, 3, 3, 1,
+        1);
+
+    label = gtk_label_new ("A/V offset");
+    gtk_grid_attach (GTK_GRID (boxes3), label, 4, 2, 1, 1);
+    app->av_offset_entry = gtk_entry_new ();
+    g_signal_connect (app->av_offset_entry, "activate",
+        G_CALLBACK (av_offset_activate_cb), app);
+    gtk_entry_set_text (GTK_ENTRY (app->av_offset_entry), "0");
+    g_signal_connect (app->av_offset_entry, "activate",
+        G_CALLBACK (av_offset_activate_cb), app);
+    gtk_grid_attach (GTK_GRID (boxes3), app->av_offset_entry, 4, 3, 1, 1);
+
+    label = gtk_label_new ("Subtitle Encoding");
+    gtk_grid_attach (GTK_GRID (boxes3), label, 0, 4, 1, 1);
+    app->subtitle_encoding_entry = gtk_entry_new ();
+    g_signal_connect (app->subtitle_encoding_entry, "activate",
+        G_CALLBACK (subtitle_encoding_activate_cb), app);
+    gtk_grid_attach (GTK_GRID (boxes3), app->subtitle_encoding_entry, 0, 5, 1,
+        1);
+
+    label = gtk_label_new ("Subtitle Fontdesc");
+    gtk_grid_attach (GTK_GRID (boxes3), label, 1, 4, 1, 1);
+    app->subtitle_fontdesc_button = gtk_font_button_new ();
+    g_signal_connect (app->subtitle_fontdesc_button, "font-set",
+        G_CALLBACK (subtitle_fontdesc_cb), app);
+    gtk_grid_attach (GTK_GRID (boxes3), app->subtitle_fontdesc_button, 1, 5, 1,
+        1);
+
+    pb2vbox = gtk_vbox_new (FALSE, 0);
+    gtk_box_pack_start (GTK_BOX (pb2vbox), panel, FALSE, FALSE, 2);
+    gtk_box_pack_start (GTK_BOX (pb2vbox), boxes, FALSE, FALSE, 2);
+    gtk_box_pack_start (GTK_BOX (pb2vbox), boxes2, FALSE, FALSE, 2);
+    gtk_box_pack_start (GTK_BOX (pb2vbox), boxes3, FALSE, FALSE, 2);
+    gtk_container_add (GTK_CONTAINER (playbin), pb2vbox);
+  } else {
+    playbin = NULL;
+  }
+
+  /* do the packing stuff ... */
+  gtk_window_set_default_size (GTK_WINDOW (app->window), 250, 96);
+  /* FIXME: can we avoid this for audio only? */
+  gtk_widget_set_size_request (GTK_WIDGET (app->video_window), -1,
+      DEFAULT_VIDEO_HEIGHT);
+  gtk_container_add (GTK_CONTAINER (app->window), vbox);
+  gtk_box_pack_start (GTK_BOX (vbox), app->video_window, TRUE, TRUE, 2);
+  gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (hbox), play_button, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (hbox), pause_button, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (hbox), stop_button, FALSE, FALSE, 2);
+
+  gtk_box_pack_start (GTK_BOX (vbox), seek, FALSE, FALSE, 2);
+  if (playbin)
+    gtk_box_pack_start (GTK_BOX (vbox), playbin, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (vbox), step, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (vbox), navigation, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (vbox), colorbalance, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (vbox), gtk_hseparator_new (), FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (vbox), app->seek_scale, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (vbox), app->statusbar, FALSE, FALSE, 2);
+
+  /* connect things ... */
+  g_signal_connect (G_OBJECT (play_button), "clicked", G_CALLBACK (play_cb),
+      app);
+  g_signal_connect (G_OBJECT (pause_button), "clicked", G_CALLBACK (pause_cb),
+      app);
+  g_signal_connect (G_OBJECT (stop_button), "clicked", G_CALLBACK (stop_cb),
+      app);
+
+  g_signal_connect (G_OBJECT (app->window), "delete-event",
+      G_CALLBACK (delete_event_cb), app);
+}
+
+static void
+set_defaults (PlaybackApp * app)
+{
+  memset (app, 0, sizeof (PlaybackApp));
+
+  app->flush_seek = TRUE;
+  app->scrub = TRUE;
+  app->rate = 1.0;
+
+  app->position = app->duration = -1;
+  app->state = GST_STATE_NULL;
+
+  app->need_streams = TRUE;
+
+  g_static_mutex_init (&app->state_mutex);
+
+  app->play_rate = 1.0;
+}
+
+static void
+reset_app (PlaybackApp * app)
+{
+  g_free (app->audiosink_str);
+  g_free (app->videosink_str);
+
+  g_list_free (app->formats);
+
+  g_static_mutex_free (&app->state_mutex);
+
+  if (app->xoverlay_element)
+    gst_object_unref (app->xoverlay_element);
+  if (app->navigation_element)
+    gst_object_unref (app->navigation_element);
+
+  g_list_foreach (app->paths, (GFunc) g_free, NULL);
+  g_list_free (app->paths);
+  g_list_foreach (app->sub_paths, (GFunc) g_free, NULL);
+  g_list_free (app->sub_paths);
+
+  g_print ("free pipeline\n");
+  gst_object_unref (app->pipeline);
+}
+
+int
+main (int argc, char **argv)
+{
+  PlaybackApp app;
+  GOptionEntry options[] = {
+    {"stats", 's', 0, G_OPTION_ARG_NONE, &app.stats,
+        "Show pad stats", NULL},
+    {"verbose", 'v', 0, G_OPTION_ARG_NONE, &app.verbose,
+        "Verbose properties", NULL},
+    {NULL}
+  };
+  GOptionContext *ctx;
+  GError *err = NULL;
+
+  set_defaults (&app);
+
+#if !GLIB_CHECK_VERSION (2, 31, 0)
+  if (!g_thread_supported ())
+    g_thread_init (NULL);
+#endif
+
+  ctx = g_option_context_new ("- playback testing in gsteamer");
+  g_option_context_add_main_entries (ctx, options, NULL);
+  g_option_context_add_group (ctx, gst_init_get_option_group ());
+  g_option_context_add_group (ctx, gtk_get_option_group (TRUE));
+
+  if (!g_option_context_parse (ctx, &argc, &argv, &err)) {
+    g_print ("Error initializing: %s\n", err->message);
+    exit (1);
+  }
+
+  GST_DEBUG_CATEGORY_INIT (playback_debug, "playback-test", 0,
+      "playback example");
+
+  if (argc < 3) {
+    print_usage (argc, argv);
+    exit (-1);
+  }
+
+  app.pipeline_type = atoi (argv[1]);
+
+  if (app.pipeline_type < 0 || app.pipeline_type >= G_N_ELEMENTS (pipelines)) {
+    print_usage (argc, argv);
+    exit (-1);
+  }
+
+  app.pipeline_spec = argv[2];
+
+  if (g_path_is_absolute (app.pipeline_spec) &&
+      (g_strrstr (app.pipeline_spec, "*") != NULL ||
+          g_strrstr (app.pipeline_spec, "?") != NULL)) {
+    app.paths = handle_wildcards (app.pipeline_spec);
+  } else {
+    app.paths = g_list_prepend (app.paths, g_strdup (app.pipeline_spec));
+  }
+
+  if (!app.paths) {
+    g_print ("opening %s failed\n", app.pipeline_spec);
+    exit (-1);
+  }
+
+  app.current_path = app.paths;
+
+  if (argc > 3 && argv[3]) {
+    if (g_path_is_absolute (argv[3]) &&
+        (g_strrstr (argv[3], "*") != NULL ||
+            g_strrstr (argv[3], "?") != NULL)) {
+      app.sub_paths = handle_wildcards (argv[3]);
+    } else {
+      app.sub_paths = g_list_prepend (app.sub_paths, g_strdup (argv[3]));
+    }
+
+    if (!app.sub_paths) {
+      g_print ("opening %s failed\n", argv[3]);
+      exit (-1);
+    }
+
+    app.current_sub_path = app.sub_paths;
+  }
+
+  pipelines[app.pipeline_type].func (&app, app.current_path->data);
+  g_assert (app.pipeline);
+
+  create_ui (&app);
+
+  /* show the gui. */
+  gtk_widget_show_all (app.window);
+
+  /* realize window now so that the video window gets created and we can
+   * obtain its XID before the pipeline is started up and the videosink
+   * asks for the XID of the window to render onto */
+  gtk_widget_realize (app.window);
+
+#if defined (GDK_WINDOWING_X11) || defined (GDK_WINDOWING_WIN32) || defined (GDK_WINDOWING_QUARTZ)
+  /* we should have the XID now */
+  g_assert (app.embed_xid != 0);
+
+  if (app.pipeline_type == 0) {
+    gst_x_overlay_set_window_handle (GST_X_OVERLAY (app.pipeline),
+        app.embed_xid);
+  }
+#endif
+
+  if (app.verbose) {
+    g_signal_connect (app.pipeline, "deep_notify",
+        G_CALLBACK (gst_object_default_deep_notify), NULL);
+  }
+
+  connect_bus_signals (&app);
+
+  gtk_main ();
+
+  g_print ("NULL pipeline\n");
+  gst_element_set_state (app.pipeline, GST_STATE_NULL);
+
+  reset_app (&app);
+
+  return 0;
+}
diff --git a/tests/examples/seek/Makefile.am b/tests/examples/seek/Makefile.am
index ae34780..4fe8955 100644
--- a/tests/examples/seek/Makefile.am
+++ b/tests/examples/seek/Makefile.am
@@ -1,8 +1,8 @@
 if HAVE_GTK_X11
 if HAVE_LINUX_JOYSTICK_HEADERS
-GTK_EXAMPLES=seek scrubby jsseek
+GTK_EXAMPLES=scrubby jsseek
 else
-GTK_EXAMPLES=seek scrubby
+GTK_EXAMPLES=scrubby
 endif
 endif
 
diff --git a/tests/examples/seek/jsseek.c b/tests/examples/seek/jsseek.c
index fd16c54..a2e2ae5 100644
--- a/tests/examples/seek/jsseek.c
+++ b/tests/examples/seek/jsseek.c
@@ -24,6 +24,9 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GTK versions (>= 3.3.0) */
+#define GDK_DISABLE_DEPRECATION_WARNINGS
 
 #include <glib.h>
 #include <glib/gstdio.h>
diff --git a/tests/examples/seek/scrubby.c b/tests/examples/seek/scrubby.c
index 501d559..53a28d5 100644
--- a/tests/examples/seek/scrubby.c
+++ b/tests/examples/seek/scrubby.c
@@ -1,3 +1,9 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GTK versions (>= 3.3.0) */
+#define GDK_DISABLE_DEPRECATION_WARNINGS
 #include <stdlib.h>
 #include <glib.h>
 #include <gtk/gtk.h>
diff --git a/tests/examples/seek/seek.c b/tests/examples/seek/seek.c
deleted file mode 100644
index 60c0997..0000000
--- a/tests/examples/seek/seek.c
+++ /dev/null
@@ -1,3030 +0,0 @@
-/* GStreamer
- *
- * seek.c: seeking sample application
- *
- * Copyright (C) 2005 Wim Taymans <wim@fluendo.com>
- *               2006 Stefan Kost <ensonic@users.sf.net>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <stdlib.h>
-#include <math.h>
-#include <glib.h>
-#include <gtk/gtk.h>
-#include <gst/gst.h>
-#include <string.h>
-
-#include <gdk/gdk.h>
-#if defined (GDK_WINDOWING_X11)
-#include <gdk/gdkx.h>
-#elif defined (GDK_WINDOWING_WIN32)
-#include <gdk/gdkwin32.h>
-#endif
-
-#include <gst/interfaces/xoverlay.h>
-
-GST_DEBUG_CATEGORY_STATIC (seek_debug);
-#define GST_CAT_DEFAULT (seek_debug)
-
-/* configuration */
-
-#define SOURCE "filesrc"
-
-static gchar *opt_audiosink_str;        /* NULL */
-static gchar *opt_videosink_str;        /* NULL */
-
-#define FILL_INTERVAL 100
-//#define UPDATE_INTERVAL 500
-//#define UPDATE_INTERVAL 100
-#define UPDATE_INTERVAL 40
-
-/* number of milliseconds to play for after a seek */
-#define SCRUB_TIME 100
-
-/* timeout for gst_element_get_state() after a seek */
-#define SEEK_TIMEOUT 40 * GST_MSECOND
-
-#define DEFAULT_VIDEO_HEIGHT 300
-
-/* the state to go to when stop is pressed */
-#define STOP_STATE      GST_STATE_READY
-
-#define N_GRAD 1000.0
-
-static GList *seekable_pads = NULL;
-static GList *rate_pads = NULL;
-static GList *seekable_elements = NULL;
-
-static gboolean accurate_seek = FALSE;
-static gboolean keyframe_seek = FALSE;
-static gboolean loop_seek = FALSE;
-static gboolean flush_seek = TRUE;
-static gboolean scrub = TRUE;
-static gboolean play_scrub = FALSE;
-static gboolean skip_seek = FALSE;
-static gdouble rate = 1.0;
-
-static GstElement *pipeline;
-static gint pipeline_type;
-static const gchar *pipeline_spec;
-static gint64 position = -1;
-static gint64 duration = -1;
-static GtkAdjustment *adjustment;
-static GtkWidget *hscale, *statusbar;
-static guint status_id = 0;
-static gboolean stats = FALSE;
-static gboolean elem_seek = FALSE;
-static gboolean verbose = FALSE;
-
-static gboolean is_live = FALSE;
-static gboolean buffering = FALSE;
-static GstBufferingMode mode;
-static gint64 buffering_left;
-static GstState state = GST_STATE_NULL;
-static guint update_id = 0;
-static guint seek_timeout_id = 0;
-static gulong changed_id;
-static guint fill_id = 0;
-
-static gint n_video = 0, n_audio = 0, n_text = 0;
-static gboolean need_streams = TRUE;
-static GtkWidget *video_combo, *audio_combo, *text_combo, *vis_combo;
-static GtkWidget *vis_checkbox, *video_checkbox, *audio_checkbox;
-static GtkWidget *text_checkbox, *mute_checkbox, *volume_spinbutton;
-static GtkWidget *skip_checkbox, *video_window, *download_checkbox;
-static GtkWidget *buffer_checkbox, *rate_spinbutton;
-
-static GStaticMutex state_mutex = G_STATIC_MUTEX_INIT;
-
-static GtkWidget *format_combo, *step_amount_spinbutton, *step_rate_spinbutton;
-static GtkWidget *shuttle_checkbox, *step_button;
-static GtkWidget *shuttle_hscale;
-static GtkAdjustment *shuttle_adjustment;
-
-static GList *paths = NULL, *l = NULL;
-
-/* we keep an array of the visualisation entries so that we can easily switch
- * with the combo box index. */
-typedef struct
-{
-  GstElementFactory *factory;
-} VisEntry;
-
-static GArray *vis_entries;
-
-static void clear_streams (GstElement * pipeline);
-static void volume_notify_cb (GstElement * pipeline, GParamSpec * arg,
-    gpointer user_dat);
-
-/* pipeline construction */
-
-typedef struct
-{
-  const gchar *padname;
-  GstPad *target;
-  GstElement *bin;
-}
-dyn_link;
-
-static GstElement *
-gst_element_factory_make_or_warn (const gchar * type, const gchar * name)
-{
-  GstElement *element = gst_element_factory_make (type, name);
-
-#ifndef GST_DISABLE_PARSE
-  if (!element) {
-    /* Try parsing it as a pipeline description */
-    element = gst_parse_bin_from_description (type, TRUE, NULL);
-    if (element) {
-      gst_element_set_name (element, name);
-    }
-  }
-#endif
-
-  if (!element) {
-    g_warning ("Failed to create element %s of type %s", name, type);
-  }
-
-  return element;
-}
-
-static void
-dynamic_link (GstPadTemplate * templ, GstPad * newpad, gpointer data)
-{
-  gchar *padname;
-  dyn_link *connect = (dyn_link *) data;
-
-  padname = gst_pad_get_name (newpad);
-
-  if (connect->padname == NULL || !strcmp (padname, connect->padname)) {
-    if (connect->bin)
-      gst_bin_add (GST_BIN (pipeline), connect->bin);
-    gst_pad_link (newpad, connect->target);
-
-    //seekable_pads = g_list_prepend (seekable_pads, newpad);
-    rate_pads = g_list_prepend (rate_pads, newpad);
-  }
-  g_free (padname);
-}
-
-static void
-setup_dynamic_link (GstElement * element, const gchar * padname,
-    GstPad * target, GstElement * bin)
-{
-  dyn_link *connect;
-
-  connect = g_new0 (dyn_link, 1);
-  connect->padname = g_strdup (padname);
-  connect->target = target;
-  connect->bin = bin;
-
-  g_signal_connect (G_OBJECT (element), "pad-added", G_CALLBACK (dynamic_link),
-      connect);
-}
-
-static GstElement *
-make_mod_pipeline (const gchar * location)
-{
-  GstElement *pipeline;
-  GstElement *src, *decoder, *audiosink;
-  GstPad *seekable;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  decoder = gst_element_factory_make_or_warn ("modplug", "decoder");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "sink");
-  //g_object_set (G_OBJECT (audiosink), "sync", FALSE, NULL);
-
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), decoder);
-  gst_bin_add (GST_BIN (pipeline), audiosink);
-
-  gst_element_link (src, decoder);
-  gst_element_link (decoder, audiosink);
-
-  seekable = gst_element_get_static_pad (decoder, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (decoder, "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_dv_pipeline (const gchar * location)
-{
-  GstElement *pipeline;
-  GstElement *src, *demux, *decoder, *audiosink, *videosink;
-  GstElement *a_queue, *v_queue;
-  GstPad *seekable;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  demux = gst_element_factory_make_or_warn ("dvdemux", "demuxer");
-  v_queue = gst_element_factory_make_or_warn ("queue", "v_queue");
-  decoder = gst_element_factory_make_or_warn ("ffdec_dvvideo", "decoder");
-  videosink = gst_element_factory_make_or_warn (opt_videosink_str, "v_sink");
-  a_queue = gst_element_factory_make_or_warn ("queue", "a_queue");
-  audiosink = gst_element_factory_make_or_warn ("alsasink", "a_sink");
-
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), demux);
-  gst_bin_add (GST_BIN (pipeline), a_queue);
-  gst_bin_add (GST_BIN (pipeline), audiosink);
-  gst_bin_add (GST_BIN (pipeline), v_queue);
-  gst_bin_add (GST_BIN (pipeline), decoder);
-  gst_bin_add (GST_BIN (pipeline), videosink);
-
-  gst_element_link (src, demux);
-  gst_element_link (a_queue, audiosink);
-  gst_element_link (v_queue, decoder);
-  gst_element_link (decoder, videosink);
-
-  setup_dynamic_link (demux, "video", gst_element_get_static_pad (v_queue,
-          "sink"), NULL);
-  setup_dynamic_link (demux, "audio", gst_element_get_static_pad (a_queue,
-          "sink"), NULL);
-
-  seekable = gst_element_get_static_pad (decoder, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-
-  return pipeline;
-}
-
-static GstElement *
-make_wav_pipeline (const gchar * location)
-{
-  GstElement *pipeline;
-  GstElement *src, *decoder, *audiosink;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  decoder = gst_element_factory_make_or_warn ("wavparse", "decoder");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "sink");
-
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), decoder);
-  gst_bin_add (GST_BIN (pipeline), audiosink);
-
-  gst_element_link (src, decoder);
-
-  setup_dynamic_link (decoder, "src", gst_element_get_static_pad (audiosink,
-          "sink"), NULL);
-
-  seekable_elements = g_list_prepend (seekable_elements, audiosink);
-
-  /* force element seeking on this pipeline */
-  elem_seek = TRUE;
-
-  return pipeline;
-}
-
-static GstElement *
-make_flac_pipeline (const gchar * location)
-{
-  GstElement *pipeline;
-  GstElement *src, *decoder, *audiosink;
-  GstPad *seekable;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  decoder = gst_element_factory_make_or_warn ("flacdec", "decoder");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "sink");
-  g_object_set (G_OBJECT (audiosink), "sync", FALSE, NULL);
-
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), decoder);
-  gst_bin_add (GST_BIN (pipeline), audiosink);
-
-  gst_element_link (src, decoder);
-  gst_element_link (decoder, audiosink);
-
-  seekable = gst_element_get_static_pad (decoder, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (decoder, "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_sid_pipeline (const gchar * location)
-{
-  GstElement *pipeline;
-  GstElement *src, *decoder, *audiosink;
-  GstPad *seekable;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  decoder = gst_element_factory_make_or_warn ("siddec", "decoder");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "sink");
-  //g_object_set (G_OBJECT (audiosink), "sync", FALSE, NULL);
-
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), decoder);
-  gst_bin_add (GST_BIN (pipeline), audiosink);
-
-  gst_element_link (src, decoder);
-  gst_element_link (decoder, audiosink);
-
-  seekable = gst_element_get_static_pad (decoder, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (decoder, "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_parse_pipeline (const gchar * location)
-{
-  GstElement *pipeline;
-  GstElement *src, *parser, *fakesink;
-  GstPad *seekable;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  parser = gst_element_factory_make_or_warn ("mpegparse", "parse");
-  fakesink = gst_element_factory_make_or_warn ("fakesink", "sink");
-  g_object_set (G_OBJECT (fakesink), "silent", TRUE, NULL);
-  g_object_set (G_OBJECT (fakesink), "sync", TRUE, NULL);
-
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), parser);
-  gst_bin_add (GST_BIN (pipeline), fakesink);
-
-  gst_element_link (src, parser);
-  gst_element_link (parser, fakesink);
-
-  seekable = gst_element_get_static_pad (parser, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (parser, "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_vorbis_pipeline (const gchar * location)
-{
-  GstElement *pipeline, *audio_bin;
-  GstElement *src, *demux, *decoder, *convert, *audiosink;
-  GstPad *pad, *seekable;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  demux = gst_element_factory_make_or_warn ("oggdemux", "demux");
-  decoder = gst_element_factory_make_or_warn ("vorbisdec", "decoder");
-  convert = gst_element_factory_make_or_warn ("audioconvert", "convert");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "sink");
-  g_object_set (G_OBJECT (audiosink), "sync", TRUE, NULL);
-
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  audio_bin = gst_bin_new ("a_decoder_bin");
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), demux);
-  gst_bin_add (GST_BIN (audio_bin), decoder);
-  gst_bin_add (GST_BIN (audio_bin), convert);
-  gst_bin_add (GST_BIN (audio_bin), audiosink);
-  gst_bin_add (GST_BIN (pipeline), audio_bin);
-
-  gst_element_link (src, demux);
-  gst_element_link (decoder, convert);
-  gst_element_link (convert, audiosink);
-
-  pad = gst_element_get_static_pad (decoder, "sink");
-  gst_element_add_pad (audio_bin, gst_ghost_pad_new ("sink", pad));
-  gst_object_unref (pad);
-
-  setup_dynamic_link (demux, NULL, gst_element_get_static_pad (audio_bin,
-          "sink"), NULL);
-
-  seekable = gst_element_get_static_pad (decoder, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (decoder, "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_theora_pipeline (const gchar * location)
-{
-  GstElement *pipeline, *video_bin;
-  GstElement *src, *demux, *decoder, *convert, *videosink;
-  GstPad *pad, *seekable;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  demux = gst_element_factory_make_or_warn ("oggdemux", "demux");
-  decoder = gst_element_factory_make_or_warn ("theoradec", "decoder");
-  convert = gst_element_factory_make_or_warn ("ffmpegcolorspace", "convert");
-  videosink = gst_element_factory_make_or_warn (opt_videosink_str, "sink");
-
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  video_bin = gst_bin_new ("v_decoder_bin");
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), demux);
-  gst_bin_add (GST_BIN (video_bin), decoder);
-  gst_bin_add (GST_BIN (video_bin), convert);
-  gst_bin_add (GST_BIN (video_bin), videosink);
-  gst_bin_add (GST_BIN (pipeline), video_bin);
-
-  gst_element_link (src, demux);
-  gst_element_link (decoder, convert);
-  gst_element_link (convert, videosink);
-
-  pad = gst_element_get_static_pad (decoder, "sink");
-  gst_element_add_pad (video_bin, gst_ghost_pad_new ("sink", pad));
-  gst_object_unref (pad);
-
-  setup_dynamic_link (demux, NULL, gst_element_get_static_pad (video_bin,
-          "sink"), NULL);
-
-  seekable = gst_element_get_static_pad (decoder, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (decoder, "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_vorbis_theora_pipeline (const gchar * location)
-{
-  GstElement *pipeline, *audio_bin, *video_bin;
-  GstElement *src, *demux, *a_decoder, *a_convert, *v_decoder, *v_convert;
-  GstElement *audiosink, *videosink;
-  GstElement *a_queue, *v_queue, *v_scale;
-  GstPad *seekable;
-  GstPad *pad;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  demux = gst_element_factory_make_or_warn ("oggdemux", "demux");
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), demux);
-  gst_element_link (src, demux);
-
-  audio_bin = gst_bin_new ("a_decoder_bin");
-  a_queue = gst_element_factory_make_or_warn ("queue", "a_queue");
-  a_decoder = gst_element_factory_make_or_warn ("vorbisdec", "a_dec");
-  a_convert = gst_element_factory_make_or_warn ("audioconvert", "a_convert");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "a_sink");
-
-  gst_bin_add (GST_BIN (pipeline), audio_bin);
-
-  gst_bin_add (GST_BIN (audio_bin), a_queue);
-  gst_bin_add (GST_BIN (audio_bin), a_decoder);
-  gst_bin_add (GST_BIN (audio_bin), a_convert);
-  gst_bin_add (GST_BIN (audio_bin), audiosink);
-
-  gst_element_link (a_queue, a_decoder);
-  gst_element_link (a_decoder, a_convert);
-  gst_element_link (a_convert, audiosink);
-
-  pad = gst_element_get_static_pad (a_queue, "sink");
-  gst_element_add_pad (audio_bin, gst_ghost_pad_new ("sink", pad));
-  gst_object_unref (pad);
-
-  setup_dynamic_link (demux, NULL, gst_element_get_static_pad (audio_bin,
-          "sink"), NULL);
-
-  video_bin = gst_bin_new ("v_decoder_bin");
-  v_queue = gst_element_factory_make_or_warn ("queue", "v_queue");
-  v_decoder = gst_element_factory_make_or_warn ("theoradec", "v_dec");
-  v_convert =
-      gst_element_factory_make_or_warn ("ffmpegcolorspace", "v_convert");
-  v_scale = gst_element_factory_make_or_warn ("videoscale", "v_scale");
-  videosink = gst_element_factory_make_or_warn (opt_videosink_str, "v_sink");
-
-  gst_bin_add (GST_BIN (pipeline), video_bin);
-
-  gst_bin_add (GST_BIN (video_bin), v_queue);
-  gst_bin_add (GST_BIN (video_bin), v_decoder);
-  gst_bin_add (GST_BIN (video_bin), v_convert);
-  gst_bin_add (GST_BIN (video_bin), v_scale);
-  gst_bin_add (GST_BIN (video_bin), videosink);
-
-  gst_element_link_many (v_queue, v_decoder, v_convert, v_scale, videosink,
-      NULL);
-
-  pad = gst_element_get_static_pad (v_queue, "sink");
-  gst_element_add_pad (video_bin, gst_ghost_pad_new ("sink", pad));
-  gst_object_unref (pad);
-
-  setup_dynamic_link (demux, NULL, gst_element_get_static_pad (video_bin,
-          "sink"), NULL);
-
-  seekable = gst_element_get_static_pad (a_decoder, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (a_decoder,
-          "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_avi_msmpeg4v3_mp3_pipeline (const gchar * location)
-{
-  GstElement *pipeline, *audio_bin, *video_bin;
-  GstElement *src, *demux, *a_decoder, *a_convert, *v_decoder, *v_convert;
-  GstElement *audiosink, *videosink;
-  GstElement *a_queue, *v_queue;
-  GstPad *seekable, *pad;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  demux = gst_element_factory_make_or_warn ("avidemux", "demux");
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), demux);
-  gst_element_link (src, demux);
-
-  audio_bin = gst_bin_new ("a_decoder_bin");
-  a_queue = gst_element_factory_make_or_warn ("queue", "a_queue");
-  a_decoder = gst_element_factory_make_or_warn ("mad", "a_dec");
-  a_convert = gst_element_factory_make_or_warn ("audioconvert", "a_convert");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "a_sink");
-
-  gst_bin_add (GST_BIN (audio_bin), a_queue);
-  gst_bin_add (GST_BIN (audio_bin), a_decoder);
-  gst_bin_add (GST_BIN (audio_bin), a_convert);
-  gst_bin_add (GST_BIN (audio_bin), audiosink);
-
-  gst_element_link (a_queue, a_decoder);
-  gst_element_link (a_decoder, a_convert);
-  gst_element_link (a_convert, audiosink);
-
-  gst_bin_add (GST_BIN (pipeline), audio_bin);
-
-  pad = gst_element_get_static_pad (a_queue, "sink");
-  gst_element_add_pad (audio_bin, gst_ghost_pad_new ("sink", pad));
-  gst_object_unref (pad);
-
-  setup_dynamic_link (demux, NULL, gst_element_get_static_pad (audio_bin,
-          "sink"), NULL);
-
-  video_bin = gst_bin_new ("v_decoder_bin");
-  v_queue = gst_element_factory_make_or_warn ("queue", "v_queue");
-  v_decoder = gst_element_factory_make_or_warn ("ffdec_msmpeg4", "v_dec");
-  v_convert =
-      gst_element_factory_make_or_warn ("ffmpegcolorspace", "v_convert");
-  videosink = gst_element_factory_make_or_warn (opt_videosink_str, "v_sink");
-
-  gst_bin_add (GST_BIN (video_bin), v_queue);
-  gst_bin_add (GST_BIN (video_bin), v_decoder);
-  gst_bin_add (GST_BIN (video_bin), v_convert);
-  gst_bin_add (GST_BIN (video_bin), videosink);
-
-  gst_element_link_many (v_queue, v_decoder, v_convert, videosink, NULL);
-
-  gst_bin_add (GST_BIN (pipeline), video_bin);
-
-  pad = gst_element_get_static_pad (v_queue, "sink");
-  gst_element_add_pad (video_bin, gst_ghost_pad_new ("sink", pad));
-  gst_object_unref (pad);
-
-  setup_dynamic_link (demux, NULL, gst_element_get_static_pad (video_bin,
-          "sink"), NULL);
-
-  seekable = gst_element_get_static_pad (a_decoder, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (a_decoder,
-          "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_mp3_pipeline (const gchar * location)
-{
-  GstElement *pipeline;
-  GstElement *src, *parser, *decoder, *audiosink, *queue;
-  GstPad *seekable;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  parser = gst_element_factory_make_or_warn ("mp3parse", "parse");
-  decoder = gst_element_factory_make_or_warn ("mad", "dec");
-  queue = gst_element_factory_make_or_warn ("queue", "queue");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "sink");
-
-  seekable_elements = g_list_prepend (seekable_elements, audiosink);
-
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-  //g_object_set (G_OBJECT (audiosink), "fragment", 0x00180008, NULL);
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), parser);
-  gst_bin_add (GST_BIN (pipeline), decoder);
-  gst_bin_add (GST_BIN (pipeline), queue);
-  gst_bin_add (GST_BIN (pipeline), audiosink);
-
-  gst_element_link (src, parser);
-  gst_element_link (parser, decoder);
-  gst_element_link (decoder, queue);
-  gst_element_link (queue, audiosink);
-
-  seekable = gst_element_get_static_pad (queue, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (decoder, "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_avi_pipeline (const gchar * location)
-{
-  GstElement *pipeline, *audio_bin, *video_bin;
-  GstElement *src, *demux, *a_decoder, *v_decoder, *audiosink, *videosink;
-  GstElement *a_queue = NULL, *v_queue = NULL;
-  GstPad *seekable;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  demux = gst_element_factory_make_or_warn ("avidemux", "demux");
-  seekable_elements = g_list_prepend (seekable_elements, demux);
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), demux);
-  gst_element_link (src, demux);
-
-  audio_bin = gst_bin_new ("a_decoder_bin");
-  a_decoder = gst_element_factory_make_or_warn ("mad", "a_dec");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "a_sink");
-  a_queue = gst_element_factory_make_or_warn ("queue", "a_queue");
-  gst_element_link (a_decoder, a_queue);
-  gst_element_link (a_queue, audiosink);
-  gst_bin_add (GST_BIN (audio_bin), a_decoder);
-  gst_bin_add (GST_BIN (audio_bin), a_queue);
-  gst_bin_add (GST_BIN (audio_bin), audiosink);
-  gst_element_set_state (audio_bin, GST_STATE_PAUSED);
-
-  setup_dynamic_link (demux, "audio_00", gst_element_get_static_pad (a_decoder,
-          "sink"), audio_bin);
-
-  seekable = gst_element_get_static_pad (a_queue, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (a_decoder,
-          "sink"));
-
-  video_bin = gst_bin_new ("v_decoder_bin");
-  v_decoder = gst_element_factory_make_or_warn ("ffmpegdecall", "v_dec");
-  videosink = gst_element_factory_make_or_warn (opt_videosink_str, "v_sink");
-  v_queue = gst_element_factory_make_or_warn ("queue", "v_queue");
-  gst_element_link (v_decoder, v_queue);
-  gst_element_link (v_queue, videosink);
-  gst_bin_add (GST_BIN (video_bin), v_decoder);
-  gst_bin_add (GST_BIN (video_bin), v_queue);
-  gst_bin_add (GST_BIN (video_bin), videosink);
-
-  gst_element_set_state (video_bin, GST_STATE_PAUSED);
-
-  setup_dynamic_link (demux, "video_00", gst_element_get_static_pad (v_decoder,
-          "sink"), video_bin);
-
-  seekable = gst_element_get_static_pad (v_queue, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (v_decoder,
-          "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_mpeg_pipeline (const gchar * location)
-{
-  GstElement *pipeline, *audio_bin, *video_bin;
-  GstElement *src, *demux, *a_decoder, *v_decoder, *v_filter;
-  GstElement *audiosink, *videosink;
-  GstElement *a_queue, *v_queue;
-  GstPad *seekable;
-  GstPad *pad;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  //demux = gst_element_factory_make_or_warn ("mpegdemux", "demux");
-  demux = gst_element_factory_make_or_warn ("flupsdemux", "demux");
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), demux);
-  gst_element_link (src, demux);
-
-  audio_bin = gst_bin_new ("a_decoder_bin");
-  a_decoder = gst_element_factory_make_or_warn ("mad", "a_dec");
-  a_queue = gst_element_factory_make_or_warn ("queue", "a_queue");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "a_sink");
-  gst_bin_add (GST_BIN (audio_bin), a_decoder);
-  gst_bin_add (GST_BIN (audio_bin), a_queue);
-  gst_bin_add (GST_BIN (audio_bin), audiosink);
-
-  gst_element_link (a_decoder, a_queue);
-  gst_element_link (a_queue, audiosink);
-
-  gst_bin_add (GST_BIN (pipeline), audio_bin);
-
-  pad = gst_element_get_static_pad (a_decoder, "sink");
-  gst_element_add_pad (audio_bin, gst_ghost_pad_new ("sink", pad));
-  gst_object_unref (pad);
-
-  setup_dynamic_link (demux, "audio_c0", gst_element_get_static_pad (audio_bin,
-          "sink"), NULL);
-
-  video_bin = gst_bin_new ("v_decoder_bin");
-  v_decoder = gst_element_factory_make_or_warn ("mpeg2dec", "v_dec");
-  v_queue = gst_element_factory_make_or_warn ("queue", "v_queue");
-  v_filter = gst_element_factory_make_or_warn ("ffmpegcolorspace", "v_filter");
-  videosink = gst_element_factory_make_or_warn (opt_videosink_str, "v_sink");
-
-  gst_bin_add (GST_BIN (video_bin), v_decoder);
-  gst_bin_add (GST_BIN (video_bin), v_queue);
-  gst_bin_add (GST_BIN (video_bin), v_filter);
-  gst_bin_add (GST_BIN (video_bin), videosink);
-
-  gst_element_link (v_decoder, v_queue);
-  gst_element_link (v_queue, v_filter);
-  gst_element_link (v_filter, videosink);
-
-  gst_bin_add (GST_BIN (pipeline), video_bin);
-
-  pad = gst_element_get_static_pad (v_decoder, "sink");
-  gst_element_add_pad (video_bin, gst_ghost_pad_new ("sink", pad));
-  gst_object_unref (pad);
-
-  setup_dynamic_link (demux, "video_e0", gst_element_get_static_pad (video_bin,
-          "sink"), NULL);
-
-  seekable = gst_element_get_static_pad (v_filter, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (v_decoder,
-          "sink"));
-
-  return pipeline;
-}
-
-static GstElement *
-make_mpegnt_pipeline (const gchar * location)
-{
-  GstElement *pipeline, *audio_bin, *video_bin;
-  GstElement *src, *demux, *a_decoder, *v_decoder, *v_filter;
-  GstElement *audiosink, *videosink;
-  GstElement *a_queue;
-  GstPad *seekable;
-
-  pipeline = gst_pipeline_new ("app");
-
-  src = gst_element_factory_make_or_warn (SOURCE, "src");
-  g_object_set (G_OBJECT (src), "location", location, NULL);
-
-  demux = gst_element_factory_make_or_warn ("mpegdemux", "demux");
-  //g_object_set (G_OBJECT (demux), "sync", TRUE, NULL);
-
-  seekable_elements = g_list_prepend (seekable_elements, demux);
-
-  gst_bin_add (GST_BIN (pipeline), src);
-  gst_bin_add (GST_BIN (pipeline), demux);
-  gst_element_link (src, demux);
-
-  audio_bin = gst_bin_new ("a_decoder_bin");
-  a_decoder = gst_element_factory_make_or_warn ("mad", "a_dec");
-  a_queue = gst_element_factory_make_or_warn ("queue", "a_queue");
-  audiosink = gst_element_factory_make_or_warn (opt_audiosink_str, "a_sink");
-  //g_object_set (G_OBJECT (audiosink), "fragment", 0x00180008, NULL);
-  g_object_set (G_OBJECT (audiosink), "sync", FALSE, NULL);
-  gst_element_link (a_decoder, a_queue);
-  gst_element_link (a_queue, audiosink);
-  gst_bin_add (GST_BIN (audio_bin), a_decoder);
-  gst_bin_add (GST_BIN (audio_bin), a_queue);
-  gst_bin_add (GST_BIN (audio_bin), audiosink);
-
-  setup_dynamic_link (demux, "audio_00", gst_element_get_static_pad (a_decoder,
-          "sink"), audio_bin);
-
-  seekable = gst_element_get_static_pad (a_queue, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (a_decoder,
-          "sink"));
-
-  video_bin = gst_bin_new ("v_decoder_bin");
-  v_decoder = gst_element_factory_make_or_warn ("mpeg2dec", "v_dec");
-  v_filter = gst_element_factory_make_or_warn ("ffmpegcolorspace", "v_filter");
-  videosink = gst_element_factory_make_or_warn (opt_videosink_str, "v_sink");
-  gst_element_link_many (v_decoder, v_filter, videosink, NULL);
-
-  gst_bin_add_many (GST_BIN (video_bin), v_decoder, v_filter, videosink, NULL);
-
-  setup_dynamic_link (demux, "video_00", gst_element_get_static_pad (v_decoder,
-          "sink"), video_bin);
-
-  seekable = gst_element_get_static_pad (v_decoder, "src");
-  seekable_pads = g_list_prepend (seekable_pads, seekable);
-  rate_pads = g_list_prepend (rate_pads, seekable);
-  rate_pads =
-      g_list_prepend (rate_pads, gst_element_get_static_pad (v_decoder,
-          "sink"));
-
-  return pipeline;
-}
-
-static void
-playerbin_set_uri (GstElement * player, const gchar * location)
-{
-  gchar *uri;
-
-  /* Add "file://" prefix for convenience */
-  if (g_str_has_prefix (location, "/") || !gst_uri_is_valid (location)) {
-    uri = gst_filename_to_uri (location, NULL);
-    g_print ("Setting URI: %s\n", uri);
-    g_object_set (G_OBJECT (player), "uri", uri, NULL);
-    g_free (uri);
-  } else {
-    g_print ("Setting URI: %s\n", location);
-    g_object_set (G_OBJECT (player), "uri", location, NULL);
-  }
-}
-
-static GstElement *
-construct_playerbin (const gchar * name, const gchar * location)
-{
-  GstElement *player;
-  GstElement *avsink;
-
-  player = gst_element_factory_make (name, "player");
-  g_assert (player);
-
-  playerbin_set_uri (player, location);
-
-  seekable_elements = g_list_prepend (seekable_elements, player);
-
-  /* force element seeking on this pipeline */
-  elem_seek = TRUE;
-
-  avsink = gst_element_factory_make_or_warn (opt_audiosink_str, "a_sink");
-  if (avsink)
-    g_object_set (player, "audio-sink", avsink, NULL);
-
-  avsink = gst_element_factory_make_or_warn (opt_videosink_str, "v_sink");
-  if (avsink)
-    g_object_set (player, "video-sink", avsink, NULL);
-
-  return player;
-}
-
-static GstElement *
-make_playerbin_pipeline (const gchar * location)
-{
-  return construct_playerbin ("playbin", location);
-}
-
-static GstElement *
-make_playerbin2_pipeline (const gchar * location)
-{
-  GstElement *pipeline = construct_playerbin ("playbin2", location);
-
-  /* FIXME: this is not triggered, playbin2 is not forwarding it from the sink */
-  g_signal_connect (pipeline, "notify::volume", G_CALLBACK (volume_notify_cb),
-      NULL);
-  return pipeline;
-}
-
-#ifndef GST_DISABLE_PARSE
-static GstElement *
-make_parselaunch_pipeline (const gchar * description)
-{
-  GstElement *pipeline;
-  GError *error = NULL;
-
-  pipeline = gst_parse_launch (description, &error);
-
-  seekable_elements = g_list_prepend (seekable_elements, pipeline);
-
-  elem_seek = TRUE;
-
-  return pipeline;
-}
-#endif
-
-typedef struct
-{
-  const gchar *name;
-  GstElement *(*func) (const gchar * location);
-}
-Pipeline;
-
-static Pipeline pipelines[] = {
-  {"mp3", make_mp3_pipeline},
-  {"avi", make_avi_pipeline},
-  {"mpeg1", make_mpeg_pipeline},
-  {"mpegparse", make_parse_pipeline},
-  {"vorbis", make_vorbis_pipeline},
-  {"theora", make_theora_pipeline},
-  {"ogg/v/t", make_vorbis_theora_pipeline},
-  {"avi/msmpeg4v3/mp3", make_avi_msmpeg4v3_mp3_pipeline},
-  {"sid", make_sid_pipeline},
-  {"flac", make_flac_pipeline},
-  {"wav", make_wav_pipeline},
-  {"mod", make_mod_pipeline},
-  {"dv", make_dv_pipeline},
-  {"mpeg1nothreads", make_mpegnt_pipeline},
-  {"playerbin", make_playerbin_pipeline},
-#ifndef GST_DISABLE_PARSE
-  {"parse-launch", make_parselaunch_pipeline},
-#endif
-  {"playerbin2", make_playerbin2_pipeline},
-  {NULL, NULL},
-};
-
-#define NUM_TYPES       ((sizeof (pipelines) / sizeof (Pipeline)) - 1)
-
-/* ui callbacks and helpers */
-
-static gchar *
-format_value (GtkScale * scale, gdouble value)
-{
-  gint64 real;
-  gint64 seconds;
-  gint64 subseconds;
-
-  real = value * duration / N_GRAD;
-  seconds = (gint64) real / GST_SECOND;
-  subseconds = (gint64) real / (GST_SECOND / N_GRAD);
-
-  return g_strdup_printf ("%02" G_GINT64_FORMAT ":%02" G_GINT64_FORMAT ":%02"
-      G_GINT64_FORMAT, seconds / 60, seconds % 60, subseconds % 100);
-}
-
-
-static gchar *
-shuttle_format_value (GtkScale * scale, gdouble value)
-{
-  return g_strdup_printf ("%0.*g", gtk_scale_get_digits (scale), value);
-}
-
-typedef struct
-{
-  const gchar *name;
-  const GstFormat format;
-}
-seek_format;
-
-static seek_format seek_formats[] = {
-  {"tim", GST_FORMAT_TIME},
-  {"byt", GST_FORMAT_BYTES},
-  {"buf", GST_FORMAT_BUFFERS},
-  {"def", GST_FORMAT_DEFAULT},
-  {NULL, 0},
-};
-
-G_GNUC_UNUSED static void
-query_rates (void)
-{
-  GList *walk = rate_pads;
-
-  while (walk) {
-    GstPad *pad = GST_PAD (walk->data);
-    gint i = 0;
-
-    g_print ("rate/sec  %8.8s: ", GST_PAD_NAME (pad));
-    while (seek_formats[i].name) {
-      gint64 value;
-      GstFormat format;
-
-      format = seek_formats[i].format;
-
-      if (gst_pad_query_convert (pad, GST_FORMAT_TIME, GST_SECOND, &format,
-              &value)) {
-        g_print ("%s %13" G_GINT64_FORMAT " | ", seek_formats[i].name, value);
-      } else {
-        g_print ("%s %13.13s | ", seek_formats[i].name, "*NA*");
-      }
-
-      i++;
-    }
-    g_print (" %s:%s\n", GST_DEBUG_PAD_NAME (pad));
-
-    walk = g_list_next (walk);
-  }
-}
-
-G_GNUC_UNUSED static void
-query_positions_elems (void)
-{
-  GList *walk = seekable_elements;
-
-  while (walk) {
-    GstElement *element = GST_ELEMENT (walk->data);
-    gint i = 0;
-
-    g_print ("positions %8.8s: ", GST_ELEMENT_NAME (element));
-    while (seek_formats[i].name) {
-      gint64 position, total;
-      GstFormat format;
-
-      format = seek_formats[i].format;
-
-      if (gst_element_query_position (element, &format, &position) &&
-          gst_element_query_duration (element, &format, &total)) {
-        g_print ("%s %13" G_GINT64_FORMAT " / %13" G_GINT64_FORMAT " | ",
-            seek_formats[i].name, position, total);
-      } else {
-        g_print ("%s %13.13s / %13.13s | ", seek_formats[i].name, "*NA*",
-            "*NA*");
-      }
-      i++;
-    }
-    g_print (" %s\n", GST_ELEMENT_NAME (element));
-
-    walk = g_list_next (walk);
-  }
-}
-
-G_GNUC_UNUSED static void
-query_positions_pads (void)
-{
-  GList *walk = seekable_pads;
-
-  while (walk) {
-    GstPad *pad = GST_PAD (walk->data);
-    gint i = 0;
-
-    g_print ("positions %8.8s: ", GST_PAD_NAME (pad));
-    while (seek_formats[i].name) {
-      GstFormat format;
-      gint64 position, total;
-
-      format = seek_formats[i].format;
-
-      if (gst_pad_query_position (pad, &format, &position) &&
-          gst_pad_query_duration (pad, &format, &total)) {
-        g_print ("%s %13" G_GINT64_FORMAT " / %13" G_GINT64_FORMAT " | ",
-            seek_formats[i].name, position, total);
-      } else {
-        g_print ("%s %13.13s / %13.13s | ", seek_formats[i].name, "*NA*",
-            "*NA*");
-      }
-
-      i++;
-    }
-    g_print (" %s:%s\n", GST_DEBUG_PAD_NAME (pad));
-
-    walk = g_list_next (walk);
-  }
-}
-
-static gboolean start_seek (GtkWidget * widget, GdkEventButton * event,
-    gpointer user_data);
-static gboolean stop_seek (GtkWidget * widget, GdkEventButton * event,
-    gpointer user_data);
-static void seek_cb (GtkWidget * widget);
-
-static void
-set_scale (gdouble value)
-{
-  g_signal_handlers_block_by_func (hscale, (void *) start_seek,
-      (void *) pipeline);
-  g_signal_handlers_block_by_func (hscale, (void *) stop_seek,
-      (void *) pipeline);
-  g_signal_handlers_block_by_func (hscale, (void *) seek_cb, (void *) pipeline);
-  gtk_adjustment_set_value (adjustment, value);
-  g_signal_handlers_unblock_by_func (hscale, (void *) start_seek,
-      (void *) pipeline);
-  g_signal_handlers_unblock_by_func (hscale, (void *) stop_seek,
-      (void *) pipeline);
-  g_signal_handlers_unblock_by_func (hscale, (void *) seek_cb,
-      (void *) pipeline);
-  gtk_widget_queue_draw (hscale);
-}
-
-static gboolean
-update_fill (gpointer data)
-{
-  if (elem_seek) {
-    if (seekable_elements) {
-      GstElement *element = GST_ELEMENT (seekable_elements->data);
-      GstQuery *query;
-
-      query = gst_query_new_buffering (GST_FORMAT_PERCENT);
-      if (gst_element_query (element, query)) {
-        gint64 start, stop, buffering_total;
-        GstFormat format;
-        gdouble fill;
-        gboolean busy;
-        gint percent;
-        GstBufferingMode mode;
-        gint avg_in, avg_out;
-        gint64 buffering_left;
-
-        gst_query_parse_buffering_percent (query, &busy, &percent);
-        gst_query_parse_buffering_range (query, &format, &start, &stop,
-            &buffering_total);
-        gst_query_parse_buffering_stats (query, &mode, &avg_in, &avg_out,
-            &buffering_left);
-
-        /* note that we could start the playback when buffering_left < remaining
-         * playback time */
-        GST_DEBUG ("buffering total %" G_GINT64_FORMAT " ms, left %"
-            G_GINT64_FORMAT " ms", buffering_total, buffering_left);
-        GST_DEBUG ("start %" G_GINT64_FORMAT ", stop %" G_GINT64_FORMAT,
-            start, stop);
-
-        if (stop != -1)
-          fill = N_GRAD * stop / GST_FORMAT_PERCENT_MAX;
-        else
-          fill = N_GRAD;
-
-        gtk_range_set_fill_level (GTK_RANGE (hscale), fill);
-      }
-      gst_query_unref (query);
-    }
-  }
-  return TRUE;
-}
-
-static gboolean
-update_scale (gpointer data)
-{
-  GstFormat format = GST_FORMAT_TIME;
-
-  //position = 0;
-  //duration = 0;
-
-  if (elem_seek) {
-    if (seekable_elements) {
-      GstElement *element = GST_ELEMENT (seekable_elements->data);
-
-      gst_element_query_position (element, &format, &position);
-      gst_element_query_duration (element, &format, &duration);
-    }
-  } else {
-    if (seekable_pads) {
-      GstPad *pad = GST_PAD (seekable_pads->data);
-
-      gst_pad_query_position (pad, &format, &position);
-      gst_pad_query_duration (pad, &format, &duration);
-    }
-  }
-
-  if (stats) {
-    if (elem_seek) {
-      query_positions_elems ();
-    } else {
-      query_positions_pads ();
-    }
-    query_rates ();
-  }
-
-  if (position >= duration)
-    duration = position;
-
-  if (duration > 0) {
-    set_scale (position * N_GRAD / duration);
-  }
-
-  /* FIXME: see make_playerbin2_pipeline() and volume_notify_cb() */
-  if (pipeline_type == 16) {
-    g_object_notify (G_OBJECT (pipeline), "volume");
-  }
-
-  return TRUE;
-}
-
-static void do_seek (GtkWidget * widget);
-static void connect_bus_signals (GstElement * pipeline);
-static void set_update_scale (gboolean active);
-static void set_update_fill (gboolean active);
-
-static gboolean
-end_scrub (GtkWidget * widget)
-{
-  GST_DEBUG ("end scrub, PAUSE");
-  gst_element_set_state (pipeline, GST_STATE_PAUSED);
-  seek_timeout_id = 0;
-
-  return FALSE;
-}
-
-static gboolean
-send_event (GstEvent * event)
-{
-  gboolean res = FALSE;
-
-  if (!elem_seek) {
-    GList *walk = seekable_pads;
-
-    while (walk) {
-      GstPad *seekable = GST_PAD (walk->data);
-
-      GST_DEBUG ("send event on pad %s:%s", GST_DEBUG_PAD_NAME (seekable));
-
-      gst_event_ref (event);
-      res = gst_pad_send_event (seekable, event);
-
-      walk = g_list_next (walk);
-    }
-  } else {
-    GList *walk = seekable_elements;
-
-    while (walk) {
-      GstElement *seekable = GST_ELEMENT (walk->data);
-
-      GST_DEBUG ("send event on element %s", GST_ELEMENT_NAME (seekable));
-
-      gst_event_ref (event);
-      res = gst_element_send_event (seekable, event);
-
-      walk = g_list_next (walk);
-    }
-  }
-  gst_event_unref (event);
-  return res;
-}
-
-static void
-do_seek (GtkWidget * widget)
-{
-  gint64 real;
-  gboolean res = FALSE;
-  GstEvent *s_event;
-  GstSeekFlags flags;
-
-  real = gtk_range_get_value (GTK_RANGE (widget)) * duration / N_GRAD;
-
-  GST_DEBUG ("value=%f, real=%" G_GINT64_FORMAT,
-      gtk_range_get_value (GTK_RANGE (widget)), real);
-
-  flags = 0;
-  if (flush_seek)
-    flags |= GST_SEEK_FLAG_FLUSH;
-  if (accurate_seek)
-    flags |= GST_SEEK_FLAG_ACCURATE;
-  if (keyframe_seek)
-    flags |= GST_SEEK_FLAG_KEY_UNIT;
-  if (loop_seek)
-    flags |= GST_SEEK_FLAG_SEGMENT;
-  if (skip_seek)
-    flags |= GST_SEEK_FLAG_SKIP;
-
-  if (rate >= 0) {
-    s_event = gst_event_new_seek (rate,
-        GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, real, GST_SEEK_TYPE_SET,
-        GST_CLOCK_TIME_NONE);
-    GST_DEBUG ("seek with rate %lf to %" GST_TIME_FORMAT " / %" GST_TIME_FORMAT,
-        rate, GST_TIME_ARGS (real), GST_TIME_ARGS (duration));
-  } else {
-    s_event = gst_event_new_seek (rate,
-        GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, G_GINT64_CONSTANT (0),
-        GST_SEEK_TYPE_SET, real);
-    GST_DEBUG ("seek with rate %lf to %" GST_TIME_FORMAT " / %" GST_TIME_FORMAT,
-        rate, GST_TIME_ARGS (0), GST_TIME_ARGS (real));
-  }
-
-  res = send_event (s_event);
-
-  if (res) {
-    if (flush_seek) {
-      gst_element_get_state (GST_ELEMENT (pipeline), NULL, NULL, SEEK_TIMEOUT);
-    } else {
-      set_update_scale (TRUE);
-    }
-  } else {
-    g_print ("seek failed\n");
-    set_update_scale (TRUE);
-  }
-}
-
-static void
-seek_cb (GtkWidget * widget)
-{
-  /* If the timer hasn't expired yet, then the pipeline is running */
-  if (play_scrub && seek_timeout_id != 0) {
-    GST_DEBUG ("do scrub seek, PAUSED");
-    gst_element_set_state (pipeline, GST_STATE_PAUSED);
-  }
-
-  GST_DEBUG ("do seek");
-  do_seek (widget);
-
-  if (play_scrub) {
-    GST_DEBUG ("do scrub seek, PLAYING");
-    gst_element_set_state (pipeline, GST_STATE_PLAYING);
-
-    if (seek_timeout_id == 0) {
-      seek_timeout_id =
-          g_timeout_add (SCRUB_TIME, (GSourceFunc) end_scrub, widget);
-    }
-  }
-}
-
-static void
-set_update_fill (gboolean active)
-{
-  GST_DEBUG ("fill scale is %d", active);
-
-  if (active) {
-    if (fill_id == 0) {
-      fill_id =
-          g_timeout_add (FILL_INTERVAL, (GSourceFunc) update_fill, pipeline);
-    }
-  } else {
-    if (fill_id) {
-      g_source_remove (fill_id);
-      fill_id = 0;
-    }
-  }
-}
-
-static void
-set_update_scale (gboolean active)
-{
-
-  GST_DEBUG ("update scale is %d", active);
-
-  if (active) {
-    if (update_id == 0) {
-      update_id =
-          g_timeout_add (UPDATE_INTERVAL, (GSourceFunc) update_scale, pipeline);
-    }
-  } else {
-    if (update_id) {
-      g_source_remove (update_id);
-      update_id = 0;
-    }
-  }
-}
-
-static gboolean
-start_seek (GtkWidget * widget, GdkEventButton * event, gpointer user_data)
-{
-  if (event->type != GDK_BUTTON_PRESS)
-    return FALSE;
-
-  set_update_scale (FALSE);
-
-  if (state == GST_STATE_PLAYING && flush_seek && scrub) {
-    GST_DEBUG ("start scrub seek, PAUSE");
-    gst_element_set_state (pipeline, GST_STATE_PAUSED);
-  }
-
-  if (changed_id == 0 && flush_seek && scrub) {
-    changed_id =
-        g_signal_connect (hscale, "value_changed", G_CALLBACK (seek_cb),
-        pipeline);
-  }
-
-  return FALSE;
-}
-
-static gboolean
-stop_seek (GtkWidget * widget, GdkEventButton * event, gpointer user_data)
-{
-  if (changed_id) {
-    g_signal_handler_disconnect (hscale, changed_id);
-    changed_id = 0;
-  }
-
-  if (!flush_seek || !scrub) {
-    GST_DEBUG ("do final seek");
-    do_seek (widget);
-  }
-
-  if (seek_timeout_id != 0) {
-    g_source_remove (seek_timeout_id);
-    seek_timeout_id = 0;
-    /* Still scrubbing, so the pipeline is playing, see if we need PAUSED
-     * instead. */
-    if (state == GST_STATE_PAUSED) {
-      GST_DEBUG ("stop scrub seek, PAUSED");
-      gst_element_set_state (pipeline, GST_STATE_PAUSED);
-    }
-  } else {
-    if (state == GST_STATE_PLAYING) {
-      GST_DEBUG ("stop scrub seek, PLAYING");
-      gst_element_set_state (pipeline, GST_STATE_PLAYING);
-    }
-  }
-
-  return FALSE;
-}
-
-static void
-play_cb (GtkButton * button, gpointer data)
-{
-  GstStateChangeReturn ret;
-
-  if (state != GST_STATE_PLAYING) {
-    g_print ("PLAY pipeline\n");
-    gtk_statusbar_pop (GTK_STATUSBAR (statusbar), status_id);
-
-    ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);
-    switch (ret) {
-      case GST_STATE_CHANGE_FAILURE:
-        goto failed;
-      case GST_STATE_CHANGE_NO_PREROLL:
-        is_live = TRUE;
-        break;
-      default:
-        break;
-    }
-    state = GST_STATE_PLAYING;
-    gtk_statusbar_push (GTK_STATUSBAR (statusbar), status_id, "Playing");
-  }
-
-  return;
-
-failed:
-  {
-    g_print ("PLAY failed\n");
-    gtk_statusbar_push (GTK_STATUSBAR (statusbar), status_id, "Play failed");
-  }
-}
-
-static void
-pause_cb (GtkButton * button, gpointer data)
-{
-  g_static_mutex_lock (&state_mutex);
-  if (state != GST_STATE_PAUSED) {
-    GstStateChangeReturn ret;
-
-    gtk_statusbar_pop (GTK_STATUSBAR (statusbar), status_id);
-    g_print ("PAUSE pipeline\n");
-    ret = gst_element_set_state (pipeline, GST_STATE_PAUSED);
-    switch (ret) {
-      case GST_STATE_CHANGE_FAILURE:
-        goto failed;
-      case GST_STATE_CHANGE_NO_PREROLL:
-        is_live = TRUE;
-        break;
-      default:
-        break;
-    }
-
-    state = GST_STATE_PAUSED;
-    gtk_statusbar_push (GTK_STATUSBAR (statusbar), status_id, "Paused");
-  }
-  g_static_mutex_unlock (&state_mutex);
-
-  return;
-
-failed:
-  {
-    g_static_mutex_unlock (&state_mutex);
-    g_print ("PAUSE failed\n");
-    gtk_statusbar_push (GTK_STATUSBAR (statusbar), status_id, "Pause failed");
-  }
-}
-
-static void
-stop_cb (GtkButton * button, gpointer data)
-{
-  if (state != STOP_STATE) {
-    GstStateChangeReturn ret;
-
-    g_print ("READY pipeline\n");
-    gtk_statusbar_pop (GTK_STATUSBAR (statusbar), status_id);
-
-    g_static_mutex_lock (&state_mutex);
-    ret = gst_element_set_state (pipeline, STOP_STATE);
-    if (ret == GST_STATE_CHANGE_FAILURE)
-      goto failed;
-
-    state = STOP_STATE;
-    gtk_statusbar_push (GTK_STATUSBAR (statusbar), status_id, "Stopped");
-    gtk_widget_queue_draw (video_window);
-
-    is_live = FALSE;
-    buffering = FALSE;
-    set_update_scale (FALSE);
-    set_scale (0.0);
-    set_update_fill (FALSE);
-
-    if (pipeline_type == 16)
-      clear_streams (pipeline);
-    g_static_mutex_unlock (&state_mutex);
-
-#if 0
-    /* if one uses parse_launch, play, stop and play again it fails as all the
-     * pads after the demuxer can't be reconnected
-     */
-    if (!strcmp (pipelines[pipeline_type].name, "parse-launch")) {
-      gst_element_set_state (pipeline, GST_STATE_NULL);
-      gst_object_unref (pipeline);
-
-      g_list_free (seekable_elements);
-      seekable_elements = NULL;
-      g_list_free (seekable_pads);
-      seekable_pads = NULL;
-      g_list_free (rate_pads);
-      rate_pads = NULL;
-
-      pipeline = pipelines[pipeline_type].func (pipeline_spec);
-      g_assert (pipeline);
-      gst_element_set_state (pipeline, STOP_STATE);
-      connect_bus_signals (pipeline);
-    }
-#endif
-  }
-  return;
-
-failed:
-  {
-    g_static_mutex_unlock (&state_mutex);
-    g_print ("STOP failed\n");
-    gtk_statusbar_push (GTK_STATUSBAR (statusbar), status_id, "Stop failed");
-  }
-}
-
-static void
-accurate_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  accurate_seek = gtk_toggle_button_get_active (button);
-}
-
-static void
-key_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  keyframe_seek = gtk_toggle_button_get_active (button);
-}
-
-static void
-loop_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  loop_seek = gtk_toggle_button_get_active (button);
-  if (state == GST_STATE_PLAYING) {
-    do_seek (hscale);
-  }
-}
-
-static void
-flush_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  flush_seek = gtk_toggle_button_get_active (button);
-}
-
-static void
-scrub_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  scrub = gtk_toggle_button_get_active (button);
-}
-
-static void
-play_scrub_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  play_scrub = gtk_toggle_button_get_active (button);
-}
-
-static void
-skip_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  skip_seek = gtk_toggle_button_get_active (button);
-  if (state == GST_STATE_PLAYING) {
-    do_seek (hscale);
-  }
-}
-
-static void
-rate_spinbutton_changed_cb (GtkSpinButton * button, GstPipeline * pipeline)
-{
-  gboolean res = FALSE;
-  GstEvent *s_event;
-  GstSeekFlags flags;
-
-  rate = gtk_spin_button_get_value (button);
-
-  GST_DEBUG ("rate changed to %lf", rate);
-
-  flags = 0;
-  if (flush_seek)
-    flags |= GST_SEEK_FLAG_FLUSH;
-  if (loop_seek)
-    flags |= GST_SEEK_FLAG_SEGMENT;
-  if (accurate_seek)
-    flags |= GST_SEEK_FLAG_ACCURATE;
-  if (keyframe_seek)
-    flags |= GST_SEEK_FLAG_KEY_UNIT;
-  if (skip_seek)
-    flags |= GST_SEEK_FLAG_SKIP;
-
-  if (rate >= 0.0) {
-    s_event = gst_event_new_seek (rate,
-        GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, position,
-        GST_SEEK_TYPE_SET, GST_CLOCK_TIME_NONE);
-  } else {
-    s_event = gst_event_new_seek (rate,
-        GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, G_GINT64_CONSTANT (0),
-        GST_SEEK_TYPE_SET, position);
-  }
-
-  res = send_event (s_event);
-
-  if (res) {
-    if (flush_seek) {
-      gst_element_get_state (GST_ELEMENT (pipeline), NULL, NULL, SEEK_TIMEOUT);
-    }
-  } else
-    g_print ("seek failed\n");
-}
-
-static void
-update_flag (GstPipeline * pipeline, gint num, gboolean state)
-{
-  gint flags;
-
-  g_object_get (pipeline, "flags", &flags, NULL);
-  if (state)
-    flags |= (1 << num);
-  else
-    flags &= ~(1 << num);
-  g_object_set (pipeline, "flags", flags, NULL);
-}
-
-static void
-vis_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  gboolean state;
-
-  state = gtk_toggle_button_get_active (button);
-  update_flag (pipeline, 3, state);
-  gtk_widget_set_sensitive (vis_combo, state);
-}
-
-static void
-audio_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  gboolean state;
-
-  state = gtk_toggle_button_get_active (button);
-  update_flag (pipeline, 1, state);
-  gtk_widget_set_sensitive (audio_combo, state);
-}
-
-static void
-video_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  gboolean state;
-
-  state = gtk_toggle_button_get_active (button);
-  update_flag (pipeline, 0, state);
-  gtk_widget_set_sensitive (video_combo, state);
-}
-
-static void
-text_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  gboolean state;
-
-  state = gtk_toggle_button_get_active (button);
-  update_flag (pipeline, 2, state);
-  gtk_widget_set_sensitive (text_combo, state);
-}
-
-static void
-mute_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  gboolean mute;
-
-  mute = gtk_toggle_button_get_active (button);
-  g_object_set (pipeline, "mute", mute, NULL);
-}
-
-static void
-download_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  gboolean state;
-
-  state = gtk_toggle_button_get_active (button);
-  update_flag (pipeline, 7, state);
-}
-
-static void
-buffer_toggle_cb (GtkToggleButton * button, GstPipeline * pipeline)
-{
-  gboolean state;
-
-  state = gtk_toggle_button_get_active (button);
-  update_flag (pipeline, 8, state);
-}
-
-static void
-clear_streams (GstElement * pipeline)
-{
-  gint i;
-
-  /* remove previous info */
-  for (i = 0; i < n_video; i++)
-    gtk_combo_box_text_remove (GTK_COMBO_BOX_TEXT (video_combo), 0);
-  for (i = 0; i < n_audio; i++)
-    gtk_combo_box_text_remove (GTK_COMBO_BOX_TEXT (audio_combo), 0);
-  for (i = 0; i < n_text; i++)
-    gtk_combo_box_text_remove (GTK_COMBO_BOX_TEXT (text_combo), 0);
-
-  n_audio = n_video = n_text = 0;
-  gtk_widget_set_sensitive (video_combo, FALSE);
-  gtk_widget_set_sensitive (audio_combo, FALSE);
-  gtk_widget_set_sensitive (text_combo, FALSE);
-
-  need_streams = TRUE;
-}
-
-static void
-update_streams (GstPipeline * pipeline)
-{
-  gint i;
-
-  if (pipeline_type == 16 && need_streams) {
-    GstTagList *tags;
-    gchar *name, *str;
-    gint active_idx;
-    gboolean state;
-
-    /* remove previous info */
-    clear_streams (GST_ELEMENT_CAST (pipeline));
-
-    /* here we get and update the different streams detected by playbin2 */
-    g_object_get (pipeline, "n-video", &n_video, NULL);
-    g_object_get (pipeline, "n-audio", &n_audio, NULL);
-    g_object_get (pipeline, "n-text", &n_text, NULL);
-
-    g_print ("video %d, audio %d, text %d\n", n_video, n_audio, n_text);
-
-    active_idx = 0;
-    for (i = 0; i < n_video; i++) {
-      g_signal_emit_by_name (pipeline, "get-video-tags", i, &tags);
-      if (tags) {
-        str = gst_structure_to_string ((GstStructure *) tags);
-        g_print ("video %d: %s\n", i, str);
-        g_free (str);
-      }
-      /* find good name for the label */
-      name = g_strdup_printf ("video %d", i + 1);
-      gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (video_combo), name);
-      g_free (name);
-    }
-    state = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (video_checkbox));
-    gtk_widget_set_sensitive (video_combo, state && n_video > 0);
-    gtk_combo_box_set_active (GTK_COMBO_BOX (video_combo), active_idx);
-
-    active_idx = 0;
-    for (i = 0; i < n_audio; i++) {
-      g_signal_emit_by_name (pipeline, "get-audio-tags", i, &tags);
-      if (tags) {
-        str = gst_structure_to_string ((GstStructure *) tags);
-        g_print ("audio %d: %s\n", i, str);
-        g_free (str);
-      }
-      /* find good name for the label */
-      name = g_strdup_printf ("audio %d", i + 1);
-      gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (audio_combo), name);
-      g_free (name);
-    }
-    state = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (audio_checkbox));
-    gtk_widget_set_sensitive (audio_combo, state && n_audio > 0);
-    gtk_combo_box_set_active (GTK_COMBO_BOX (audio_combo), active_idx);
-
-    active_idx = 0;
-    for (i = 0; i < n_text; i++) {
-      g_signal_emit_by_name (pipeline, "get-text-tags", i, &tags);
-
-      name = NULL;
-      if (tags) {
-        const GValue *value;
-
-        str = gst_structure_to_string ((GstStructure *) tags);
-        g_print ("text %d: %s\n", i, str);
-        g_free (str);
-
-        /* get the language code if we can */
-        value = gst_tag_list_get_value_index (tags, GST_TAG_LANGUAGE_CODE, 0);
-        if (value && G_VALUE_HOLDS_STRING (value)) {
-          name = g_strdup_printf ("text %s", g_value_get_string (value));
-        }
-      }
-      /* find good name for the label if we didn't use a tag */
-      if (name == NULL)
-        name = g_strdup_printf ("text %d", i + 1);
-
-      gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (text_combo), name);
-      g_free (name);
-    }
-    state = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (text_checkbox));
-    gtk_widget_set_sensitive (text_combo, state && n_text > 0);
-    gtk_combo_box_set_active (GTK_COMBO_BOX (text_combo), active_idx);
-
-    need_streams = FALSE;
-  }
-}
-
-static void
-video_combo_cb (GtkComboBox * combo, GstPipeline * pipeline)
-{
-  gint active;
-
-  active = gtk_combo_box_get_active (combo);
-
-  g_print ("setting current video track %d\n", active);
-  g_object_set (pipeline, "current-video", active, NULL);
-}
-
-static void
-audio_combo_cb (GtkComboBox * combo, GstPipeline * pipeline)
-{
-  gint active;
-
-  active = gtk_combo_box_get_active (combo);
-
-  g_print ("setting current audio track %d\n", active);
-  g_object_set (pipeline, "current-audio", active, NULL);
-}
-
-static void
-text_combo_cb (GtkComboBox * combo, GstPipeline * pipeline)
-{
-  gint active;
-
-  active = gtk_combo_box_get_active (combo);
-
-  g_print ("setting current text track %d\n", active);
-  g_object_set (pipeline, "current-text", active, NULL);
-}
-
-static gboolean
-filter_features (GstPluginFeature * feature, gpointer data)
-{
-  GstElementFactory *f;
-
-  if (!GST_IS_ELEMENT_FACTORY (feature))
-    return FALSE;
-  f = GST_ELEMENT_FACTORY (feature);
-  if (!g_strrstr (gst_element_factory_get_klass (f), "Visualization"))
-    return FALSE;
-
-  return TRUE;
-}
-
-static void
-init_visualization_features (void)
-{
-  GList *list, *walk;
-
-  vis_entries = g_array_new (FALSE, FALSE, sizeof (VisEntry));
-
-  list = gst_registry_feature_filter (gst_registry_get_default (),
-      filter_features, FALSE, NULL);
-
-  for (walk = list; walk; walk = g_list_next (walk)) {
-    VisEntry entry;
-    const gchar *name;
-
-    entry.factory = GST_ELEMENT_FACTORY (walk->data);
-    name = gst_element_factory_get_longname (entry.factory);
-
-    g_array_append_val (vis_entries, entry);
-    gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (vis_combo), name);
-  }
-  gtk_combo_box_set_active (GTK_COMBO_BOX (vis_combo), 0);
-}
-
-static void
-vis_combo_cb (GtkComboBox * combo, GstPipeline * pipeline)
-{
-  guint index;
-  VisEntry *entry;
-  GstElement *element;
-
-  /* get the selected index and get the factory for this index */
-  index = gtk_combo_box_get_active (GTK_COMBO_BOX (vis_combo));
-  if (vis_entries->len > 0) {
-    entry = &g_array_index (vis_entries, VisEntry, index);
-
-    /* create an instance of the element from the factory */
-    element = gst_element_factory_create (entry->factory, NULL);
-    if (!element)
-      return;
-
-    /* set vis plugin for playbin2 */
-    g_object_set (pipeline, "vis-plugin", element, NULL);
-  }
-}
-
-static void
-volume_spinbutton_changed_cb (GtkSpinButton * button, GstPipeline * pipeline)
-{
-  gdouble volume;
-
-  volume = gtk_spin_button_get_value (button);
-
-  g_object_set (pipeline, "volume", volume, NULL);
-}
-
-static void
-volume_notify_cb (GstElement * pipeline, GParamSpec * arg, gpointer user_dat)
-{
-  gdouble cur_volume, new_volume;
-
-  g_object_get (pipeline, "volume", &new_volume, NULL);
-  cur_volume = gtk_spin_button_get_value (GTK_SPIN_BUTTON (volume_spinbutton));
-  if (fabs (cur_volume - new_volume) > 0.001) {
-    g_signal_handlers_block_by_func (volume_spinbutton,
-        volume_spinbutton_changed_cb, pipeline);
-    gtk_spin_button_set_value (GTK_SPIN_BUTTON (volume_spinbutton), new_volume);
-    g_signal_handlers_unblock_by_func (volume_spinbutton,
-        volume_spinbutton_changed_cb, pipeline);
-  }
-}
-
-static void
-shot_cb (GtkButton * button, gpointer data)
-{
-  GstBuffer *buffer;
-  GstCaps *caps;
-
-  /* convert to our desired format (RGB24) */
-  caps = gst_caps_new_simple ("video/x-raw-rgb",
-      "bpp", G_TYPE_INT, 24, "depth", G_TYPE_INT, 24,
-      /* Note: we don't ask for a specific width/height here, so that
-       * videoscale can adjust dimensions from a non-1/1 pixel aspect
-       * ratio to a 1/1 pixel-aspect-ratio */
-      "pixel-aspect-ratio", GST_TYPE_FRACTION, 1, 1,
-      "endianness", G_TYPE_INT, G_BIG_ENDIAN,
-      "red_mask", G_TYPE_INT, 0xff0000,
-      "green_mask", G_TYPE_INT, 0x00ff00,
-      "blue_mask", G_TYPE_INT, 0x0000ff, NULL);
-
-  /* convert the latest frame to the requested format */
-  g_signal_emit_by_name (pipeline, "convert-frame", caps, &buffer);
-  gst_caps_unref (caps);
-
-  if (buffer) {
-    GstCaps *caps;
-    GstStructure *s;
-    gboolean res;
-    gint width, height;
-    GdkPixbuf *pixbuf;
-    GError *error = NULL;
-
-    /* get the snapshot buffer format now. We set the caps on the appsink so
-     * that it can only be an rgb buffer. The only thing we have not specified
-     * on the caps is the height, which is dependant on the pixel-aspect-ratio
-     * of the source material */
-    caps = GST_BUFFER_CAPS (buffer);
-    if (!caps) {
-      g_warning ("could not get snapshot format\n");
-      goto done;
-    }
-    s = gst_caps_get_structure (caps, 0);
-
-    /* we need to get the final caps on the buffer to get the size */
-    res = gst_structure_get_int (s, "width", &width);
-    res |= gst_structure_get_int (s, "height", &height);
-    if (!res) {
-      g_warning ("could not get snapshot dimension\n");
-      goto done;
-    }
-
-    /* create pixmap from buffer and save, gstreamer video buffers have a stride
-     * that is rounded up to the nearest multiple of 4 */
-    pixbuf = gdk_pixbuf_new_from_data (GST_BUFFER_DATA (buffer),
-        GDK_COLORSPACE_RGB, FALSE, 8, width, height,
-        GST_ROUND_UP_4 (width * 3), NULL, NULL);
-
-    /* save the pixbuf */
-    gdk_pixbuf_save (pixbuf, "snapshot.png", "png", &error, NULL);
-
-  done:
-    gst_buffer_unref (buffer);
-  }
-}
-
-/* called when the Step button is pressed */
-static void
-step_cb (GtkButton * button, gpointer data)
-{
-  GstEvent *event;
-  GstFormat format;
-  guint64 amount;
-  gdouble rate;
-  gboolean flush, res;
-  gint active;
-
-  active = gtk_combo_box_get_active (GTK_COMBO_BOX (format_combo));
-  amount =
-      gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON
-      (step_amount_spinbutton));
-  rate = gtk_spin_button_get_value (GTK_SPIN_BUTTON (step_rate_spinbutton));
-  flush = TRUE;
-
-  switch (active) {
-    case 0:
-      format = GST_FORMAT_BUFFERS;
-      break;
-    case 1:
-      format = GST_FORMAT_TIME;
-      amount *= GST_MSECOND;
-      break;
-    default:
-      format = GST_FORMAT_UNDEFINED;
-      break;
-  }
-
-  event = gst_event_new_step (format, amount, rate, flush, FALSE);
-
-  res = send_event (event);
-
-  if (!res) {
-    g_print ("Sending step event failed\n");
-  }
-}
-
-static void
-message_received (GstBus * bus, GstMessage * message, GstPipeline * pipeline)
-{
-  const GstStructure *s;
-
-  switch (GST_MESSAGE_TYPE (message)) {
-    case GST_MESSAGE_ERROR:
-      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (pipeline),
-          GST_DEBUG_GRAPH_SHOW_ALL, "seek.error");
-      break;
-    case GST_MESSAGE_WARNING:
-      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (pipeline),
-          GST_DEBUG_GRAPH_SHOW_ALL, "seek.warning");
-      break;
-    default:
-      break;
-  }
-
-  s = gst_message_get_structure (message);
-  g_print ("message from \"%s\" (%s): ",
-      GST_STR_NULL (GST_ELEMENT_NAME (GST_MESSAGE_SRC (message))),
-      gst_message_type_get_name (GST_MESSAGE_TYPE (message)));
-  if (s) {
-    gchar *sstr;
-
-    sstr = gst_structure_to_string (s);
-    g_print ("%s\n", sstr);
-    g_free (sstr);
-  } else {
-    g_print ("no message details\n");
-  }
-}
-
-static gboolean shuttling = FALSE;
-static gdouble shuttle_rate = 0.0;
-static gdouble play_rate = 1.0;
-
-static void
-do_shuttle (GstElement * element)
-{
-  guint64 duration;
-
-  if (shuttling)
-    duration = 40 * GST_MSECOND;
-  else
-    duration = -1;
-
-  gst_element_send_event (element,
-      gst_event_new_step (GST_FORMAT_TIME, duration, shuttle_rate, FALSE,
-          FALSE));
-}
-
-static void
-msg_sync_step_done (GstBus * bus, GstMessage * message, GstElement * element)
-{
-  GstFormat format;
-  guint64 amount;
-  gdouble rate;
-  gboolean flush;
-  gboolean intermediate;
-  guint64 duration;
-  gboolean eos;
-
-  gst_message_parse_step_done (message, &format, &amount, &rate, &flush,
-      &intermediate, &duration, &eos);
-
-  if (eos) {
-    g_print ("stepped till EOS\n");
-    return;
-  }
-
-  if (g_static_mutex_trylock (&state_mutex)) {
-    if (shuttling)
-      do_shuttle (element);
-    g_static_mutex_unlock (&state_mutex);
-  } else {
-    /* ignore step messages that come while we are doing a state change */
-    g_print ("state change is busy\n");
-  }
-}
-
-static void
-shuttle_toggled (GtkToggleButton * button, GstElement * element)
-{
-  gboolean active;
-
-  active = gtk_toggle_button_get_active (button);
-
-  if (active != shuttling) {
-    shuttling = active;
-    g_print ("shuttling %s\n", shuttling ? "active" : "inactive");
-    if (active) {
-      shuttle_rate = 0.0;
-      play_rate = 1.0;
-      pause_cb (NULL, NULL);
-      gst_element_get_state (element, NULL, NULL, -1);
-    }
-  }
-}
-
-static void
-shuttle_rate_switch (GstElement * element)
-{
-  GstSeekFlags flags;
-  GstEvent *s_event;
-  gboolean res;
-
-  if (state == GST_STATE_PLAYING) {
-    /* pause when we need to */
-    pause_cb (NULL, NULL);
-    gst_element_get_state (element, NULL, NULL, -1);
-  }
-
-  if (play_rate == 1.0)
-    play_rate = -1.0;
-  else
-    play_rate = 1.0;
-
-  g_print ("rate changed to %lf %" GST_TIME_FORMAT "\n", play_rate,
-      GST_TIME_ARGS (position));
-
-  flags = GST_SEEK_FLAG_FLUSH;
-  flags |= GST_SEEK_FLAG_ACCURATE;
-
-  if (play_rate >= 0.0) {
-    s_event = gst_event_new_seek (play_rate,
-        GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, position,
-        GST_SEEK_TYPE_SET, GST_CLOCK_TIME_NONE);
-  } else {
-    s_event = gst_event_new_seek (play_rate,
-        GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, G_GINT64_CONSTANT (0),
-        GST_SEEK_TYPE_SET, position);
-  }
-  res = send_event (s_event);
-  if (res) {
-    gst_element_get_state (element, NULL, NULL, SEEK_TIMEOUT);
-  } else {
-    g_print ("seek failed\n");
-  }
-}
-
-static void
-shuttle_value_changed (GtkRange * range, GstElement * element)
-{
-  gdouble rate;
-
-  rate = gtk_adjustment_get_value (shuttle_adjustment);
-
-  if (rate == 0.0) {
-    g_print ("rate 0.0, pause\n");
-    pause_cb (NULL, NULL);
-    gst_element_get_state (element, NULL, NULL, -1);
-  } else {
-    g_print ("rate changed %0.3g\n", rate);
-
-    if ((rate < 0.0 && play_rate > 0.0) || (rate > 0.0 && play_rate < 0.0)) {
-      shuttle_rate_switch (element);
-    }
-
-    shuttle_rate = ABS (rate);
-    if (state != GST_STATE_PLAYING) {
-      do_shuttle (element);
-      play_cb (NULL, NULL);
-    }
-  }
-}
-
-static void
-msg_async_done (GstBus * bus, GstMessage * message, GstPipeline * pipeline)
-{
-  GST_DEBUG ("async done");
-  /* when we get ASYNC_DONE we can query position, duration and other
-   * properties */
-  update_scale (pipeline);
-
-  /* update the available streams */
-  update_streams (pipeline);
-}
-
-static void
-msg_state_changed (GstBus * bus, GstMessage * message, GstPipeline * pipeline)
-{
-  const GstStructure *s;
-
-  s = gst_message_get_structure (message);
-
-  /* We only care about state changed on the pipeline */
-  if (s && GST_MESSAGE_SRC (message) == GST_OBJECT_CAST (pipeline)) {
-    GstState old, new, pending;
-
-    gst_message_parse_state_changed (message, &old, &new, &pending);
-
-    /* When state of the pipeline changes to paused or playing we start updating scale */
-    if (new == GST_STATE_PLAYING) {
-      set_update_scale (TRUE);
-    } else {
-      set_update_scale (FALSE);
-    }
-
-    /* dump graph for (some) pipeline state changes */
-    {
-      gchar *dump_name;
-
-      dump_name = g_strdup_printf ("seek.%s_%s",
-          gst_element_state_get_name (old), gst_element_state_get_name (new));
-
-      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (pipeline),
-          GST_DEBUG_GRAPH_SHOW_ALL, dump_name);
-
-      g_free (dump_name);
-    }
-  }
-}
-
-static void
-msg_segment_done (GstBus * bus, GstMessage * message, GstPipeline * pipeline)
-{
-  GstEvent *s_event;
-  GstSeekFlags flags;
-  gboolean res;
-  GstFormat format;
-
-  GST_DEBUG ("position is %" GST_TIME_FORMAT, GST_TIME_ARGS (position));
-  gst_message_parse_segment_done (message, &format, &position);
-  GST_DEBUG ("end of segment at %" GST_TIME_FORMAT, GST_TIME_ARGS (position));
-
-  flags = 0;
-  /* in the segment-done callback we never flush as this would not make sense
-   * for seamless playback. */
-  if (loop_seek)
-    flags |= GST_SEEK_FLAG_SEGMENT;
-  if (skip_seek)
-    flags |= GST_SEEK_FLAG_SKIP;
-
-  s_event = gst_event_new_seek (rate,
-      GST_FORMAT_TIME, flags, GST_SEEK_TYPE_SET, G_GINT64_CONSTANT (0),
-      GST_SEEK_TYPE_SET, duration);
-
-  GST_DEBUG ("restart loop with rate %lf to 0 / %" GST_TIME_FORMAT,
-      rate, GST_TIME_ARGS (duration));
-
-  res = send_event (s_event);
-  if (!res)
-    g_print ("segment seek failed\n");
-}
-
-/* in stream buffering mode we PAUSE the pipeline until we receive a 100%
- * message */
-static void
-do_stream_buffering (gint percent)
-{
-  gchar *bufstr;
-
-  gtk_statusbar_pop (GTK_STATUSBAR (statusbar), status_id);
-  bufstr = g_strdup_printf ("Buffering...%d", percent);
-  gtk_statusbar_push (GTK_STATUSBAR (statusbar), status_id, bufstr);
-  g_free (bufstr);
-
-  if (percent == 100) {
-    /* a 100% message means buffering is done */
-    buffering = FALSE;
-    /* if the desired state is playing, go back */
-    if (state == GST_STATE_PLAYING) {
-      /* no state management needed for live pipelines */
-      if (!is_live) {
-        fprintf (stderr, "Done buffering, setting pipeline to PLAYING ...\n");
-        gst_element_set_state (pipeline, GST_STATE_PLAYING);
-      }
-      gtk_statusbar_pop (GTK_STATUSBAR (statusbar), status_id);
-      gtk_statusbar_push (GTK_STATUSBAR (statusbar), status_id, "Playing");
-    }
-  } else {
-    /* buffering busy */
-    if (buffering == FALSE && state == GST_STATE_PLAYING) {
-      /* we were not buffering but PLAYING, PAUSE  the pipeline. */
-      if (!is_live) {
-        fprintf (stderr, "Buffering, setting pipeline to PAUSED ...\n");
-        gst_element_set_state (pipeline, GST_STATE_PAUSED);
-      }
-    }
-    buffering = TRUE;
-  }
-}
-
-static void
-do_download_buffering (gint percent)
-{
-  if (!buffering && percent < 100) {
-    gchar *bufstr;
-
-    buffering = TRUE;
-
-    bufstr = g_strdup_printf ("Downloading...");
-    gtk_statusbar_push (GTK_STATUSBAR (statusbar), status_id, bufstr);
-    g_free (bufstr);
-
-    /* once we get a buffering message, we'll do the fill update */
-    set_update_fill (TRUE);
-
-    if (state == GST_STATE_PLAYING && !is_live) {
-      fprintf (stderr, "Downloading, setting pipeline to PAUSED ...\n");
-      gst_element_set_state (pipeline, GST_STATE_PAUSED);
-      /* user has to manually start the playback */
-      state = GST_STATE_PAUSED;
-    }
-  }
-}
-
-static void
-msg_buffering (GstBus * bus, GstMessage * message, GstPipeline * data)
-{
-  gint percent;
-
-  gst_message_parse_buffering (message, &percent);
-
-  /* get more stats */
-  gst_message_parse_buffering_stats (message, &mode, NULL, NULL,
-      &buffering_left);
-
-  switch (mode) {
-    case GST_BUFFERING_DOWNLOAD:
-      do_download_buffering (percent);
-      break;
-    case GST_BUFFERING_LIVE:
-      is_live = TRUE;
-    case GST_BUFFERING_TIMESHIFT:
-    case GST_BUFFERING_STREAM:
-      do_stream_buffering (percent);
-      break;
-  }
-}
-
-static void
-msg_clock_lost (GstBus * bus, GstMessage * message, GstPipeline * data)
-{
-  g_print ("clock lost! PAUSE and PLAY to select a new clock\n");
-  if (state == GST_STATE_PLAYING) {
-    gst_element_set_state (pipeline, GST_STATE_PAUSED);
-    gst_element_set_state (pipeline, GST_STATE_PLAYING);
-  }
-}
-
-#if defined (GDK_WINDOWING_X11) || defined (GDK_WINDOWING_WIN32)
-
-static gulong embed_xid = 0;
-
-/* We set the xid here in response to the prepare-xwindow-id message via a
- * bus sync handler because we don't know the actual videosink used from the
- * start (as we don't know the pipeline, or bin elements such as autovideosink
- * or gconfvideosink may be used which create the actual videosink only once
- * the pipeline is started) */
-static GstBusSyncReply
-bus_sync_handler (GstBus * bus, GstMessage * message, GstPipeline * data)
-{
-  if ((GST_MESSAGE_TYPE (message) == GST_MESSAGE_ELEMENT) &&
-      gst_structure_has_name (message->structure, "prepare-xwindow-id")) {
-    GstElement *element = GST_ELEMENT (GST_MESSAGE_SRC (message));
-
-    g_print ("got prepare-xwindow-id, setting XID %lu\n", embed_xid);
-
-    if (g_object_class_find_property (G_OBJECT_GET_CLASS (element),
-            "force-aspect-ratio")) {
-      g_object_set (element, "force-aspect-ratio", TRUE, NULL);
-    }
-
-    /* Should have been initialised from main thread before (can't use
-     * GDK_WINDOW_XID here with Gtk+ >= 2.18, because the sync handler will
-     * be called from a streaming thread and GDK_WINDOW_XID maps to more than
-     * a simple structure lookup with Gtk+ >= 2.18, where 'more' is stuff that
-     * shouldn't be done from a non-GUI thread without explicit locking).  */
-    g_assert (embed_xid != 0);
-
-    gst_x_overlay_set_window_handle (GST_X_OVERLAY (element), embed_xid);
-  }
-  return GST_BUS_PASS;
-}
-#endif
-
-static gboolean
-draw_cb (GtkWidget * widget, cairo_t * cr, gpointer data)
-{
-  if (state < GST_STATE_PAUSED) {
-    int width, height;
-
-    width = gtk_widget_get_allocated_width (widget);
-    height = gtk_widget_get_allocated_height (widget);
-    cairo_set_source_rgb (cr, 0, 0, 0);
-    cairo_rectangle (cr, 0, 0, width, height);
-    cairo_fill (cr);
-    return TRUE;
-  }
-  return FALSE;
-}
-
-static void
-realize_cb (GtkWidget * widget, gpointer data)
-{
-  GdkWindow *window = gtk_widget_get_window (widget);
-
-  /* This is here just for pedagogical purposes, GDK_WINDOW_XID will call it
-   * as well */
-  if (!gdk_window_ensure_native (window))
-    g_error ("Couldn't create native window needed for GstXOverlay!");
-
-#if defined (GDK_WINDOWING_WIN32)
-  embed_xid = GDK_WINDOW_HWND (window);
-  g_print ("Window realize: video window HWND = %lu\n", embed_xid);
-#else
-  embed_xid = GDK_WINDOW_XID (window);
-  g_print ("Window realize: video window XID = %lu\n", embed_xid);
-#endif
-}
-
-static void
-msg_eos (GstBus * bus, GstMessage * message, GstPipeline * data)
-{
-  message_received (bus, message, data);
-
-  /* Set new uri for playerbins and continue playback */
-  if (l && (pipeline_type == 14 || pipeline_type == 16)) {
-    stop_cb (NULL, NULL);
-    l = g_list_next (l);
-    if (l) {
-      playerbin_set_uri (GST_ELEMENT (data), l->data);
-      play_cb (NULL, NULL);
-    }
-  }
-}
-
-static void
-msg_step_done (GstBus * bus, GstMessage * message, GstPipeline * data)
-{
-  if (!shuttling)
-    message_received (bus, message, data);
-}
-
-static void
-connect_bus_signals (GstElement * pipeline)
-{
-  GstBus *bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
-
-#if defined (GDK_WINDOWING_X11) || defined (GDK_WINDOWING_WIN32)
-  /* handle prepare-xwindow-id element message synchronously */
-  gst_bus_set_sync_handler (bus, (GstBusSyncHandler) bus_sync_handler,
-      pipeline);
-#endif
-
-  gst_bus_add_signal_watch_full (bus, G_PRIORITY_HIGH);
-  gst_bus_enable_sync_message_emission (bus);
-
-  g_signal_connect (bus, "message::state-changed",
-      (GCallback) msg_state_changed, pipeline);
-  g_signal_connect (bus, "message::segment-done", (GCallback) msg_segment_done,
-      pipeline);
-  g_signal_connect (bus, "message::async-done", (GCallback) msg_async_done,
-      pipeline);
-
-  g_signal_connect (bus, "message::new-clock", (GCallback) message_received,
-      pipeline);
-  g_signal_connect (bus, "message::clock-lost", (GCallback) msg_clock_lost,
-      pipeline);
-  g_signal_connect (bus, "message::error", (GCallback) message_received,
-      pipeline);
-  g_signal_connect (bus, "message::warning", (GCallback) message_received,
-      pipeline);
-  g_signal_connect (bus, "message::eos", (GCallback) msg_eos, pipeline);
-  g_signal_connect (bus, "message::tag", (GCallback) message_received,
-      pipeline);
-  g_signal_connect (bus, "message::element", (GCallback) message_received,
-      pipeline);
-  g_signal_connect (bus, "message::segment-done", (GCallback) message_received,
-      pipeline);
-  g_signal_connect (bus, "message::buffering", (GCallback) msg_buffering,
-      pipeline);
-//  g_signal_connect (bus, "message::step-done", (GCallback) msg_step_done,
-//      pipeline);
-  g_signal_connect (bus, "message::step-start", (GCallback) msg_step_done,
-      pipeline);
-  g_signal_connect (bus, "sync-message::step-done",
-      (GCallback) msg_sync_step_done, pipeline);
-
-  gst_object_unref (bus);
-}
-
-/* Return GList of paths described in location string */
-static GList *
-handle_wildcards (const gchar * location)
-{
-  GList *res = NULL;
-  gchar *path = g_path_get_dirname (location);
-  gchar *pattern = g_path_get_basename (location);
-  GPatternSpec *pspec = g_pattern_spec_new (pattern);
-  GDir *dir = g_dir_open (path, 0, NULL);
-  const gchar *name;
-
-  g_print ("matching %s from %s\n", pattern, path);
-
-  if (!dir) {
-    g_print ("opening directory %s failed\n", path);
-    goto out;
-  }
-
-  while ((name = g_dir_read_name (dir)) != NULL) {
-    if (g_pattern_match_string (pspec, name)) {
-      res = g_list_append (res, g_strjoin ("/", path, name, NULL));
-      g_print ("  found clip %s\n", name);
-    }
-  }
-
-  g_dir_close (dir);
-out:
-  g_pattern_spec_free (pspec);
-  g_free (pattern);
-  g_free (path);
-
-  return res;
-}
-
-static void
-delete_event_cb (void)
-{
-  stop_cb (NULL, NULL);
-  gtk_main_quit ();
-}
-
-static void
-print_usage (int argc, char **argv)
-{
-  gint i;
-
-  g_print ("usage: %s <type> <filename>\n", argv[0]);
-  g_print ("   possible types:\n");
-
-  for (i = 0; i < NUM_TYPES; i++) {
-    g_print ("     %d = %s\n", i, pipelines[i].name);
-  }
-}
-
-int
-main (int argc, char **argv)
-{
-  GtkWidget *window, *hbox, *vbox, *panel, *expander, *pb2vbox, *boxes,
-      *flagtable, *boxes2, *step;
-  GtkWidget *play_button, *pause_button, *stop_button, *shot_button;
-  GtkWidget *accurate_checkbox, *key_checkbox, *loop_checkbox, *flush_checkbox;
-  GtkWidget *scrub_checkbox, *play_scrub_checkbox;
-  GtkWidget *rate_label, *volume_label;
-  GOptionEntry options[] = {
-    {"audiosink", '\0', 0, G_OPTION_ARG_STRING, &opt_audiosink_str,
-        "audio sink to use (default: " DEFAULT_AUDIOSINK ")", NULL},
-    {"stats", 's', 0, G_OPTION_ARG_NONE, &stats,
-        "Show pad stats", NULL},
-    {"elem", 'e', 0, G_OPTION_ARG_NONE, &elem_seek,
-        "Seek on elements instead of pads", NULL},
-    {"verbose", 'v', 0, G_OPTION_ARG_NONE, &verbose,
-        "Verbose properties", NULL},
-    {"videosink", '\0', 0, G_OPTION_ARG_STRING, &opt_videosink_str,
-        "video sink to use (default: " DEFAULT_VIDEOSINK ")", NULL},
-    {NULL}
-  };
-  GOptionContext *ctx;
-  GError *err = NULL;
-
-#if !GLIB_CHECK_VERSION (2, 31, 0)
-  if (!g_thread_supported ())
-    g_thread_init (NULL);
-#endif
-
-  ctx = g_option_context_new ("- test seeking in gsteamer");
-  g_option_context_add_main_entries (ctx, options, NULL);
-  g_option_context_add_group (ctx, gst_init_get_option_group ());
-  g_option_context_add_group (ctx, gtk_get_option_group (TRUE));
-
-  if (!g_option_context_parse (ctx, &argc, &argv, &err)) {
-    g_print ("Error initializing: %s\n", err->message);
-    exit (1);
-  }
-
-  if (opt_audiosink_str == NULL)
-    opt_audiosink_str = g_strdup (DEFAULT_AUDIOSINK);
-
-  if (opt_videosink_str == NULL)
-    opt_videosink_str = g_strdup (DEFAULT_VIDEOSINK);
-
-  GST_DEBUG_CATEGORY_INIT (seek_debug, "seek", 0, "seek example");
-
-  if (argc != 3) {
-    print_usage (argc, argv);
-    exit (-1);
-  }
-
-  pipeline_type = atoi (argv[1]);
-
-  if (pipeline_type < 0 || pipeline_type >= NUM_TYPES) {
-    print_usage (argc, argv);
-    exit (-1);
-  }
-
-  pipeline_spec = argv[2];
-
-  if (g_path_is_absolute (pipeline_spec) &&
-      (g_strrstr (pipeline_spec, "*") != NULL ||
-          g_strrstr (pipeline_spec, "?") != NULL)) {
-    paths = handle_wildcards (pipeline_spec);
-  } else {
-    paths = g_list_prepend (paths, g_strdup (pipeline_spec));
-  }
-
-  if (!paths) {
-    g_print ("opening %s failed\n", pipeline_spec);
-    exit (-1);
-  }
-
-  l = paths;
-
-  pipeline = pipelines[pipeline_type].func ((gchar *) l->data);
-  g_assert (pipeline);
-
-  /* initialize gui elements ... */
-  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-  video_window = gtk_drawing_area_new ();
-  g_signal_connect (video_window, "draw", G_CALLBACK (draw_cb), NULL);
-  g_signal_connect (video_window, "realize", G_CALLBACK (realize_cb), NULL);
-  gtk_widget_set_double_buffered (video_window, FALSE);
-
-  statusbar = gtk_statusbar_new ();
-  status_id = gtk_statusbar_get_context_id (GTK_STATUSBAR (statusbar), "seek");
-  gtk_statusbar_push (GTK_STATUSBAR (statusbar), status_id, "Stopped");
-  hbox = gtk_hbox_new (FALSE, 0);
-  vbox = gtk_vbox_new (FALSE, 0);
-  flagtable = gtk_table_new (4, 2, FALSE);
-  gtk_container_set_border_width (GTK_CONTAINER (vbox), 3);
-
-  /* media controls */
-  play_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_PLAY);
-  pause_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_PAUSE);
-  stop_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_STOP);
-
-  /* seek flags */
-  accurate_checkbox = gtk_check_button_new_with_label ("Accurate Seek");
-  key_checkbox = gtk_check_button_new_with_label ("Key-unit Seek");
-  loop_checkbox = gtk_check_button_new_with_label ("Loop");
-  flush_checkbox = gtk_check_button_new_with_label ("Flush");
-  scrub_checkbox = gtk_check_button_new_with_label ("Scrub");
-  play_scrub_checkbox = gtk_check_button_new_with_label ("Play Scrub");
-  skip_checkbox = gtk_check_button_new_with_label ("Play Skip");
-  rate_spinbutton = gtk_spin_button_new_with_range (-100, 100, 0.1);
-  gtk_spin_button_set_digits (GTK_SPIN_BUTTON (rate_spinbutton), 3);
-  rate_label = gtk_label_new ("Rate");
-
-  gtk_widget_set_tooltip_text (accurate_checkbox,
-      "accurate position is requested, this might be considerably slower for some formats");
-  gtk_widget_set_tooltip_text (key_checkbox,
-      "seek to the nearest keyframe. This might be faster but less accurate");
-  gtk_widget_set_tooltip_text (loop_checkbox, "loop playback");
-  gtk_widget_set_tooltip_text (flush_checkbox, "flush pipeline after seeking");
-  gtk_widget_set_tooltip_text (rate_spinbutton, "define the playback rate, "
-      "negative value trigger reverse playback");
-  gtk_widget_set_tooltip_text (scrub_checkbox, "show images while seeking");
-  gtk_widget_set_tooltip_text (play_scrub_checkbox, "play video while seeking");
-  gtk_widget_set_tooltip_text (skip_checkbox,
-      "Skip frames while playing at high frame rates");
-
-  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (flush_checkbox), TRUE);
-  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (scrub_checkbox), TRUE);
-
-  gtk_spin_button_set_value (GTK_SPIN_BUTTON (rate_spinbutton), rate);
-
-  /* step expander */
-  {
-    GtkWidget *hbox;
-
-    step = gtk_expander_new ("step options");
-    hbox = gtk_hbox_new (FALSE, 0);
-
-    format_combo = gtk_combo_box_text_new ();
-    gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (format_combo),
-        "frames");
-    gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (format_combo),
-        "time (ms)");
-    gtk_combo_box_set_active (GTK_COMBO_BOX (format_combo), 0);
-    gtk_box_pack_start (GTK_BOX (hbox), format_combo, FALSE, FALSE, 2);
-
-    step_amount_spinbutton = gtk_spin_button_new_with_range (1, 1000, 1);
-    gtk_spin_button_set_digits (GTK_SPIN_BUTTON (step_amount_spinbutton), 0);
-    gtk_spin_button_set_value (GTK_SPIN_BUTTON (step_amount_spinbutton), 1.0);
-    gtk_box_pack_start (GTK_BOX (hbox), step_amount_spinbutton, FALSE, FALSE,
-        2);
-
-    step_rate_spinbutton = gtk_spin_button_new_with_range (0.0, 100, 0.1);
-    gtk_spin_button_set_digits (GTK_SPIN_BUTTON (step_rate_spinbutton), 3);
-    gtk_spin_button_set_value (GTK_SPIN_BUTTON (step_rate_spinbutton), 1.0);
-    gtk_box_pack_start (GTK_BOX (hbox), step_rate_spinbutton, FALSE, FALSE, 2);
-
-    step_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_FORWARD);
-    gtk_button_set_label (GTK_BUTTON (step_button), "Step");
-    gtk_box_pack_start (GTK_BOX (hbox), step_button, FALSE, FALSE, 2);
-
-    g_signal_connect (G_OBJECT (step_button), "clicked", G_CALLBACK (step_cb),
-        pipeline);
-
-    /* shuttle scale */
-    shuttle_checkbox = gtk_check_button_new_with_label ("Shuttle");
-    gtk_box_pack_start (GTK_BOX (hbox), shuttle_checkbox, FALSE, FALSE, 2);
-    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (shuttle_checkbox), FALSE);
-    g_signal_connect (shuttle_checkbox, "toggled", G_CALLBACK (shuttle_toggled),
-        pipeline);
-
-    shuttle_adjustment =
-        GTK_ADJUSTMENT (gtk_adjustment_new (0.0, -3.00, 4.0, 0.1, 1.0, 1.0));
-    shuttle_hscale = gtk_hscale_new (shuttle_adjustment);
-    gtk_scale_set_digits (GTK_SCALE (shuttle_hscale), 2);
-    gtk_scale_set_value_pos (GTK_SCALE (shuttle_hscale), GTK_POS_TOP);
-    g_signal_connect (shuttle_hscale, "value_changed",
-        G_CALLBACK (shuttle_value_changed), pipeline);
-    g_signal_connect (shuttle_hscale, "format_value",
-        G_CALLBACK (shuttle_format_value), pipeline);
-
-    gtk_box_pack_start (GTK_BOX (hbox), shuttle_hscale, TRUE, TRUE, 2);
-
-    gtk_container_add (GTK_CONTAINER (step), hbox);
-  }
-
-  /* seek bar */
-  adjustment =
-      GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.00, N_GRAD, 0.1, 1.0, 1.0));
-  hscale = gtk_hscale_new (adjustment);
-  gtk_scale_set_digits (GTK_SCALE (hscale), 2);
-  gtk_scale_set_value_pos (GTK_SCALE (hscale), GTK_POS_RIGHT);
-  gtk_range_set_show_fill_level (GTK_RANGE (hscale), TRUE);
-  gtk_range_set_fill_level (GTK_RANGE (hscale), N_GRAD);
-
-  g_signal_connect (hscale, "button_press_event", G_CALLBACK (start_seek),
-      pipeline);
-  g_signal_connect (hscale, "button_release_event", G_CALLBACK (stop_seek),
-      pipeline);
-  g_signal_connect (hscale, "format_value", G_CALLBACK (format_value),
-      pipeline);
-
-  if (pipeline_type == 16) {
-    /* the playbin2 panel controls for the video/audio/subtitle tracks */
-    panel = gtk_hbox_new (FALSE, 0);
-    video_combo = gtk_combo_box_text_new ();
-    audio_combo = gtk_combo_box_text_new ();
-    text_combo = gtk_combo_box_text_new ();
-    gtk_widget_set_sensitive (video_combo, FALSE);
-    gtk_widget_set_sensitive (audio_combo, FALSE);
-    gtk_widget_set_sensitive (text_combo, FALSE);
-    gtk_box_pack_start (GTK_BOX (panel), video_combo, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (panel), audio_combo, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (panel), text_combo, TRUE, TRUE, 2);
-    g_signal_connect (G_OBJECT (video_combo), "changed",
-        G_CALLBACK (video_combo_cb), pipeline);
-    g_signal_connect (G_OBJECT (audio_combo), "changed",
-        G_CALLBACK (audio_combo_cb), pipeline);
-    g_signal_connect (G_OBJECT (text_combo), "changed",
-        G_CALLBACK (text_combo_cb), pipeline);
-    /* playbin2 panel for flag checkboxes and volume/mute */
-    boxes = gtk_hbox_new (FALSE, 0);
-    vis_checkbox = gtk_check_button_new_with_label ("Vis");
-    video_checkbox = gtk_check_button_new_with_label ("Video");
-    audio_checkbox = gtk_check_button_new_with_label ("Audio");
-    text_checkbox = gtk_check_button_new_with_label ("Text");
-    mute_checkbox = gtk_check_button_new_with_label ("Mute");
-    download_checkbox = gtk_check_button_new_with_label ("Download");
-    buffer_checkbox = gtk_check_button_new_with_label ("Buffer");
-    volume_label = gtk_label_new ("Volume");
-    volume_spinbutton = gtk_spin_button_new_with_range (0, 10.0, 0.1);
-    gtk_spin_button_set_value (GTK_SPIN_BUTTON (volume_spinbutton), 1.0);
-    gtk_box_pack_start (GTK_BOX (boxes), video_checkbox, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (boxes), audio_checkbox, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (boxes), text_checkbox, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (boxes), vis_checkbox, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (boxes), mute_checkbox, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (boxes), download_checkbox, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (boxes), buffer_checkbox, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (boxes), volume_label, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (boxes), volume_spinbutton, TRUE, TRUE, 2);
-    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (vis_checkbox), FALSE);
-    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (audio_checkbox), TRUE);
-    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (video_checkbox), TRUE);
-    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (text_checkbox), TRUE);
-    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (mute_checkbox), FALSE);
-    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (download_checkbox), FALSE);
-    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (buffer_checkbox), FALSE);
-    g_signal_connect (G_OBJECT (vis_checkbox), "toggled",
-        G_CALLBACK (vis_toggle_cb), pipeline);
-    g_signal_connect (G_OBJECT (audio_checkbox), "toggled",
-        G_CALLBACK (audio_toggle_cb), pipeline);
-    g_signal_connect (G_OBJECT (video_checkbox), "toggled",
-        G_CALLBACK (video_toggle_cb), pipeline);
-    g_signal_connect (G_OBJECT (text_checkbox), "toggled",
-        G_CALLBACK (text_toggle_cb), pipeline);
-    g_signal_connect (G_OBJECT (mute_checkbox), "toggled",
-        G_CALLBACK (mute_toggle_cb), pipeline);
-    g_signal_connect (G_OBJECT (download_checkbox), "toggled",
-        G_CALLBACK (download_toggle_cb), pipeline);
-    g_signal_connect (G_OBJECT (buffer_checkbox), "toggled",
-        G_CALLBACK (buffer_toggle_cb), pipeline);
-    g_signal_connect (G_OBJECT (volume_spinbutton), "value_changed",
-        G_CALLBACK (volume_spinbutton_changed_cb), pipeline);
-    /* playbin2 panel for snapshot */
-    boxes2 = gtk_hbox_new (FALSE, 0);
-    shot_button = gtk_button_new_from_stock (GTK_STOCK_SAVE);
-    gtk_widget_set_tooltip_text (shot_button,
-        "save a screenshot .png in the current directory");
-    g_signal_connect (G_OBJECT (shot_button), "clicked", G_CALLBACK (shot_cb),
-        pipeline);
-    vis_combo = gtk_combo_box_text_new ();
-    g_signal_connect (G_OBJECT (vis_combo), "changed",
-        G_CALLBACK (vis_combo_cb), pipeline);
-    gtk_widget_set_sensitive (vis_combo, FALSE);
-    gtk_box_pack_start (GTK_BOX (boxes2), shot_button, TRUE, TRUE, 2);
-    gtk_box_pack_start (GTK_BOX (boxes2), vis_combo, TRUE, TRUE, 2);
-
-    /* fill the vis combo box and the array of factories */
-    init_visualization_features ();
-  } else {
-    panel = boxes = boxes2 = NULL;
-  }
-
-  /* do the packing stuff ... */
-  gtk_window_set_default_size (GTK_WINDOW (window), 250, 96);
-  /* FIXME: can we avoid this for audio only? */
-  gtk_widget_set_size_request (GTK_WIDGET (video_window), -1,
-      DEFAULT_VIDEO_HEIGHT);
-  gtk_container_add (GTK_CONTAINER (window), vbox);
-  gtk_box_pack_start (GTK_BOX (vbox), video_window, TRUE, TRUE, 2);
-  gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 2);
-  gtk_box_pack_start (GTK_BOX (hbox), play_button, FALSE, FALSE, 2);
-  gtk_box_pack_start (GTK_BOX (hbox), pause_button, FALSE, FALSE, 2);
-  gtk_box_pack_start (GTK_BOX (hbox), stop_button, FALSE, FALSE, 2);
-  gtk_box_pack_start (GTK_BOX (hbox), flagtable, FALSE, FALSE, 2);
-  gtk_table_attach_defaults (GTK_TABLE (flagtable), accurate_checkbox, 0, 1, 0,
-      1);
-  gtk_table_attach_defaults (GTK_TABLE (flagtable), flush_checkbox, 1, 2, 0, 1);
-  gtk_table_attach_defaults (GTK_TABLE (flagtable), loop_checkbox, 2, 3, 0, 1);
-  gtk_table_attach_defaults (GTK_TABLE (flagtable), key_checkbox, 0, 1, 1, 2);
-  gtk_table_attach_defaults (GTK_TABLE (flagtable), scrub_checkbox, 1, 2, 1, 2);
-  gtk_table_attach_defaults (GTK_TABLE (flagtable), play_scrub_checkbox, 2, 3,
-      1, 2);
-  gtk_table_attach_defaults (GTK_TABLE (flagtable), skip_checkbox, 3, 4, 0, 1);
-  gtk_table_attach_defaults (GTK_TABLE (flagtable), rate_label, 4, 5, 0, 1);
-  gtk_table_attach_defaults (GTK_TABLE (flagtable), rate_spinbutton, 4, 5, 1,
-      2);
-  if (panel && boxes && boxes2) {
-    expander = gtk_expander_new ("playbin2 options");
-    pb2vbox = gtk_vbox_new (FALSE, 0);
-    gtk_box_pack_start (GTK_BOX (pb2vbox), panel, FALSE, FALSE, 2);
-    gtk_box_pack_start (GTK_BOX (pb2vbox), boxes, FALSE, FALSE, 2);
-    gtk_box_pack_start (GTK_BOX (pb2vbox), boxes2, FALSE, FALSE, 2);
-    gtk_container_add (GTK_CONTAINER (expander), pb2vbox);
-    gtk_box_pack_start (GTK_BOX (vbox), expander, FALSE, FALSE, 2);
-  }
-  gtk_box_pack_start (GTK_BOX (vbox), step, FALSE, FALSE, 2);
-  gtk_box_pack_start (GTK_BOX (vbox), hscale, FALSE, FALSE, 2);
-  gtk_box_pack_start (GTK_BOX (vbox), statusbar, FALSE, FALSE, 2);
-
-  /* connect things ... */
-  g_signal_connect (G_OBJECT (play_button), "clicked", G_CALLBACK (play_cb),
-      pipeline);
-  g_signal_connect (G_OBJECT (pause_button), "clicked", G_CALLBACK (pause_cb),
-      pipeline);
-  g_signal_connect (G_OBJECT (stop_button), "clicked", G_CALLBACK (stop_cb),
-      pipeline);
-  g_signal_connect (G_OBJECT (accurate_checkbox), "toggled",
-      G_CALLBACK (accurate_toggle_cb), pipeline);
-  g_signal_connect (G_OBJECT (key_checkbox), "toggled",
-      G_CALLBACK (key_toggle_cb), pipeline);
-  g_signal_connect (G_OBJECT (loop_checkbox), "toggled",
-      G_CALLBACK (loop_toggle_cb), pipeline);
-  g_signal_connect (G_OBJECT (flush_checkbox), "toggled",
-      G_CALLBACK (flush_toggle_cb), pipeline);
-  g_signal_connect (G_OBJECT (scrub_checkbox), "toggled",
-      G_CALLBACK (scrub_toggle_cb), pipeline);
-  g_signal_connect (G_OBJECT (play_scrub_checkbox), "toggled",
-      G_CALLBACK (play_scrub_toggle_cb), pipeline);
-  g_signal_connect (G_OBJECT (skip_checkbox), "toggled",
-      G_CALLBACK (skip_toggle_cb), pipeline);
-  g_signal_connect (G_OBJECT (rate_spinbutton), "value_changed",
-      G_CALLBACK (rate_spinbutton_changed_cb), pipeline);
-
-  g_signal_connect (G_OBJECT (window), "delete-event", delete_event_cb, NULL);
-
-  /* show the gui. */
-  gtk_widget_show_all (window);
-
-  /* realize window now so that the video window gets created and we can
-   * obtain its XID before the pipeline is started up and the videosink
-   * asks for the XID of the window to render onto */
-  gtk_widget_realize (window);
-
-#if defined (GDK_WINDOWING_X11) || defined (GDK_WINDOWING_WIN32)
-  /* we should have the XID now */
-  g_assert (embed_xid != 0);
-#endif
-
-  if (verbose) {
-    g_signal_connect (pipeline, "deep_notify",
-        G_CALLBACK (gst_object_default_deep_notify), NULL);
-  }
-
-  connect_bus_signals (pipeline);
-  gtk_main ();
-
-  g_print ("NULL pipeline\n");
-  gst_element_set_state (pipeline, GST_STATE_NULL);
-
-  g_print ("free pipeline\n");
-  gst_object_unref (pipeline);
-
-  g_list_foreach (paths, (GFunc) g_free, NULL);
-  g_list_free (paths);
-
-  return 0;
-}
diff --git a/tests/examples/v4l/probe.c b/tests/examples/v4l/probe.c
index 435aeac..c29be16 100644
--- a/tests/examples/v4l/probe.c
+++ b/tests/examples/v4l/probe.c
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <stdlib.h>
 #include <gst/gst.h>
 #include <gst/interfaces/propertyprobe.h>
diff --git a/tests/files/Makefile.am b/tests/files/Makefile.am
index 9556f5e..1370c39 100644
--- a/tests/files/Makefile.am
+++ b/tests/files/Makefile.am
@@ -3,4 +3,6 @@ EXTRA_DIST = \
 	hls.m3u8 \
 	license-uris \
 	partialframe.mjpeg \
-	test.mp3
+	test.mkv \
+	test.mp3 \
+	theora-vorbis.ogg
diff --git a/tests/files/test.mkv b/tests/files/test.mkv
new file mode 100644
index 0000000..649cf3f
Binary files /dev/null and b/tests/files/test.mkv differ
diff --git a/tests/files/theora-vorbis.ogg b/tests/files/theora-vorbis.ogg
new file mode 100644
index 0000000..ab635cc
Binary files /dev/null and b/tests/files/theora-vorbis.ogg differ
diff --git a/tests/icles/test-colorkey.c b/tests/icles/test-colorkey.c
index 9d88aec..5ab1c33 100644
--- a/tests/icles/test-colorkey.c
+++ b/tests/icles/test-colorkey.c
@@ -23,6 +23,11 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GTK versions (>= 3.3.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+#define GDK_DISABLE_DEPRECATION_WARNINGS
+
 #include <stdlib.h>
 #include <string.h>
 
diff --git a/tests/icles/test-xoverlay.c b/tests/icles/test-xoverlay.c
index c1610b6..c7dcbd3 100644
--- a/tests/icles/test-xoverlay.c
+++ b/tests/icles/test-xoverlay.c
@@ -22,6 +22,9 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GTK versions (>= 3.3.0) */
+#define GDK_DISABLE_DEPRECATION_WARNINGS
 
 #include <stdlib.h>
 #include <string.h>
diff --git a/win32/common/_stdint.h b/win32/common/_stdint.h
index 34887b1..2b2bc61 100644
--- a/win32/common/_stdint.h
+++ b/win32/common/_stdint.h
@@ -1,7 +1,7 @@
 #ifndef _GST_PLUGINS_BASE__STDINT_H
 #define _GST_PLUGINS_BASE__STDINT_H 1
 #ifndef _GENERATED_STDINT_H
-#define _GENERATED_STDINT_H "gst-plugins-base 0.10.36"
+#define _GENERATED_STDINT_H "gst-plugins-base 0.10.36.1"
 /* generated using gnu compiler gcc (Debian 4.6.2-12) 4.6.2 */
 #define _STDINT_HAVE_STDINT_H 1
 #include <stdint.h>
diff --git a/win32/common/config.h b/win32/common/config.h
index be21f96..421b571 100644
--- a/win32/common/config.h
+++ b/win32/common/config.h
@@ -81,13 +81,13 @@
 #define GST_MAJORMINOR "0.10"
 
 /* package name in plugins */
-#define GST_PACKAGE_NAME "GStreamer Base Plug-ins source release"
+#define GST_PACKAGE_NAME "GStreamer Base Plug-ins git"
 
 /* package origin */
 #define GST_PACKAGE_ORIGIN "Unknown package origin"
 
 /* GStreamer package release date/time for plugins as YYYY-MM-DD */
-#define GST_PACKAGE_RELEASE_DATETIME "2012-02-20"
+#define GST_PACKAGE_RELEASE_DATETIME "2012-02-23T10:41Z"
 
 /* I know the API is subject to change. */
 #undef G_UDEV_API_IS_SUBJECT_TO_CHANGE
@@ -358,7 +358,7 @@
 #define PACKAGE_NAME "GStreamer Base Plug-ins"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "GStreamer Base Plug-ins 0.10.36"
+#define PACKAGE_STRING "GStreamer Base Plug-ins 0.10.36.1"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "gst-plugins-base"
@@ -367,7 +367,7 @@
 #undef PACKAGE_URL
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "0.10.36"
+#define PACKAGE_VERSION "0.10.36.1"
 
 /* directory where plugins are located */
 #ifdef _DEBUG
@@ -398,7 +398,7 @@
 #undef USE_TREMOLO
 
 /* Version number of package */
-#define VERSION "0.10.36"
+#define VERSION "0.10.36.1"
 
 /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
    significant byte first (like Motorola and SPARC, unlike Intel). */
diff --git a/win32/common/libgstaudio.def b/win32/common/libgstaudio.def
index 6f47c46..68af0ec 100644
--- a/win32/common/libgstaudio.def
+++ b/win32/common/libgstaudio.def
@@ -24,6 +24,7 @@ EXPORTS
 	gst_audio_decoder_get_plc_aware
 	gst_audio_decoder_get_tolerance
 	gst_audio_decoder_get_type
+	gst_audio_decoder_merge_tags
 	gst_audio_decoder_set_byte_time
 	gst_audio_decoder_set_drainable
 	gst_audio_decoder_set_latency
diff --git a/win32/common/libgsttag.def b/win32/common/libgsttag.def
index 8fa522c..4af90e3 100644
--- a/win32/common/libgsttag.def
+++ b/win32/common/libgsttag.def
@@ -1,4 +1,5 @@
 EXPORTS
+	gst_tag_check_language_code
 	gst_tag_demux_get_type
 	gst_tag_demux_result_get_type
 	gst_tag_freeform_string_to_utf8
diff --git a/win32/common/libgstvideo.def b/win32/common/libgstvideo.def
index dd6e2b0..879b942 100644
--- a/win32/common/libgstvideo.def
+++ b/win32/common/libgstvideo.def
@@ -45,6 +45,7 @@ EXPORTS
 	gst_video_overlay_composition_n_rectangles
 	gst_video_overlay_composition_new
 	gst_video_overlay_rectangle_copy
+	gst_video_overlay_rectangle_get_flags
 	gst_video_overlay_rectangle_get_pixels_argb
 	gst_video_overlay_rectangle_get_pixels_unscaled_argb
 	gst_video_overlay_rectangle_get_render_rectangle
