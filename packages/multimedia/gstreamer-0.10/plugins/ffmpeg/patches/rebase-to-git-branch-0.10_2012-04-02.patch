diff --git a/configure.ac b/configure.ac
index 9271c1d..6605762 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3,7 +3,7 @@ AC_PREREQ(2.60)
 dnl initialize autoconf
 dnl when going to/from release please set the nano (fourth number) right !
 dnl releases only do Wall, cvs and prerelease does Werror too
-AC_INIT(GStreamer Libav, 0.10.13,
+AC_INIT(GStreamer Libav, 0.10.13.1,
     http://bugzilla.gnome.org/enter_bug.cgi?product=GStreamer,
     gst-ffmpeg)
 
@@ -47,7 +47,7 @@ AC_LIBTOOL_WIN32_DLL
 AM_PROG_LIBTOOL
 
 dnl *** required versions of GStreamer stuff ***
-GST_REQ=0.10.31
+GST_REQ=0.10.35.1
 ORC_REQ=0.4.6
 
 dnl *** autotools stuff ****
@@ -60,6 +60,8 @@ AC_SUBST(ACLOCAL_AMFLAGS, "-I m4 -I common/m4")
 
 dnl *** check for arguments to configure ***
 
+AG_GST_ARG_DISABLE_FATAL_WARNINGS
+
 AG_GST_ARG_WITH_PKG_CONFIG_PATH
 AG_GST_ARG_WITH_PACKAGE_NAME
 AG_GST_ARG_WITH_PACKAGE_ORIGIN
@@ -132,7 +134,7 @@ dnl set location of plugin directory
 AG_GST_SET_PLUGINDIR
 
 dnl define an ERROR_CFLAGS Makefile variable
-AG_GST_SET_ERROR_CFLAGS($GST_GIT, [
+AG_GST_SET_ERROR_CFLAGS($FATAL_WARNINGS, [
     -Wmissing-declarations -Wmissing-prototypes -Wredundant-decls -Wundef
     -Wwrite-strings -Wformat-nonliteral -Wformat-security -Wold-style-definition
     -Winit-self -Wmissing-include-dirs -Waddress
@@ -314,8 +316,8 @@ else
   embffmpeg_configure_args="--prefix=$prefix"
 
   # Enable pic and static so that we get .a files, but with PIC code.
-  embffmpeg_configure_args="$embffmpeg_configure_args --disable-ffserver --disable-ffplay\
-        --disable-ffmpeg --disable-ffprobe --enable-static --enable-pic \
+  embffmpeg_configure_args="$embffmpeg_configure_args --disable-avserver --disable-avplay\
+        --disable-ffmpeg --disable-avprobe --enable-static --enable-pic \
 	--disable-encoder=flac --disable-decoder=cavs --disable-protocols --disable-devices\
 	--disable-network --disable-hwaccels --disable-filters --disable-doc\
 	--enable-optimizations"
@@ -379,7 +381,7 @@ else
      if test -z "$srcdir" -o "$srcdir" = .; then
        confcmd=./configure
      else
-       confcmd="$origdir"/"$ac_top_srcdir"/gst-libs/ext/libav/configure
+       confcmd="$ac_abs_top_srcdir"/gst-libs/ext/libav/configure
      fi
 
      AS_MKDIR_P(["$ac_top_build_prefix"gst-libs/ext/libav])
diff --git a/ext/ffmpeg/gstffmpegaudioresample.c b/ext/ffmpeg/gstffmpegaudioresample.c
index 321a008..b63068d 100644
--- a/ext/ffmpeg/gstffmpegaudioresample.c
+++ b/ext/ffmpeg/gstffmpegaudioresample.c
@@ -103,10 +103,8 @@ gst_ffmpegaudioresample_base_init (gpointer g_class)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
 
-  gst_element_class_add_pad_template (element_class,
-      gst_static_pad_template_get (&src_factory));
-  gst_element_class_add_pad_template (element_class,
-      gst_static_pad_template_get (&sink_factory));
+  gst_element_class_add_static_pad_template (element_class, &src_factory);
+  gst_element_class_add_static_pad_template (element_class, &sink_factory);
   gst_element_class_set_details_simple (element_class,
       "FFMPEG Audio resampling element", "Filter/Converter/Audio",
       "Converts audio from one samplerate to another",
diff --git a/ext/ffmpeg/gstffmpegcodecmap.c b/ext/ffmpeg/gstffmpegcodecmap.c
index f3381dd..3759a35 100644
--- a/ext/ffmpeg/gstffmpegcodecmap.c
+++ b/ext/ffmpeg/gstffmpegcodecmap.c
@@ -340,25 +340,6 @@ gst_ff_aud_caps_new (AVCodecContext * context, enum CodecID codec_id,
     GstAudioChannelPosition *pos;
     guint64 channel_layout = context->channel_layout;
 
-    if (channel_layout == 0) {
-      const guint64 default_channel_set[] = {
-        0, 0, CH_LAYOUT_SURROUND, CH_LAYOUT_QUAD, CH_LAYOUT_5POINT0,
-        CH_LAYOUT_5POINT1, 0, CH_LAYOUT_7POINT1
-      };
-
-      switch (codec_id) {
-        case CODEC_ID_EAC3:
-        case CODEC_ID_AC3:
-        case CODEC_ID_DTS:
-          if (context->channels > 0
-              && context->channels < G_N_ELEMENTS (default_channel_set))
-            channel_layout = default_channel_set[context->channels - 1];
-          break;
-        default:
-          break;
-      }
-    }
-
     caps = gst_caps_new_simple (mimetype,
         "rate", G_TYPE_INT, context->sample_rate,
         "channels", G_TYPE_INT, context->channels, NULL);
@@ -925,6 +906,11 @@ gst_ffmpeg_codecid_to_caps (enum CodecID codec_id,
           "indeoversion", G_TYPE_INT, 5, NULL);
       break;
 
+    case CODEC_ID_INDEO4:
+      caps = gst_ff_vid_caps_new (context, codec_id, "video/x-indeo",
+          "indeoversion", G_TYPE_INT, 4, NULL);
+      break;
+
     case CODEC_ID_INDEO3:
       caps = gst_ff_vid_caps_new (context, codec_id, "video/x-indeo",
           "indeoversion", G_TYPE_INT, 3, NULL);
@@ -3181,6 +3167,9 @@ gst_ffmpeg_caps_to_codecid (const GstCaps * caps, AVCodecContext * context)
         case 5:
           id = CODEC_ID_INDEO5;
           break;
+        case 4:
+          id = CODEC_ID_INDEO4;
+          break;
         case 3:
           id = CODEC_ID_INDEO3;
           break;
diff --git a/ext/ffmpeg/gstffmpegdec.c b/ext/ffmpeg/gstffmpegdec.c
index cc07889..918abf8 100644
--- a/ext/ffmpeg/gstffmpegdec.c
+++ b/ext/ffmpeg/gstffmpegdec.c
@@ -197,7 +197,7 @@ gst_ts_info_get (GstFFMpegDec * dec, gint idx)
 #define DEFAULT_DO_PADDING		TRUE
 #define DEFAULT_DEBUG_MV		FALSE
 #define DEFAULT_CROP			TRUE
-#define DEFAULT_MAX_THREADS		1
+#define DEFAULT_MAX_THREADS		0
 
 enum
 {
@@ -477,35 +477,43 @@ static gboolean
 gst_ffmpegdec_query (GstPad * pad, GstQuery * query)
 {
   GstFFMpegDec *ffmpegdec;
-  GstPad *peer;
-  gboolean res;
+  gboolean res = FALSE;
 
   ffmpegdec = (GstFFMpegDec *) gst_pad_get_parent (pad);
 
-  res = FALSE;
-
-  if ((peer = gst_pad_get_peer (ffmpegdec->sinkpad))) {
-    /* just forward to peer */
-    res = gst_pad_query (peer, query);
-    gst_object_unref (peer);
-  }
-#if 0
-  {
-    GstFormat bfmt;
-
-    bfmt = GST_FORMAT_BYTES;
-
-    /* ok, do bitrate calc... */
-    if ((type != GST_QUERY_POSITION && type != GST_QUERY_TOTAL) ||
-        *fmt != GST_FORMAT_TIME || ffmpegdec->context->bit_rate == 0 ||
-        !gst_pad_query (peer, type, &bfmt, value))
-      return FALSE;
-
-    if (ffmpegdec->pcache && type == GST_QUERY_POSITION)
-      *value -= GST_BUFFER_SIZE (ffmpegdec->pcache);
-    *value *= GST_SECOND / ffmpegdec->context->bit_rate;
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_LATENCY:
+    {
+      GST_DEBUG_OBJECT (ffmpegdec, "latency query %d",
+          ffmpegdec->context->has_b_frames);
+      if ((res = gst_pad_peer_query (ffmpegdec->sinkpad, query))) {
+        if (ffmpegdec->context->has_b_frames) {
+          gboolean live;
+          GstClockTime min_lat, max_lat, our_lat;
+
+          gst_query_parse_latency (query, &live, &min_lat, &max_lat);
+          if (ffmpegdec->format.video.fps_n > 0)
+            our_lat =
+                gst_util_uint64_scale_int (ffmpegdec->context->has_b_frames *
+                GST_SECOND, ffmpegdec->format.video.fps_d,
+                ffmpegdec->format.video.fps_n);
+          else
+            our_lat =
+                gst_util_uint64_scale_int (ffmpegdec->context->has_b_frames *
+                GST_SECOND, 1, 25);
+          if (min_lat != -1)
+            min_lat += our_lat;
+          if (max_lat != -1)
+            max_lat += our_lat;
+          gst_query_set_latency (query, live, min_lat, max_lat);
+        }
+      }
+    }
+      break;
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
   }
-#endif
 
   gst_object_unref (ffmpegdec);
 
@@ -758,9 +766,11 @@ gst_ffmpegdec_setcaps (GstPad * pad, GstCaps * caps)
   }
 
   /* set buffer functions */
-  ffmpegdec->context->get_buffer = gst_ffmpegdec_get_buffer;
-  ffmpegdec->context->release_buffer = gst_ffmpegdec_release_buffer;
-  ffmpegdec->context->draw_horiz_band = NULL;
+  if (oclass->in_plugin->type == AVMEDIA_TYPE_VIDEO) {
+    ffmpegdec->context->get_buffer = gst_ffmpegdec_get_buffer;
+    ffmpegdec->context->release_buffer = gst_ffmpegdec_release_buffer;
+    ffmpegdec->context->draw_horiz_band = NULL;
+  }
 
   /* default is to let format decide if it needs a parser */
   ffmpegdec->turnoff_parser = FALSE;
@@ -874,11 +884,16 @@ gst_ffmpegdec_setcaps (GstPad * pad, GstCaps * caps)
    * supports it) */
   ffmpegdec->context->debug_mv = ffmpegdec->debug_mv;
 
-  if (ffmpegdec->max_threads == 0)
-    ffmpegdec->context->thread_count = gst_ffmpeg_auto_max_threads ();
-  else
+  if (ffmpegdec->max_threads == 0) {
+    if (!(oclass->in_plugin->capabilities & CODEC_CAP_AUTO_THREADS))
+      ffmpegdec->context->thread_count = gst_ffmpeg_auto_max_threads ();
+    else
+      ffmpegdec->context->thread_count = 0;
+  } else
     ffmpegdec->context->thread_count = ffmpegdec->max_threads;
 
+  ffmpegdec->context->thread_type = FF_THREAD_SLICE;
+
   /* open codec - we don't select an output pix_fmt yet,
    * simply because we don't know! We only get it
    * during playback... */
@@ -1546,6 +1561,9 @@ check_keyframe (GstFFMpegDec * ffmpegdec)
   if (!ffmpegdec->has_b_frames && ffmpegdec->picture->pict_type == FF_B_TYPE) {
     GST_DEBUG_OBJECT (ffmpegdec, "we have B frames");
     ffmpegdec->has_b_frames = TRUE;
+    /* Emit latency message to recalculate it */
+    gst_element_post_message (GST_ELEMENT_CAST (ffmpegdec),
+        gst_message_new_latency (GST_OBJECT_CAST (ffmpegdec)));
   }
 
   is_itype = (ffmpegdec->picture->pict_type == FF_I_TYPE);
@@ -1821,7 +1839,7 @@ gst_ffmpegdec_video_frame (GstFFMpegDec * ffmpegdec,
       GstStructure *s = gst_caps_get_structure (GST_BUFFER_CAPS (buffer), 0);
       gboolean interlaced;
       gboolean found = gst_structure_get_boolean (s, "interlaced", &interlaced);
-      if (!found || (!!interlaced != !!ffmpegdec->format.video.interlaced)) {
+      if (!found || (! !interlaced != ! !ffmpegdec->format.video.interlaced)) {
         GST_DEBUG_OBJECT (ffmpegdec,
             "Buffer interlacing does not match pad, updating");
         buffer = gst_buffer_make_metadata_writable (buffer);
@@ -3045,14 +3063,6 @@ gst_ffmpegdec_register (GstPlugin * plugin)
       case CODEC_ID_MP3:
         rank = GST_RANK_NONE;
         break;
-        /* TEMPORARILY DISABLING AC3/EAC3/DTS for 0.10.12 release
-         * due to downmixing failure.
-         * See Bug #608892 for more details */
-      case CODEC_ID_EAC3:
-      case CODEC_ID_AC3:
-      case CODEC_ID_DTS:
-        rank = GST_RANK_NONE;
-        break;
       default:
         rank = GST_RANK_MARGINAL;
         break;
diff --git a/ext/ffmpeg/gstffmpegdeinterlace.c b/ext/ffmpeg/gstffmpegdeinterlace.c
index de95314..40fea5e 100644
--- a/ext/ffmpeg/gstffmpegdeinterlace.c
+++ b/ext/ffmpeg/gstffmpegdeinterlace.c
@@ -145,10 +145,8 @@ gst_ffmpegdeinterlace_base_init (gpointer g_class)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
 
-  gst_element_class_add_pad_template (element_class,
-      gst_static_pad_template_get (&src_factory));
-  gst_element_class_add_pad_template (element_class,
-      gst_static_pad_template_get (&sink_factory));
+  gst_element_class_add_static_pad_template (element_class, &src_factory);
+  gst_element_class_add_static_pad_template (element_class, &sink_factory);
   gst_element_class_set_details_simple (element_class,
       "FFMPEG Deinterlace element", "Filter/Effect/Video/Deinterlace",
       "Deinterlace video", "Luca Ognibene <luogni@tin.it>");
diff --git a/ext/ffmpeg/gstffmpegdemux.c b/ext/ffmpeg/gstffmpegdemux.c
index 3eb5328..82e61c9 100644
--- a/ext/ffmpeg/gstffmpegdemux.c
+++ b/ext/ffmpeg/gstffmpegdemux.c
@@ -1330,6 +1330,7 @@ gst_ffmpegdemux_type_find (GstTypeFind * tf, gpointer priv)
           in_plugin->name, sinkcaps, res);
 
       gst_type_find_suggest (tf, res, sinkcaps);
+      gst_caps_unref (sinkcaps);
     }
   }
 }
@@ -1958,7 +1959,7 @@ gst_ffmpegdemux_register (GstPlugin * plugin)
         )
       register_typefind_func = FALSE;
 
-    /* Set the rank of demuxers know to work to MARGINAL.
+    /* Set the rank of demuxers known to work to MARGINAL.
      * Set demuxers for which we already have another implementation to NONE
      * Set All others to NONE*/
     if (!strcmp (in_plugin->name, "wsvqa") ||
@@ -1966,7 +1967,6 @@ gst_ffmpegdemux_register (GstPlugin * plugin)
         !strcmp (in_plugin->name, "wc3movie") ||
         !strcmp (in_plugin->name, "voc") ||
         !strcmp (in_plugin->name, "tta") ||
-        !strcmp (in_plugin->name, "swf") ||
         !strcmp (in_plugin->name, "sol") ||
         !strcmp (in_plugin->name, "smk") ||
         !strcmp (in_plugin->name, "vmd") ||
diff --git a/ext/ffmpeg/gstffmpegmux.c b/ext/ffmpeg/gstffmpegmux.c
index 538aeed..687203a 100644
--- a/ext/ffmpeg/gstffmpegmux.c
+++ b/ext/ffmpeg/gstffmpegmux.c
@@ -29,7 +29,7 @@
 #endif
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 #include "gstffmpeg.h"
 #include "gstffmpegcodecmap.h"
@@ -40,7 +40,7 @@ typedef struct _GstFFMpegMuxPad GstFFMpegMuxPad;
 
 struct _GstFFMpegMuxPad
 {
-  GstCollectData collect;       /* we extend the CollectData */
+  GstCollectData2 collect;      /* we extend the CollectData2 */
 
   gint padnum;
 };
@@ -49,7 +49,7 @@ struct _GstFFMpegMux
 {
   GstElement element;
 
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
   /* We need to keep track of our pads, so we do so here. */
   GstPad *srcpad;
 
@@ -114,7 +114,7 @@ static void gst_ffmpegmux_finalize (GObject * object);
 static gboolean gst_ffmpegmux_setcaps (GstPad * pad, GstCaps * caps);
 static GstPad *gst_ffmpegmux_request_new_pad (GstElement * element,
     GstPadTemplate * templ, const gchar * name);
-static GstFlowReturn gst_ffmpegmux_collected (GstCollectPads * pads,
+static GstFlowReturn gst_ffmpegmux_collected (GstCollectPads2 * pads,
     gpointer user_data);
 
 static gboolean gst_ffmpegmux_sink_event (GstPad * pad, GstEvent * event);
@@ -272,17 +272,20 @@ gst_ffmpegmux_base_init (gpointer g_class)
   /* pad templates */
   srctempl = gst_pad_template_new ("src", GST_PAD_SRC, GST_PAD_ALWAYS, srccaps);
   gst_element_class_add_pad_template (element_class, srctempl);
+  gst_object_unref (srctempl);
 
   if (audiosinkcaps) {
     audiosinktempl = gst_pad_template_new ("audio_%d",
         GST_PAD_SINK, GST_PAD_REQUEST, audiosinkcaps);
     gst_element_class_add_pad_template (element_class, audiosinktempl);
+    gst_object_unref (audiosinktempl);
   }
 
   if (videosinkcaps) {
     videosinktempl = gst_pad_template_new ("video_%d",
         GST_PAD_SINK, GST_PAD_REQUEST, videosinkcaps);
     gst_element_class_add_pad_template (element_class, videosinktempl);
+    gst_object_unref (videosinktempl);
   }
 
 beach:
@@ -329,9 +332,9 @@ gst_ffmpegmux_init (GstFFMpegMux * ffmpegmux, GstFFMpegMuxClass * g_class)
   gst_pad_set_caps (ffmpegmux->srcpad, gst_pad_template_get_caps (templ));
   gst_element_add_pad (GST_ELEMENT (ffmpegmux), ffmpegmux->srcpad);
 
-  ffmpegmux->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (ffmpegmux->collect,
-      (GstCollectPadsFunction) gst_ffmpegmux_collected, ffmpegmux);
+  ffmpegmux->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (ffmpegmux->collect,
+      (GstCollectPads2Function) gst_ffmpegmux_collected, ffmpegmux);
 
   ffmpegmux->context = g_new0 (AVFormatContext, 1);
   ffmpegmux->context->oformat = oclass->in_plugin;
@@ -437,7 +440,7 @@ gst_ffmpegmux_request_new_pad (GstElement * element,
   /* create pad */
   pad = gst_pad_new_from_template (templ, padname);
   collect_pad = (GstFFMpegMuxPad *)
-      gst_collect_pads_add_pad (ffmpegmux->collect, pad,
+      gst_collect_pads2_add_pad (ffmpegmux->collect, pad,
       sizeof (GstFFMpegMuxPad));
   collect_pad->padnum = ffmpegmux->context->nb_streams;
 
@@ -537,7 +540,7 @@ gst_ffmpegmux_sink_event (GstPad * pad, GstEvent * event)
 }
 
 static GstFlowReturn
-gst_ffmpegmux_collected (GstCollectPads * pads, gpointer user_data)
+gst_ffmpegmux_collected (GstCollectPads2 * pads, gpointer user_data)
 {
   GstFFMpegMux *ffmpegmux = (GstFFMpegMux *) user_data;
   GSList *collected;
@@ -586,8 +589,8 @@ gst_ffmpegmux_collected (GstCollectPads * pads, gpointer user_data)
 
             /* FIXME : This doesn't work for RAW AUDIO...
              * in fact I'm wondering if it even works for any kind of audio... */
-            buffer = gst_collect_pads_peek (ffmpegmux->collect,
-                (GstCollectData *) collect_pad);
+            buffer = gst_collect_pads2_peek (ffmpegmux->collect,
+                (GstCollectData2 *) collect_pad);
             if (buffer) {
               st->codec->frame_size =
                   st->codec->sample_rate *
@@ -680,8 +683,8 @@ gst_ffmpegmux_collected (GstCollectPads * pads, gpointer user_data)
   for (collected = ffmpegmux->collect->data; collected;
       collected = g_slist_next (collected)) {
     GstFFMpegMuxPad *collect_pad = (GstFFMpegMuxPad *) collected->data;
-    GstBuffer *buffer = gst_collect_pads_peek (ffmpegmux->collect,
-        (GstCollectData *) collect_pad);
+    GstBuffer *buffer = gst_collect_pads2_peek (ffmpegmux->collect,
+        (GstCollectData2 *) collect_pad);
 
     /* if there's no buffer, just continue */
     if (buffer == NULL) {
@@ -717,8 +720,8 @@ gst_ffmpegmux_collected (GstCollectPads * pads, gpointer user_data)
     gboolean need_free = FALSE;
 
     /* push out current buffer */
-    buf = gst_collect_pads_pop (ffmpegmux->collect,
-        (GstCollectData *) best_pad);
+    buf = gst_collect_pads2_pop (ffmpegmux->collect,
+        (GstCollectData2 *) best_pad);
 
     ffmpegmux->context->streams[best_pad->padnum]->codec->frame_number++;
 
@@ -782,19 +785,19 @@ gst_ffmpegmux_collected (GstCollectPads * pads, gpointer user_data)
 static GstStateChangeReturn
 gst_ffmpegmux_change_state (GstElement * element, GstStateChange transition)
 {
-  GstFlowReturn ret;
+  GstStateChangeReturn ret;
   GstFFMpegMux *ffmpegmux = (GstFFMpegMux *) (element);
 
   switch (transition) {
     case GST_STATE_CHANGE_NULL_TO_READY:
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (ffmpegmux->collect);
+      gst_collect_pads2_start (ffmpegmux->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_collect_pads_stop (ffmpegmux->collect);
+      gst_collect_pads2_stop (ffmpegmux->collect);
       break;
     default:
       break;
diff --git a/ext/ffmpeg/gstffmpegutils.c b/ext/ffmpeg/gstffmpegutils.c
index d039914..4c5bd1e 100644
--- a/ext/ffmpeg/gstffmpegutils.c
+++ b/ext/ffmpeg/gstffmpegutils.c
@@ -466,7 +466,7 @@ gst_ffmpeg_auto_max_threads (void)
       int mib[] = { CTL_HW, HW_NCPU };
       size_t dataSize = sizeof (int);
 
-      if (sysctl (mib, 2, &n_threads, &dataSize, NULL, 0)) {
+      if (sysctl (mib, 2, &n, &dataSize, NULL, 0)) {
         n = 1;
       }
     }
diff --git a/ext/ffmpeg/gstffmpegutils.h b/ext/ffmpeg/gstffmpegutils.h
index 4b713de..dbc3fae 100644
--- a/ext/ffmpeg/gstffmpegutils.h
+++ b/ext/ffmpeg/gstffmpegutils.h
@@ -20,11 +20,17 @@
 #ifndef __GST_FFMPEG_UTILS_H__
 #define __GST_FFMPEG_UTILS_H__
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #ifdef HAVE_FFMPEG_UNINSTALLED
+#include <mathematics.h>
 #include <avcodec.h>
 #else
 #include <libavcodec/avcodec.h>
 #endif
+
 #include <gst/gst.h>
 
 /*
diff --git a/ext/libpostproc/gstpostproc.c b/ext/libpostproc/gstpostproc.c
index f9ddcdd..963b77d 100644
--- a/ext/libpostproc/gstpostproc.c
+++ b/ext/libpostproc/gstpostproc.c
@@ -381,10 +381,10 @@ gst_post_proc_base_init (GstPostProcClass * klass)
   g_free (longname);
   g_free (description);
 
-  gst_element_class_add_pad_template (element_class,
-      gst_static_pad_template_get (&gst_post_proc_src_template));
-  gst_element_class_add_pad_template (element_class,
-      gst_static_pad_template_get (&gst_post_proc_sink_template));
+  gst_element_class_add_static_pad_template (element_class,
+      &gst_post_proc_src_template);
+  gst_element_class_add_static_pad_template (element_class,
+      &gst_post_proc_sink_template);
 
   klass->filterid = ppidx;
 }

