From ec2467e19c48a503853d45bd8c023648b9db4826 Mon Sep 17 00:00:00 2001
From: Soeren Grunewald <soeren.grunewald@avionic-design.de>
Date: Fri, 12 Apr 2013 11:14:02 +0200
Subject: [PATCH 3/5] Rebase tests to 2013-04-08.

Commit id is fbb5ded64350b3364c4b917130ae3d8c37a3c689
---
 tests/Makefile.in                                  |  182 +-
 tests/check/Makefile.am                            |   18 +-
 tests/check/Makefile.in                            |  251 +-
 tests/check/elements/camerabin2.c                  |   26 +
 tests/check/elements/mpegtsmux.c                   |  303 +-
 tests/check/elements/mpegvideoparse.c              |    3 +-
 tests/check/elements/uvch264demux.c                |  696 ++
 tests/check/elements/x264enc.c                     |  206 +
 tests/check/libs/mpegvideoparser.c                 |   89 +-
 tests/check/orc/cog.c                              | 9718 --------------------
 tests/examples/Makefile.am                         |   10 +-
 tests/examples/Makefile.in                         |  188 +-
 tests/examples/camerabin/Makefile.in               |  113 +-
 tests/examples/camerabin/gst-camera-perf.c         |    2 +
 tests/examples/camerabin/gst-camera-perf.ui        |   80 +
 tests/examples/camerabin/gst-camerabin-test.c      |    2 +
 tests/examples/camerabin2/Makefile.in              |  113 +-
 tests/examples/camerabin2/gst-camerabin2-test.c    |    2 +
 tests/examples/capsfilter/Makefile.am              |    6 +
 tests/examples/capsfilter/capsfilter1.c            |   87 +
 tests/examples/directfb/Makefile.in                |  113 +-
 tests/examples/gstplay/.gitignore                  |    1 +
 tests/examples/gstplay/Makefile.am                 |   11 +
 tests/examples/gstplay/player.c                    |  176 +
 tests/examples/indexing/.gitignore                 |    1 +
 tests/examples/indexing/Makefile.am                |    7 +
 tests/examples/indexing/indexmpeg.c                |  321 +
 tests/examples/level/Makefile.am                   |   11 +
 tests/examples/level/README                        |   39 +
 tests/examples/level/demo.c                        |  155 +
 tests/examples/level/plot.c                        |  124 +
 tests/examples/mpegtsmux/mpts_test2.c              |  199 +
 tests/examples/mxf/Makefile.in                     |  112 +-
 tests/examples/mxf/mxfdemux-structure.c            |    3 +-
 tests/examples/opencv/Makefile.in                  |  112 +-
 .../examples/opencv/gst_element_print_properties.c |    4 +
 tests/examples/scaletempo/Makefile.am              |    4 +-
 tests/examples/scaletempo/Makefile.in              |  116 +-
 tests/examples/scaletempo/demo-gui.c               |    5 +
 tests/examples/scaletempo/demo-main.c              |    2 +
 tests/examples/stats/Makefile.am                   |    6 +
 tests/examples/stats/mp2ogg.c                      |  102 +
 tests/examples/uvch264/Makefile.am                 |   36 +
 tests/examples/uvch264/Makefile.in                 |  937 ++
 tests/examples/uvch264/boolean_property.glade      |   94 +
 tests/examples/uvch264/enum_property.glade         |   88 +
 tests/examples/uvch264/enum_property_gtk2.glade    |   88 +
 tests/examples/uvch264/int_property.glade          |  147 +
 tests/examples/uvch264/test-uvch264.c              |  673 ++
 tests/examples/uvch264/window.glade                |  345 +
 tests/files/Makefile.in                            |   79 +-
 tests/icles/Makefile.in                            |  113 +-
 tests/icles/dccp/README                            |   52 +
 tests/icles/dccp/call/DCCPClient.c                 |  151 +
 tests/icles/dccp/call/DCCPServer.c                 |  144 +
 tests/icles/dccp/call/README                       |    1 +
 tests/icles/dccp/file/DCCPClientSaveFile.c         |  113 +
 tests/icles/dccp/file/DCCPServerSendFile.c         |  112 +
 tests/icles/dccp/mic/DCCPClientPlayMic.c           |  116 +
 tests/icles/dccp/mic/DCCPServerMic.c               |  111 +
 tests/icles/dccp/mp3/DCCPClientPlayMP3.c           |  117 +
 tests/icles/dccp/mp3/DCCPServerSendMP3.c           |  113 +
 tests/icles/dccp/mp3Speex/DCCPClientPlaySpeexMP3.c |  120 +
 tests/icles/dccp/mp3Speex/DCCPServerSendSpeexMP3.c |  128 +
 .../icles/dccp/mp3Stream/DCCPClientPlayMP3Stream.c |  113 +
 .../icles/dccp/mp3Stream/DCCPServerSendMP3Stream.c |  113 +
 tests/icles/metadata_editor.c                      | 1370 +++
 tests/icles/metadata_editor.h                      |  103 +
 tests/icles/metadata_editor.ui                     |  347 +
 69 files changed, 9524 insertions(+), 10119 deletions(-)
 create mode 100644 tests/check/elements/uvch264demux.c
 create mode 100644 tests/check/elements/x264enc.c
 delete mode 100644 tests/check/orc/cog.c
 create mode 100644 tests/examples/camerabin/gst-camera-perf.ui
 create mode 100644 tests/examples/capsfilter/Makefile.am
 create mode 100644 tests/examples/capsfilter/capsfilter1.c
 create mode 100644 tests/examples/gstplay/.gitignore
 create mode 100644 tests/examples/gstplay/Makefile.am
 create mode 100644 tests/examples/gstplay/player.c
 create mode 100644 tests/examples/indexing/.gitignore
 create mode 100644 tests/examples/indexing/Makefile.am
 create mode 100644 tests/examples/indexing/indexmpeg.c
 create mode 100644 tests/examples/level/Makefile.am
 create mode 100644 tests/examples/level/README
 create mode 100644 tests/examples/level/demo.c
 create mode 100644 tests/examples/level/plot.c
 create mode 100644 tests/examples/mpegtsmux/mpts_test2.c
 create mode 100644 tests/examples/stats/Makefile.am
 create mode 100644 tests/examples/stats/mp2ogg.c
 create mode 100644 tests/examples/uvch264/Makefile.am
 create mode 100644 tests/examples/uvch264/Makefile.in
 create mode 100644 tests/examples/uvch264/boolean_property.glade
 create mode 100644 tests/examples/uvch264/enum_property.glade
 create mode 100644 tests/examples/uvch264/enum_property_gtk2.glade
 create mode 100644 tests/examples/uvch264/int_property.glade
 create mode 100644 tests/examples/uvch264/test-uvch264.c
 create mode 100644 tests/examples/uvch264/window.glade
 create mode 100644 tests/icles/dccp/README
 create mode 100644 tests/icles/dccp/call/DCCPClient.c
 create mode 100644 tests/icles/dccp/call/DCCPServer.c
 create mode 100644 tests/icles/dccp/call/README
 create mode 100644 tests/icles/dccp/file/DCCPClientSaveFile.c
 create mode 100644 tests/icles/dccp/file/DCCPServerSendFile.c
 create mode 100644 tests/icles/dccp/mic/DCCPClientPlayMic.c
 create mode 100644 tests/icles/dccp/mic/DCCPServerMic.c
 create mode 100644 tests/icles/dccp/mp3/DCCPClientPlayMP3.c
 create mode 100644 tests/icles/dccp/mp3/DCCPServerSendMP3.c
 create mode 100644 tests/icles/dccp/mp3Speex/DCCPClientPlaySpeexMP3.c
 create mode 100644 tests/icles/dccp/mp3Speex/DCCPServerSendSpeexMP3.c
 create mode 100644 tests/icles/dccp/mp3Stream/DCCPClientPlayMP3Stream.c
 create mode 100644 tests/icles/dccp/mp3Stream/DCCPServerSendMP3Stream.c
 create mode 100644 tests/icles/metadata_editor.c
 create mode 100644 tests/icles/metadata_editor.h
 create mode 100644 tests/icles/metadata_editor.ui

diff --git a/tests/Makefile.in b/tests/Makefile.in
index bf9b477..acb32f4 100644
--- a/tests/Makefile.in
+++ b/tests/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,6 +14,23 @@
 
 @SET_MAKE@
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -33,6 +49,7 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 subdir = tests
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
@@ -40,7 +57,6 @@ am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -77,12 +93,18 @@ mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
 AM_V_GEN = $(am__v_GEN_@AM_V@)
 am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
 AM_V_at = $(am__v_at_@AM_V@)
 am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
 am__v_at_0 = @
+am__v_at_1 = 
 SOURCES =
 DIST_SOURCES =
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
@@ -92,6 +114,11 @@ RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	install-pdf-recursive install-ps-recursive install-recursive \
 	installcheck-recursive installdirs-recursive pdf-recursive \
 	ps-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
 AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
@@ -156,6 +183,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -180,10 +209,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -198,9 +229,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -258,13 +292,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -283,13 +320,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -299,6 +342,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -326,6 +370,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -363,7 +411,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -372,6 +420,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -405,6 +454,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -421,6 +472,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -449,12 +501,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -522,7 +577,11 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
@@ -573,12 +632,12 @@ clean-libtool:
 	-rm -rf .libs _libs
 
 # This directory's subdirectories are mostly independent; you can cd
-# into them and run `make' without going through this Makefile.
-# To change the values of `make' variables: instead of editing Makefiles,
-# (1) if the variable is set in `config.status', edit `config.status'
-#     (which will cause the Makefiles to be regenerated when you run `make');
-# (2) otherwise, pass the desired values on the `make' command line.
-$(RECURSIVE_TARGETS):
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(RECURSIVE_TARGETS) $(RECURSIVE_CLEAN_TARGETS):
 	@fail= failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
@@ -588,7 +647,11 @@ $(RECURSIVE_TARGETS):
 	done; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
 	  echo "Making $$target in $$subdir"; \
 	  if test "$$subdir" = "."; then \
 	    dot_seen=yes; \
@@ -602,37 +665,6 @@ $(RECURSIVE_TARGETS):
 	if test "$$dot_seen" = "no"; then \
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
-
-$(RECURSIVE_CLEAN_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
-	dot_seen=no; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	rev=''; for subdir in $$list; do \
-	  if test "$$subdir" = "."; then :; else \
-	    rev="$$subdir $$rev"; \
-	  fi; \
-	done; \
-	rev="$$rev ."; \
-	target=`echo $@ | sed s/-recursive//`; \
-	for subdir in $$rev; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done && test -z "$$fail"
 tags-recursive:
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
@@ -641,6 +673,10 @@ ctags-recursive:
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
 	done
+cscopelist-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) cscopelist); \
+	done
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -704,6 +740,20 @@ GTAGS:
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscopelist: cscopelist-recursive $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
@@ -739,13 +789,10 @@ distdir: $(DISTFILES)
 	done
 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
 	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
 	    $(am__relativize); \
 	    new_distdir=$$reldir; \
@@ -866,22 +913,23 @@ ps-am:
 
 uninstall-am:
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \
-	install-am install-strip tags-recursive
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) \
+	cscopelist-recursive ctags-recursive install-am install-strip \
+	tags-recursive
 
 .PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
 	all all-am check check-am clean clean-generic clean-libtool \
-	ctags ctags-recursive distclean distclean-generic \
-	distclean-libtool distclean-tags distdir dvi dvi-am html \
-	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs installdirs-am maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-generic \
-	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
-	uninstall uninstall-am
+	cscopelist cscopelist-recursive ctags ctags-recursive \
+	distclean distclean-generic distclean-libtool distclean-tags \
+	distdir dvi dvi-am html html-am info info-am install \
+	install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	installdirs-am maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
+	ps ps-am tags tags-recursive uninstall uninstall-am
 
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
diff --git a/tests/check/Makefile.am b/tests/check/Makefile.am
index 74e1860..0887023 100644
--- a/tests/check/Makefile.am
+++ b/tests/check/Makefile.am
@@ -147,6 +147,19 @@ else
 check_opus =
 endif
 
+if USE_UVCH264
+check_uvch264=elements/uvch264demux
+else
+check_uvch264=
+endif
+uvch264_dist_data = elements/uvch264demux_data/valid_h264_jpg.mjpg \
+			elements/uvch264demux_data/valid_h264_jpg.jpg \
+			elements/uvch264demux_data/valid_h264_jpg.h264 \
+			elements/uvch264demux_data/valid_h264_yuy2.mjpg \
+			elements/uvch264demux_data/valid_h264_yuy2.h264 \
+			elements/uvch264demux_data/valid_h264_yuy2.yuy2
+
+
 VALGRIND_TO_FIX = \
 	elements/mpeg2enc \
 	elements/mplex    \
@@ -201,6 +214,7 @@ check_PROGRAMS = \
 	elements/rtpmux \
 	libs/mpegvideoparser \
 	libs/h264parser \
+	$(check_uvch264) \
 	libs/vc1parser \
 	$(check_schro) \
 	$(check_vp8) \
@@ -320,8 +334,10 @@ elements_assrender_LDADD = $(GST_PLUGINS_BASE_LIBS) -lgstvideo-0.10 -lgstapp-0.1
 elements_mpegtsmux_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(AM_CFLAGS)
 elements_mpegtsmux_LDADD = $(GST_PLUGINS_BASE_LIBS) -lgstvideo-0.10 $(GST_BASE_LIBS) $(LDADD)
 
+elements_uvch264demux_CFLAGS = -DUVCH264DEMUX_DATADIR="$(srcdir)/elements/uvch264demux_data" \
+				$(AM_CFLAGS)
 
-EXTRA_DIST = gst-plugins-bad.supp
+EXTRA_DIST = gst-plugins-bad.supp $(uvch264_dist_data)
 
 orc_cog_CFLAGS = $(ORC_CFLAGS)
 orc_cog_LDADD = $(ORC_LIBS) -lorc-test-0.4
diff --git a/tests/check/Makefile.in b/tests/check/Makefile.in
index bb83e1b..b20d4a4 100644
--- a/tests/check/Makefile.in
+++ b/tests/check/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -18,6 +17,23 @@
 
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -36,9 +52,11 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in $(top_srcdir)/common/check.mak
-noinst_PROGRAMS = pipelines/colorspace$(EXEEXT) $(am__EXEEXT_19)
+	$(srcdir)/Makefile.in $(top_srcdir)/common/check.mak \
+	$(top_srcdir)/depcomp
+noinst_PROGRAMS = pipelines/colorspace$(EXEEXT) $(am__EXEEXT_20)
 check_PROGRAMS = generic/states$(EXEEXT) $(am__EXEEXT_1) \
 	$(am__EXEEXT_2) $(am__EXEEXT_3) $(am__EXEEXT_4) \
 	$(am__EXEEXT_5) $(am__EXEEXT_6) $(am__EXEEXT_7) \
@@ -55,17 +73,16 @@ check_PROGRAMS = generic/states$(EXEEXT) $(am__EXEEXT_1) \
 	elements/mxfmux$(EXEEXT) elements/id3mux$(EXEEXT) \
 	pipelines/mxf$(EXEEXT) $(am__EXEEXT_14) \
 	elements/rtpmux$(EXEEXT) libs/mpegvideoparser$(EXEEXT) \
-	libs/h264parser$(EXEEXT) libs/vc1parser$(EXEEXT) \
-	$(am__EXEEXT_15) $(am__EXEEXT_16) \
-	elements/viewfinderbin$(EXEEXT) $(am__EXEEXT_17) \
-	$(am__EXEEXT_18)
+	libs/h264parser$(EXEEXT) $(am__EXEEXT_15) \
+	libs/vc1parser$(EXEEXT) $(am__EXEEXT_16) $(am__EXEEXT_17) \
+	elements/viewfinderbin$(EXEEXT) $(am__EXEEXT_18) \
+	$(am__EXEEXT_19)
 subdir = tests/check
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -109,6 +126,7 @@ libparser_la_OBJECTS = $(am_libparser_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
+am__v_lt_1 = 
 libparser_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(libparser_la_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
@@ -126,12 +144,13 @@ libparser_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 @USE_EXIF_TRUE@am__EXEEXT_12 = elements/jifmux$(EXEEXT)
 @USE_COG_TRUE@am__EXEEXT_13 = elements/logoinsert$(EXEEXT)
 @USE_MIMIC_TRUE@am__EXEEXT_14 = pipelines/mimic$(EXEEXT)
-@USE_SCHRO_TRUE@am__EXEEXT_15 = elements/schroenc$(EXEEXT)
-@USE_VP8_TRUE@am__EXEEXT_16 = elements/vp8enc$(EXEEXT) \
+@USE_UVCH264_TRUE@am__EXEEXT_15 = elements/uvch264demux$(EXEEXT)
+@USE_SCHRO_TRUE@am__EXEEXT_16 = elements/schroenc$(EXEEXT)
+@USE_VP8_TRUE@am__EXEEXT_17 = elements/vp8enc$(EXEEXT) \
 @USE_VP8_TRUE@	elements/vp8dec$(EXEEXT)
-@USE_ZBAR_TRUE@am__EXEEXT_17 = elements/zbar$(EXEEXT)
-@HAVE_ORC_TRUE@am__EXEEXT_18 = orc/cog$(EXEEXT)
-@USE_NEON_TRUE@am__EXEEXT_19 = elements/neonhttpsrc$(EXEEXT)
+@USE_ZBAR_TRUE@am__EXEEXT_18 = elements/zbar$(EXEEXT)
+@HAVE_ORC_TRUE@am__EXEEXT_19 = orc/cog$(EXEEXT)
+@USE_NEON_TRUE@am__EXEEXT_20 = elements/neonhttpsrc$(EXEEXT)
 PROGRAMS = $(noinst_PROGRAMS)
 elements_asfmux_SOURCES = elements/asfmux.c
 elements_asfmux_OBJECTS = asfmux.$(OBJEXT)
@@ -303,6 +322,15 @@ elements_timidity_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(elements_timidity_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \
 	-o $@
+elements_uvch264demux_SOURCES = elements/uvch264demux.c
+elements_uvch264demux_OBJECTS =  \
+	elements_uvch264demux-uvch264demux.$(OBJEXT)
+elements_uvch264demux_LDADD = $(LDADD)
+elements_uvch264demux_DEPENDENCIES = $(am__DEPENDENCIES_1)
+elements_uvch264demux_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(elements_uvch264demux_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
 elements_viewfinderbin_SOURCES = elements/viewfinderbin.c
 elements_viewfinderbin_OBJECTS = viewfinderbin.$(OBJEXT)
 elements_viewfinderbin_LDADD = $(LDADD)
@@ -382,6 +410,18 @@ pipelines_mxf_SOURCES = pipelines/mxf.c
 pipelines_mxf_OBJECTS = mxf.$(OBJEXT)
 pipelines_mxf_LDADD = $(LDADD)
 pipelines_mxf_DEPENDENCIES = $(am__DEPENDENCIES_1)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -394,20 +434,16 @@ LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(libparser_la_SOURCES) elements/asfmux.c \
 	elements/assrender.c elements/autoconvert.c \
 	elements/autovideoconvert.c \
@@ -422,12 +458,12 @@ SOURCES = $(libparser_la_SOURCES) elements/asfmux.c \
 	elements/mpegvideoparse.c elements/mplex.c elements/mxfdemux.c \
 	elements/mxfmux.c elements/neonhttpsrc.c elements/ofa.c \
 	elements/opus.c elements/rtpmux.c elements/schroenc.c \
-	elements/timidity.c elements/viewfinderbin.c \
-	elements/voaacenc.c elements/voamrwbenc.c elements/vp8dec.c \
-	elements/vp8enc.c elements/zbar.c generic/states.c \
-	libs/h264parser.c libs/mpegvideoparser.c libs/vc1parser.c \
-	orc/cog.c pipelines/colorspace.c pipelines/mimic.c \
-	pipelines/mxf.c
+	elements/timidity.c elements/uvch264demux.c \
+	elements/viewfinderbin.c elements/voaacenc.c \
+	elements/voamrwbenc.c elements/vp8dec.c elements/vp8enc.c \
+	elements/zbar.c generic/states.c libs/h264parser.c \
+	libs/mpegvideoparser.c libs/vc1parser.c orc/cog.c \
+	pipelines/colorspace.c pipelines/mimic.c pipelines/mxf.c
 DIST_SOURCES = $(libparser_la_SOURCES) elements/asfmux.c \
 	elements/assrender.c elements/autoconvert.c \
 	elements/autovideoconvert.c \
@@ -442,17 +478,24 @@ DIST_SOURCES = $(libparser_la_SOURCES) elements/asfmux.c \
 	elements/mpegvideoparse.c elements/mplex.c elements/mxfdemux.c \
 	elements/mxfmux.c elements/neonhttpsrc.c elements/ofa.c \
 	elements/opus.c elements/rtpmux.c elements/schroenc.c \
-	elements/timidity.c elements/viewfinderbin.c \
-	elements/voaacenc.c elements/voamrwbenc.c elements/vp8dec.c \
-	elements/vp8enc.c elements/zbar.c generic/states.c \
-	libs/h264parser.c libs/mpegvideoparser.c libs/vc1parser.c \
-	orc/cog.c pipelines/colorspace.c pipelines/mimic.c \
-	pipelines/mxf.c
+	elements/timidity.c elements/uvch264demux.c \
+	elements/viewfinderbin.c elements/voaacenc.c \
+	elements/voamrwbenc.c elements/vp8dec.c elements/vp8enc.c \
+	elements/zbar.c generic/states.c libs/h264parser.c \
+	libs/mpegvideoparser.c libs/vc1parser.c orc/cog.c \
+	pipelines/colorspace.c pipelines/mimic.c pipelines/mxf.c
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 HEADERS = $(noinst_HEADERS)
 ETAGS = etags
 CTAGS = ctags
-am__tty_colors = \
-red=; grn=; lgn=; blu=; std=
+am__tty_colors_dummy = \
+  mgn= red= grn= lgn= blu= brg= std=; \
+  am__color_tests=no
+am__tty_colors = $(am__tty_colors_dummy)
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ACLOCAL_AMFLAGS = @ACLOCAL_AMFLAGS@
@@ -485,6 +528,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -509,10 +554,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -527,9 +574,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -587,13 +637,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -612,13 +665,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = $(top_builddir)/tools
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -628,6 +687,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -655,6 +715,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -692,7 +756,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -701,6 +765,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -734,6 +799,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -750,6 +817,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -778,12 +846,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -851,7 +922,11 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
@@ -920,6 +995,15 @@ SUPPRESSIONS = $(top_srcdir)/common/gst.supp $(srcdir)/gst-plugins-bad.supp
 @USE_ZBAR_TRUE@check_zbar = elements/zbar
 @USE_OPUS_FALSE@check_opus = 
 @USE_OPUS_TRUE@check_opus = elements/opus
+@USE_UVCH264_FALSE@check_uvch264 = 
+@USE_UVCH264_TRUE@check_uvch264 = elements/uvch264demux
+uvch264_dist_data = elements/uvch264demux_data/valid_h264_jpg.mjpg \
+			elements/uvch264demux_data/valid_h264_jpg.jpg \
+			elements/uvch264demux_data/valid_h264_jpg.h264 \
+			elements/uvch264demux_data/valid_h264_yuy2.mjpg \
+			elements/uvch264demux_data/valid_h264_yuy2.h264 \
+			elements/uvch264demux_data/valid_h264_yuy2.yuy2
+
 VALGRIND_TO_FIX = \
 	elements/mpeg2enc \
 	elements/mplex    \
@@ -1035,7 +1119,10 @@ elements_assrender_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(AM_C
 elements_assrender_LDADD = $(GST_PLUGINS_BASE_LIBS) -lgstvideo-0.10 -lgstapp-0.10 $(GST_BASE_LIBS) $(LDADD)
 elements_mpegtsmux_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(AM_CFLAGS)
 elements_mpegtsmux_LDADD = $(GST_PLUGINS_BASE_LIBS) -lgstvideo-0.10 $(GST_BASE_LIBS) $(LDADD)
-EXTRA_DIST = gst-plugins-bad.supp
+elements_uvch264demux_CFLAGS = -DUVCH264DEMUX_DATADIR="$(srcdir)/elements/uvch264demux_data" \
+				$(AM_CFLAGS)
+
+EXTRA_DIST = gst-plugins-bad.supp $(uvch264_dist_data)
 orc_cog_CFLAGS = $(ORC_CFLAGS)
 orc_cog_LDADD = $(ORC_LIBS) -lorc-test-0.4
 all: all-am
@@ -1076,12 +1163,14 @@ $(am__aclocal_m4_deps):
 
 clean-noinstLTLIBRARIES:
 	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
-	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
+	@list='$(noinst_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
 libparser.la: $(libparser_la_OBJECTS) $(libparser_la_DEPENDENCIES) $(EXTRA_libparser_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(libparser_la_LINK)  $(libparser_la_OBJECTS) $(libparser_la_LIBADD) $(LIBS)
 
@@ -1198,6 +1287,9 @@ elements/schroenc$(EXEEXT): $(elements_schroenc_OBJECTS) $(elements_schroenc_DEP
 elements/timidity$(EXEEXT): $(elements_timidity_OBJECTS) $(elements_timidity_DEPENDENCIES) $(EXTRA_elements_timidity_DEPENDENCIES) elements/$(am__dirstamp)
 	@rm -f elements/timidity$(EXEEXT)
 	$(AM_V_CCLD)$(elements_timidity_LINK) $(elements_timidity_OBJECTS) $(elements_timidity_LDADD) $(LIBS)
+elements/uvch264demux$(EXEEXT): $(elements_uvch264demux_OBJECTS) $(elements_uvch264demux_DEPENDENCIES) $(EXTRA_elements_uvch264demux_DEPENDENCIES) elements/$(am__dirstamp)
+	@rm -f elements/uvch264demux$(EXEEXT)
+	$(AM_V_CCLD)$(elements_uvch264demux_LINK) $(elements_uvch264demux_OBJECTS) $(elements_uvch264demux_LDADD) $(LIBS)
 elements/viewfinderbin$(EXEEXT): $(elements_viewfinderbin_OBJECTS) $(elements_viewfinderbin_DEPENDENCIES) $(EXTRA_elements_viewfinderbin_DEPENDENCIES) elements/$(am__dirstamp)
 	@rm -f elements/viewfinderbin$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(elements_viewfinderbin_OBJECTS) $(elements_viewfinderbin_LDADD) $(LIBS)
@@ -1274,6 +1366,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elements_mpegtsmux-mpegtsmux.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elements_rtpmux-rtpmux.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elements_timidity-timidity.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elements_uvch264demux-uvch264demux.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elements_voaacenc-voaacenc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/faac.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/faad.Po@am__quote@
@@ -1783,6 +1876,20 @@ elements_timidity-timidity.obj: elements/timidity.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(elements_timidity_CFLAGS) $(CFLAGS) -c -o elements_timidity-timidity.obj `if test -f 'elements/timidity.c'; then $(CYGPATH_W) 'elements/timidity.c'; else $(CYGPATH_W) '$(srcdir)/elements/timidity.c'; fi`
 
+elements_uvch264demux-uvch264demux.o: elements/uvch264demux.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(elements_uvch264demux_CFLAGS) $(CFLAGS) -MT elements_uvch264demux-uvch264demux.o -MD -MP -MF $(DEPDIR)/elements_uvch264demux-uvch264demux.Tpo -c -o elements_uvch264demux-uvch264demux.o `test -f 'elements/uvch264demux.c' || echo '$(srcdir)/'`elements/uvch264demux.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/elements_uvch264demux-uvch264demux.Tpo $(DEPDIR)/elements_uvch264demux-uvch264demux.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='elements/uvch264demux.c' object='elements_uvch264demux-uvch264demux.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(elements_uvch264demux_CFLAGS) $(CFLAGS) -c -o elements_uvch264demux-uvch264demux.o `test -f 'elements/uvch264demux.c' || echo '$(srcdir)/'`elements/uvch264demux.c
+
+elements_uvch264demux-uvch264demux.obj: elements/uvch264demux.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(elements_uvch264demux_CFLAGS) $(CFLAGS) -MT elements_uvch264demux-uvch264demux.obj -MD -MP -MF $(DEPDIR)/elements_uvch264demux-uvch264demux.Tpo -c -o elements_uvch264demux-uvch264demux.obj `if test -f 'elements/uvch264demux.c'; then $(CYGPATH_W) 'elements/uvch264demux.c'; else $(CYGPATH_W) '$(srcdir)/elements/uvch264demux.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/elements_uvch264demux-uvch264demux.Tpo $(DEPDIR)/elements_uvch264demux-uvch264demux.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='elements/uvch264demux.c' object='elements_uvch264demux-uvch264demux.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(elements_uvch264demux_CFLAGS) $(CFLAGS) -c -o elements_uvch264demux-uvch264demux.obj `if test -f 'elements/uvch264demux.c'; then $(CYGPATH_W) 'elements/uvch264demux.c'; else $(CYGPATH_W) '$(srcdir)/elements/uvch264demux.c'; fi`
+
 viewfinderbin.o: elements/viewfinderbin.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT viewfinderbin.o -MD -MP -MF $(DEPDIR)/viewfinderbin.Tpo -c -o viewfinderbin.o `test -f 'elements/viewfinderbin.c' || echo '$(srcdir)/'`elements/viewfinderbin.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/viewfinderbin.Tpo $(DEPDIR)/viewfinderbin.Po
@@ -2039,6 +2146,20 @@ GTAGS:
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
@@ -2052,7 +2173,7 @@ check-TESTS: $(TESTS)
 	    if test -f ./$$tst; then dir=./; \
 	    elif test -f $$tst; then dir=; \
 	    else dir="$(srcdir)/"; fi; \
-	    if $(TESTS_ENVIRONMENT) $${dir}$$tst; then \
+	    if $(TESTS_ENVIRONMENT) $${dir}$$tst $(AM_TESTS_FD_REDIRECT); then \
 	      all=`expr $$all + 1`; \
 	      case " $(XFAIL_TESTS) " in \
 	      *[\ \	]$$tst[\ \	]*) \
@@ -2282,17 +2403,18 @@ uninstall-am:
 
 .PHONY: CTAGS GTAGS all all-am check check-TESTS check-am clean \
 	clean-checkPROGRAMS clean-generic clean-libtool clean-local \
-	clean-noinstLTLIBRARIES clean-noinstPROGRAMS ctags distclean \
-	distclean-compile distclean-generic distclean-libtool \
-	distclean-tags distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
-	pdf pdf-am ps ps-am tags uninstall uninstall-am
+	clean-noinstLTLIBRARIES clean-noinstPROGRAMS cscopelist ctags \
+	distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am
 
 
 # keep target around, since it's referenced in the modules' Makefiles
@@ -2316,6 +2438,12 @@ clean-local-check:
 	CK_DEFAULT_TIMEOUT=20					\
 	$*
 
+# just like 'check', but don't run it again if it fails (useful for debugging)
+%.check-norepeat: %
+	@$(TESTS_ENVIRONMENT)					\
+	CK_DEFAULT_TIMEOUT=20					\
+	$*
+
 # run any given test in a loop
 %.torture: %
 	@for i in `seq 1 $(LOOPS)`; do				\
@@ -2441,7 +2569,8 @@ help:
 	@echo
 	@echo "make check                         -- run all checks"
 	@echo "make torture                       -- run all checks $(LOOPS) times"
-	@echo "make (dir)/(test).check            -- run the given check once"
+	@echo "make (dir)/(test).check            -- run the given check once, repeat with GST_DEBUG=*:2 if it fails"
+	@echo "make (dir)/(test).check-norepeat   -- run the given check once, but don't run it again if it fails"
 	@echo "make (dir)/(test).forever          -- run the given check forever"
 	@echo "make (dir)/(test).torture          -- run the given check $(LOOPS) times"
 	@echo
diff --git a/tests/check/elements/camerabin2.c b/tests/check/elements/camerabin2.c
index 9ae219a..d5e746c 100644
--- a/tests/check/elements/camerabin2.c
+++ b/tests/check/elements/camerabin2.c
@@ -42,6 +42,24 @@
 #define VIDEO_PAD_SUPPORTED_CAPS GST_VIDEO_CAPS_RGB ", width=600, height=480"
 #define IMAGE_PAD_SUPPORTED_CAPS GST_VIDEO_CAPS_RGB ", width=800, height=600"
 
+static GstStaticPadTemplate vfsrc_template =
+GST_STATIC_PAD_TEMPLATE (GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME,
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate imgsrc_template =
+GST_STATIC_PAD_TEMPLATE (GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME,
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate vidsrc_template =
+GST_STATIC_PAD_TEMPLATE (GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME,
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
 /* custom test camera src element */
 #define GST_TYPE_TEST_CAMERA_SRC \
   (gst_test_camera_src_get_type())
@@ -121,10 +139,18 @@ gst_test_camera_src_base_init (gpointer g_class)
 static void
 gst_test_camera_src_class_init (GstTestCameraSrcClass * klass)
 {
+  GstElementClass *gstelement_class;
   GstBaseCameraSrcClass *gstbasecamera_class;
 
+  gstelement_class = GST_ELEMENT_CLASS (klass);
   gstbasecamera_class = GST_BASE_CAMERA_SRC_CLASS (klass);
   gstbasecamera_class->set_mode = gst_test_camera_src_set_mode;
+
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &vidsrc_template);
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &imgsrc_template);
+  gst_element_class_add_static_pad_template (gstelement_class, &vfsrc_template);
 }
 
 static void
diff --git a/tests/check/elements/mpegtsmux.c b/tests/check/elements/mpegtsmux.c
index a93ac67..248c4b0 100644
--- a/tests/check/elements/mpegtsmux.c
+++ b/tests/check/elements/mpegtsmux.c
@@ -39,11 +39,299 @@ static GstStaticPadTemplate audio_src_template = GST_STATIC_PAD_TEMPLATE ("src",
     GST_STATIC_CAPS ("audio/mpeg")
     );
 
+/* For ease of programming we use globals to keep refs for our floating
+ * src and sink pads we create; otherwise we always have to do get_pad,
+ * get_peer, and then remove references in every test function */
+static GstPad *mysrcpad, *mysinkpad;
+
+#define AUDIO_CAPS_STRING "audio/mpeg, " \
+                        "channels = (int) 1, " \
+                        "rate = (int) 8000, " \
+                        "mpegversion = (int) 1"
+#define VIDEO_CAPS_STRING "video/x-h264, " \
+                           "format = (string) byte-stream"
+
+/* setup and teardown needs some special handling for muxer */
+static GstPad *
+setup_src_pad (GstElement * element,
+    GstStaticPadTemplate * template, GstCaps * caps, const gchar * sinkname,
+    gchar ** padname)
+{
+  GstPad *srcpad, *sinkpad;
+
+  GST_DEBUG_OBJECT (element, "setting up sending pad");
+  /* sending pad */
+  srcpad = gst_pad_new_from_static_template (template, "src");
+  fail_if (srcpad == NULL, "Could not create a srcpad");
+  ASSERT_OBJECT_REFCOUNT (srcpad, "srcpad", 1);
+
+  if (!(sinkpad = gst_element_get_static_pad (element, sinkname)))
+    sinkpad = gst_element_get_request_pad (element, sinkname);
+  fail_if (sinkpad == NULL, "Could not get sink pad from %s",
+      GST_ELEMENT_NAME (element));
+  /* references are owned by: 1) us, 2) tsmux, 3) collect pads */
+  ASSERT_OBJECT_REFCOUNT (sinkpad, "sinkpad", 3);
+  if (caps)
+    fail_unless (gst_pad_set_caps (srcpad, caps));
+  fail_unless (gst_pad_link (srcpad, sinkpad) == GST_PAD_LINK_OK,
+      "Could not link source and %s sink pads", GST_ELEMENT_NAME (element));
+  gst_object_unref (sinkpad);   /* because we got it higher up */
+
+  /* references are owned by: 1) tsmux, 2) collect pads */
+  ASSERT_OBJECT_REFCOUNT (sinkpad, "sinkpad", 2);
+
+  if (padname)
+    *padname = g_strdup (GST_PAD_NAME (sinkpad));
+
+  return srcpad;
+}
+
+static void
+teardown_src_pad (GstElement * element, const gchar * sinkname)
+{
+  GstPad *srcpad, *sinkpad;
+
+  /* clean up floating src pad */
+  if (!(sinkpad = gst_element_get_static_pad (element, sinkname)))
+    sinkpad = gst_element_get_request_pad (element, sinkname);
+  /* pad refs held by 1) tsmux 2) collectpads and 3) us (through _get) */
+  ASSERT_OBJECT_REFCOUNT (sinkpad, "sinkpad", 3);
+  srcpad = gst_pad_get_peer (sinkpad);
+
+  gst_pad_unlink (srcpad, sinkpad);
+  GST_DEBUG ("src %p", srcpad);
+
+  /* after unlinking, pad refs still held by
+   * 1) tsmux and 2) collectpads and 3) us (through _get) */
+  ASSERT_OBJECT_REFCOUNT (sinkpad, "sinkpad", 3);
+  gst_object_unref (sinkpad);
+  /* one more ref is held by element itself */
+
+  /* pad refs held by both creator and this function (through _get_peer) */
+  ASSERT_OBJECT_REFCOUNT (srcpad, "srcpad", 2);
+  gst_object_unref (srcpad);
+  gst_object_unref (srcpad);
+
+}
+
+static GstElement *
+setup_tsmux (GstStaticPadTemplate * srctemplate, const gchar * sinkname,
+    gchar ** padname)
+{
+  GstElement *mux;
+
+  GST_DEBUG ("setup_tsmux");
+  mux = gst_check_setup_element ("mpegtsmux");
+  mysrcpad = setup_src_pad (mux, srctemplate, NULL, sinkname, padname);
+  mysinkpad = gst_check_setup_sink_pad (mux, &sink_template, NULL);
+  gst_pad_set_active (mysrcpad, TRUE);
+  gst_pad_set_active (mysinkpad, TRUE);
+
+  return mux;
+}
+
+static void
+cleanup_tsmux (GstElement * mux, const gchar * sinkname)
+{
+  GST_DEBUG ("cleanup_mux");
+  gst_element_set_state (mux, GST_STATE_NULL);
+
+  gst_pad_set_active (mysrcpad, FALSE);
+  gst_pad_set_active (mysinkpad, FALSE);
+  teardown_src_pad (mux, sinkname);
+  gst_check_teardown_sink_pad (mux);
+  gst_check_teardown_element (mux);
+}
+
+static void
+check_tsmux_pad (GstStaticPadTemplate * srctemplate,
+    const gchar * src_caps_string, gint pes_id, gint pmt_id,
+    const gchar * sinkname)
+{
+  GstElement *mux;
+  GstBuffer *inbuffer, *outbuffer;
+  GstCaps *caps;
+  gint num_buffers;
+  gint i;
+  gint pmt_pid = -1, el_pid = -1, pcr_pid = -1, packets = 0;
+  gchar *padname;
+
+  mux = setup_tsmux (srctemplate, sinkname, &padname);
+  fail_unless (gst_element_set_state (mux,
+          GST_STATE_PLAYING) == GST_STATE_CHANGE_SUCCESS,
+      "could not set to playing");
+
+  inbuffer = gst_buffer_new_and_alloc (1);
+  caps = gst_caps_from_string (src_caps_string);
+  gst_buffer_set_caps (inbuffer, caps);
+  gst_caps_unref (caps);
+  GST_BUFFER_TIMESTAMP (inbuffer) = 0;
+  ASSERT_BUFFER_REFCOUNT (inbuffer, "inbuffer", 1);
+  fail_unless (gst_pad_push (mysrcpad, inbuffer) == GST_FLOW_OK);
+  num_buffers = g_list_length (buffers);
+  /* all output might get aggregated */
+  fail_unless (num_buffers >= 1);
+
+  /* collect buffers in adapter for convenience */
+  for (i = 0; i < num_buffers; ++i) {
+    guint8 *odata;
+    gint size;
+
+    outbuffer = GST_BUFFER (buffers->data);
+    fail_if (outbuffer == NULL);
+    buffers = g_list_remove (buffers, outbuffer);
+    ASSERT_BUFFER_REFCOUNT (outbuffer, "outbuffer", 1);
+
+    odata = GST_BUFFER_DATA (outbuffer);
+    size = GST_BUFFER_SIZE (outbuffer);
+    fail_unless (size % 188 == 0);
+
+    for (; size; odata += 188, size -= 188) {
+      guint pid, y;
+      guint8 *data = odata;
+
+      /* need sync_byte */
+      fail_unless (*data == 0x47);
+      data++;
+
+      y = GST_READ_UINT16_BE (data);
+      pid = y & (0x1FFF);
+      data += 2;
+      GST_DEBUG ("pid: %d", pid);
+
+      y = (y >> 14) & 0x1;
+      /* only check packets with payload_start_indicator == 1 */
+      if (!y) {
+        GST_DEBUG ("not at start");
+        continue;
+      }
+
+      y = *data;
+      data++;
+
+      if (y & 0x20) {
+        /* adaptation field */
+        y = *data;
+        data++;
+        data += y;
+        GST_DEBUG ("adaptation %d", y);
+      }
+
+      if (pid == 0) {
+        /* look for PAT */
+        /* pointer field */
+        y = *data;
+        data++;
+        data += y;
+        /* table_id */
+        y = *data;
+        data++;
+        fail_unless (y == 0x0);
+        /* skip */
+        data += 5;
+        /* section_number */
+        y = *data;
+        fail_unless (y == 0);
+        data++;
+        /* last_section_number */
+        y = *data;
+        fail_unless (y == 0);
+        data++;
+        /* program_number */
+        y = GST_READ_UINT16_BE (data);
+        fail_unless (y != 0);
+        data += 2;
+        /* program_map_PID */
+        y = GST_READ_UINT16_BE (data);
+        pmt_pid = y & 0x1FFF;
+        fail_unless (pmt_pid > 0x10 && pmt_pid != 0x1FF);
+      } else if (pid == pmt_pid) {
+        /* look for PMT */
+        /* pointer field */
+        y = *data;
+        data++;
+        data += y;
+        /* table_id */
+        y = *data;
+        data++;
+        fail_unless (y == 0x2);
+        /* skip */
+        data += 5;
+        /* section_number */
+        y = *data;
+        fail_unless (y == 0);
+        data++;
+        /* last_section_number */
+        y = *data;
+        fail_unless (y == 0);
+        data++;
+        /* PCR_PID */
+        y = GST_READ_UINT16_BE (data);
+        data += 2;
+        pcr_pid = y & 0x1FFF;
+        /* program_info_length */
+        y = GST_READ_UINT16_BE (data);
+        data += 2;
+        y = y & 0x0FFF;
+        data += y;
+        /* parsing only ES stream */
+        /* stream_type */
+        y = *data;
+        data++;
+        fail_unless (y == pmt_id);
+        /* elementary_PID */
+        y = GST_READ_UINT16_BE (data);
+        data += 2;
+        el_pid = y & 0x1FFF;
+        fail_unless (el_pid > 0x10 && el_pid != 0x1FF);
+      } else if (pid == el_pid) {
+        packets++;
+        /* expect to see a PES packet start */
+        y = GST_READ_UINT32_BE (data);
+        fail_unless (y >> 8 == 0x1);
+        /* stream_id */
+        y = y & 0xFF;
+        fail_unless ((pes_id & 0xF0) == (y & 0xF0));
+      }
+    }
+    gst_buffer_unref (outbuffer);
+    outbuffer = NULL;
+  }
+
+  fail_unless (pmt_pid > 0);
+  fail_unless (el_pid > 0);
+  fail_unless (pcr_pid == el_pid);
+  fail_unless (packets > 0);
+
+  g_list_free (buffers);
+  buffers = NULL;
+
+  cleanup_tsmux (mux, padname);
+  g_free (padname);
+}
+
+
+GST_START_TEST (test_video)
+{
+  check_tsmux_pad (&video_src_template, VIDEO_CAPS_STRING, 0xE0, 0x1b,
+      "sink_%d");
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_audio)
+{
+  check_tsmux_pad (&audio_src_template, AUDIO_CAPS_STRING, 0xC0, 0x03,
+      "sink_%d");
+}
+
+GST_END_TEST;
+
+
 typedef struct _TestData
 {
   GstEvent *sink_event;
-  GstEvent *src_event1;
-  GstEvent *src_event2;
   gint src_events;
 } TestData;
 
@@ -60,14 +348,10 @@ src_event (GstPad * pad, GstEvent * event)
 {
   TestData *data = (TestData *) gst_pad_get_element_private (pad);
 
-  if (event->type == GST_EVENT_CUSTOM_UPSTREAM) {
+  if (event->type == GST_EVENT_CUSTOM_UPSTREAM)
     data->src_events += 1;
-    if (data->src_event1 != NULL)
-      data->src_event2 = event;
-    else
-      data->src_event1 = event;
-  }
 
+  gst_event_unref (event);
   return TRUE;
 }
 
@@ -79,6 +363,7 @@ sink_event (GstPad * pad, GstEvent * event)
   if (event->type == GST_EVENT_CUSTOM_DOWNSTREAM)
     data->sink_event = event;
 
+  gst_event_unref (event);
   return TRUE;
 }
 
@@ -314,6 +599,8 @@ mpegtsmux_suite (void)
 
   suite_add_tcase (s, tc_chain);
 
+  tcase_add_test (tc_chain, test_audio);
+  tcase_add_test (tc_chain, test_video);
   tcase_add_test (tc_chain, test_force_key_unit_event_downstream);
   tcase_add_test (tc_chain, test_force_key_unit_event_upstream);
 
diff --git a/tests/check/elements/mpegvideoparse.c b/tests/check/elements/mpegvideoparse.c
index 9aab78f..54a72f6 100644
--- a/tests/check/elements/mpegvideoparse.c
+++ b/tests/check/elements/mpegvideoparse.c
@@ -184,8 +184,7 @@ mpeg_video_parse_check_caps (guint version, guint8 * seq, gint size)
   fail_unless (buf != NULL);
   /* codec-data = header - GOP */
   assert_equals_int (GST_BUFFER_SIZE (buf), size - 8);
-  fail_unless (memcmp (GST_BUFFER_DATA (buf), seq + 4,
-          GST_BUFFER_SIZE (buf)) == 0);
+  fail_unless (memcmp (GST_BUFFER_DATA (buf), seq, GST_BUFFER_SIZE (buf)) == 0);
 
   gst_caps_unref (caps);
 }
diff --git a/tests/check/elements/uvch264demux.c b/tests/check/elements/uvch264demux.c
new file mode 100644
index 0000000..a633c69
--- /dev/null
+++ b/tests/check/elements/uvch264demux.c
@@ -0,0 +1,696 @@
+/* GStreamer
+ *
+ * unit test for uvch264_demux
+ *
+ * Copyright (C) <2012> Collabora Ltd.
+ *   Author: Youness Alaoui <youness.alaoui@collabora.co.uk>
+ * Copyright (C) <2008> Sebastian Dröge <sebastian.droege@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <gst/check/gstcheck.h>
+#include <string.h>
+
+static GstElement *demux;
+static GstPad *mjpg_pad, *h264_pad, *yuy2_pad, *nv12_pad, *jpg_pad;
+static gboolean have_h264_eos, have_yuy2_eos, have_nv12_eos, have_jpg_eos;
+static GstBuffer *buffer_h264, *buffer_yuy2, *buffer_nv12, *buffer_jpg;
+static GError *gerror;
+static gchar *error_debug;
+
+static GstStaticPadTemplate mjpg_template =
+GST_STATIC_PAD_TEMPLATE ("src", GST_PAD_SRC, GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("image/jpeg, width=640, height=480, framerate=15/1"));
+
+static GstStaticPadTemplate sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink", GST_PAD_SINK, GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+#define STRINGIFY_(x) #x
+#define STRINGIFY(x) STRINGIFY_ (x)
+#define DATADIR STRINGIFY (UVCH264DEMUX_DATADIR)
+#define VALID_H264_JPG_MJPG_FILENAME  DATADIR "/valid_h264_jpg.mjpg"
+#define VALID_H264_JPG_JPG_FILENAME   DATADIR "/valid_h264_jpg.jpg"
+#define VALID_H264_JPG_H264_FILENAME  DATADIR "/valid_h264_jpg.h264"
+#define VALID_H264_YUY2_MJPG_FILENAME DATADIR "/valid_h264_yuy2.mjpg"
+#define VALID_H264_YUY2_YUY2_FILENAME DATADIR "/valid_h264_yuy2.yuy2"
+#define VALID_H264_YUY2_H264_FILENAME DATADIR "/valid_h264_yuy2.h264"
+
+#define _sink_chain_func(type)                                          \
+static GstFlowReturn                                                    \
+ _sink_##type##_chain (GstPad * pad, GstBuffer * buffer)                \
+{                                                                       \
+  fail_unless (GST_BUFFER_CAPS (buffer) != NULL);                       \
+                                                                        \
+  buffer_##type = buffer;                                               \
+                                                                        \
+  return GST_FLOW_OK;                                                   \
+}
+
+#define _sink_event_func(type)                          \
+static gboolean                                         \
+ _sink_##type##_event (GstPad * pad, GstEvent * event)  \
+{                                                       \
+  if (GST_EVENT_TYPE (event) == GST_EVENT_EOS)          \
+    have_##type##_eos = TRUE;                           \
+                                                        \
+  gst_event_unref (event);                              \
+                                                        \
+  return TRUE;                                          \
+}
+
+
+_sink_chain_func (h264);
+_sink_chain_func (yuy2);
+_sink_chain_func (nv12);
+_sink_chain_func (jpg);
+
+_sink_event_func (h264);
+_sink_event_func (yuy2);
+_sink_event_func (nv12);
+_sink_event_func (jpg);
+
+
+static GstBusSyncReply
+_bus_sync_handler (GstBus * bus, GstMessage * message, gpointer data)
+{
+  if (GST_MESSAGE_TYPE (message) == GST_MESSAGE_ERROR) {
+    fail_unless (gerror == NULL && error_debug == NULL);
+    fail_unless (GST_MESSAGE_SRC (message) == GST_OBJECT (demux));
+    gst_message_parse_error (message, &gerror, &error_debug);
+  }
+  return GST_BUS_PASS;
+}
+
+static void
+_teardown_test (void)
+{
+  GstBus *bus;
+  gst_element_set_state (demux, GST_STATE_NULL);
+
+  bus = GST_ELEMENT_BUS (demux);
+  gst_bus_set_flushing (bus, TRUE);
+  gst_object_unref (bus);
+
+  gst_pad_set_active (mjpg_pad, FALSE);
+  gst_object_unref (mjpg_pad);
+  if (h264_pad) {
+    gst_pad_set_active (h264_pad, FALSE);
+    gst_object_unref (h264_pad);
+  }
+  if (yuy2_pad) {
+    gst_pad_set_active (yuy2_pad, FALSE);
+    gst_object_unref (yuy2_pad);
+  }
+  if (nv12_pad) {
+    gst_pad_set_active (nv12_pad, FALSE);
+    gst_object_unref (nv12_pad);
+  }
+  if (jpg_pad) {
+    gst_pad_set_active (jpg_pad, FALSE);
+    gst_object_unref (jpg_pad);
+  }
+  if (gerror) {
+    g_error_free (gerror);
+    gerror = NULL;
+  }
+  if (error_debug) {
+    g_free (error_debug);
+    error_debug = NULL;
+  }
+
+  gst_object_unref (demux);
+  mjpg_pad = h264_pad = yuy2_pad = nv12_pad = jpg_pad = NULL;
+  demux = NULL;
+}
+
+static void
+_setup_test (gboolean link_h264, gboolean link_yuy2, gboolean link_nv12,
+    gboolean link_jpg)
+{
+  GstBus *bus = gst_bus_new ();
+  GstPad *sinkpad, *h264pad, *yuy2pad, *nv12pad, *jpgpad;
+
+  have_h264_eos = have_yuy2_eos = have_nv12_eos = have_jpg_eos = FALSE;
+  buffer_h264 = buffer_yuy2 = buffer_nv12 = buffer_jpg = NULL;
+
+  demux = gst_element_factory_make ("uvch264_mjpgdemux", NULL);
+  fail_unless (demux != NULL);
+
+  gst_element_set_bus (demux, bus);
+  gst_bus_set_sync_handler (bus, _bus_sync_handler, NULL);
+
+  mjpg_pad = gst_pad_new_from_static_template (&mjpg_template, "src");
+  fail_unless (mjpg_pad != NULL);
+  sinkpad = gst_element_get_static_pad (demux, "sink");
+  fail_unless (sinkpad != NULL);
+  fail_unless (gst_pad_link (mjpg_pad, sinkpad) == GST_PAD_LINK_OK);
+  gst_object_unref (sinkpad);
+
+  gst_pad_set_active (mjpg_pad, TRUE);
+
+  if (link_h264) {
+    h264pad = gst_element_get_static_pad (demux, "h264");
+    fail_unless (h264pad != NULL);
+
+    h264_pad = gst_pad_new_from_static_template (&sink_template, "h264");
+    fail_unless (h264_pad != NULL);
+    gst_pad_set_chain_function (h264_pad, _sink_h264_chain);
+    gst_pad_set_event_function (h264_pad, _sink_h264_event);
+
+    fail_unless (gst_pad_link (h264pad, h264_pad) == GST_PAD_LINK_OK);
+    gst_object_unref (h264pad);
+
+    gst_pad_set_active (h264_pad, TRUE);
+  }
+  if (link_yuy2) {
+    yuy2pad = gst_element_get_static_pad (demux, "yuy2");
+    fail_unless (yuy2pad != NULL);
+
+    yuy2_pad = gst_pad_new_from_static_template (&sink_template, "yuy2");
+    fail_unless (yuy2_pad != NULL);
+    gst_pad_set_chain_function (yuy2_pad, _sink_yuy2_chain);
+    gst_pad_set_event_function (yuy2_pad, _sink_yuy2_event);
+
+    fail_unless (gst_pad_link (yuy2pad, yuy2_pad) == GST_PAD_LINK_OK);
+    gst_object_unref (yuy2pad);
+
+    gst_pad_set_active (yuy2_pad, TRUE);
+  }
+  if (link_nv12) {
+    nv12pad = gst_element_get_static_pad (demux, "nv12");
+    fail_unless (nv12pad != NULL);
+
+    nv12_pad = gst_pad_new_from_static_template (&sink_template, "nv12");
+    fail_unless (nv12_pad != NULL);
+    gst_pad_set_chain_function (nv12_pad, _sink_nv12_chain);
+    gst_pad_set_event_function (nv12_pad, _sink_nv12_event);
+
+    fail_unless (gst_pad_link (nv12pad, nv12_pad) == GST_PAD_LINK_OK);
+    gst_object_unref (nv12pad);
+    gst_pad_set_active (nv12_pad, TRUE);
+  }
+  if (link_jpg) {
+    jpgpad = gst_element_get_static_pad (demux, "jpeg");
+    fail_unless (jpgpad != NULL);
+
+    jpg_pad = gst_pad_new_from_static_template (&sink_template, "jpeg");
+    fail_unless (jpg_pad != NULL);
+    gst_pad_set_chain_function (jpg_pad, _sink_jpg_chain);
+    gst_pad_set_event_function (jpg_pad, _sink_jpg_event);
+
+    fail_unless (gst_pad_link (jpgpad, jpg_pad) == GST_PAD_LINK_OK);
+    gst_object_unref (jpgpad);
+
+    gst_pad_set_active (jpg_pad, TRUE);
+  }
+
+  gst_element_set_state (demux, GST_STATE_PLAYING);
+}
+
+static GstBuffer *
+_buffer_from_file (const gchar * filename)
+{
+  GstBuffer *buffer = gst_buffer_new ();
+  gchar *contents = NULL;
+  gsize length = 0;
+
+  fail_unless (g_file_get_contents (filename, &contents, &length, NULL));
+
+  GST_BUFFER_MALLOCDATA (buffer) = (guint8 *) contents;
+  GST_BUFFER_DATA (buffer) = (guint8 *) contents;
+  GST_BUFFER_SIZE (buffer) = length;
+  GST_BUFFER_OFFSET (buffer) = 0;
+
+  return buffer;
+}
+
+GST_START_TEST (test_valid_h264_jpg)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstCaps *h264_caps;
+  GstBuffer *buffer;
+  gchar *h264_data, *jpg_data;
+  gsize h264_size, jpg_size;
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  h264_caps = gst_caps_new_simple ("video/x-h264",
+      "width", G_TYPE_INT, 640, "height", G_TYPE_INT, 480,
+      "framerate", GST_TYPE_FRACTION, 15, 1, NULL);
+  buffer = _buffer_from_file (VALID_H264_JPG_MJPG_FILENAME);
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (g_file_get_contents (VALID_H264_JPG_H264_FILENAME,
+          &h264_data, &h264_size, NULL));
+  fail_unless (g_file_get_contents (VALID_H264_JPG_JPG_FILENAME,
+          &jpg_data, &jpg_size, NULL));
+
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_OK);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos);
+  fail_unless (have_yuy2_eos);
+  fail_unless (have_nv12_eos);
+  fail_unless (have_jpg_eos);
+  fail_unless (buffer_h264 != NULL);
+  fail_unless (buffer_jpg != NULL);
+  fail_unless (buffer_nv12 == NULL);
+  fail_unless (buffer_yuy2 == NULL);
+  fail_unless (gerror == NULL && error_debug == NULL);
+  fail_unless (gst_caps_is_always_compatible (GST_BUFFER_CAPS (buffer_h264),
+          h264_caps));
+  fail_unless (gst_caps_is_always_compatible (GST_BUFFER_CAPS (buffer_jpg),
+          mjpg_caps));
+  fail_unless (GST_BUFFER_SIZE (buffer_h264) == h264_size);
+  fail_unless (GST_BUFFER_SIZE (buffer_jpg) == jpg_size);
+  fail_unless (memcmp (GST_BUFFER_DATA (buffer_h264), h264_data,
+          h264_size) == 0);
+  fail_unless (memcmp (GST_BUFFER_DATA (buffer_jpg), jpg_data, jpg_size) == 0);
+
+  gst_caps_unref (mjpg_caps);
+  gst_caps_unref (h264_caps);
+  g_free (h264_data);
+  g_free (jpg_data);
+  gst_buffer_unref (buffer_h264);
+  gst_buffer_unref (buffer_jpg);
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_valid_h264_yuy2)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstCaps *h264_caps;
+  GstCaps *yuy2_caps;
+  GstBuffer *buffer;
+  gchar *h264_data, *yuy2_data;
+  gsize h264_size, yuy2_size;
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  h264_caps = gst_caps_new_simple ("video/x-h264",
+      "width", G_TYPE_INT, 640, "height", G_TYPE_INT, 480,
+      "framerate", GST_TYPE_FRACTION, 15, 1, NULL);
+  yuy2_caps = gst_caps_new_simple ("video/x-raw-yuv",
+      "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('Y', 'U', 'Y', '2'),
+      "width", G_TYPE_INT, 160, "height", G_TYPE_INT, 90,
+      "framerate", GST_TYPE_FRACTION, 15, 1, NULL);
+  buffer = _buffer_from_file (VALID_H264_YUY2_MJPG_FILENAME);
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (g_file_get_contents (VALID_H264_YUY2_H264_FILENAME,
+          &h264_data, &h264_size, NULL));
+  fail_unless (g_file_get_contents (VALID_H264_YUY2_YUY2_FILENAME,
+          &yuy2_data, &yuy2_size, NULL));
+
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_OK);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos);
+  fail_unless (have_yuy2_eos);
+  fail_unless (have_nv12_eos);
+  fail_unless (have_jpg_eos);
+  fail_unless (buffer_h264 != NULL);
+  fail_unless (buffer_jpg == NULL);
+  fail_unless (buffer_nv12 == NULL);
+  fail_unless (buffer_yuy2 != NULL);
+  fail_unless (gerror == NULL && error_debug == NULL);
+  fail_unless (gst_caps_is_always_compatible (GST_BUFFER_CAPS (buffer_h264),
+          h264_caps));
+  fail_unless (gst_caps_is_always_compatible (GST_BUFFER_CAPS (buffer_yuy2),
+          yuy2_caps));
+  fail_unless (GST_BUFFER_SIZE (buffer_h264) == h264_size);
+  fail_unless (GST_BUFFER_SIZE (buffer_yuy2) == yuy2_size);
+  fail_unless (memcmp (GST_BUFFER_DATA (buffer_h264), h264_data,
+          h264_size) == 0);
+  fail_unless (memcmp (GST_BUFFER_DATA (buffer_yuy2), yuy2_data,
+          yuy2_size) == 0);
+
+  gst_caps_unref (mjpg_caps);
+  gst_caps_unref (yuy2_caps);
+  gst_caps_unref (h264_caps);
+  g_free (h264_data);
+  g_free (yuy2_data);
+  gst_buffer_unref (buffer_h264);
+  gst_buffer_unref (buffer_yuy2);
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_no_data)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstBuffer *buffer = gst_buffer_new ();
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_OK);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos && have_yuy2_eos && have_nv12_eos && have_jpg_eos);
+  fail_unless (buffer_h264 == NULL && buffer_jpg != NULL);
+  fail_unless (buffer_nv12 == NULL && buffer_yuy2 == NULL);
+  fail_unless (gerror == NULL && error_debug == NULL);
+
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_data_zero)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstBuffer *buffer = gst_buffer_new_and_alloc (1024);
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  memset (GST_BUFFER_DATA (buffer), 0, 1024);
+  GST_BUFFER_SIZE (buffer) = 1024;
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_OK);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos && have_yuy2_eos && have_nv12_eos && have_jpg_eos);
+  fail_unless (buffer_h264 == NULL && buffer_jpg == NULL);
+  fail_unless (buffer_nv12 == NULL && buffer_yuy2 == NULL);
+
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_no_marker_size)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstBuffer *buffer = gst_buffer_new_and_alloc (1024);
+  const guchar data[] = {
+    0xff, 0xd8, 0xff, 0xe4, 0x00
+  };
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  memcpy (GST_BUFFER_DATA (buffer), data, sizeof (data));
+  GST_BUFFER_SIZE (buffer) = sizeof (data);
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_ERROR);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos && have_yuy2_eos && have_nv12_eos && have_jpg_eos);
+  fail_unless (buffer_h264 == NULL && buffer_jpg == NULL);
+  fail_unless (buffer_nv12 == NULL && buffer_yuy2 == NULL);
+  fail_unless (gerror != NULL);
+  fail_unless (gerror->domain == GST_STREAM_ERROR);
+  fail_unless (gerror->code == GST_STREAM_ERROR_DEMUX);
+  fail_unless (memcmp (gerror->message,
+          "Not enough data to read marker size",
+          strlen (gerror->message)) == 0);
+
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_not_enough_data)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstBuffer *buffer = gst_buffer_new_and_alloc (1024);
+  const guchar data[] = {
+    0xff, 0xd8, 0xff, 0xe4, 0x00, 0xff, 0x00, 0x00
+  };
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  memcpy (GST_BUFFER_DATA (buffer), data, sizeof (data));
+  GST_BUFFER_SIZE (buffer) = sizeof (data);
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_ERROR);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos && have_yuy2_eos && have_nv12_eos && have_jpg_eos);
+  fail_unless (buffer_h264 == NULL && buffer_jpg == NULL);
+  fail_unless (buffer_nv12 == NULL && buffer_yuy2 == NULL);
+  fail_unless (gerror != NULL);
+  fail_unless (gerror->domain == GST_STREAM_ERROR);
+  fail_unless (gerror->code == GST_STREAM_ERROR_DEMUX);
+  fail_unless (memcmp (gerror->message,
+          "Not enough data to read marker content",
+          strlen (gerror->message)) == 0);
+
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_no_aux_header)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstBuffer *buffer = gst_buffer_new_and_alloc (1024);
+  const guchar data[] = {
+    0xff, 0xd8, 0xff, 0xe4, 0x00, 0x02, 0x00, 0x00,
+    0xff, 0xd9
+  };
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  memcpy (GST_BUFFER_DATA (buffer), data, sizeof (data));
+  GST_BUFFER_SIZE (buffer) = sizeof (data);
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_ERROR);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos && have_yuy2_eos && have_nv12_eos && have_jpg_eos);
+  fail_unless (buffer_h264 == NULL && buffer_jpg == NULL);
+  fail_unless (buffer_nv12 == NULL && buffer_yuy2 == NULL);
+  fail_unless (gerror != NULL);
+  fail_unless (gerror->domain == GST_STREAM_ERROR);
+  fail_unless (gerror->code == GST_STREAM_ERROR_DEMUX);
+  fail_unless (memcmp (gerror->message,
+          "Not enough data to read aux header", strlen (gerror->message)) == 0);
+
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_empty_aux_data)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstBuffer *buffer = gst_buffer_new_and_alloc (1024);
+  const guchar data[] = {
+    0xff, 0xd8, 0xff, 0xe4, 0x00, 0x1C, 0x00, 0x01,
+    0x16, 0x00, 0x48, 0x32, 0x36, 0x34, 0x80, 0x07,
+    0x38, 0x04, 0x2a, 0x2c, 0x0a, 0x00, 0x1b, 0x00,
+    0x40, 0x62, 0xcb, 0x0a, 0x00, 0x00, 0x00, 0x00,
+    0xff, 0xd9
+  };
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  memcpy (GST_BUFFER_DATA (buffer), data, sizeof (data));
+  GST_BUFFER_SIZE (buffer) = sizeof (data);
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_OK);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos && have_yuy2_eos && have_nv12_eos && have_jpg_eos);
+  fail_unless (buffer_h264 == NULL && buffer_jpg == NULL);
+  fail_unless (buffer_nv12 == NULL && buffer_yuy2 == NULL);
+  fail_unless (gerror == NULL);
+
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_unknown_fcc)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstBuffer *buffer = gst_buffer_new_and_alloc (1024);
+  const guchar data[] = {
+    0xff, 0xd8, 0xff, 0xe4, 0x00, 0x2C, 0x00, 0x01,
+    0x16, 0x00, 0x48, 0x30, 0x30, 0x30, 0x80, 0x07,
+    0x38, 0x04, 0x2a, 0x2c, 0x0a, 0x00, 0x1b, 0x00,
+    0x40, 0x62, 0xcb, 0x0a, 0x10, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xff, 0xd9
+  };
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  memcpy (GST_BUFFER_DATA (buffer), data, sizeof (data));
+  GST_BUFFER_SIZE (buffer) = sizeof (data);
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_ERROR);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos && have_yuy2_eos && have_nv12_eos && have_jpg_eos);
+  fail_unless (buffer_h264 == NULL && buffer_jpg == NULL);
+  fail_unless (buffer_nv12 == NULL && buffer_yuy2 == NULL);
+  fail_unless (gerror != NULL);
+  fail_unless (gerror->domain == GST_STREAM_ERROR);
+  fail_unless (gerror->code == GST_STREAM_ERROR_DEMUX);
+  fail_unless (memcmp (gerror->message,
+          "Unknown auxiliary stream format : H000",
+          strlen (gerror->message)) == 0);
+
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_not_enough_aux_data)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstBuffer *buffer = gst_buffer_new_and_alloc (1024);
+  const guchar data[] = {
+    0xff, 0xd8, 0xff, 0xe4, 0x00, 0x1C, 0x00, 0x01,
+    0x16, 0x00, 0x48, 0x32, 0x36, 0x34, 0x80, 0x07,
+    0x38, 0x04, 0x2a, 0x2c, 0x0a, 0x00, 0x1b, 0x00,
+    0x40, 0x62, 0xcb, 0x0a, 0x10, 0x00, 0x00, 0x00,
+    0xff, 0xd9
+  };
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  memcpy (GST_BUFFER_DATA (buffer), data, sizeof (data));
+  GST_BUFFER_SIZE (buffer) = sizeof (data);
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_ERROR);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos && have_yuy2_eos && have_nv12_eos && have_jpg_eos);
+  fail_unless (buffer_h264 == NULL && buffer_jpg == NULL);
+  fail_unless (buffer_nv12 == NULL && buffer_yuy2 == NULL);
+  fail_unless (gerror != NULL);
+  fail_unless (gerror->domain == GST_STREAM_ERROR);
+  fail_unless (gerror->code == GST_STREAM_ERROR_DEMUX);
+  fail_unless (memcmp (gerror->message,
+          "Incomplete auxiliary stream. 16 bytes missing",
+          strlen (gerror->message)) == 0);
+
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_too_much_aux_data)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstBuffer *buffer = gst_buffer_new_and_alloc (1024);
+  const guchar data[] = {
+    0xff, 0xd8, 0xff, 0xe4, 0x00, 0x3C, 0x00, 0x01,
+    0x16, 0x00, 0x48, 0x32, 0x36, 0x34, 0x80, 0x07,
+    0x38, 0x04, 0x2a, 0x2c, 0x0a, 0x00, 0x1b, 0x00,
+    0x40, 0x62, 0xcb, 0x0a, 0x10, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xff, 0xd9
+  };
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  memcpy (GST_BUFFER_DATA (buffer), data, sizeof (data));
+  GST_BUFFER_SIZE (buffer) = sizeof (data);
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_ERROR);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos && have_yuy2_eos && have_nv12_eos && have_jpg_eos);
+  fail_unless (buffer_h264 == NULL && buffer_jpg == NULL);
+  fail_unless (buffer_nv12 == NULL && buffer_yuy2 == NULL);
+  fail_unless (gerror != NULL);
+  fail_unless (gerror->domain == GST_STREAM_ERROR);
+  fail_unless (gerror->code == GST_STREAM_ERROR_DEMUX);
+  fail_unless (memcmp (gerror->message,
+          "Expected 16 auxiliary data, got 32 bytes",
+          strlen (gerror->message)) == 0);
+
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_no_sos_marker)
+{
+  GstCaps *mjpg_caps = gst_static_pad_template_get_caps (&mjpg_template);
+  GstBuffer *buffer = gst_buffer_new_and_alloc (1024);
+  const guchar data[] = {
+    0xff, 0xd8, 0xff, 0xe4, 0x00, 0x2C, 0x00, 0x01,
+    0x16, 0x00, 0x48, 0x32, 0x36, 0x34, 0x80, 0x07,
+    0x38, 0x04, 0x2a, 0x2c, 0x0a, 0x00, 0x1b, 0x00,
+    0x40, 0x62, 0xcb, 0x0a, 0x10, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xff, 0xd9
+  };
+  const guchar h264_data[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+  };
+
+  _setup_test (TRUE, TRUE, TRUE, TRUE);
+
+  memcpy (GST_BUFFER_DATA (buffer), data, sizeof (data));
+  GST_BUFFER_SIZE (buffer) = sizeof (data);
+  gst_buffer_set_caps (buffer, mjpg_caps);
+  fail_unless (gst_pad_push (mjpg_pad, buffer) == GST_FLOW_OK);
+  fail_unless (gst_pad_push_event (mjpg_pad, gst_event_new_eos ()));
+
+  fail_unless (have_h264_eos && have_yuy2_eos && have_nv12_eos && have_jpg_eos);
+  fail_unless (buffer_h264 != NULL && buffer_jpg == NULL);
+  fail_unless (buffer_nv12 == NULL && buffer_yuy2 == NULL);
+  fail_unless (gerror == NULL);
+  fail_unless (GST_BUFFER_SIZE (buffer_h264) == sizeof (h264_data));
+  fail_unless (memcmp (GST_BUFFER_DATA (buffer_h264), h264_data,
+          sizeof (h264_data)) == 0);
+
+  _teardown_test ();
+}
+
+GST_END_TEST;
+
+static Suite *
+uvch264demux_suite (void)
+{
+  Suite *s = suite_create ("uvch264demux");
+  TCase *tc_chain = tcase_create ("general");
+
+  suite_add_tcase (s, tc_chain);
+  tcase_set_timeout (tc_chain, 180);
+  tcase_add_test (tc_chain, test_valid_h264_jpg);
+  tcase_add_test (tc_chain, test_valid_h264_yuy2);
+  tcase_add_test (tc_chain, test_no_data);
+  tcase_add_test (tc_chain, test_data_zero);
+  tcase_add_test (tc_chain, test_no_marker_size);
+  tcase_add_test (tc_chain, test_not_enough_data);
+  tcase_add_test (tc_chain, test_no_aux_header);
+  tcase_add_test (tc_chain, test_empty_aux_data);
+  tcase_add_test (tc_chain, test_unknown_fcc);
+  tcase_add_test (tc_chain, test_no_sos_marker);
+  tcase_add_test (tc_chain, test_not_enough_aux_data);
+  tcase_add_test (tc_chain, test_too_much_aux_data);
+
+  return s;
+}
+
+GST_CHECK_MAIN (uvch264demux);
diff --git a/tests/check/elements/x264enc.c b/tests/check/elements/x264enc.c
new file mode 100644
index 0000000..721f6e9
--- /dev/null
+++ b/tests/check/elements/x264enc.c
@@ -0,0 +1,206 @@
+/* GStreamer
+ *
+ * unit test for x264enc
+ *
+ * Copyright (C) <2008> Mark Nauwelaerts <mnauw@users.sf.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <unistd.h>
+
+#include <gst/check/gstcheck.h>
+
+/* For ease of programming we use globals to keep refs for our floating
+ * src and sink pads we create; otherwise we always have to do get_pad,
+ * get_peer, and then remove references in every test function */
+static GstPad *mysrcpad, *mysinkpad;
+
+#define VIDEO_CAPS_STRING "video/x-raw-yuv, " \
+                           "format = (fourcc) I420, " \
+                           "width = (int) 384, " \
+                           "height = (int) 288, " \
+                           "framerate = (fraction) 25/1"
+
+#define MPEG_CAPS_STRING "video/x-h264, " \
+                           "width = (int) 384, " \
+                           "height = (int) 288, " \
+                           "framerate = (fraction) 25/1"
+
+static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (MPEG_CAPS_STRING));
+
+static GstStaticPadTemplate srctemplate = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (VIDEO_CAPS_STRING));
+
+
+GstElement *
+setup_x264enc ()
+{
+  GstElement *x264enc;
+
+  GST_DEBUG ("setup_x264enc");
+  x264enc = gst_check_setup_element ("x264enc");
+  mysrcpad = gst_check_setup_src_pad (x264enc, &srctemplate, NULL);
+  mysinkpad = gst_check_setup_sink_pad (x264enc, &sinktemplate, NULL);
+  gst_pad_set_active (mysrcpad, TRUE);
+  gst_pad_set_active (mysinkpad, TRUE);
+
+  return x264enc;
+}
+
+void
+cleanup_x264enc (GstElement * x264enc)
+{
+  GST_DEBUG ("cleanup_x264enc");
+  gst_element_set_state (x264enc, GST_STATE_NULL);
+
+  gst_pad_set_active (mysrcpad, FALSE);
+  gst_pad_set_active (mysinkpad, FALSE);
+  gst_check_teardown_src_pad (x264enc);
+  gst_check_teardown_sink_pad (x264enc);
+  gst_check_teardown_element (x264enc);
+}
+
+GST_START_TEST (test_video_pad)
+{
+  GstElement *x264enc;
+  GstBuffer *inbuffer, *outbuffer;
+  GstCaps *caps;
+  int i, num_buffers;
+
+  x264enc = setup_x264enc ();
+  fail_unless (gst_element_set_state (x264enc,
+          GST_STATE_PLAYING) == GST_STATE_CHANGE_SUCCESS,
+      "could not set to playing");
+
+  /* corresponds to I420 buffer for the size mentioned in the caps */
+  inbuffer = gst_buffer_new_and_alloc (384 * 288 * 3 / 2);
+  /* makes valgrind's memcheck happier */
+  memset (GST_BUFFER_DATA (inbuffer), 0, GST_BUFFER_SIZE (inbuffer));
+  caps = gst_caps_from_string (VIDEO_CAPS_STRING);
+  gst_buffer_set_caps (inbuffer, caps);
+  gst_caps_unref (caps);
+  GST_BUFFER_TIMESTAMP (inbuffer) = 0;
+  ASSERT_BUFFER_REFCOUNT (inbuffer, "inbuffer", 1);
+  fail_unless (gst_pad_push (mysrcpad, inbuffer) == GST_FLOW_OK);
+
+  /* send eos to have all flushed if needed */
+  fail_unless (gst_pad_push_event (mysrcpad, gst_event_new_eos ()) == TRUE);
+
+  num_buffers = g_list_length (buffers);
+  fail_unless (num_buffers == 1);
+
+  /* clean up buffers */
+  for (i = 0; i < num_buffers; ++i) {
+    outbuffer = GST_BUFFER (buffers->data);
+    fail_if (outbuffer == NULL);
+
+    switch (i) {
+      case 0:
+      {
+        gint nsize, npos, j, type;
+        guint8 *data = GST_BUFFER_DATA (outbuffer);
+        gint size = GST_BUFFER_SIZE (outbuffer);
+
+        npos = 0;
+        j = 0;
+        /* loop through NALs */
+        while (npos < size) {
+          fail_unless (size - npos >= 4);
+          nsize = GST_READ_UINT32_BE (data + npos);
+          fail_unless (nsize > 0);
+          fail_unless (npos + 4 + nsize <= size);
+          type = data[npos + 4] & 0x1F;
+          /* check the first NALs, disregard AU (9) */
+          if (type != 9) {
+            switch (j) {
+              case 0:
+                /* SEI */
+                fail_unless (type == 6);
+                break;
+              case 1:
+                /* SPS */
+                fail_unless (type == 7);
+                break;
+              case 2:
+                /* PPS */
+                fail_unless (type == 8);
+                break;
+              case 3:
+                /* IDR */
+                fail_unless (type == 5);
+                break;
+              default:
+                break;
+            }
+            j++;
+          }
+          npos += nsize + 4;
+        }
+        /* should have reached the exact end */
+        fail_unless (npos == size);
+        break;
+      }
+      default:
+        break;
+    }
+    buffers = g_list_remove (buffers, outbuffer);
+
+    ASSERT_BUFFER_REFCOUNT (outbuffer, "outbuffer", 1);
+    gst_buffer_unref (outbuffer);
+    outbuffer = NULL;
+  }
+
+  cleanup_x264enc (x264enc);
+  g_list_free (buffers);
+  buffers = NULL;
+}
+
+GST_END_TEST;
+
+Suite *
+x264enc_suite (void)
+{
+  Suite *s = suite_create ("x264enc");
+  TCase *tc_chain = tcase_create ("general");
+
+  suite_add_tcase (s, tc_chain);
+  tcase_add_test (tc_chain, test_video_pad);
+
+  return s;
+}
+
+int
+main (int argc, char **argv)
+{
+  int nf;
+
+  Suite *s = x264enc_suite ();
+  SRunner *sr = srunner_create (s);
+
+  gst_check_init (&argc, &argv);
+
+  srunner_run_all (sr, CK_NORMAL);
+  nf = srunner_ntests_failed (sr);
+  srunner_free (sr);
+
+  return nf;
+}
diff --git a/tests/check/libs/mpegvideoparser.c b/tests/check/libs/mpegvideoparser.c
index e5a2358..f598dd7 100644
--- a/tests/check/libs/mpegvideoparser.c
+++ b/tests/check/libs/mpegvideoparser.c
@@ -68,41 +68,37 @@ static GstMpegVideoPacketTypeCode ordercode[] = {
 
 GST_START_TEST (test_mpeg_parse)
 {
-  gint i;
-  GList *list, *tmp;
-  GstMpegVideoTypeOffsetSize *typeoffsz;
-
-  list = gst_mpeg_video_parse (mpeg2_seq, sizeof (mpeg2_seq), 12);
-
-  assert_equals_int (g_list_length (list), 4);
-  for (tmp = list, i = 0; tmp; tmp = g_list_next (tmp), i++) {
-    typeoffsz = tmp->data;
+  gint i, off;
+  GstMpegVideoPacket packet;
+
+  off = 12;
+  for (i = 0; i < 4; ++i) {
+    fail_unless (gst_mpeg_video_parse (&packet, mpeg2_seq, sizeof (mpeg2_seq),
+            off));
+    fail_unless (packet.offset == off + 4);
     if (i == 3) {
-      fail_unless (GST_MPEG_VIDEO_PACKET_SLICE_MIN <= typeoffsz->type &&
-          typeoffsz->type <= GST_MPEG_VIDEO_PACKET_SLICE_MAX);
-      fail_unless (typeoffsz->size < 0);
-    } else
-      assert_equals_int (ordercode[i], typeoffsz->type);
+      fail_unless (GST_MPEG_VIDEO_PACKET_SLICE_MIN <= packet.type &&
+          packet.type <= GST_MPEG_VIDEO_PACKET_SLICE_MAX);
+      fail_unless (packet.size < 0);
+    } else {
+      assert_equals_int (ordercode[i], packet.type);
+    }
+    off = packet.offset + packet.size;
   }
-
-  g_list_foreach (list, (GFunc) g_free, NULL);
-  g_list_free (list);
 }
 
 GST_END_TEST;
 
 GST_START_TEST (test_mpeg_parse_sequence_header)
 {
-  GList *list;
-  GstMpegVideoTypeOffsetSize *typeoffsz;
   GstMpegVideoSequenceHdr seqhdr;
+  GstMpegVideoPacket packet;
 
-  list = gst_mpeg_video_parse (mpeg2_seq, sizeof (mpeg2_seq), 12);
+  gst_mpeg_video_parse (&packet, mpeg2_seq, sizeof (mpeg2_seq), 12);
 
-  typeoffsz = list->data;
-  fail_unless (typeoffsz->type == GST_MPEG_VIDEO_PACKET_SEQUENCE);
+  fail_unless (packet.type == GST_MPEG_VIDEO_PACKET_SEQUENCE);
   fail_unless (gst_mpeg_video_parse_sequence_header (&seqhdr, mpeg2_seq,
-          sizeof (mpeg2_seq), typeoffsz->offset));
+          sizeof (mpeg2_seq), packet.offset));
   assert_equals_int (seqhdr.width, 1920);
   assert_equals_int (seqhdr.height, 1080);
   assert_equals_int (seqhdr.aspect_ratio_info, 3);
@@ -115,25 +111,20 @@ GST_START_TEST (test_mpeg_parse_sequence_header)
   assert_equals_int (seqhdr.bitrate, 0);
   assert_equals_int (seqhdr.vbv_buffer_size_value, 512);
   fail_unless (seqhdr.constrained_parameters_flag == FALSE);
-
-  g_list_foreach (list, (GFunc) g_free, NULL);
-  g_list_free (list);
 }
 
 GST_END_TEST;
 
 GST_START_TEST (test_mpeg_parse_sequence_extension)
 {
-  GList *list;
-  GstMpegVideoTypeOffsetSize *typeoffsz;
   GstMpegVideoSequenceExt seqext;
+  GstMpegVideoPacket packet;
 
-  list = gst_mpeg_video_parse (mpeg2_seq, sizeof (mpeg2_seq), 12);
+  gst_mpeg_video_parse (&packet, mpeg2_seq, sizeof (mpeg2_seq), 24);
 
-  typeoffsz = list->next->data;
-  fail_unless (typeoffsz->type == GST_MPEG_VIDEO_PACKET_EXTENSION);
+  fail_unless (packet.type == GST_MPEG_VIDEO_PACKET_EXTENSION);
   fail_unless (gst_mpeg_video_parse_sequence_extension (&seqext,
-          mpeg2_seq, sizeof (mpeg2_seq), typeoffsz->offset));
+          mpeg2_seq, sizeof (mpeg2_seq), packet.offset));
   assert_equals_int (seqext.profile, 4);
   assert_equals_int (seqext.level, 8);
   assert_equals_int (seqext.progressive, 1);
@@ -146,33 +137,29 @@ GST_START_TEST (test_mpeg_parse_sequence_extension)
   assert_equals_int (seqext.low_delay, 0);
   assert_equals_int (seqext.fps_n_ext, 3);
   assert_equals_int (seqext.fps_d_ext, 2);
-
-  g_list_foreach (list, (GFunc) g_free, NULL);
-  g_list_free (list);
 }
 
 GST_END_TEST;
 
 GST_START_TEST (test_mis_identified_datas)
 {
-  GList *list, *tmp;
-  GstMpegVideoTypeOffsetSize *typeoffsz;
+  GstMpegVideoPacket packet = { 0, };
   const guint8 *data = mis_identified_datas;
-
-  list = gst_mpeg_video_parse (mis_identified_datas,
-      sizeof (mis_identified_datas), 0);
-
-  assert_equals_int (g_list_length (list), 2);
-  for (tmp = list; tmp; tmp = g_list_next (tmp)) {
-    typeoffsz = tmp->data;
-
-    assert_equals_int (data[typeoffsz->offset - 4], 0);
-    assert_equals_int (data[typeoffsz->offset - 3], 0);
-    assert_equals_int (data[typeoffsz->offset - 2], 1);
+  gint i, off;
+
+  off = 0;
+  for (i = 0; i < 2; i++) {
+    gst_mpeg_video_parse (&packet, mis_identified_datas,
+        sizeof (mis_identified_datas), off);
+    assert_equals_int (data[packet.offset - 4], 0);
+    assert_equals_int (data[packet.offset - 3], 0);
+    assert_equals_int (data[packet.offset - 2], 1);
+    off = packet.offset + packet.size;
+    if (i == 1)
+      fail_unless (packet.size < 0);
+    else
+      fail_unless (packet.size > 0);
   }
-
-  g_list_foreach (list, (GFunc) g_free, NULL);
-  g_list_free (list);
 }
 
 GST_END_TEST;
diff --git a/tests/check/orc/cog.c b/tests/check/orc/cog.c
deleted file mode 100644
index 89b3fed..0000000
--- a/tests/check/orc/cog.c
+++ /dev/null
@@ -1,9718 +0,0 @@
-
-/* autogenerated from gstcogorc.orc */
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <math.h>
-
-#ifndef _ORC_INTEGER_TYPEDEFS_
-#define _ORC_INTEGER_TYPEDEFS_
-#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-#include <stdint.h>
-typedef int8_t orc_int8;
-typedef int16_t orc_int16;
-typedef int32_t orc_int32;
-typedef int64_t orc_int64;
-typedef uint8_t orc_uint8;
-typedef uint16_t orc_uint16;
-typedef uint32_t orc_uint32;
-typedef uint64_t orc_uint64;
-#define ORC_UINT64_C(x) UINT64_C(x)
-#elif defined(_MSC_VER)
-typedef signed __int8 orc_int8;
-typedef signed __int16 orc_int16;
-typedef signed __int32 orc_int32;
-typedef signed __int64 orc_int64;
-typedef unsigned __int8 orc_uint8;
-typedef unsigned __int16 orc_uint16;
-typedef unsigned __int32 orc_uint32;
-typedef unsigned __int64 orc_uint64;
-#define ORC_UINT64_C(x) (x##Ui64)
-#define inline __inline
-#else
-#include <limits.h>
-typedef signed char orc_int8;
-typedef short orc_int16;
-typedef int orc_int32;
-typedef unsigned char orc_uint8;
-typedef unsigned short orc_uint16;
-typedef unsigned int orc_uint32;
-#if INT_MAX == LONG_MAX
-typedef long long orc_int64;
-typedef unsigned long long orc_uint64;
-#define ORC_UINT64_C(x) (x##ULL)
-#else
-typedef long orc_int64;
-typedef unsigned long orc_uint64;
-#define ORC_UINT64_C(x) (x##UL)
-#endif
-#endif
-typedef union { orc_int16 i; orc_int8 x2[2]; } orc_union16;
-typedef union { orc_int32 i; float f; orc_int16 x2[2]; orc_int8 x4[4]; } orc_union32;
-typedef union { orc_int64 i; double f; orc_int32 x2[2]; float x2f[2]; orc_int16 x4[4]; } orc_union64;
-#endif
-#ifndef ORC_RESTRICT
-#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-#define ORC_RESTRICT restrict
-#elif defined(__GNUC__) && __GNUC__ >= 4
-#define ORC_RESTRICT __restrict__
-#else
-#define ORC_RESTRICT
-#endif
-#endif
-#include <orc/orc.h>
-#include <orc-test/orctest.h>
-
-/* begin Orc C target preamble */
-#define ORC_CLAMP(x,a,b) ((x)<(a) ? (a) : ((x)>(b) ? (b) : (x)))
-#define ORC_ABS(a) ((a)<0 ? -(a) : (a))
-#define ORC_MIN(a,b) ((a)<(b) ? (a) : (b))
-#define ORC_MAX(a,b) ((a)>(b) ? (a) : (b))
-#define ORC_SB_MAX 127
-#define ORC_SB_MIN (-1-ORC_SB_MAX)
-#define ORC_UB_MAX 255
-#define ORC_UB_MIN 0
-#define ORC_SW_MAX 32767
-#define ORC_SW_MIN (-1-ORC_SW_MAX)
-#define ORC_UW_MAX 65535
-#define ORC_UW_MIN 0
-#define ORC_SL_MAX 2147483647
-#define ORC_SL_MIN (-1-ORC_SL_MAX)
-#define ORC_UL_MAX 4294967295U
-#define ORC_UL_MIN 0
-#define ORC_CLAMP_SB(x) ORC_CLAMP(x,ORC_SB_MIN,ORC_SB_MAX)
-#define ORC_CLAMP_UB(x) ORC_CLAMP(x,ORC_UB_MIN,ORC_UB_MAX)
-#define ORC_CLAMP_SW(x) ORC_CLAMP(x,ORC_SW_MIN,ORC_SW_MAX)
-#define ORC_CLAMP_UW(x) ORC_CLAMP(x,ORC_UW_MIN,ORC_UW_MAX)
-#define ORC_CLAMP_SL(x) ORC_CLAMP(x,ORC_SL_MIN,ORC_SL_MAX)
-#define ORC_CLAMP_UL(x) ORC_CLAMP(x,ORC_UL_MIN,ORC_UL_MAX)
-#define ORC_SWAP_W(x) ((((x)&0xff)<<8) | (((x)&0xff00)>>8))
-#define ORC_SWAP_L(x) ((((x)&0xff)<<24) | (((x)&0xff00)<<8) | (((x)&0xff0000)>>8) | (((x)&0xff000000)>>24))
-#define ORC_SWAP_Q(x) ((((x)&ORC_UINT64_C(0xff))<<56) | (((x)&ORC_UINT64_C(0xff00))<<40) | (((x)&ORC_UINT64_C(0xff0000))<<24) | (((x)&ORC_UINT64_C(0xff000000))<<8) | (((x)&ORC_UINT64_C(0xff00000000))>>8) | (((x)&ORC_UINT64_C(0xff0000000000))>>24) | (((x)&ORC_UINT64_C(0xff000000000000))>>40) | (((x)&ORC_UINT64_C(0xff00000000000000))>>56))
-#define ORC_PTR_OFFSET(ptr,offset) ((void *)(((unsigned char *)(ptr)) + (offset)))
-#define ORC_DENORMAL(x) ((x) & ((((x)&0x7f800000) == 0) ? 0xff800000 : 0xffffffff))
-#define ORC_ISNAN(x) ((((x)&0x7f800000) == 0x7f800000) && (((x)&0x007fffff) != 0))
-#define ORC_DENORMAL_DOUBLE(x) ((x) & ((((x)&ORC_UINT64_C(0x7ff0000000000000)) == 0) ? ORC_UINT64_C(0xfff0000000000000) : ORC_UINT64_C(0xffffffffffffffff)))
-#define ORC_ISNAN_DOUBLE(x) ((((x)&ORC_UINT64_C(0x7ff0000000000000)) == ORC_UINT64_C(0x7ff0000000000000)) && (((x)&ORC_UINT64_C(0x000fffffffffffff)) != 0))
-#ifndef ORC_RESTRICT
-#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-#define ORC_RESTRICT restrict
-#elif defined(__GNUC__) && __GNUC__ >= 4
-#define ORC_RESTRICT __restrict__
-#else
-#define ORC_RESTRICT
-#endif
-#endif
-/* end Orc C target preamble */
-
-
-/* cogorc_memcpy_2d */
-static void
-_backup_cogorc_memcpy_2d (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  orc_int8 var32;
-  orc_int8 var33;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadb */
-      var32 = ptr4[i];
-      /* 1: copyb */
-      var33 = var32;
-      /* 2: storeb */
-      ptr0[i] = var33;
-    }
-  }
-
-}
-
-/* cogorc_downsample_horiz_cosite_1tap */
-static void
-_backup_cogorc_downsample_horiz_cosite_1tap (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  orc_union16 var32;
-  orc_int8 var33;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union16 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadw */
-    var32 = ptr4[i];
-    /* 1: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var32.i;
-       var33 = _src.x2[0];
-    }
-    /* 2: storeb */
-    ptr0[i] = var33;
-  }
-
-}
-
-/* cogorc_downsample_horiz_cosite_3tap */
-static void
-_backup_cogorc_downsample_horiz_cosite_3tap (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_union16 * ORC_RESTRICT ptr5;
-  orc_union16 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-  orc_union16 var41;
-  orc_int8 var42;
-  orc_union16 var43;
-  orc_int8 var44;
-  orc_int8 var45;
-  orc_int8 var46;
-  orc_union16 var47;
-  orc_union16 var48;
-  orc_union16 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union16 *)ex->arrays[4];
-  ptr5 = (orc_union16 *)ex->arrays[5];
-
-    /* 9: loadpw */
-    var40.i = (int)0x00000002; /* 2 or 9.88131e-324f */
-    /* 13: loadpw */
-    var41.i = (int)0x00000002; /* 2 or 9.88131e-324f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadw */
-    var38 = ptr4[i];
-    /* 1: copyw */
-    var43.i = var38.i;
-    /* 2: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var43.i;
-       var44 = _src.x2[0];
-    }
-    /* 3: select1wb */
-    {
-       orc_union16 _src;
-       _src.i = var43.i;
-       var45 = _src.x2[1];
-    }
-    /* 4: loadw */
-    var39 = ptr5[i];
-    /* 5: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var39.i;
-       var46 = _src.x2[0];
-    }
-    /* 6: convubw */
-    var47.i = (orc_uint8)var44;
-    /* 7: convubw */
-    var48.i = (orc_uint8)var45;
-    /* 8: convubw */
-    var49.i = (orc_uint8)var46;
-    /* 10: mullw */
-    var50.i = (var48.i * var40.i) & 0xffff;
-    /* 11: addw */
-    var51.i = var47.i + var49.i;
-    /* 12: addw */
-    var52.i = var51.i + var50.i;
-    /* 14: addw */
-    var53.i = var52.i + var41.i;
-    /* 15: shrsw */
-    var54.i = var53.i >> 2;
-    /* 16: convsuswb */
-    var42 = ORC_CLAMP_UB(var54.i);
-    /* 17: storeb */
-    ptr0[i] = var42;
-  }
-
-}
-
-/* cogorc_downsample_420_jpeg */
-static void
-_backup_cogorc_downsample_420_jpeg (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_union16 * ORC_RESTRICT ptr5;
-  orc_union16 var37;
-  orc_union16 var38;
-  orc_int8 var39;
-  orc_union16 var40;
-  orc_int8 var41;
-  orc_int8 var42;
-  orc_int8 var43;
-  orc_union16 var44;
-  orc_int8 var45;
-  orc_int8 var46;
-  orc_int8 var47;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union16 *)ex->arrays[4];
-  ptr5 = (orc_union16 *)ex->arrays[5];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadw */
-    var37 = ptr4[i];
-    /* 1: copyw */
-    var40.i = var37.i;
-    /* 2: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var40.i;
-       var41 = _src.x2[0];
-    }
-    /* 3: select1wb */
-    {
-       orc_union16 _src;
-       _src.i = var40.i;
-       var42 = _src.x2[1];
-    }
-    /* 4: avgub */
-    var43 = ((orc_uint8)var41 + (orc_uint8)var42 + 1)>>1;
-    /* 5: loadw */
-    var38 = ptr5[i];
-    /* 6: copyw */
-    var44.i = var38.i;
-    /* 7: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var44.i;
-       var45 = _src.x2[0];
-    }
-    /* 8: select1wb */
-    {
-       orc_union16 _src;
-       _src.i = var44.i;
-       var46 = _src.x2[1];
-    }
-    /* 9: avgub */
-    var47 = ((orc_uint8)var45 + (orc_uint8)var46 + 1)>>1;
-    /* 10: avgub */
-    var39 = ((orc_uint8)var43 + (orc_uint8)var47 + 1)>>1;
-    /* 11: storeb */
-    ptr0[i] = var39;
-  }
-
-}
-
-/* cogorc_downsample_vert_halfsite_2tap */
-static void
-_backup_cogorc_downsample_vert_halfsite_2tap (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  orc_int8 var32;
-  orc_int8 var33;
-  orc_int8 var34;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var32 = ptr4[i];
-    /* 1: loadb */
-    var33 = ptr5[i];
-    /* 2: avgub */
-    var34 = ((orc_uint8)var32 + (orc_uint8)var33 + 1)>>1;
-    /* 3: storeb */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* cogorc_downsample_vert_cosite_3tap */
-static void
-_backup_cogorc_downsample_vert_cosite_3tap (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var35;
-  orc_int8 var36;
-  orc_int8 var37;
-  orc_union16 var38;
-  orc_union16 var39;
-  orc_int8 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-  orc_union16 var46;
-  orc_union16 var47;
-  orc_union16 var48;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-
-    /* 6: loadpw */
-    var38.i = (int)0x00000002; /* 2 or 9.88131e-324f */
-    /* 10: loadpw */
-    var39.i = (int)0x00000002; /* 2 or 9.88131e-324f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var35 = ptr4[i];
-    /* 1: convubw */
-    var41.i = (orc_uint8)var35;
-    /* 2: loadb */
-    var36 = ptr5[i];
-    /* 3: convubw */
-    var42.i = (orc_uint8)var36;
-    /* 4: loadb */
-    var37 = ptr6[i];
-    /* 5: convubw */
-    var43.i = (orc_uint8)var37;
-    /* 7: mullw */
-    var44.i = (var42.i * var38.i) & 0xffff;
-    /* 8: addw */
-    var45.i = var41.i + var43.i;
-    /* 9: addw */
-    var46.i = var45.i + var44.i;
-    /* 11: addw */
-    var47.i = var46.i + var39.i;
-    /* 12: shrsw */
-    var48.i = var47.i >> 2;
-    /* 13: convsuswb */
-    var40 = ORC_CLAMP_UB(var48.i);
-    /* 14: storeb */
-    ptr0[i] = var40;
-  }
-
-}
-
-/* cogorc_downsample_vert_halfsite_4tap */
-static void
-_backup_cogorc_downsample_vert_halfsite_4tap (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  const orc_int8 * ORC_RESTRICT ptr7;
-  orc_int8 var36;
-  orc_int8 var37;
-  orc_int8 var38;
-  orc_int8 var39;
-  orc_union16 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_int8 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-  orc_union16 var46;
-  orc_union16 var47;
-  orc_union16 var48;
-  orc_union16 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-  ptr7 = (orc_int8 *)ex->arrays[7];
-
-    /* 9: loadpw */
-    var40.i = (int)0x0000001a; /* 26 or 1.28457e-322f */
-    /* 12: loadpw */
-    var41.i = (int)0x00000006; /* 6 or 2.96439e-323f */
-    /* 15: loadpw */
-    var42.i = (int)0x00000020; /* 32 or 1.58101e-322f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var36 = ptr4[i];
-    /* 1: convubw */
-    var44.i = (orc_uint8)var36;
-    /* 2: loadb */
-    var37 = ptr5[i];
-    /* 3: convubw */
-    var45.i = (orc_uint8)var37;
-    /* 4: loadb */
-    var38 = ptr6[i];
-    /* 5: convubw */
-    var46.i = (orc_uint8)var38;
-    /* 6: loadb */
-    var39 = ptr7[i];
-    /* 7: convubw */
-    var47.i = (orc_uint8)var39;
-    /* 8: addw */
-    var48.i = var45.i + var46.i;
-    /* 10: mullw */
-    var49.i = (var48.i * var40.i) & 0xffff;
-    /* 11: addw */
-    var50.i = var44.i + var47.i;
-    /* 13: mullw */
-    var51.i = (var50.i * var41.i) & 0xffff;
-    /* 14: addw */
-    var52.i = var49.i + var51.i;
-    /* 16: addw */
-    var53.i = var52.i + var42.i;
-    /* 17: shrsw */
-    var54.i = var53.i >> 6;
-    /* 18: convsuswb */
-    var43 = ORC_CLAMP_UB(var54.i);
-    /* 19: storeb */
-    ptr0[i] = var43;
-  }
-
-}
-
-/* cogorc_upsample_horiz_cosite_1tap */
-static void
-_backup_cogorc_upsample_horiz_cosite_1tap (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union16 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  orc_int8 var33;
-  orc_union16 var34;
-  orc_int8 var35;
-
-  ptr0 = (orc_union16 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var33 = ptr4[i];
-    /* 1: copyb */
-    var35 = var33;
-    /* 2: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var35;
-       _dest.x2[1] = var35;
-       var34.i = _dest.i;
-    }
-    /* 3: storew */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* cogorc_upsample_horiz_cosite */
-static void
-_backup_cogorc_upsample_horiz_cosite (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union16 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  orc_int8 var34;
-  orc_int8 var35;
-  orc_union16 var36;
-  orc_int8 var37;
-  orc_int8 var38;
-
-  ptr0 = (orc_union16 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var34 = ptr4[i];
-    /* 1: copyb */
-    var37 = var34;
-    /* 2: loadb */
-    var35 = ptr5[i];
-    /* 3: avgub */
-    var38 = ((orc_uint8)var37 + (orc_uint8)var35 + 1)>>1;
-    /* 4: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var37;
-       _dest.x2[1] = var38;
-       var36.i = _dest.i;
-    }
-    /* 5: storew */
-    ptr0[i] = var36;
-  }
-
-}
-
-/* cogorc_upsample_vert_avgub */
-static void
-_backup_cogorc_upsample_vert_avgub (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  orc_int8 var32;
-  orc_int8 var33;
-  orc_int8 var34;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var32 = ptr4[i];
-    /* 1: loadb */
-    var33 = ptr5[i];
-    /* 2: avgub */
-    var34 = ((orc_uint8)var32 + (orc_uint8)var33 + 1)>>1;
-    /* 3: storeb */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* orc_unpack_yuyv_y */
-static void
-_backup_orc_unpack_yuyv_y (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  orc_union16 var32;
-  orc_int8 var33;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union16 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadw */
-    var32 = ptr4[i];
-    /* 1: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var32.i;
-       var33 = _src.x2[0];
-    }
-    /* 2: storeb */
-    ptr0[i] = var33;
-  }
-
-}
-
-/* orc_unpack_yuyv_u */
-static void
-_backup_orc_unpack_yuyv_u (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union32 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadl */
-    var33 = ptr4[i];
-    /* 1: select0lw */
-    {
-       orc_union32 _src;
-       _src.i = var33.i;
-       var35.i = _src.x2[0];
-    }
-    /* 2: select1wb */
-    {
-       orc_union16 _src;
-       _src.i = var35.i;
-       var34 = _src.x2[1];
-    }
-    /* 3: storeb */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* orc_unpack_yuyv_v */
-static void
-_backup_orc_unpack_yuyv_v (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union32 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadl */
-    var33 = ptr4[i];
-    /* 1: select1lw */
-    {
-       orc_union32 _src;
-       _src.i = var33.i;
-       var35.i = _src.x2[1];
-    }
-    /* 2: select1wb */
-    {
-       orc_union16 _src;
-       _src.i = var35.i;
-       var34 = _src.x2[1];
-    }
-    /* 3: storeb */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* orc_pack_yuyv */
-static void
-_backup_orc_pack_yuyv (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_union16 var37;
-  orc_int8 var38;
-  orc_int8 var39;
-  orc_union32 var40;
-  orc_union16 var41;
-  orc_int8 var42;
-  orc_int8 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-
-  ptr0 = (orc_union32 *)ex->arrays[0];
-  ptr4 = (orc_union16 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadw */
-    var37 = ptr4[i];
-    /* 1: copyw */
-    var41.i = var37.i;
-    /* 2: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var41.i;
-       var42 = _src.x2[0];
-    }
-    /* 3: select1wb */
-    {
-       orc_union16 _src;
-       _src.i = var41.i;
-       var43 = _src.x2[1];
-    }
-    /* 4: loadb */
-    var38 = ptr5[i];
-    /* 5: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var42;
-       _dest.x2[1] = var38;
-       var44.i = _dest.i;
-    }
-    /* 6: loadb */
-    var39 = ptr6[i];
-    /* 7: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var43;
-       _dest.x2[1] = var39;
-       var45.i = _dest.i;
-    }
-    /* 8: mergewl */
-    {
-       orc_union32 _dest;
-       _dest.x2[0] = var44.i;
-       _dest.x2[1] = var45.i;
-       var40.i = _dest.i;
-    }
-    /* 9: storel */
-    ptr0[i] = var40;
-  }
-
-}
-
-/* orc_unpack_uyvy_y */
-static void
-_backup_orc_unpack_uyvy_y (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  orc_union16 var32;
-  orc_int8 var33;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union16 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadw */
-    var32 = ptr4[i];
-    /* 1: select1wb */
-    {
-       orc_union16 _src;
-       _src.i = var32.i;
-       var33 = _src.x2[1];
-    }
-    /* 2: storeb */
-    ptr0[i] = var33;
-  }
-
-}
-
-/* orc_unpack_uyvy_u */
-static void
-_backup_orc_unpack_uyvy_u (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union32 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadl */
-    var33 = ptr4[i];
-    /* 1: select0lw */
-    {
-       orc_union32 _src;
-       _src.i = var33.i;
-       var35.i = _src.x2[0];
-    }
-    /* 2: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var35.i;
-       var34 = _src.x2[0];
-    }
-    /* 3: storeb */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* orc_unpack_uyvy_v */
-static void
-_backup_orc_unpack_uyvy_v (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union32 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadl */
-    var33 = ptr4[i];
-    /* 1: select1lw */
-    {
-       orc_union32 _src;
-       _src.i = var33.i;
-       var35.i = _src.x2[1];
-    }
-    /* 2: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var35.i;
-       var34 = _src.x2[0];
-    }
-    /* 3: storeb */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* orc_pack_uyvy */
-static void
-_backup_orc_pack_uyvy (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_union16 var37;
-  orc_int8 var38;
-  orc_int8 var39;
-  orc_union32 var40;
-  orc_union16 var41;
-  orc_int8 var42;
-  orc_int8 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-
-  ptr0 = (orc_union32 *)ex->arrays[0];
-  ptr4 = (orc_union16 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadw */
-    var37 = ptr4[i];
-    /* 1: copyw */
-    var41.i = var37.i;
-    /* 2: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var41.i;
-       var42 = _src.x2[0];
-    }
-    /* 3: select1wb */
-    {
-       orc_union16 _src;
-       _src.i = var41.i;
-       var43 = _src.x2[1];
-    }
-    /* 4: loadb */
-    var38 = ptr5[i];
-    /* 5: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var38;
-       _dest.x2[1] = var42;
-       var44.i = _dest.i;
-    }
-    /* 6: loadb */
-    var39 = ptr6[i];
-    /* 7: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var39;
-       _dest.x2[1] = var43;
-       var45.i = _dest.i;
-    }
-    /* 8: mergewl */
-    {
-       orc_union32 _dest;
-       _dest.x2[0] = var44.i;
-       _dest.x2[1] = var45.i;
-       var40.i = _dest.i;
-    }
-    /* 9: storel */
-    ptr0[i] = var40;
-  }
-
-}
-
-/* orc_addc_convert_u8_s16 */
-static void
-_backup_orc_addc_convert_u8_s16 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  orc_union16 var33;
-  orc_union16 var34;
-  orc_int8 var35;
-  orc_union16 var36;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union16 *)ex->arrays[4];
-
-    /* 1: loadpw */
-    var34.i = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadw */
-    var33 = ptr4[i];
-    /* 2: addw */
-    var36.i = var33.i + var34.i;
-    /* 3: convsuswb */
-    var35 = ORC_CLAMP_UB(var36.i);
-    /* 4: storeb */
-    ptr0[i] = var35;
-  }
-
-}
-
-/* orc_subc_convert_s16_u8 */
-static void
-_backup_orc_subc_convert_s16_u8 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union16 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  orc_int8 var33;
-  orc_union16 var34;
-  orc_union16 var35;
-  orc_union16 var36;
-
-  ptr0 = (orc_union16 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-
-    /* 2: loadpw */
-    var34.i = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var33 = ptr4[i];
-    /* 1: convubw */
-    var36.i = (orc_uint8)var33;
-    /* 3: subw */
-    var35.i = var36.i - var34.i;
-    /* 4: storew */
-    ptr0[i] = var35;
-  }
-
-}
-
-/* orc_splat_u8_ns */
-static void
-_backup_orc_splat_u8_ns (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  orc_int8 var32;
-  orc_int8 var33;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-
-    /* 0: loadpb */
-    var32 = ex->params[24];
-
-  for (i = 0; i < n; i++) {
-    /* 1: copyb */
-    var33 = var32;
-    /* 2: storeb */
-    ptr0[i] = var33;
-  }
-
-}
-
-/* orc_splat_s16_ns */
-static void
-_backup_orc_splat_s16_ns (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union16 * ORC_RESTRICT ptr0;
-  orc_union16 var32;
-  orc_union16 var33;
-
-  ptr0 = (orc_union16 *)ex->arrays[0];
-
-    /* 0: loadpw */
-    var32.i = ex->params[24];
-
-  for (i = 0; i < n; i++) {
-    /* 1: copyw */
-    var33.i = var32.i;
-    /* 2: storew */
-    ptr0[i] = var33;
-  }
-
-}
-
-/* orc_matrix2_u8 */
-static void
-_backup_orc_matrix2_u8 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  orc_int8 var34;
-  orc_union16 var35;
-  orc_int8 var36;
-  orc_union16 var37;
-  orc_union16 var38;
-  orc_int8 var39;
-  orc_union16 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-  orc_union16 var46;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-
-    /* 2: loadpw */
-    var35.i = ex->params[24];
-    /* 6: loadpw */
-    var37.i = ex->params[25];
-    /* 9: loadpw */
-    var38.i = ex->params[26];
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var34 = ptr4[i];
-    /* 1: convubw */
-    var40.i = (orc_uint8)var34;
-    /* 3: mullw */
-    var41.i = (var40.i * var35.i) & 0xffff;
-    /* 4: loadb */
-    var36 = ptr5[i];
-    /* 5: convubw */
-    var42.i = (orc_uint8)var36;
-    /* 7: mullw */
-    var43.i = (var42.i * var37.i) & 0xffff;
-    /* 8: addw */
-    var44.i = var41.i + var43.i;
-    /* 10: addw */
-    var45.i = var44.i + var38.i;
-    /* 11: shrsw */
-    var46.i = var45.i >> 6;
-    /* 12: convsuswb */
-    var39 = ORC_CLAMP_UB(var46.i);
-    /* 13: storeb */
-    ptr0[i] = var39;
-  }
-
-}
-
-/* orc_matrix2_11_u8 */
-static void
-_backup_orc_matrix2_11_u8 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  orc_int8 var36;
-  orc_union16 var37;
-  orc_union16 var38;
-  orc_int8 var39;
-  orc_union16 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_int8 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-  orc_union16 var46;
-  orc_union16 var47;
-  orc_union16 var48;
-  orc_union16 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-
-    /* 2: loadpw */
-    var37.i = (int)0x00000010; /* 16 or 7.90505e-323f */
-    /* 4: loadpw */
-    var38.i = ex->params[24];
-    /* 8: loadpw */
-    var40.i = (int)0x00000080; /* 128 or 6.32404e-322f */
-    /* 10: loadpw */
-    var41.i = ex->params[25];
-    /* 13: loadpw */
-    var42.i = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var36 = ptr4[i];
-    /* 1: convubw */
-    var44.i = (orc_uint8)var36;
-    /* 3: subw */
-    var45.i = var44.i - var37.i;
-    /* 5: mullw */
-    var46.i = (var45.i * var38.i) & 0xffff;
-    /* 6: loadb */
-    var39 = ptr5[i];
-    /* 7: convubw */
-    var47.i = (orc_uint8)var39;
-    /* 9: subw */
-    var48.i = var47.i - var40.i;
-    /* 11: mullw */
-    var49.i = (var48.i * var41.i) & 0xffff;
-    /* 12: addw */
-    var50.i = var46.i + var49.i;
-    /* 14: addw */
-    var51.i = var50.i + var42.i;
-    /* 15: shrsw */
-    var52.i = var51.i >> 8;
-    /* 16: addw */
-    var53.i = var52.i + var45.i;
-    /* 17: addw */
-    var54.i = var53.i + var48.i;
-    /* 18: convsuswb */
-    var43 = ORC_CLAMP_UB(var54.i);
-    /* 19: storeb */
-    ptr0[i] = var43;
-  }
-
-}
-
-/* orc_matrix2_12_u8 */
-static void
-_backup_orc_matrix2_12_u8 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  orc_int8 var36;
-  orc_union16 var37;
-  orc_union16 var38;
-  orc_int8 var39;
-  orc_union16 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_int8 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-  orc_union16 var46;
-  orc_union16 var47;
-  orc_union16 var48;
-  orc_union16 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-  orc_union16 var55;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-
-    /* 2: loadpw */
-    var37.i = (int)0x00000010; /* 16 or 7.90505e-323f */
-    /* 4: loadpw */
-    var38.i = ex->params[24];
-    /* 8: loadpw */
-    var40.i = (int)0x00000080; /* 128 or 6.32404e-322f */
-    /* 10: loadpw */
-    var41.i = ex->params[25];
-    /* 13: loadpw */
-    var42.i = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var36 = ptr4[i];
-    /* 1: convubw */
-    var44.i = (orc_uint8)var36;
-    /* 3: subw */
-    var45.i = var44.i - var37.i;
-    /* 5: mullw */
-    var46.i = (var45.i * var38.i) & 0xffff;
-    /* 6: loadb */
-    var39 = ptr5[i];
-    /* 7: convubw */
-    var47.i = (orc_uint8)var39;
-    /* 9: subw */
-    var48.i = var47.i - var40.i;
-    /* 11: mullw */
-    var49.i = (var48.i * var41.i) & 0xffff;
-    /* 12: addw */
-    var50.i = var46.i + var49.i;
-    /* 14: addw */
-    var51.i = var50.i + var42.i;
-    /* 15: shrsw */
-    var52.i = var51.i >> 8;
-    /* 16: addw */
-    var53.i = var52.i + var45.i;
-    /* 17: addw */
-    var54.i = var53.i + var48.i;
-    /* 18: addw */
-    var55.i = var54.i + var48.i;
-    /* 19: convsuswb */
-    var43 = ORC_CLAMP_UB(var55.i);
-    /* 20: storeb */
-    ptr0[i] = var43;
-  }
-
-}
-
-/* orc_matrix3_u8 */
-static void
-_backup_orc_matrix3_u8 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var34;
-  orc_union16 var35;
-  orc_int8 var36;
-  orc_union16 var37;
-  orc_int8 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-  orc_int8 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-  orc_union16 var46;
-  orc_union16 var47;
-  orc_union16 var48;
-  orc_union16 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-
-    /* 2: loadpw */
-    var35.i = ex->params[24];
-    /* 6: loadpw */
-    var37.i = ex->params[25];
-    /* 11: loadpw */
-    var39.i = ex->params[26];
-    /* 14: loadpw */
-    var40.i = ex->params[27];
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var34 = ptr4[i];
-    /* 1: convubw */
-    var42.i = (orc_uint8)var34;
-    /* 3: mullw */
-    var43.i = (var42.i * var35.i) & 0xffff;
-    /* 4: loadb */
-    var36 = ptr5[i];
-    /* 5: convubw */
-    var44.i = (orc_uint8)var36;
-    /* 7: mullw */
-    var45.i = (var44.i * var37.i) & 0xffff;
-    /* 8: addw */
-    var46.i = var43.i + var45.i;
-    /* 9: loadb */
-    var38 = ptr6[i];
-    /* 10: convubw */
-    var47.i = (orc_uint8)var38;
-    /* 12: mullw */
-    var48.i = (var47.i * var39.i) & 0xffff;
-    /* 13: addw */
-    var49.i = var46.i + var48.i;
-    /* 15: addw */
-    var50.i = var49.i + var40.i;
-    /* 16: shrsw */
-    var51.i = var50.i >> 6;
-    /* 17: convsuswb */
-    var41 = ORC_CLAMP_UB(var51.i);
-    /* 18: storeb */
-    ptr0[i] = var41;
-  }
-
-}
-
-/* orc_matrix3_100_u8 */
-static void
-_backup_orc_matrix3_100_u8 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var35;
-  orc_union16 var36;
-  orc_union16 var37;
-  orc_int8 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-  orc_int8 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-  orc_union16 var44;
-  orc_int8 var45;
-  orc_union16 var46;
-  orc_union16 var47;
-  orc_union16 var48;
-  orc_union16 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-  orc_union16 var55;
-  orc_union16 var56;
-  orc_union16 var57;
-  orc_union16 var58;
-  orc_union16 var59;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-
-    /* 2: loadpw */
-    var36.i = (int)0x00000010; /* 16 or 7.90505e-323f */
-    /* 4: loadpw */
-    var37.i = ex->params[24];
-    /* 8: loadpw */
-    var39.i = (int)0x00000080; /* 128 or 6.32404e-322f */
-    /* 10: loadpw */
-    var40.i = ex->params[25];
-    /* 15: loadpw */
-    var42.i = (int)0x00000080; /* 128 or 6.32404e-322f */
-    /* 17: loadpw */
-    var43.i = ex->params[26];
-    /* 20: loadpw */
-    var44.i = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var35 = ptr4[i];
-    /* 1: convubw */
-    var46.i = (orc_uint8)var35;
-    /* 3: subw */
-    var47.i = var46.i - var36.i;
-    /* 5: mullw */
-    var48.i = (var47.i * var37.i) & 0xffff;
-    /* 6: loadb */
-    var38 = ptr5[i];
-    /* 7: convubw */
-    var49.i = (orc_uint8)var38;
-    /* 9: subw */
-    var50.i = var49.i - var39.i;
-    /* 11: mullw */
-    var51.i = (var50.i * var40.i) & 0xffff;
-    /* 12: addw */
-    var52.i = var48.i + var51.i;
-    /* 13: loadb */
-    var41 = ptr6[i];
-    /* 14: convubw */
-    var53.i = (orc_uint8)var41;
-    /* 16: subw */
-    var54.i = var53.i - var42.i;
-    /* 18: mullw */
-    var55.i = (var54.i * var43.i) & 0xffff;
-    /* 19: addw */
-    var56.i = var52.i + var55.i;
-    /* 21: addw */
-    var57.i = var56.i + var44.i;
-    /* 22: shrsw */
-    var58.i = var57.i >> 8;
-    /* 23: addw */
-    var59.i = var58.i + var47.i;
-    /* 24: convsuswb */
-    var45 = ORC_CLAMP_UB(var59.i);
-    /* 25: storeb */
-    ptr0[i] = var45;
-  }
-
-}
-
-/* orc_matrix3_100_offset_u8 */
-static void
-_backup_orc_matrix3_100_offset_u8 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var35;
-  orc_union16 var36;
-  orc_int8 var37;
-  orc_union16 var38;
-  orc_int8 var39;
-  orc_union16 var40;
-  orc_union16 var41;
-  orc_int8 var42;
-  orc_union16 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-  orc_union16 var46;
-  orc_union16 var47;
-  orc_union16 var48;
-  orc_union16 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-
-    /* 2: loadpw */
-    var36.i = ex->params[24];
-    /* 6: loadpw */
-    var38.i = ex->params[25];
-    /* 11: loadpw */
-    var40.i = ex->params[26];
-    /* 14: loadpw */
-    var41.i = ex->params[27];
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var35 = ptr4[i];
-    /* 1: convubw */
-    var43.i = (orc_uint8)var35;
-    /* 3: mullw */
-    var44.i = (var43.i * var36.i) & 0xffff;
-    /* 4: loadb */
-    var37 = ptr5[i];
-    /* 5: convubw */
-    var45.i = (orc_uint8)var37;
-    /* 7: mullw */
-    var46.i = (var45.i * var38.i) & 0xffff;
-    /* 8: addw */
-    var47.i = var44.i + var46.i;
-    /* 9: loadb */
-    var39 = ptr6[i];
-    /* 10: convubw */
-    var48.i = (orc_uint8)var39;
-    /* 12: mullw */
-    var49.i = (var48.i * var40.i) & 0xffff;
-    /* 13: addw */
-    var50.i = var47.i + var49.i;
-    /* 15: addw */
-    var51.i = var50.i + var41.i;
-    /* 16: shrsw */
-    var52.i = var51.i >> ex->params[28];
-    /* 17: addw */
-    var53.i = var52.i + var43.i;
-    /* 18: convsuswb */
-    var42 = ORC_CLAMP_UB(var53.i);
-    /* 19: storeb */
-    ptr0[i] = var42;
-  }
-
-}
-
-/* orc_matrix3_000_u8 */
-static void
-_backup_orc_matrix3_000_u8 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var34;
-  orc_union16 var35;
-  orc_int8 var36;
-  orc_union16 var37;
-  orc_int8 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-  orc_int8 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-  orc_union16 var46;
-  orc_union16 var47;
-  orc_union16 var48;
-  orc_union16 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-
-    /* 2: loadpw */
-    var35.i = ex->params[24];
-    /* 6: loadpw */
-    var37.i = ex->params[25];
-    /* 11: loadpw */
-    var39.i = ex->params[26];
-    /* 14: loadpw */
-    var40.i = ex->params[27];
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var34 = ptr4[i];
-    /* 1: convubw */
-    var42.i = (orc_uint8)var34;
-    /* 3: mullw */
-    var43.i = (var42.i * var35.i) & 0xffff;
-    /* 4: loadb */
-    var36 = ptr5[i];
-    /* 5: convubw */
-    var44.i = (orc_uint8)var36;
-    /* 7: mullw */
-    var45.i = (var44.i * var37.i) & 0xffff;
-    /* 8: addw */
-    var46.i = var43.i + var45.i;
-    /* 9: loadb */
-    var38 = ptr6[i];
-    /* 10: convubw */
-    var47.i = (orc_uint8)var38;
-    /* 12: mullw */
-    var48.i = (var47.i * var39.i) & 0xffff;
-    /* 13: addw */
-    var49.i = var46.i + var48.i;
-    /* 15: addw */
-    var50.i = var49.i + var40.i;
-    /* 16: shrsw */
-    var51.i = var50.i >> ex->params[28];
-    /* 17: convwb */
-    var41 = var51.i;
-    /* 18: storeb */
-    ptr0[i] = var41;
-  }
-
-}
-
-/* orc_pack_123x */
-static void
-_backup_orc_pack_123x (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var34;
-  orc_int8 var35;
-  orc_int8 var36;
-  orc_int8 var37;
-  orc_union32 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-
-  ptr0 = (orc_union32 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-
-    /* 4: loadpb */
-    var37 = ex->params[24];
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var34 = ptr4[i];
-    /* 1: loadb */
-    var35 = ptr5[i];
-    /* 2: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var34;
-       _dest.x2[1] = var35;
-       var39.i = _dest.i;
-    }
-    /* 3: loadb */
-    var36 = ptr6[i];
-    /* 5: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var36;
-       _dest.x2[1] = var37;
-       var40.i = _dest.i;
-    }
-    /* 6: mergewl */
-    {
-       orc_union32 _dest;
-       _dest.x2[0] = var39.i;
-       _dest.x2[1] = var40.i;
-       var38.i = _dest.i;
-    }
-    /* 7: storel */
-    ptr0[i] = var38;
-  }
-
-}
-
-/* orc_pack_x123 */
-static void
-_backup_orc_pack_x123 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var34;
-  orc_int8 var35;
-  orc_int8 var36;
-  orc_int8 var37;
-  orc_union32 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-
-  ptr0 = (orc_union32 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-
-    /* 0: loadpb */
-    var34 = ex->params[24];
-
-  for (i = 0; i < n; i++) {
-    /* 1: loadb */
-    var35 = ptr4[i];
-    /* 2: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var34;
-       _dest.x2[1] = var35;
-       var39.i = _dest.i;
-    }
-    /* 3: loadb */
-    var36 = ptr5[i];
-    /* 4: loadb */
-    var37 = ptr6[i];
-    /* 5: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var36;
-       _dest.x2[1] = var37;
-       var40.i = _dest.i;
-    }
-    /* 6: mergewl */
-    {
-       orc_union32 _dest;
-       _dest.x2[0] = var39.i;
-       _dest.x2[1] = var40.i;
-       var38.i = _dest.i;
-    }
-    /* 7: storel */
-    ptr0[i] = var38;
-  }
-
-}
-
-/* cogorc_combine2_u8 */
-static void
-_backup_cogorc_combine2_u8 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  orc_int8 var34;
-  orc_union16 var35;
-  orc_int8 var36;
-  orc_union16 var37;
-  orc_int8 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-  orc_union16 var44;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-
-    /* 2: loadpw */
-    var35.i = ex->params[24];
-    /* 6: loadpw */
-    var37.i = ex->params[25];
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var34 = ptr4[i];
-    /* 1: convubw */
-    var39.i = (orc_uint8)var34;
-    /* 3: mullw */
-    var40.i = (var39.i * var35.i) & 0xffff;
-    /* 4: loadb */
-    var36 = ptr5[i];
-    /* 5: convubw */
-    var41.i = (orc_uint8)var36;
-    /* 7: mullw */
-    var42.i = (var41.i * var37.i) & 0xffff;
-    /* 8: addw */
-    var43.i = var40.i + var42.i;
-    /* 9: shruw */
-    var44.i = ((orc_uint16)var43.i) >> 8;
-    /* 10: convsuswb */
-    var38 = ORC_CLAMP_UB(var44.i);
-    /* 11: storeb */
-    ptr0[i] = var38;
-  }
-
-}
-
-/* cogorc_combine4_u8 */
-static void
-_backup_cogorc_combine4_u8 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  const orc_int8 * ORC_RESTRICT ptr7;
-  orc_int8 var34;
-  orc_union16 var35;
-  orc_int8 var36;
-  orc_union16 var37;
-  orc_int8 var38;
-  orc_union16 var39;
-  orc_int8 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_int8 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-  orc_union16 var46;
-  orc_union16 var47;
-  orc_union16 var48;
-  orc_union16 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-  orc_union16 var55;
-  orc_union16 var56;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-  ptr7 = (orc_int8 *)ex->arrays[7];
-
-    /* 2: loadpw */
-    var35.i = ex->params[24];
-    /* 6: loadpw */
-    var37.i = ex->params[25];
-    /* 11: loadpw */
-    var39.i = ex->params[26];
-    /* 16: loadpw */
-    var41.i = ex->params[27];
-    /* 19: loadpw */
-    var42.i = (int)0x00000020; /* 32 or 1.58101e-322f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var34 = ptr4[i];
-    /* 1: convubw */
-    var44.i = (orc_uint8)var34;
-    /* 3: mullw */
-    var45.i = (var44.i * var35.i) & 0xffff;
-    /* 4: loadb */
-    var36 = ptr5[i];
-    /* 5: convubw */
-    var46.i = (orc_uint8)var36;
-    /* 7: mullw */
-    var47.i = (var46.i * var37.i) & 0xffff;
-    /* 8: addw */
-    var48.i = var45.i + var47.i;
-    /* 9: loadb */
-    var38 = ptr6[i];
-    /* 10: convubw */
-    var49.i = (orc_uint8)var38;
-    /* 12: mullw */
-    var50.i = (var49.i * var39.i) & 0xffff;
-    /* 13: addw */
-    var51.i = var48.i + var50.i;
-    /* 14: loadb */
-    var40 = ptr7[i];
-    /* 15: convubw */
-    var52.i = (orc_uint8)var40;
-    /* 17: mullw */
-    var53.i = (var52.i * var41.i) & 0xffff;
-    /* 18: addw */
-    var54.i = var51.i + var53.i;
-    /* 20: addw */
-    var55.i = var54.i + var42.i;
-    /* 21: shrsw */
-    var56.i = var55.i >> 6;
-    /* 22: convsuswb */
-    var43 = ORC_CLAMP_UB(var56.i);
-    /* 23: storeb */
-    ptr0[i] = var43;
-  }
-
-}
-
-/* cogorc_unpack_axyz_0 */
-static void
-_backup_cogorc_unpack_axyz_0 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union32 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadl */
-    var33 = ptr4[i];
-    /* 1: select0lw */
-    {
-       orc_union32 _src;
-       _src.i = var33.i;
-       var35.i = _src.x2[0];
-    }
-    /* 2: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var35.i;
-       var34 = _src.x2[0];
-    }
-    /* 3: storeb */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* cogorc_unpack_axyz_1 */
-static void
-_backup_cogorc_unpack_axyz_1 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union32 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadl */
-    var33 = ptr4[i];
-    /* 1: select0lw */
-    {
-       orc_union32 _src;
-       _src.i = var33.i;
-       var35.i = _src.x2[0];
-    }
-    /* 2: select1wb */
-    {
-       orc_union16 _src;
-       _src.i = var35.i;
-       var34 = _src.x2[1];
-    }
-    /* 3: storeb */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* cogorc_unpack_axyz_2 */
-static void
-_backup_cogorc_unpack_axyz_2 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union32 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadl */
-    var33 = ptr4[i];
-    /* 1: select1lw */
-    {
-       orc_union32 _src;
-       _src.i = var33.i;
-       var35.i = _src.x2[1];
-    }
-    /* 2: select0wb */
-    {
-       orc_union16 _src;
-       _src.i = var35.i;
-       var34 = _src.x2[0];
-    }
-    /* 3: storeb */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* cogorc_unpack_axyz_3 */
-static void
-_backup_cogorc_unpack_axyz_3 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_union32 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadl */
-    var33 = ptr4[i];
-    /* 1: select1lw */
-    {
-       orc_union32 _src;
-       _src.i = var33.i;
-       var35.i = _src.x2[1];
-    }
-    /* 2: select1wb */
-    {
-       orc_union16 _src;
-       _src.i = var35.i;
-       var34 = _src.x2[1];
-    }
-    /* 3: storeb */
-    ptr0[i] = var34;
-  }
-
-}
-
-/* cogorc_resample_horiz_1tap */
-static void
-_backup_cogorc_resample_horiz_1tap (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  orc_int8 var32;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: ldresnearb */
-    var32 = ptr4[(ex->params[24] + i*ex->params[25])>>16];
-    /* 1: storeb */
-    ptr0[i] = var32;
-  }
-
-}
-
-/* cogorc_resample_horiz_2tap */
-static void
-_backup_cogorc_resample_horiz_2tap (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  orc_int8 var32;
-
-  ptr0 = (orc_int8 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: ldreslinb */
-    {
-    int tmp = ex->params[24] + i * ex->params[25];
-    var32 = ((orc_uint8)ptr4[tmp>>16] * (256-((tmp>>8)&0xff)) + (orc_uint8)ptr4[(tmp>>16)+1] * ((tmp>>8)&0xff))>>8;
-    }
-    /* 1: storeb */
-    ptr0[i] = var32;
-  }
-
-}
-
-/* cogorc_convert_I420_UYVY */
-static void
-_backup_cogorc_convert_I420_UYVY (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union32 * ORC_RESTRICT ptr0;
-  orc_union32 * ORC_RESTRICT ptr1;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_union16 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  const orc_int8 * ORC_RESTRICT ptr7;
-  orc_int8 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-  orc_union32 var36;
-  orc_union16 var37;
-  orc_union32 var38;
-  orc_union16 var39;
-
-  ptr0 = (orc_union32 *)ex->arrays[0];
-  ptr1 = (orc_union32 *)ex->arrays[1];
-  ptr4 = (orc_union16 *)ex->arrays[4];
-  ptr5 = (orc_union16 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-  ptr7 = (orc_int8 *)ex->arrays[7];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var33 = ptr6[i];
-    /* 1: loadb */
-    var34 = ptr7[i];
-    /* 2: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var33;
-       _dest.x2[1] = var34;
-       var39.i = _dest.i;
-    }
-    /* 3: loadw */
-    var35 = ptr4[i];
-    /* 4: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var39.x2[0];
-       _dest.x2[1] = var35.x2[0];
-       var36.x2[0] = _dest.i;
-    }
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var39.x2[1];
-       _dest.x2[1] = var35.x2[1];
-       var36.x2[1] = _dest.i;
-    }
-    /* 5: storel */
-    ptr0[i] = var36;
-    /* 6: loadw */
-    var37 = ptr5[i];
-    /* 7: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var39.x2[0];
-       _dest.x2[1] = var37.x2[0];
-       var38.x2[0] = _dest.i;
-    }
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var39.x2[1];
-       _dest.x2[1] = var37.x2[1];
-       var38.x2[1] = _dest.i;
-    }
-    /* 8: storel */
-    ptr1[i] = var38;
-  }
-
-}
-
-/* cogorc_convert_I420_YUY2 */
-static void
-_backup_cogorc_convert_I420_YUY2 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union32 * ORC_RESTRICT ptr0;
-  orc_union32 * ORC_RESTRICT ptr1;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_union16 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  const orc_int8 * ORC_RESTRICT ptr7;
-  orc_int8 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-  orc_union32 var36;
-  orc_union16 var37;
-  orc_union32 var38;
-  orc_union16 var39;
-
-  ptr0 = (orc_union32 *)ex->arrays[0];
-  ptr1 = (orc_union32 *)ex->arrays[1];
-  ptr4 = (orc_union16 *)ex->arrays[4];
-  ptr5 = (orc_union16 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-  ptr7 = (orc_int8 *)ex->arrays[7];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var33 = ptr6[i];
-    /* 1: loadb */
-    var34 = ptr7[i];
-    /* 2: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var33;
-       _dest.x2[1] = var34;
-       var39.i = _dest.i;
-    }
-    /* 3: loadw */
-    var35 = ptr4[i];
-    /* 4: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var35.x2[0];
-       _dest.x2[1] = var39.x2[0];
-       var36.x2[0] = _dest.i;
-    }
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var35.x2[1];
-       _dest.x2[1] = var39.x2[1];
-       var36.x2[1] = _dest.i;
-    }
-    /* 5: storel */
-    ptr0[i] = var36;
-    /* 6: loadw */
-    var37 = ptr5[i];
-    /* 7: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var37.x2[0];
-       _dest.x2[1] = var39.x2[0];
-       var38.x2[0] = _dest.i;
-    }
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var37.x2[1];
-       _dest.x2[1] = var39.x2[1];
-       var38.x2[1] = _dest.i;
-    }
-    /* 8: storel */
-    ptr1[i] = var38;
-  }
-
-}
-
-/* cogorc_convert_I420_AYUV */
-static void
-_backup_cogorc_convert_I420_AYUV (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union32 * ORC_RESTRICT ptr0;
-  orc_union32 * ORC_RESTRICT ptr1;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  const orc_int8 * ORC_RESTRICT ptr7;
-  orc_int8 var36;
-  orc_int8 var37;
-  orc_union32 var38;
-  orc_int8 var39;
-  orc_int8 var40;
-  orc_union32 var41;
-  orc_int8 var42;
-  orc_int8 var43;
-  orc_union16 var44;
-  orc_union16 var45;
-  orc_union16 var46;
-
-  ptr0 = (orc_union32 *)ex->arrays[0];
-  ptr1 = (orc_union32 *)ex->arrays[1];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-  ptr7 = (orc_int8 *)ex->arrays[7];
-
-    /* 3: loadpb */
-    var36 = (int)0x000000ff; /* 255 or 1.25987e-321f */
-    /* 8: loadpb */
-    var39 = (int)0x000000ff; /* 255 or 1.25987e-321f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadupdb */
-    var42 = ptr6[i>>1];
-    /* 1: loadupdb */
-    var43 = ptr7[i>>1];
-    /* 2: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var42;
-       _dest.x2[1] = var43;
-       var44.i = _dest.i;
-    }
-    /* 4: loadb */
-    var37 = ptr4[i];
-    /* 5: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var36;
-       _dest.x2[1] = var37;
-       var45.i = _dest.i;
-    }
-    /* 6: mergewl */
-    {
-       orc_union32 _dest;
-       _dest.x2[0] = var45.i;
-       _dest.x2[1] = var44.i;
-       var38.i = _dest.i;
-    }
-    /* 7: storel */
-    ptr0[i] = var38;
-    /* 9: loadb */
-    var40 = ptr5[i];
-    /* 10: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var39;
-       _dest.x2[1] = var40;
-       var46.i = _dest.i;
-    }
-    /* 11: mergewl */
-    {
-       orc_union32 _dest;
-       _dest.x2[0] = var46.i;
-       _dest.x2[1] = var44.i;
-       var41.i = _dest.i;
-    }
-    /* 12: storel */
-    ptr1[i] = var41;
-  }
-
-}
-
-/* cogorc_convert_YUY2_I420 */
-static void
-_backup_cogorc_convert_YUY2_I420 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union16 * ORC_RESTRICT ptr0;
-  orc_union16 * ORC_RESTRICT ptr1;
-  orc_int8 * ORC_RESTRICT ptr2;
-  orc_int8 * ORC_RESTRICT ptr3;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  const orc_union32 * ORC_RESTRICT ptr5;
-  orc_union32 var35;
-  orc_union32 var36;
-  orc_int8 var37;
-  orc_int8 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-
-  ptr0 = (orc_union16 *)ex->arrays[0];
-  ptr1 = (orc_union16 *)ex->arrays[1];
-  ptr2 = (orc_int8 *)ex->arrays[2];
-  ptr3 = (orc_int8 *)ex->arrays[3];
-  ptr4 = (orc_union32 *)ex->arrays[4];
-  ptr5 = (orc_union32 *)ex->arrays[5];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadl */
-    var35 = ptr4[i];
-    /* 1: splitwb */
-    {
-       orc_union16 _src;
-       _src.i = var35.x2[0];
-       var39.x2[0] = _src.x2[1];
-       var40.x2[0] = _src.x2[0];
-    }
-    {
-       orc_union16 _src;
-       _src.i = var35.x2[1];
-       var39.x2[1] = _src.x2[1];
-       var40.x2[1] = _src.x2[0];
-    }
-    /* 2: storew */
-    ptr0[i] = var40;
-    /* 3: loadl */
-    var36 = ptr5[i];
-    /* 4: splitwb */
-    {
-       orc_union16 _src;
-       _src.i = var36.x2[0];
-       var41.x2[0] = _src.x2[1];
-       var42.x2[0] = _src.x2[0];
-    }
-    {
-       orc_union16 _src;
-       _src.i = var36.x2[1];
-       var41.x2[1] = _src.x2[1];
-       var42.x2[1] = _src.x2[0];
-    }
-    /* 5: storew */
-    ptr1[i] = var42;
-    /* 6: avgub */
-    var43.x2[0] = ((orc_uint8)var39.x2[0] + (orc_uint8)var41.x2[0] + 1)>>1;
-    var43.x2[1] = ((orc_uint8)var39.x2[1] + (orc_uint8)var41.x2[1] + 1)>>1;
-    /* 7: splitwb */
-    {
-       orc_union16 _src;
-       _src.i = var43.i;
-       var37 = _src.x2[1];
-       var38 = _src.x2[0];
-    }
-    /* 8: storeb */
-    ptr3[i] = var37;
-    /* 9: storeb */
-    ptr2[i] = var38;
-  }
-
-}
-
-/* cogorc_convert_UYVY_YUY2 */
-static void
-_backup_cogorc_convert_UYVY_YUY2 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var32;
-  orc_union32 var33;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var32 = ptr4[i];
-      /* 1: swapw */
-      var33.x2[0] = ORC_SWAP_W(var32.x2[0]);
-      var33.x2[1] = ORC_SWAP_W(var32.x2[1]);
-      /* 2: storel */
-      ptr0[i] = var33;
-    }
-  }
-
-}
-
-/* cogorc_planar_chroma_420_422 */
-static void
-_backup_cogorc_planar_chroma_420_422 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_int8 * ORC_RESTRICT ptr0;
-  orc_int8 * ORC_RESTRICT ptr1;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  orc_int8 var32;
-  orc_int8 var33;
-  orc_int8 var34;
-  orc_int8 var35;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr1 = ORC_PTR_OFFSET(ex->arrays[1], ex->params[1] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadb */
-      var32 = ptr4[i];
-      /* 1: copyb */
-      var33 = var32;
-      /* 2: storeb */
-      ptr0[i] = var33;
-      /* 3: loadb */
-      var34 = ptr4[i];
-      /* 4: copyb */
-      var35 = var34;
-      /* 5: storeb */
-      ptr1[i] = var35;
-    }
-  }
-
-}
-
-/* cogorc_planar_chroma_420_444 */
-static void
-_backup_cogorc_planar_chroma_420_444 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union16 * ORC_RESTRICT ptr0;
-  orc_union16 * ORC_RESTRICT ptr1;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  orc_int8 var33;
-  orc_union16 var34;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr1 = ORC_PTR_OFFSET(ex->arrays[1], ex->params[1] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadb */
-      var33 = ptr4[i];
-      /* 1: splatbw */
-      var34.i = ((var33&0xff) << 8) | (var33&0xff);
-      /* 2: storew */
-      ptr0[i] = var34;
-      /* 3: storew */
-      ptr1[i] = var34;
-    }
-  }
-
-}
-
-/* cogorc_planar_chroma_422_444 */
-static void
-_backup_cogorc_planar_chroma_422_444 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union16 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  orc_int8 var33;
-  orc_union16 var34;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadb */
-      var33 = ptr4[i];
-      /* 1: splatbw */
-      var34.i = ((var33&0xff) << 8) | (var33&0xff);
-      /* 2: storew */
-      ptr0[i] = var34;
-    }
-  }
-
-}
-
-/* cogorc_planar_chroma_444_422 */
-static void
-_backup_cogorc_planar_chroma_444_422 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  orc_union16 var34;
-  orc_int8 var35;
-  orc_int8 var36;
-  orc_int8 var37;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadw */
-      var34 = ptr4[i];
-      /* 1: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var34.i;
-       var36 = _src.x2[1];
-       var37 = _src.x2[0];
-    }
-      /* 2: avgub */
-      var35 = ((orc_uint8)var36 + (orc_uint8)var37 + 1)>>1;
-      /* 3: storeb */
-      ptr0[i] = var35;
-    }
-  }
-
-}
-
-/* cogorc_planar_chroma_444_420 */
-static void
-_backup_cogorc_planar_chroma_444_420 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_union16 * ORC_RESTRICT ptr5;
-  orc_union16 var35;
-  orc_union16 var36;
-  orc_int8 var37;
-  orc_union16 var38;
-  orc_int8 var39;
-  orc_int8 var40;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-    ptr5 = ORC_PTR_OFFSET(ex->arrays[5], ex->params[5] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadw */
-      var35 = ptr4[i];
-      /* 1: loadw */
-      var36 = ptr5[i];
-      /* 2: avgub */
-      var38.x2[0] = ((orc_uint8)var35.x2[0] + (orc_uint8)var36.x2[0] + 1)>>1;
-      var38.x2[1] = ((orc_uint8)var35.x2[1] + (orc_uint8)var36.x2[1] + 1)>>1;
-      /* 3: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var38.i;
-       var39 = _src.x2[1];
-       var40 = _src.x2[0];
-    }
-      /* 4: avgub */
-      var37 = ((orc_uint8)var39 + (orc_uint8)var40 + 1)>>1;
-      /* 5: storeb */
-      ptr0[i] = var37;
-    }
-  }
-
-}
-
-/* cogorc_planar_chroma_422_420 */
-static void
-_backup_cogorc_planar_chroma_422_420 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_int8 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  orc_int8 var32;
-  orc_int8 var33;
-  orc_int8 var34;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-    ptr5 = ORC_PTR_OFFSET(ex->arrays[5], ex->params[5] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadb */
-      var32 = ptr4[i];
-      /* 1: loadb */
-      var33 = ptr5[i];
-      /* 2: avgub */
-      var34 = ((orc_uint8)var32 + (orc_uint8)var33 + 1)>>1;
-      /* 3: storeb */
-      ptr0[i] = var34;
-    }
-  }
-
-}
-
-/* cogorc_convert_YUY2_AYUV */
-static void
-_backup_cogorc_convert_YUY2_AYUV (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union64 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var36;
-  orc_union16 var37;
-  orc_union64 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-  orc_union32 var41;
-  orc_union32 var42;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-      /* 2: loadpb */
-        var37.x2[0] = (int)0x000000ff; /* 255 or 1.25987e-321f */
-      var37.x2[1] = (int)0x000000ff; /* 255 or 1.25987e-321f */
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var36 = ptr4[i];
-      /* 1: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var36.x2[0];
-       var39.x2[0] = _src.x2[1];
-       var40.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var36.x2[1];
-       var39.x2[1] = _src.x2[1];
-       var40.x2[1] = _src.x2[0];
-    }
-      /* 3: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var37.x2[0];
-       _dest.x2[1] = var40.x2[0];
-       var41.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var37.x2[1];
-       _dest.x2[1] = var40.x2[1];
-       var41.x2[1] = _dest.i;
-    }
-      /* 4: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var39.i;
-       _dest.x2[1] = var39.i;
-       var42.i = _dest.i;
-    }
-      /* 5: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var41.x2[0];
-       _dest.x2[1] = var42.x2[0];
-       var38.x2[0] = _dest.i;
-    }
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var41.x2[1];
-       _dest.x2[1] = var42.x2[1];
-       var38.x2[1] = _dest.i;
-    }
-      /* 6: storeq */
-      ptr0[i] = var38;
-    }
-  }
-
-}
-
-/* cogorc_convert_UYVY_AYUV */
-static void
-_backup_cogorc_convert_UYVY_AYUV (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union64 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var36;
-  orc_union16 var37;
-  orc_union64 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-  orc_union32 var41;
-  orc_union32 var42;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-      /* 2: loadpb */
-        var37.x2[0] = (int)0x000000ff; /* 255 or 1.25987e-321f */
-      var37.x2[1] = (int)0x000000ff; /* 255 or 1.25987e-321f */
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var36 = ptr4[i];
-      /* 1: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var36.x2[0];
-       var39.x2[0] = _src.x2[1];
-       var40.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var36.x2[1];
-       var39.x2[1] = _src.x2[1];
-       var40.x2[1] = _src.x2[0];
-    }
-      /* 3: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var37.x2[0];
-       _dest.x2[1] = var39.x2[0];
-       var41.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var37.x2[1];
-       _dest.x2[1] = var39.x2[1];
-       var41.x2[1] = _dest.i;
-    }
-      /* 4: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var40.i;
-       _dest.x2[1] = var40.i;
-       var42.i = _dest.i;
-    }
-      /* 5: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var41.x2[0];
-       _dest.x2[1] = var42.x2[0];
-       var38.x2[0] = _dest.i;
-    }
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var41.x2[1];
-       _dest.x2[1] = var42.x2[1];
-       var38.x2[1] = _dest.i;
-    }
-      /* 6: storeq */
-      ptr0[i] = var38;
-    }
-  }
-
-}
-
-/* cogorc_convert_YUY2_Y42B */
-static void
-_backup_cogorc_convert_YUY2_Y42B (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union16 * ORC_RESTRICT ptr0;
-  orc_int8 * ORC_RESTRICT ptr1;
-  orc_int8 * ORC_RESTRICT ptr2;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var33;
-  orc_union16 var34;
-  orc_int8 var35;
-  orc_int8 var36;
-  orc_union16 var37;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr1 = ORC_PTR_OFFSET(ex->arrays[1], ex->params[1] * j);
-    ptr2 = ORC_PTR_OFFSET(ex->arrays[2], ex->params[2] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var33 = ptr4[i];
-      /* 1: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var33.x2[0];
-       var37.x2[0] = _src.x2[1];
-       var34.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var33.x2[1];
-       var37.x2[1] = _src.x2[1];
-       var34.x2[1] = _src.x2[0];
-    }
-      /* 2: storew */
-      ptr0[i] = var34;
-      /* 3: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var37.i;
-       var35 = _src.x2[1];
-       var36 = _src.x2[0];
-    }
-      /* 4: storeb */
-      ptr2[i] = var35;
-      /* 5: storeb */
-      ptr1[i] = var36;
-    }
-  }
-
-}
-
-/* cogorc_convert_UYVY_Y42B */
-static void
-_backup_cogorc_convert_UYVY_Y42B (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union16 * ORC_RESTRICT ptr0;
-  orc_int8 * ORC_RESTRICT ptr1;
-  orc_int8 * ORC_RESTRICT ptr2;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var33;
-  orc_union16 var34;
-  orc_int8 var35;
-  orc_int8 var36;
-  orc_union16 var37;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr1 = ORC_PTR_OFFSET(ex->arrays[1], ex->params[1] * j);
-    ptr2 = ORC_PTR_OFFSET(ex->arrays[2], ex->params[2] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var33 = ptr4[i];
-      /* 1: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var33.x2[0];
-       var34.x2[0] = _src.x2[1];
-       var37.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var33.x2[1];
-       var34.x2[1] = _src.x2[1];
-       var37.x2[1] = _src.x2[0];
-    }
-      /* 2: storew */
-      ptr0[i] = var34;
-      /* 3: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var37.i;
-       var35 = _src.x2[1];
-       var36 = _src.x2[0];
-    }
-      /* 4: storeb */
-      ptr2[i] = var35;
-      /* 5: storeb */
-      ptr1[i] = var36;
-    }
-  }
-
-}
-
-/* cogorc_convert_YUY2_Y444 */
-static void
-_backup_cogorc_convert_YUY2_Y444 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union16 * ORC_RESTRICT ptr0;
-  orc_union16 * ORC_RESTRICT ptr1;
-  orc_union16 * ORC_RESTRICT ptr2;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var35;
-  orc_union16 var36;
-  orc_union16 var37;
-  orc_union16 var38;
-  orc_union16 var39;
-  orc_int8 var40;
-  orc_int8 var41;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr1 = ORC_PTR_OFFSET(ex->arrays[1], ex->params[1] * j);
-    ptr2 = ORC_PTR_OFFSET(ex->arrays[2], ex->params[2] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var35 = ptr4[i];
-      /* 1: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var35.x2[0];
-       var39.x2[0] = _src.x2[1];
-       var36.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var35.x2[1];
-       var39.x2[1] = _src.x2[1];
-       var36.x2[1] = _src.x2[0];
-    }
-      /* 2: storew */
-      ptr0[i] = var36;
-      /* 3: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var39.i;
-       var40 = _src.x2[1];
-       var41 = _src.x2[0];
-    }
-      /* 4: splatbw */
-      var37.i = ((var41&0xff) << 8) | (var41&0xff);
-      /* 5: storew */
-      ptr1[i] = var37;
-      /* 6: splatbw */
-      var38.i = ((var40&0xff) << 8) | (var40&0xff);
-      /* 7: storew */
-      ptr2[i] = var38;
-    }
-  }
-
-}
-
-/* cogorc_convert_UYVY_Y444 */
-static void
-_backup_cogorc_convert_UYVY_Y444 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union16 * ORC_RESTRICT ptr0;
-  orc_union16 * ORC_RESTRICT ptr1;
-  orc_union16 * ORC_RESTRICT ptr2;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var35;
-  orc_union16 var36;
-  orc_union16 var37;
-  orc_union16 var38;
-  orc_union16 var39;
-  orc_int8 var40;
-  orc_int8 var41;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr1 = ORC_PTR_OFFSET(ex->arrays[1], ex->params[1] * j);
-    ptr2 = ORC_PTR_OFFSET(ex->arrays[2], ex->params[2] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var35 = ptr4[i];
-      /* 1: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var35.x2[0];
-       var36.x2[0] = _src.x2[1];
-       var39.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var35.x2[1];
-       var36.x2[1] = _src.x2[1];
-       var39.x2[1] = _src.x2[0];
-    }
-      /* 2: storew */
-      ptr0[i] = var36;
-      /* 3: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var39.i;
-       var40 = _src.x2[1];
-       var41 = _src.x2[0];
-    }
-      /* 4: splatbw */
-      var37.i = ((var41&0xff) << 8) | (var41&0xff);
-      /* 5: storew */
-      ptr1[i] = var37;
-      /* 6: splatbw */
-      var38.i = ((var40&0xff) << 8) | (var40&0xff);
-      /* 7: storew */
-      ptr2[i] = var38;
-    }
-  }
-
-}
-
-/* cogorc_convert_UYVY_I420 */
-static void
-_backup_cogorc_convert_UYVY_I420 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union16 * ORC_RESTRICT ptr0;
-  orc_union16 * ORC_RESTRICT ptr1;
-  orc_int8 * ORC_RESTRICT ptr2;
-  orc_int8 * ORC_RESTRICT ptr3;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  const orc_union32 * ORC_RESTRICT ptr5;
-  orc_union32 var35;
-  orc_union32 var36;
-  orc_int8 var37;
-  orc_int8 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-
-  ptr0 = (orc_union16 *)ex->arrays[0];
-  ptr1 = (orc_union16 *)ex->arrays[1];
-  ptr2 = (orc_int8 *)ex->arrays[2];
-  ptr3 = (orc_int8 *)ex->arrays[3];
-  ptr4 = (orc_union32 *)ex->arrays[4];
-  ptr5 = (orc_union32 *)ex->arrays[5];
-
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadl */
-    var35 = ptr4[i];
-    /* 1: splitwb */
-    {
-       orc_union16 _src;
-       _src.i = var35.x2[0];
-       var39.x2[0] = _src.x2[1];
-       var40.x2[0] = _src.x2[0];
-    }
-    {
-       orc_union16 _src;
-       _src.i = var35.x2[1];
-       var39.x2[1] = _src.x2[1];
-       var40.x2[1] = _src.x2[0];
-    }
-    /* 2: storew */
-    ptr0[i] = var39;
-    /* 3: loadl */
-    var36 = ptr5[i];
-    /* 4: splitwb */
-    {
-       orc_union16 _src;
-       _src.i = var36.x2[0];
-       var41.x2[0] = _src.x2[1];
-       var42.x2[0] = _src.x2[0];
-    }
-    {
-       orc_union16 _src;
-       _src.i = var36.x2[1];
-       var41.x2[1] = _src.x2[1];
-       var42.x2[1] = _src.x2[0];
-    }
-    /* 5: storew */
-    ptr1[i] = var41;
-    /* 6: avgub */
-    var43.x2[0] = ((orc_uint8)var40.x2[0] + (orc_uint8)var42.x2[0] + 1)>>1;
-    var43.x2[1] = ((orc_uint8)var40.x2[1] + (orc_uint8)var42.x2[1] + 1)>>1;
-    /* 7: splitwb */
-    {
-       orc_union16 _src;
-       _src.i = var43.i;
-       var37 = _src.x2[1];
-       var38 = _src.x2[0];
-    }
-    /* 8: storeb */
-    ptr3[i] = var37;
-    /* 9: storeb */
-    ptr2[i] = var38;
-  }
-
-}
-
-/* cogorc_convert_AYUV_I420 */
-static void
-_backup_cogorc_convert_AYUV_I420 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union16 * ORC_RESTRICT ptr0;
-  orc_union16 * ORC_RESTRICT ptr1;
-  orc_int8 * ORC_RESTRICT ptr2;
-  orc_int8 * ORC_RESTRICT ptr3;
-  const orc_union64 * ORC_RESTRICT ptr4;
-  const orc_union64 * ORC_RESTRICT ptr5;
-  orc_union64 var40;
-  orc_union16 var41;
-  orc_union64 var42;
-  orc_union16 var43;
-  orc_int8 var44;
-  orc_int8 var45;
-  orc_union32 var46;
-  orc_union32 var47;
-  orc_union32 var48;
-  orc_union32 var49;
-  orc_union32 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_int8 var53;
-  orc_int8 var54;
-  orc_int8 var55;
-  orc_int8 var56;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr1 = ORC_PTR_OFFSET(ex->arrays[1], ex->params[1] * j);
-    ptr2 = ORC_PTR_OFFSET(ex->arrays[2], ex->params[2] * j);
-    ptr3 = ORC_PTR_OFFSET(ex->arrays[3], ex->params[3] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-    ptr5 = ORC_PTR_OFFSET(ex->arrays[5], ex->params[5] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadq */
-      var40 = ptr4[i];
-      /* 1: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var40.x2[0];
-       var46.x2[0] = _src.x2[1];
-       var47.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union32 _src;
-       _src.i = var40.x2[1];
-       var46.x2[1] = _src.x2[1];
-       var47.x2[1] = _src.x2[0];
-    }
-      /* 2: select1wb */
-      {
-       orc_union16 _src;
-       _src.i = var47.x2[0];
-       var41.x2[0] = _src.x2[1];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var47.x2[1];
-       var41.x2[1] = _src.x2[1];
-    }
-      /* 3: storew */
-      ptr0[i] = var41;
-      /* 4: loadq */
-      var42 = ptr5[i];
-      /* 5: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var42.x2[0];
-       var48.x2[0] = _src.x2[1];
-       var49.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union32 _src;
-       _src.i = var42.x2[1];
-       var48.x2[1] = _src.x2[1];
-       var49.x2[1] = _src.x2[0];
-    }
-      /* 6: select1wb */
-      {
-       orc_union16 _src;
-       _src.i = var49.x2[0];
-       var43.x2[0] = _src.x2[1];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var49.x2[1];
-       var43.x2[1] = _src.x2[1];
-    }
-      /* 7: storew */
-      ptr1[i] = var43;
-      /* 8: avgub */
-      var50.x4[0] = ((orc_uint8)var46.x4[0] + (orc_uint8)var48.x4[0] + 1)>>1;
-      var50.x4[1] = ((orc_uint8)var46.x4[1] + (orc_uint8)var48.x4[1] + 1)>>1;
-      var50.x4[2] = ((orc_uint8)var46.x4[2] + (orc_uint8)var48.x4[2] + 1)>>1;
-      var50.x4[3] = ((orc_uint8)var46.x4[3] + (orc_uint8)var48.x4[3] + 1)>>1;
-      /* 9: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var50.x2[0];
-       var51.x2[0] = _src.x2[1];
-       var52.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var50.x2[1];
-       var51.x2[1] = _src.x2[1];
-       var52.x2[1] = _src.x2[0];
-    }
-      /* 10: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var52.i;
-       var53 = _src.x2[1];
-       var54 = _src.x2[0];
-    }
-      /* 11: avgub */
-      var44 = ((orc_uint8)var53 + (orc_uint8)var54 + 1)>>1;
-      /* 12: storeb */
-      ptr2[i] = var44;
-      /* 13: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var51.i;
-       var55 = _src.x2[1];
-       var56 = _src.x2[0];
-    }
-      /* 14: avgub */
-      var45 = ((orc_uint8)var55 + (orc_uint8)var56 + 1)>>1;
-      /* 15: storeb */
-      ptr3[i] = var45;
-    }
-  }
-
-}
-
-/* cogorc_convert_AYUV_YUY2 */
-static void
-_backup_cogorc_convert_AYUV_YUY2 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union64 * ORC_RESTRICT ptr4;
-  orc_union64 var37;
-  orc_union32 var38;
-  orc_union32 var39;
-  orc_union32 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-  orc_union16 var44;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadq */
-      var37 = ptr4[i];
-      /* 1: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var37.x2[0];
-       var39.x2[0] = _src.x2[1];
-       var40.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union32 _src;
-       _src.i = var37.x2[1];
-       var39.x2[1] = _src.x2[1];
-       var40.x2[1] = _src.x2[0];
-    }
-      /* 2: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var39.i;
-       var41.i = _src.x2[1];
-       var42.i = _src.x2[0];
-    }
-      /* 3: avgub */
-      var43.x2[0] = ((orc_uint8)var41.x2[0] + (orc_uint8)var42.x2[0] + 1)>>1;
-      var43.x2[1] = ((orc_uint8)var41.x2[1] + (orc_uint8)var42.x2[1] + 1)>>1;
-      /* 4: select1wb */
-      {
-       orc_union16 _src;
-       _src.i = var40.x2[0];
-       var44.x2[0] = _src.x2[1];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var40.x2[1];
-       var44.x2[1] = _src.x2[1];
-    }
-      /* 5: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var44.x2[0];
-       _dest.x2[1] = var43.x2[0];
-       var38.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var44.x2[1];
-       _dest.x2[1] = var43.x2[1];
-       var38.x2[1] = _dest.i;
-    }
-      /* 6: storel */
-      ptr0[i] = var38;
-    }
-  }
-
-}
-
-/* cogorc_convert_AYUV_UYVY */
-static void
-_backup_cogorc_convert_AYUV_UYVY (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union64 * ORC_RESTRICT ptr4;
-  orc_union64 var37;
-  orc_union32 var38;
-  orc_union32 var39;
-  orc_union32 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-  orc_union16 var44;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadq */
-      var37 = ptr4[i];
-      /* 1: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var37.x2[0];
-       var39.x2[0] = _src.x2[1];
-       var40.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union32 _src;
-       _src.i = var37.x2[1];
-       var39.x2[1] = _src.x2[1];
-       var40.x2[1] = _src.x2[0];
-    }
-      /* 2: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var39.i;
-       var41.i = _src.x2[1];
-       var42.i = _src.x2[0];
-    }
-      /* 3: avgub */
-      var43.x2[0] = ((orc_uint8)var41.x2[0] + (orc_uint8)var42.x2[0] + 1)>>1;
-      var43.x2[1] = ((orc_uint8)var41.x2[1] + (orc_uint8)var42.x2[1] + 1)>>1;
-      /* 4: select1wb */
-      {
-       orc_union16 _src;
-       _src.i = var40.x2[0];
-       var44.x2[0] = _src.x2[1];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var40.x2[1];
-       var44.x2[1] = _src.x2[1];
-    }
-      /* 5: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var43.x2[0];
-       _dest.x2[1] = var44.x2[0];
-       var38.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var43.x2[1];
-       _dest.x2[1] = var44.x2[1];
-       var38.x2[1] = _dest.i;
-    }
-      /* 6: storel */
-      ptr0[i] = var38;
-    }
-  }
-
-}
-
-/* cogorc_convert_AYUV_Y42B */
-static void
-_backup_cogorc_convert_AYUV_Y42B (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union16 * ORC_RESTRICT ptr0;
-  orc_int8 * ORC_RESTRICT ptr1;
-  orc_int8 * ORC_RESTRICT ptr2;
-  const orc_union64 * ORC_RESTRICT ptr4;
-  orc_union64 var36;
-  orc_int8 var37;
-  orc_int8 var38;
-  orc_union16 var39;
-  orc_union32 var40;
-  orc_union32 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-  orc_union16 var44;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr1 = ORC_PTR_OFFSET(ex->arrays[1], ex->params[1] * j);
-    ptr2 = ORC_PTR_OFFSET(ex->arrays[2], ex->params[2] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadq */
-      var36 = ptr4[i];
-      /* 1: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var36.x2[0];
-       var40.x2[0] = _src.x2[1];
-       var41.x2[0] = _src.x2[0];
-    }
-      {
-       orc_union32 _src;
-       _src.i = var36.x2[1];
-       var40.x2[1] = _src.x2[1];
-       var41.x2[1] = _src.x2[0];
-    }
-      /* 2: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var40.i;
-       var42.i = _src.x2[1];
-       var43.i = _src.x2[0];
-    }
-      /* 3: avgub */
-      var44.x2[0] = ((orc_uint8)var42.x2[0] + (orc_uint8)var43.x2[0] + 1)>>1;
-      var44.x2[1] = ((orc_uint8)var42.x2[1] + (orc_uint8)var43.x2[1] + 1)>>1;
-      /* 4: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var44.i;
-       var37 = _src.x2[1];
-       var38 = _src.x2[0];
-    }
-      /* 5: storeb */
-      ptr2[i] = var37;
-      /* 6: storeb */
-      ptr1[i] = var38;
-      /* 7: select1wb */
-      {
-       orc_union16 _src;
-       _src.i = var41.x2[0];
-       var39.x2[0] = _src.x2[1];
-    }
-      {
-       orc_union16 _src;
-       _src.i = var41.x2[1];
-       var39.x2[1] = _src.x2[1];
-    }
-      /* 8: storew */
-      ptr0[i] = var39;
-    }
-  }
-
-}
-
-/* cogorc_convert_AYUV_Y444 */
-static void
-_backup_cogorc_convert_AYUV_Y444 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_int8 * ORC_RESTRICT ptr0;
-  orc_int8 * ORC_RESTRICT ptr1;
-  orc_int8 * ORC_RESTRICT ptr2;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var34;
-  orc_int8 var35;
-  orc_int8 var36;
-  orc_int8 var37;
-  orc_union16 var38;
-  orc_union16 var39;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr1 = ORC_PTR_OFFSET(ex->arrays[1], ex->params[1] * j);
-    ptr2 = ORC_PTR_OFFSET(ex->arrays[2], ex->params[2] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var34 = ptr4[i];
-      /* 1: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var34.i;
-       var38.i = _src.x2[1];
-       var39.i = _src.x2[0];
-    }
-      /* 2: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var38.i;
-       var35 = _src.x2[1];
-       var36 = _src.x2[0];
-    }
-      /* 3: storeb */
-      ptr2[i] = var35;
-      /* 4: storeb */
-      ptr1[i] = var36;
-      /* 5: select1wb */
-      {
-       orc_union16 _src;
-       _src.i = var39.i;
-       var37 = _src.x2[1];
-    }
-      /* 6: storeb */
-      ptr0[i] = var37;
-    }
-  }
-
-}
-
-/* cogorc_convert_Y42B_YUY2 */
-static void
-_backup_cogorc_convert_Y42B_YUY2 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-  orc_union32 var36;
-  orc_union16 var37;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-    ptr5 = ORC_PTR_OFFSET(ex->arrays[5], ex->params[5] * j);
-    ptr6 = ORC_PTR_OFFSET(ex->arrays[6], ex->params[6] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadb */
-      var33 = ptr5[i];
-      /* 1: loadb */
-      var34 = ptr6[i];
-      /* 2: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var33;
-       _dest.x2[1] = var34;
-       var37.i = _dest.i;
-    }
-      /* 3: loadw */
-      var35 = ptr4[i];
-      /* 4: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var35.x2[0];
-       _dest.x2[1] = var37.x2[0];
-       var36.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var35.x2[1];
-       _dest.x2[1] = var37.x2[1];
-       var36.x2[1] = _dest.i;
-    }
-      /* 5: storel */
-      ptr0[i] = var36;
-    }
-  }
-
-}
-
-/* cogorc_convert_Y42B_UYVY */
-static void
-_backup_cogorc_convert_Y42B_UYVY (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var33;
-  orc_int8 var34;
-  orc_union16 var35;
-  orc_union32 var36;
-  orc_union16 var37;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-    ptr5 = ORC_PTR_OFFSET(ex->arrays[5], ex->params[5] * j);
-    ptr6 = ORC_PTR_OFFSET(ex->arrays[6], ex->params[6] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadb */
-      var33 = ptr5[i];
-      /* 1: loadb */
-      var34 = ptr6[i];
-      /* 2: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var33;
-       _dest.x2[1] = var34;
-       var37.i = _dest.i;
-    }
-      /* 3: loadw */
-      var35 = ptr4[i];
-      /* 4: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var37.x2[0];
-       _dest.x2[1] = var35.x2[0];
-       var36.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var37.x2[1];
-       _dest.x2[1] = var35.x2[1];
-       var36.x2[1] = _dest.i;
-    }
-      /* 5: storel */
-      ptr0[i] = var36;
-    }
-  }
-
-}
-
-/* cogorc_convert_Y42B_AYUV */
-static void
-_backup_cogorc_convert_Y42B_AYUV (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union64 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var36;
-  orc_int8 var37;
-  orc_union16 var38;
-  orc_union16 var39;
-  orc_union64 var40;
-  orc_union16 var41;
-  orc_union32 var42;
-  orc_union32 var43;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-    ptr5 = ORC_PTR_OFFSET(ex->arrays[5], ex->params[5] * j);
-    ptr6 = ORC_PTR_OFFSET(ex->arrays[6], ex->params[6] * j);
-
-      /* 3: loadpb */
-        var38.x2[0] = (int)0x000000ff; /* 255 or 1.25987e-321f */
-      var38.x2[1] = (int)0x000000ff; /* 255 or 1.25987e-321f */
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadb */
-      var36 = ptr5[i];
-      /* 1: loadb */
-      var37 = ptr6[i];
-      /* 2: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var36;
-       _dest.x2[1] = var37;
-       var41.i = _dest.i;
-    }
-      /* 4: loadw */
-      var39 = ptr4[i];
-      /* 5: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var38.x2[0];
-       _dest.x2[1] = var39.x2[0];
-       var42.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var38.x2[1];
-       _dest.x2[1] = var39.x2[1];
-       var42.x2[1] = _dest.i;
-    }
-      /* 6: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var41.i;
-       _dest.x2[1] = var41.i;
-       var43.i = _dest.i;
-    }
-      /* 7: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var42.x2[0];
-       _dest.x2[1] = var43.x2[0];
-       var40.x2[0] = _dest.i;
-    }
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var42.x2[1];
-       _dest.x2[1] = var43.x2[1];
-       var40.x2[1] = _dest.i;
-    }
-      /* 8: storeq */
-      ptr0[i] = var40;
-    }
-  }
-
-}
-
-/* cogorc_convert_Y444_YUY2 */
-static void
-_backup_cogorc_convert_Y444_YUY2 (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_union16 * ORC_RESTRICT ptr5;
-  const orc_union16 * ORC_RESTRICT ptr6;
-  orc_union16 var36;
-  orc_union16 var37;
-  orc_union16 var38;
-  orc_union32 var39;
-  orc_union32 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-    ptr5 = ORC_PTR_OFFSET(ex->arrays[5], ex->params[5] * j);
-    ptr6 = ORC_PTR_OFFSET(ex->arrays[6], ex->params[6] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadw */
-      var36 = ptr5[i];
-      /* 1: loadw */
-      var37 = ptr6[i];
-      /* 2: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var36.x2[0];
-       _dest.x2[1] = var37.x2[0];
-       var40.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var36.x2[1];
-       _dest.x2[1] = var37.x2[1];
-       var40.x2[1] = _dest.i;
-    }
-      /* 3: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var40.i;
-       var41.i = _src.x2[1];
-       var42.i = _src.x2[0];
-    }
-      /* 4: avgub */
-      var43.x2[0] = ((orc_uint8)var41.x2[0] + (orc_uint8)var42.x2[0] + 1)>>1;
-      var43.x2[1] = ((orc_uint8)var41.x2[1] + (orc_uint8)var42.x2[1] + 1)>>1;
-      /* 5: loadw */
-      var38 = ptr4[i];
-      /* 6: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var38.x2[0];
-       _dest.x2[1] = var43.x2[0];
-       var39.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var38.x2[1];
-       _dest.x2[1] = var43.x2[1];
-       var39.x2[1] = _dest.i;
-    }
-      /* 7: storel */
-      ptr0[i] = var39;
-    }
-  }
-
-}
-
-/* cogorc_convert_Y444_UYVY */
-static void
-_backup_cogorc_convert_Y444_UYVY (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union16 * ORC_RESTRICT ptr4;
-  const orc_union16 * ORC_RESTRICT ptr5;
-  const orc_union16 * ORC_RESTRICT ptr6;
-  orc_union16 var36;
-  orc_union16 var37;
-  orc_union16 var38;
-  orc_union32 var39;
-  orc_union32 var40;
-  orc_union16 var41;
-  orc_union16 var42;
-  orc_union16 var43;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-    ptr5 = ORC_PTR_OFFSET(ex->arrays[5], ex->params[5] * j);
-    ptr6 = ORC_PTR_OFFSET(ex->arrays[6], ex->params[6] * j);
-
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadw */
-      var36 = ptr5[i];
-      /* 1: loadw */
-      var37 = ptr6[i];
-      /* 2: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var36.x2[0];
-       _dest.x2[1] = var37.x2[0];
-       var40.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var36.x2[1];
-       _dest.x2[1] = var37.x2[1];
-       var40.x2[1] = _dest.i;
-    }
-      /* 3: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var40.i;
-       var41.i = _src.x2[1];
-       var42.i = _src.x2[0];
-    }
-      /* 4: avgub */
-      var43.x2[0] = ((orc_uint8)var41.x2[0] + (orc_uint8)var42.x2[0] + 1)>>1;
-      var43.x2[1] = ((orc_uint8)var41.x2[1] + (orc_uint8)var42.x2[1] + 1)>>1;
-      /* 5: loadw */
-      var38 = ptr4[i];
-      /* 6: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var43.x2[0];
-       _dest.x2[1] = var38.x2[0];
-       var39.x2[0] = _dest.i;
-    }
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var43.x2[1];
-       _dest.x2[1] = var38.x2[1];
-       var39.x2[1] = _dest.i;
-    }
-      /* 7: storel */
-      ptr0[i] = var39;
-    }
-  }
-
-}
-
-/* cogorc_convert_Y444_AYUV */
-static void
-_backup_cogorc_convert_Y444_AYUV (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var34;
-  orc_int8 var35;
-  orc_int8 var36;
-  orc_int8 var37;
-  orc_union32 var38;
-  orc_union16 var39;
-  orc_union16 var40;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-    ptr5 = ORC_PTR_OFFSET(ex->arrays[5], ex->params[5] * j);
-    ptr6 = ORC_PTR_OFFSET(ex->arrays[6], ex->params[6] * j);
-
-      /* 3: loadpb */
-        var36 = (int)0x000000ff; /* 255 or 1.25987e-321f */
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadb */
-      var34 = ptr5[i];
-      /* 1: loadb */
-      var35 = ptr6[i];
-      /* 2: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var34;
-       _dest.x2[1] = var35;
-       var39.i = _dest.i;
-    }
-      /* 4: loadb */
-      var37 = ptr4[i];
-      /* 5: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var36;
-       _dest.x2[1] = var37;
-       var40.i = _dest.i;
-    }
-      /* 6: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var40.i;
-       _dest.x2[1] = var39.i;
-       var38.i = _dest.i;
-    }
-      /* 7: storel */
-      ptr0[i] = var38;
-    }
-  }
-
-}
-
-/* cogorc_convert_AYUV_ARGB */
-static void
-_backup_cogorc_convert_AYUV_ARGB (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var48;
-  orc_union32 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-  orc_union32 var55;
-  orc_union32 var56;
-  orc_union32 var57;
-  orc_union16 var58;
-  orc_union16 var59;
-  orc_int8 var60;
-  orc_int8 var61;
-  orc_int8 var62;
-  orc_int8 var63;
-  orc_union16 var64;
-  orc_union16 var65;
-  orc_union16 var66;
-  orc_union16 var67;
-  orc_union16 var68;
-  orc_union16 var69;
-  orc_union16 var70;
-  orc_union16 var71;
-  orc_union16 var72;
-  orc_union16 var73;
-  orc_union16 var74;
-  orc_union16 var75;
-  orc_union16 var76;
-  orc_union16 var77;
-  orc_union16 var78;
-  orc_union16 var79;
-  orc_union16 var80;
-  orc_union16 var81;
-  orc_union16 var82;
-  orc_union16 var83;
-  orc_union16 var84;
-  orc_union16 var85;
-  orc_union16 var86;
-  orc_int8 var87;
-  orc_int8 var88;
-  orc_int8 var89;
-  orc_union16 var90;
-  orc_union16 var91;
-  orc_union32 var92;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-      /* 1: loadpb */
-        var49.x4[0] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[1] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[2] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[3] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      /* 9: loadpw */
-        var50.i = (int)0x0000002a; /* 42 or 2.07508e-322f */
-      /* 14: loadpw */
-        var51.i = (int)0x00000067; /* 103 or 5.08888e-322f */
-      /* 21: loadpw */
-        var52.i = (int)0x00000004; /* 4 or 1.97626e-323f */
-      /* 25: loadpw */
-        var53.i = (int)0x00000064; /* 100 or 4.94066e-322f */
-      /* 29: loadpw */
-        var54.i = (int)0x00000068; /* 104 or 5.13828e-322f */
-      /* 40: loadpb */
-        var55.x4[0] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[1] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[2] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[3] = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var48 = ptr4[i];
-      /* 2: subb */
-      var57.x4[0] = var48.x4[0] - var49.x4[0];
-      var57.x4[1] = var48.x4[1] - var49.x4[1];
-      var57.x4[2] = var48.x4[2] - var49.x4[2];
-      var57.x4[3] = var48.x4[3] - var49.x4[3];
-      /* 3: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var57.i;
-       var58.i = _src.x2[1];
-       var59.i = _src.x2[0];
-    }
-      /* 4: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var59.i;
-       var60 = _src.x2[1];
-       var61 = _src.x2[0];
-    }
-      /* 5: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var58.i;
-       var62 = _src.x2[1];
-       var63 = _src.x2[0];
-    }
-      /* 6: convsbw */
-      var64.i = var60;
-      /* 7: convsbw */
-      var65.i = var63;
-      /* 8: convsbw */
-      var66.i = var62;
-      /* 10: mullw */
-      var67.i = (var64.i * var50.i) & 0xffff;
-      /* 11: shrsw */
-      var68.i = var67.i >> 8;
-      /* 12: addssw */
-      var69.i = ORC_CLAMP_SW(var64.i + var68.i);
-      /* 13: addssw */
-      var70.i = ORC_CLAMP_SW(var69.i + var66.i);
-      /* 15: mullw */
-      var71.i = (var66.i * var51.i) & 0xffff;
-      /* 16: shrsw */
-      var72.i = var71.i >> 8;
-      /* 17: subssw */
-      var73.i = ORC_CLAMP_SW(var70.i - var72.i);
-      /* 18: addssw */
-      var74.i = ORC_CLAMP_SW(var73.i + var66.i);
-      /* 19: addssw */
-      var75.i = ORC_CLAMP_SW(var69.i + var65.i);
-      /* 20: addssw */
-      var76.i = ORC_CLAMP_SW(var75.i + var65.i);
-      /* 22: mullw */
-      var77.i = (var65.i * var52.i) & 0xffff;
-      /* 23: shrsw */
-      var78.i = var77.i >> 8;
-      /* 24: addssw */
-      var79.i = ORC_CLAMP_SW(var76.i + var78.i);
-      /* 26: mullw */
-      var80.i = (var65.i * var53.i) & 0xffff;
-      /* 27: shrsw */
-      var81.i = var80.i >> 8;
-      /* 28: subssw */
-      var82.i = ORC_CLAMP_SW(var69.i - var81.i);
-      /* 30: mullw */
-      var83.i = (var66.i * var54.i) & 0xffff;
-      /* 31: shrsw */
-      var84.i = var83.i >> 8;
-      /* 32: subssw */
-      var85.i = ORC_CLAMP_SW(var82.i - var84.i);
-      /* 33: subssw */
-      var86.i = ORC_CLAMP_SW(var85.i - var84.i);
-      /* 34: convssswb */
-      var87 = ORC_CLAMP_SB(var74.i);
-      /* 35: convssswb */
-      var88 = ORC_CLAMP_SB(var86.i);
-      /* 36: convssswb */
-      var89 = ORC_CLAMP_SB(var79.i);
-      /* 37: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var61;
-       _dest.x2[1] = var87;
-       var90.i = _dest.i;
-    }
-      /* 38: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var88;
-       _dest.x2[1] = var89;
-       var91.i = _dest.i;
-    }
-      /* 39: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var90.i;
-       _dest.x2[1] = var91.i;
-       var92.i = _dest.i;
-    }
-      /* 41: addb */
-      var56.x4[0] = var92.x4[0] + var55.x4[0];
-      var56.x4[1] = var92.x4[1] + var55.x4[1];
-      var56.x4[2] = var92.x4[2] + var55.x4[2];
-      var56.x4[3] = var92.x4[3] + var55.x4[3];
-      /* 42: storel */
-      ptr0[i] = var56;
-    }
-  }
-
-}
-
-/* cogorc_convert_AYUV_BGRA */
-static void
-_backup_cogorc_convert_AYUV_BGRA (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var48;
-  orc_union32 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-  orc_union32 var55;
-  orc_union32 var56;
-  orc_union32 var57;
-  orc_union16 var58;
-  orc_union16 var59;
-  orc_int8 var60;
-  orc_int8 var61;
-  orc_int8 var62;
-  orc_int8 var63;
-  orc_union16 var64;
-  orc_union16 var65;
-  orc_union16 var66;
-  orc_union16 var67;
-  orc_union16 var68;
-  orc_union16 var69;
-  orc_union16 var70;
-  orc_union16 var71;
-  orc_union16 var72;
-  orc_union16 var73;
-  orc_union16 var74;
-  orc_union16 var75;
-  orc_union16 var76;
-  orc_union16 var77;
-  orc_union16 var78;
-  orc_union16 var79;
-  orc_union16 var80;
-  orc_union16 var81;
-  orc_union16 var82;
-  orc_union16 var83;
-  orc_union16 var84;
-  orc_union16 var85;
-  orc_union16 var86;
-  orc_int8 var87;
-  orc_int8 var88;
-  orc_int8 var89;
-  orc_union16 var90;
-  orc_union16 var91;
-  orc_union32 var92;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-      /* 1: loadpb */
-        var49.x4[0] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[1] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[2] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[3] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      /* 9: loadpw */
-        var50.i = (int)0x0000002a; /* 42 or 2.07508e-322f */
-      /* 14: loadpw */
-        var51.i = (int)0x00000067; /* 103 or 5.08888e-322f */
-      /* 21: loadpw */
-        var52.i = (int)0x00000004; /* 4 or 1.97626e-323f */
-      /* 25: loadpw */
-        var53.i = (int)0x00000064; /* 100 or 4.94066e-322f */
-      /* 29: loadpw */
-        var54.i = (int)0x00000068; /* 104 or 5.13828e-322f */
-      /* 40: loadpb */
-        var55.x4[0] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[1] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[2] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[3] = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var48 = ptr4[i];
-      /* 2: subb */
-      var57.x4[0] = var48.x4[0] - var49.x4[0];
-      var57.x4[1] = var48.x4[1] - var49.x4[1];
-      var57.x4[2] = var48.x4[2] - var49.x4[2];
-      var57.x4[3] = var48.x4[3] - var49.x4[3];
-      /* 3: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var57.i;
-       var58.i = _src.x2[1];
-       var59.i = _src.x2[0];
-    }
-      /* 4: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var59.i;
-       var60 = _src.x2[1];
-       var61 = _src.x2[0];
-    }
-      /* 5: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var58.i;
-       var62 = _src.x2[1];
-       var63 = _src.x2[0];
-    }
-      /* 6: convsbw */
-      var64.i = var60;
-      /* 7: convsbw */
-      var65.i = var63;
-      /* 8: convsbw */
-      var66.i = var62;
-      /* 10: mullw */
-      var67.i = (var64.i * var50.i) & 0xffff;
-      /* 11: shrsw */
-      var68.i = var67.i >> 8;
-      /* 12: addssw */
-      var69.i = ORC_CLAMP_SW(var64.i + var68.i);
-      /* 13: addssw */
-      var70.i = ORC_CLAMP_SW(var69.i + var66.i);
-      /* 15: mullw */
-      var71.i = (var66.i * var51.i) & 0xffff;
-      /* 16: shrsw */
-      var72.i = var71.i >> 8;
-      /* 17: subssw */
-      var73.i = ORC_CLAMP_SW(var70.i - var72.i);
-      /* 18: addssw */
-      var74.i = ORC_CLAMP_SW(var73.i + var66.i);
-      /* 19: addssw */
-      var75.i = ORC_CLAMP_SW(var69.i + var65.i);
-      /* 20: addssw */
-      var76.i = ORC_CLAMP_SW(var75.i + var65.i);
-      /* 22: mullw */
-      var77.i = (var65.i * var52.i) & 0xffff;
-      /* 23: shrsw */
-      var78.i = var77.i >> 8;
-      /* 24: addssw */
-      var79.i = ORC_CLAMP_SW(var76.i + var78.i);
-      /* 26: mullw */
-      var80.i = (var65.i * var53.i) & 0xffff;
-      /* 27: shrsw */
-      var81.i = var80.i >> 8;
-      /* 28: subssw */
-      var82.i = ORC_CLAMP_SW(var69.i - var81.i);
-      /* 30: mullw */
-      var83.i = (var66.i * var54.i) & 0xffff;
-      /* 31: shrsw */
-      var84.i = var83.i >> 8;
-      /* 32: subssw */
-      var85.i = ORC_CLAMP_SW(var82.i - var84.i);
-      /* 33: subssw */
-      var86.i = ORC_CLAMP_SW(var85.i - var84.i);
-      /* 34: convssswb */
-      var87 = ORC_CLAMP_SB(var74.i);
-      /* 35: convssswb */
-      var88 = ORC_CLAMP_SB(var86.i);
-      /* 36: convssswb */
-      var89 = ORC_CLAMP_SB(var79.i);
-      /* 37: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var89;
-       _dest.x2[1] = var88;
-       var90.i = _dest.i;
-    }
-      /* 38: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var87;
-       _dest.x2[1] = var61;
-       var91.i = _dest.i;
-    }
-      /* 39: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var90.i;
-       _dest.x2[1] = var91.i;
-       var92.i = _dest.i;
-    }
-      /* 41: addb */
-      var56.x4[0] = var92.x4[0] + var55.x4[0];
-      var56.x4[1] = var92.x4[1] + var55.x4[1];
-      var56.x4[2] = var92.x4[2] + var55.x4[2];
-      var56.x4[3] = var92.x4[3] + var55.x4[3];
-      /* 42: storel */
-      ptr0[i] = var56;
-    }
-  }
-
-}
-
-/* cogorc_convert_AYUV_ABGR */
-static void
-_backup_cogorc_convert_AYUV_ABGR (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var48;
-  orc_union32 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-  orc_union32 var55;
-  orc_union32 var56;
-  orc_union32 var57;
-  orc_union16 var58;
-  orc_union16 var59;
-  orc_int8 var60;
-  orc_int8 var61;
-  orc_int8 var62;
-  orc_int8 var63;
-  orc_union16 var64;
-  orc_union16 var65;
-  orc_union16 var66;
-  orc_union16 var67;
-  orc_union16 var68;
-  orc_union16 var69;
-  orc_union16 var70;
-  orc_union16 var71;
-  orc_union16 var72;
-  orc_union16 var73;
-  orc_union16 var74;
-  orc_union16 var75;
-  orc_union16 var76;
-  orc_union16 var77;
-  orc_union16 var78;
-  orc_union16 var79;
-  orc_union16 var80;
-  orc_union16 var81;
-  orc_union16 var82;
-  orc_union16 var83;
-  orc_union16 var84;
-  orc_union16 var85;
-  orc_union16 var86;
-  orc_int8 var87;
-  orc_int8 var88;
-  orc_int8 var89;
-  orc_union16 var90;
-  orc_union16 var91;
-  orc_union32 var92;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-      /* 1: loadpb */
-        var49.x4[0] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[1] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[2] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[3] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      /* 9: loadpw */
-        var50.i = (int)0x0000002a; /* 42 or 2.07508e-322f */
-      /* 14: loadpw */
-        var51.i = (int)0x00000067; /* 103 or 5.08888e-322f */
-      /* 21: loadpw */
-        var52.i = (int)0x00000004; /* 4 or 1.97626e-323f */
-      /* 25: loadpw */
-        var53.i = (int)0x00000064; /* 100 or 4.94066e-322f */
-      /* 29: loadpw */
-        var54.i = (int)0x00000068; /* 104 or 5.13828e-322f */
-      /* 40: loadpb */
-        var55.x4[0] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[1] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[2] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[3] = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var48 = ptr4[i];
-      /* 2: subb */
-      var57.x4[0] = var48.x4[0] - var49.x4[0];
-      var57.x4[1] = var48.x4[1] - var49.x4[1];
-      var57.x4[2] = var48.x4[2] - var49.x4[2];
-      var57.x4[3] = var48.x4[3] - var49.x4[3];
-      /* 3: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var57.i;
-       var58.i = _src.x2[1];
-       var59.i = _src.x2[0];
-    }
-      /* 4: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var59.i;
-       var60 = _src.x2[1];
-       var61 = _src.x2[0];
-    }
-      /* 5: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var58.i;
-       var62 = _src.x2[1];
-       var63 = _src.x2[0];
-    }
-      /* 6: convsbw */
-      var64.i = var60;
-      /* 7: convsbw */
-      var65.i = var63;
-      /* 8: convsbw */
-      var66.i = var62;
-      /* 10: mullw */
-      var67.i = (var64.i * var50.i) & 0xffff;
-      /* 11: shrsw */
-      var68.i = var67.i >> 8;
-      /* 12: addssw */
-      var69.i = ORC_CLAMP_SW(var64.i + var68.i);
-      /* 13: addssw */
-      var70.i = ORC_CLAMP_SW(var69.i + var66.i);
-      /* 15: mullw */
-      var71.i = (var66.i * var51.i) & 0xffff;
-      /* 16: shrsw */
-      var72.i = var71.i >> 8;
-      /* 17: subssw */
-      var73.i = ORC_CLAMP_SW(var70.i - var72.i);
-      /* 18: addssw */
-      var74.i = ORC_CLAMP_SW(var73.i + var66.i);
-      /* 19: addssw */
-      var75.i = ORC_CLAMP_SW(var69.i + var65.i);
-      /* 20: addssw */
-      var76.i = ORC_CLAMP_SW(var75.i + var65.i);
-      /* 22: mullw */
-      var77.i = (var65.i * var52.i) & 0xffff;
-      /* 23: shrsw */
-      var78.i = var77.i >> 8;
-      /* 24: addssw */
-      var79.i = ORC_CLAMP_SW(var76.i + var78.i);
-      /* 26: mullw */
-      var80.i = (var65.i * var53.i) & 0xffff;
-      /* 27: shrsw */
-      var81.i = var80.i >> 8;
-      /* 28: subssw */
-      var82.i = ORC_CLAMP_SW(var69.i - var81.i);
-      /* 30: mullw */
-      var83.i = (var66.i * var54.i) & 0xffff;
-      /* 31: shrsw */
-      var84.i = var83.i >> 8;
-      /* 32: subssw */
-      var85.i = ORC_CLAMP_SW(var82.i - var84.i);
-      /* 33: subssw */
-      var86.i = ORC_CLAMP_SW(var85.i - var84.i);
-      /* 34: convssswb */
-      var87 = ORC_CLAMP_SB(var74.i);
-      /* 35: convssswb */
-      var88 = ORC_CLAMP_SB(var86.i);
-      /* 36: convssswb */
-      var89 = ORC_CLAMP_SB(var79.i);
-      /* 37: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var61;
-       _dest.x2[1] = var89;
-       var90.i = _dest.i;
-    }
-      /* 38: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var88;
-       _dest.x2[1] = var87;
-       var91.i = _dest.i;
-    }
-      /* 39: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var90.i;
-       _dest.x2[1] = var91.i;
-       var92.i = _dest.i;
-    }
-      /* 41: addb */
-      var56.x4[0] = var92.x4[0] + var55.x4[0];
-      var56.x4[1] = var92.x4[1] + var55.x4[1];
-      var56.x4[2] = var92.x4[2] + var55.x4[2];
-      var56.x4[3] = var92.x4[3] + var55.x4[3];
-      /* 42: storel */
-      ptr0[i] = var56;
-    }
-  }
-
-}
-
-/* cogorc_convert_AYUV_RGBA */
-static void
-_backup_cogorc_convert_AYUV_RGBA (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int j;
-  int n = ex->n;
-  int m = ex->params[ORC_VAR_A1];
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_union32 * ORC_RESTRICT ptr4;
-  orc_union32 var48;
-  orc_union32 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-  orc_union32 var55;
-  orc_union32 var56;
-  orc_union32 var57;
-  orc_union16 var58;
-  orc_union16 var59;
-  orc_int8 var60;
-  orc_int8 var61;
-  orc_int8 var62;
-  orc_int8 var63;
-  orc_union16 var64;
-  orc_union16 var65;
-  orc_union16 var66;
-  orc_union16 var67;
-  orc_union16 var68;
-  orc_union16 var69;
-  orc_union16 var70;
-  orc_union16 var71;
-  orc_union16 var72;
-  orc_union16 var73;
-  orc_union16 var74;
-  orc_union16 var75;
-  orc_union16 var76;
-  orc_union16 var77;
-  orc_union16 var78;
-  orc_union16 var79;
-  orc_union16 var80;
-  orc_union16 var81;
-  orc_union16 var82;
-  orc_union16 var83;
-  orc_union16 var84;
-  orc_union16 var85;
-  orc_union16 var86;
-  orc_int8 var87;
-  orc_int8 var88;
-  orc_int8 var89;
-  orc_union16 var90;
-  orc_union16 var91;
-  orc_union32 var92;
-
-  for (j = 0; j < m; j++) {
-    ptr0 = ORC_PTR_OFFSET(ex->arrays[0], ex->params[0] * j);
-    ptr4 = ORC_PTR_OFFSET(ex->arrays[4], ex->params[4] * j);
-
-      /* 1: loadpb */
-        var49.x4[0] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[1] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[2] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var49.x4[3] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      /* 9: loadpw */
-        var50.i = (int)0x0000002a; /* 42 or 2.07508e-322f */
-      /* 14: loadpw */
-        var51.i = (int)0x00000067; /* 103 or 5.08888e-322f */
-      /* 21: loadpw */
-        var52.i = (int)0x00000004; /* 4 or 1.97626e-323f */
-      /* 25: loadpw */
-        var53.i = (int)0x00000064; /* 100 or 4.94066e-322f */
-      /* 29: loadpw */
-        var54.i = (int)0x00000068; /* 104 or 5.13828e-322f */
-      /* 40: loadpb */
-        var55.x4[0] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[1] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[2] = (int)0x00000080; /* 128 or 6.32404e-322f */
-      var55.x4[3] = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-    for (i = 0; i < n; i++) {
-      /* 0: loadl */
-      var48 = ptr4[i];
-      /* 2: subb */
-      var57.x4[0] = var48.x4[0] - var49.x4[0];
-      var57.x4[1] = var48.x4[1] - var49.x4[1];
-      var57.x4[2] = var48.x4[2] - var49.x4[2];
-      var57.x4[3] = var48.x4[3] - var49.x4[3];
-      /* 3: splitlw */
-      {
-       orc_union32 _src;
-       _src.i = var57.i;
-       var58.i = _src.x2[1];
-       var59.i = _src.x2[0];
-    }
-      /* 4: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var59.i;
-       var60 = _src.x2[1];
-       var61 = _src.x2[0];
-    }
-      /* 5: splitwb */
-      {
-       orc_union16 _src;
-       _src.i = var58.i;
-       var62 = _src.x2[1];
-       var63 = _src.x2[0];
-    }
-      /* 6: convsbw */
-      var64.i = var60;
-      /* 7: convsbw */
-      var65.i = var63;
-      /* 8: convsbw */
-      var66.i = var62;
-      /* 10: mullw */
-      var67.i = (var64.i * var50.i) & 0xffff;
-      /* 11: shrsw */
-      var68.i = var67.i >> 8;
-      /* 12: addssw */
-      var69.i = ORC_CLAMP_SW(var64.i + var68.i);
-      /* 13: addssw */
-      var70.i = ORC_CLAMP_SW(var69.i + var66.i);
-      /* 15: mullw */
-      var71.i = (var66.i * var51.i) & 0xffff;
-      /* 16: shrsw */
-      var72.i = var71.i >> 8;
-      /* 17: subssw */
-      var73.i = ORC_CLAMP_SW(var70.i - var72.i);
-      /* 18: addssw */
-      var74.i = ORC_CLAMP_SW(var73.i + var66.i);
-      /* 19: addssw */
-      var75.i = ORC_CLAMP_SW(var69.i + var65.i);
-      /* 20: addssw */
-      var76.i = ORC_CLAMP_SW(var75.i + var65.i);
-      /* 22: mullw */
-      var77.i = (var65.i * var52.i) & 0xffff;
-      /* 23: shrsw */
-      var78.i = var77.i >> 8;
-      /* 24: addssw */
-      var79.i = ORC_CLAMP_SW(var76.i + var78.i);
-      /* 26: mullw */
-      var80.i = (var65.i * var53.i) & 0xffff;
-      /* 27: shrsw */
-      var81.i = var80.i >> 8;
-      /* 28: subssw */
-      var82.i = ORC_CLAMP_SW(var69.i - var81.i);
-      /* 30: mullw */
-      var83.i = (var66.i * var54.i) & 0xffff;
-      /* 31: shrsw */
-      var84.i = var83.i >> 8;
-      /* 32: subssw */
-      var85.i = ORC_CLAMP_SW(var82.i - var84.i);
-      /* 33: subssw */
-      var86.i = ORC_CLAMP_SW(var85.i - var84.i);
-      /* 34: convssswb */
-      var87 = ORC_CLAMP_SB(var74.i);
-      /* 35: convssswb */
-      var88 = ORC_CLAMP_SB(var86.i);
-      /* 36: convssswb */
-      var89 = ORC_CLAMP_SB(var79.i);
-      /* 37: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var87;
-       _dest.x2[1] = var88;
-       var90.i = _dest.i;
-    }
-      /* 38: mergebw */
-      {
-       orc_union16 _dest;
-       _dest.x2[0] = var89;
-       _dest.x2[1] = var61;
-       var91.i = _dest.i;
-    }
-      /* 39: mergewl */
-      {
-       orc_union32 _dest;
-       _dest.x2[0] = var90.i;
-       _dest.x2[1] = var91.i;
-       var92.i = _dest.i;
-    }
-      /* 41: addb */
-      var56.x4[0] = var92.x4[0] + var55.x4[0];
-      var56.x4[1] = var92.x4[1] + var55.x4[1];
-      var56.x4[2] = var92.x4[2] + var55.x4[2];
-      var56.x4[3] = var92.x4[3] + var55.x4[3];
-      /* 42: storel */
-      ptr0[i] = var56;
-    }
-  }
-
-}
-
-/* cogorc_convert_I420_BGRA */
-static void
-_backup_cogorc_convert_I420_BGRA (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  orc_int8 var45;
-  orc_int8 var46;
-  orc_int8 var47;
-  orc_int8 var48;
-  orc_union16 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_int8 var54;
-  orc_union32 var55;
-  orc_union32 var56;
-  orc_int8 var57;
-  orc_union16 var58;
-  orc_int8 var59;
-  orc_int8 var60;
-  orc_union16 var61;
-  orc_int8 var62;
-  orc_int8 var63;
-  orc_union16 var64;
-  orc_union16 var65;
-  orc_union16 var66;
-  orc_union16 var67;
-  orc_union16 var68;
-  orc_union16 var69;
-  orc_union16 var70;
-  orc_union16 var71;
-  orc_union16 var72;
-  orc_union16 var73;
-  orc_union16 var74;
-  orc_union16 var75;
-  orc_union16 var76;
-  orc_union16 var77;
-  orc_union16 var78;
-  orc_union16 var79;
-  orc_union16 var80;
-  orc_union16 var81;
-  orc_union16 var82;
-  orc_union16 var83;
-  orc_union16 var84;
-  orc_int8 var85;
-  orc_int8 var86;
-  orc_int8 var87;
-  orc_union16 var88;
-  orc_union16 var89;
-  orc_union32 var90;
-
-  ptr0 = (orc_union32 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-
-    /* 1: loadpb */
-    var46 = (int)0x00000080; /* 128 or 6.32404e-322f */
-    /* 5: loadpb */
-    var47 = (int)0x00000080; /* 128 or 6.32404e-322f */
-    /* 9: loadpb */
-    var48 = (int)0x00000080; /* 128 or 6.32404e-322f */
-    /* 12: loadpw */
-    var49.i = (int)0x0000002a; /* 42 or 2.07508e-322f */
-    /* 17: loadpw */
-    var50.i = (int)0x00000067; /* 103 or 5.08888e-322f */
-    /* 24: loadpw */
-    var51.i = (int)0x00000004; /* 4 or 1.97626e-323f */
-    /* 28: loadpw */
-    var52.i = (int)0x00000064; /* 100 or 4.94066e-322f */
-    /* 32: loadpw */
-    var53.i = (int)0x00000068; /* 104 or 5.13828e-322f */
-    /* 41: loadpb */
-    var54 = (int)0x000000ff; /* 255 or 1.25987e-321f */
-    /* 44: loadpb */
-    var55.x4[0] = (int)0x00000080; /* 128 or 6.32404e-322f */
-    var55.x4[1] = (int)0x00000080; /* 128 or 6.32404e-322f */
-    var55.x4[2] = (int)0x00000080; /* 128 or 6.32404e-322f */
-    var55.x4[3] = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var45 = ptr4[i];
-    /* 2: subb */
-    var57 = var45 - var46;
-    /* 3: convsbw */
-    var58.i = var57;
-    /* 4: loadupib */
-    var59 = (i&1) ? ((orc_uint8)ptr5[i>>1] + (orc_uint8)ptr5[(i>>1)+1] + 1)>>1 : ptr5[i>>1];
-    /* 6: subb */
-    var60 = var59 - var47;
-    /* 7: convsbw */
-    var61.i = var60;
-    /* 8: loadupib */
-    var62 = (i&1) ? ((orc_uint8)ptr6[i>>1] + (orc_uint8)ptr6[(i>>1)+1] + 1)>>1 : ptr6[i>>1];
-    /* 10: subb */
-    var63 = var62 - var48;
-    /* 11: convsbw */
-    var64.i = var63;
-    /* 13: mullw */
-    var65.i = (var58.i * var49.i) & 0xffff;
-    /* 14: shrsw */
-    var66.i = var65.i >> 8;
-    /* 15: addssw */
-    var67.i = ORC_CLAMP_SW(var58.i + var66.i);
-    /* 16: addssw */
-    var68.i = ORC_CLAMP_SW(var67.i + var64.i);
-    /* 18: mullw */
-    var69.i = (var64.i * var50.i) & 0xffff;
-    /* 19: shrsw */
-    var70.i = var69.i >> 8;
-    /* 20: subssw */
-    var71.i = ORC_CLAMP_SW(var68.i - var70.i);
-    /* 21: addssw */
-    var72.i = ORC_CLAMP_SW(var71.i + var64.i);
-    /* 22: addssw */
-    var73.i = ORC_CLAMP_SW(var67.i + var61.i);
-    /* 23: addssw */
-    var74.i = ORC_CLAMP_SW(var73.i + var61.i);
-    /* 25: mullw */
-    var75.i = (var61.i * var51.i) & 0xffff;
-    /* 26: shrsw */
-    var76.i = var75.i >> 8;
-    /* 27: addssw */
-    var77.i = ORC_CLAMP_SW(var74.i + var76.i);
-    /* 29: mullw */
-    var78.i = (var61.i * var52.i) & 0xffff;
-    /* 30: shrsw */
-    var79.i = var78.i >> 8;
-    /* 31: subssw */
-    var80.i = ORC_CLAMP_SW(var67.i - var79.i);
-    /* 33: mullw */
-    var81.i = (var64.i * var53.i) & 0xffff;
-    /* 34: shrsw */
-    var82.i = var81.i >> 8;
-    /* 35: subssw */
-    var83.i = ORC_CLAMP_SW(var80.i - var82.i);
-    /* 36: subssw */
-    var84.i = ORC_CLAMP_SW(var83.i - var82.i);
-    /* 37: convssswb */
-    var85 = ORC_CLAMP_SB(var72.i);
-    /* 38: convssswb */
-    var86 = ORC_CLAMP_SB(var84.i);
-    /* 39: convssswb */
-    var87 = ORC_CLAMP_SB(var77.i);
-    /* 40: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var87;
-       _dest.x2[1] = var86;
-       var88.i = _dest.i;
-    }
-    /* 42: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var85;
-       _dest.x2[1] = var54;
-       var89.i = _dest.i;
-    }
-    /* 43: mergewl */
-    {
-       orc_union32 _dest;
-       _dest.x2[0] = var88.i;
-       _dest.x2[1] = var89.i;
-       var90.i = _dest.i;
-    }
-    /* 45: addb */
-    var56.x4[0] = var90.x4[0] + var55.x4[0];
-    var56.x4[1] = var90.x4[1] + var55.x4[1];
-    var56.x4[2] = var90.x4[2] + var55.x4[2];
-    var56.x4[3] = var90.x4[3] + var55.x4[3];
-    /* 46: storel */
-    ptr0[i] = var56;
-  }
-
-}
-
-/* cogorc_convert_I420_BGRA_avg */
-static void
-_backup_cogorc_convert_I420_BGRA_avg (OrcExecutor * ORC_RESTRICT ex)
-{
-  int i;
-  int n = ex->n;
-  orc_union32 * ORC_RESTRICT ptr0;
-  const orc_int8 * ORC_RESTRICT ptr4;
-  const orc_int8 * ORC_RESTRICT ptr5;
-  const orc_int8 * ORC_RESTRICT ptr6;
-  const orc_int8 * ORC_RESTRICT ptr7;
-  const orc_int8 * ORC_RESTRICT ptr8;
-  orc_int8 var46;
-  orc_int8 var47;
-  orc_int8 var48;
-  orc_int8 var49;
-  orc_union16 var50;
-  orc_union16 var51;
-  orc_union16 var52;
-  orc_union16 var53;
-  orc_union16 var54;
-  orc_int8 var55;
-  orc_union32 var56;
-  orc_union32 var57;
-  orc_int8 var58;
-  orc_union16 var59;
-  orc_int8 var60;
-  orc_int8 var61;
-  orc_int8 var62;
-  orc_int8 var63;
-  orc_union16 var64;
-  orc_int8 var65;
-  orc_int8 var66;
-  orc_int8 var67;
-  orc_int8 var68;
-  orc_union16 var69;
-  orc_union16 var70;
-  orc_union16 var71;
-  orc_union16 var72;
-  orc_union16 var73;
-  orc_union16 var74;
-  orc_union16 var75;
-  orc_union16 var76;
-  orc_union16 var77;
-  orc_union16 var78;
-  orc_union16 var79;
-  orc_union16 var80;
-  orc_union16 var81;
-  orc_union16 var82;
-  orc_union16 var83;
-  orc_union16 var84;
-  orc_union16 var85;
-  orc_union16 var86;
-  orc_union16 var87;
-  orc_union16 var88;
-  orc_union16 var89;
-  orc_int8 var90;
-  orc_int8 var91;
-  orc_int8 var92;
-  orc_union16 var93;
-  orc_union16 var94;
-  orc_union32 var95;
-
-  ptr0 = (orc_union32 *)ex->arrays[0];
-  ptr4 = (orc_int8 *)ex->arrays[4];
-  ptr5 = (orc_int8 *)ex->arrays[5];
-  ptr6 = (orc_int8 *)ex->arrays[6];
-  ptr7 = (orc_int8 *)ex->arrays[7];
-  ptr8 = (orc_int8 *)ex->arrays[8];
-
-    /* 1: loadpb */
-    var47 = (int)0x00000080; /* 128 or 6.32404e-322f */
-    /* 7: loadpb */
-    var48 = (int)0x00000080; /* 128 or 6.32404e-322f */
-    /* 13: loadpb */
-    var49 = (int)0x00000080; /* 128 or 6.32404e-322f */
-    /* 16: loadpw */
-    var50.i = (int)0x0000002a; /* 42 or 2.07508e-322f */
-    /* 21: loadpw */
-    var51.i = (int)0x00000067; /* 103 or 5.08888e-322f */
-    /* 28: loadpw */
-    var52.i = (int)0x00000004; /* 4 or 1.97626e-323f */
-    /* 32: loadpw */
-    var53.i = (int)0x00000064; /* 100 or 4.94066e-322f */
-    /* 36: loadpw */
-    var54.i = (int)0x00000068; /* 104 or 5.13828e-322f */
-    /* 45: loadpb */
-    var55 = (int)0x000000ff; /* 255 or 1.25987e-321f */
-    /* 48: loadpb */
-    var56.x4[0] = (int)0x00000080; /* 128 or 6.32404e-322f */
-    var56.x4[1] = (int)0x00000080; /* 128 or 6.32404e-322f */
-    var56.x4[2] = (int)0x00000080; /* 128 or 6.32404e-322f */
-    var56.x4[3] = (int)0x00000080; /* 128 or 6.32404e-322f */
-
-  for (i = 0; i < n; i++) {
-    /* 0: loadb */
-    var46 = ptr4[i];
-    /* 2: subb */
-    var58 = var46 - var47;
-    /* 3: convsbw */
-    var59.i = var58;
-    /* 4: loadupib */
-    var60 = (i&1) ? ((orc_uint8)ptr5[i>>1] + (orc_uint8)ptr5[(i>>1)+1] + 1)>>1 : ptr5[i>>1];
-    /* 5: loadupib */
-    var61 = (i&1) ? ((orc_uint8)ptr6[i>>1] + (orc_uint8)ptr6[(i>>1)+1] + 1)>>1 : ptr6[i>>1];
-    /* 6: avgub */
-    var62 = ((orc_uint8)var60 + (orc_uint8)var61 + 1)>>1;
-    /* 8: subb */
-    var63 = var62 - var48;
-    /* 9: convsbw */
-    var64.i = var63;
-    /* 10: loadupib */
-    var65 = (i&1) ? ((orc_uint8)ptr7[i>>1] + (orc_uint8)ptr7[(i>>1)+1] + 1)>>1 : ptr7[i>>1];
-    /* 11: loadupib */
-    var66 = (i&1) ? ((orc_uint8)ptr8[i>>1] + (orc_uint8)ptr8[(i>>1)+1] + 1)>>1 : ptr8[i>>1];
-    /* 12: avgub */
-    var67 = ((orc_uint8)var65 + (orc_uint8)var66 + 1)>>1;
-    /* 14: subb */
-    var68 = var67 - var49;
-    /* 15: convsbw */
-    var69.i = var68;
-    /* 17: mullw */
-    var70.i = (var59.i * var50.i) & 0xffff;
-    /* 18: shrsw */
-    var71.i = var70.i >> 8;
-    /* 19: addssw */
-    var72.i = ORC_CLAMP_SW(var59.i + var71.i);
-    /* 20: addssw */
-    var73.i = ORC_CLAMP_SW(var72.i + var69.i);
-    /* 22: mullw */
-    var74.i = (var69.i * var51.i) & 0xffff;
-    /* 23: shrsw */
-    var75.i = var74.i >> 8;
-    /* 24: subssw */
-    var76.i = ORC_CLAMP_SW(var73.i - var75.i);
-    /* 25: addssw */
-    var77.i = ORC_CLAMP_SW(var76.i + var69.i);
-    /* 26: addssw */
-    var78.i = ORC_CLAMP_SW(var72.i + var64.i);
-    /* 27: addssw */
-    var79.i = ORC_CLAMP_SW(var78.i + var64.i);
-    /* 29: mullw */
-    var80.i = (var64.i * var52.i) & 0xffff;
-    /* 30: shrsw */
-    var81.i = var80.i >> 8;
-    /* 31: addssw */
-    var82.i = ORC_CLAMP_SW(var79.i + var81.i);
-    /* 33: mullw */
-    var83.i = (var64.i * var53.i) & 0xffff;
-    /* 34: shrsw */
-    var84.i = var83.i >> 8;
-    /* 35: subssw */
-    var85.i = ORC_CLAMP_SW(var72.i - var84.i);
-    /* 37: mullw */
-    var86.i = (var69.i * var54.i) & 0xffff;
-    /* 38: shrsw */
-    var87.i = var86.i >> 8;
-    /* 39: subssw */
-    var88.i = ORC_CLAMP_SW(var85.i - var87.i);
-    /* 40: subssw */
-    var89.i = ORC_CLAMP_SW(var88.i - var87.i);
-    /* 41: convssswb */
-    var90 = ORC_CLAMP_SB(var77.i);
-    /* 42: convssswb */
-    var91 = ORC_CLAMP_SB(var89.i);
-    /* 43: convssswb */
-    var92 = ORC_CLAMP_SB(var82.i);
-    /* 44: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var92;
-       _dest.x2[1] = var91;
-       var93.i = _dest.i;
-    }
-    /* 46: mergebw */
-    {
-       orc_union16 _dest;
-       _dest.x2[0] = var90;
-       _dest.x2[1] = var55;
-       var94.i = _dest.i;
-    }
-    /* 47: mergewl */
-    {
-       orc_union32 _dest;
-       _dest.x2[0] = var93.i;
-       _dest.x2[1] = var94.i;
-       var95.i = _dest.i;
-    }
-    /* 49: addb */
-    var57.x4[0] = var95.x4[0] + var56.x4[0];
-    var57.x4[1] = var95.x4[1] + var56.x4[1];
-    var57.x4[2] = var95.x4[2] + var56.x4[2];
-    var57.x4[3] = var95.x4[3] + var56.x4[3];
-    /* 50: storel */
-    ptr0[i] = var57;
-  }
-
-}
-
-
-static int quiet = 0;
-static int benchmark = 0;
-
-static void help (const char *argv0)
-{
-  printf("Usage:\n");
-  printf("  %s [OPTION]\n", argv0);
-  printf("Help Options:\n");
-  printf("  -h, --help          Show help options\n");
-  printf("Application Options:\n");
-  printf("  -b, --benchmark     Run benchmark and show results\n");
-  printf("  -q, --quiet         Don't output anything except on failures\n");
-
-  exit(0);
-}
-
-int
-main (int argc, char *argv[])
-{
-  int error = FALSE;
-  int i;
-
-  orc_test_init ();
-
-  for(i=1;i<argc;i++) {
-    if (strcmp(argv[i], "--help") == 0 ||
-      strcmp(argv[i], "-h") == 0) {
-      help(argv[0]);
-    } else if (strcmp(argv[i], "--quiet") == 0 ||
-      strcmp(argv[i], "-q") == 0) {
-      quiet = 1;
-      benchmark = 0;
-    } else if (strcmp(argv[i], "--benchmark") == 0 ||
-      strcmp(argv[i], "-b") == 0) {
-      benchmark = 1;
-      quiet = 0;
-    }
-  }
-
-  /* cogorc_memcpy_2d */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_memcpy_2d:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_memcpy_2d");
-    orc_program_set_backup_function (p, _backup_cogorc_memcpy_2d);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-
-      orc_program_append_2 (p, "copyb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_downsample_horiz_cosite_1tap */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_downsample_horiz_cosite_1tap:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_downsample_horiz_cosite_1tap");
-    orc_program_set_backup_function (p, _backup_cogorc_downsample_horiz_cosite_1tap);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 2, "s1");
-
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_downsample_horiz_cosite_3tap */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_downsample_horiz_cosite_3tap:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_downsample_horiz_cosite_3tap");
-    orc_program_set_backup_function (p, _backup_cogorc_downsample_horiz_cosite_3tap);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 2, "s2");
-      orc_program_add_constant (p, 4, 0x00000002, "c1");
-    orc_program_add_temporary (p, 1, "t1");
-    orc_program_add_temporary (p, 1, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-    orc_program_add_temporary (p, 2, "t4");
-    orc_program_add_temporary (p, 2, "t5");
-    orc_program_add_temporary (p, 2, "t6");
-
-      orc_program_append_2 (p, "copyw", 0, ORC_VAR_T4, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_T1, ORC_VAR_T4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_T2, ORC_VAR_T4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_T3, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T4, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T5, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T6, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T5, ORC_VAR_T5, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T4, ORC_VAR_T4, ORC_VAR_T6, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T4, ORC_VAR_T4, ORC_VAR_T5, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T4, ORC_VAR_T4, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T4, ORC_VAR_T4, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T4, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_downsample_420_jpeg */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_downsample_420_jpeg:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_downsample_420_jpeg");
-    orc_program_set_backup_function (p, _backup_cogorc_downsample_420_jpeg);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 2, "s2");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 1, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-    orc_program_add_temporary (p, 1, "t4");
-    orc_program_add_temporary (p, 1, "t5");
-
-      orc_program_append_2 (p, "copyw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_T3, ORC_VAR_D1);
-      orc_program_append_2 (p, "copyw", 0, ORC_VAR_T1, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_T4, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_T4, ORC_VAR_T4, ORC_VAR_T5, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_T4, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_downsample_vert_halfsite_2tap */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_downsample_vert_halfsite_2tap:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_downsample_vert_halfsite_2tap");
-    orc_program_set_backup_function (p, _backup_cogorc_downsample_vert_halfsite_2tap);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_S2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_downsample_vert_cosite_3tap */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_downsample_vert_cosite_3tap:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_downsample_vert_cosite_3tap");
-    orc_program_set_backup_function (p, _backup_cogorc_downsample_vert_cosite_3tap);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-      orc_program_add_constant (p, 4, 0x00000002, "c1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T3, ORC_VAR_S3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T3, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_downsample_vert_halfsite_4tap */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_downsample_vert_halfsite_4tap:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_downsample_vert_halfsite_4tap");
-    orc_program_set_backup_function (p, _backup_cogorc_downsample_vert_halfsite_4tap);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_source (p, 1, "s4");
-      orc_program_add_constant (p, 4, 0x0000001a, "c1");
-      orc_program_add_constant (p, 4, 0x00000006, "c2");
-      orc_program_add_constant (p, 4, 0x00000020, "c3");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-    orc_program_add_temporary (p, 2, "t4");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T3, ORC_VAR_S3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T4, ORC_VAR_S4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_T3, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T4, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C3, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_upsample_horiz_cosite_1tap */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_upsample_horiz_cosite_1tap:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_upsample_horiz_cosite_1tap");
-    orc_program_set_backup_function (p, _backup_cogorc_upsample_horiz_cosite_1tap);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_temporary (p, 1, "t1");
-
-      orc_program_append_2 (p, "copyb", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_upsample_horiz_cosite */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_upsample_horiz_cosite:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_upsample_horiz_cosite");
-    orc_program_set_backup_function (p, _backup_cogorc_upsample_horiz_cosite);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_temporary (p, 1, "t1");
-    orc_program_add_temporary (p, 1, "t2");
-
-      orc_program_append_2 (p, "copyb", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_S2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_upsample_vert_avgub */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_upsample_vert_avgub:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_upsample_vert_avgub");
-    orc_program_set_backup_function (p, _backup_cogorc_upsample_vert_avgub);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_S2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_unpack_yuyv_y */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_unpack_yuyv_y:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_unpack_yuyv_y");
-    orc_program_set_backup_function (p, _backup_orc_unpack_yuyv_y);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 2, "s1");
-
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_unpack_yuyv_u */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_unpack_yuyv_u:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_unpack_yuyv_u");
-    orc_program_set_backup_function (p, _backup_orc_unpack_yuyv_u);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "select0lw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_unpack_yuyv_v */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_unpack_yuyv_v:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_unpack_yuyv_v");
-    orc_program_set_backup_function (p, _backup_orc_unpack_yuyv_v);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "select1lw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_pack_yuyv */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_pack_yuyv:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_pack_yuyv");
-    orc_program_set_backup_function (p, _backup_orc_pack_yuyv);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_temporary (p, 1, "t1");
-    orc_program_add_temporary (p, 1, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-    orc_program_add_temporary (p, 2, "t4");
-    orc_program_add_temporary (p, 2, "t5");
-
-      orc_program_append_2 (p, "copyw", 0, ORC_VAR_T5, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_T1, ORC_VAR_T5, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_T2, ORC_VAR_T5, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_S2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T4, ORC_VAR_T2, ORC_VAR_S3, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_D1, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_unpack_uyvy_y */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_unpack_uyvy_y:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_unpack_uyvy_y");
-    orc_program_set_backup_function (p, _backup_orc_unpack_uyvy_y);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 2, "s1");
-
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_unpack_uyvy_u */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_unpack_uyvy_u:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_unpack_uyvy_u");
-    orc_program_set_backup_function (p, _backup_orc_unpack_uyvy_u);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "select0lw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_unpack_uyvy_v */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_unpack_uyvy_v:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_unpack_uyvy_v");
-    orc_program_set_backup_function (p, _backup_orc_unpack_uyvy_v);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "select1lw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_pack_uyvy */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_pack_uyvy:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_pack_uyvy");
-    orc_program_set_backup_function (p, _backup_orc_pack_uyvy);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_temporary (p, 1, "t1");
-    orc_program_add_temporary (p, 1, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-    orc_program_add_temporary (p, 2, "t4");
-    orc_program_add_temporary (p, 2, "t5");
-
-      orc_program_append_2 (p, "copyw", 0, ORC_VAR_T5, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_T1, ORC_VAR_T5, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_T2, ORC_VAR_T5, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T3, ORC_VAR_S2, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T4, ORC_VAR_S3, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_D1, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_addc_convert_u8_s16 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_addc_convert_u8_s16:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_addc_convert_u8_s16");
-    orc_program_set_backup_function (p, _backup_orc_addc_convert_u8_s16);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 2, "s1");
-      orc_program_add_constant (p, 4, 0x00000080, "c1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_subc_convert_s16_u8 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_subc_convert_s16_u8:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_subc_convert_s16_u8");
-    orc_program_set_backup_function (p, _backup_orc_subc_convert_s16_u8);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_source (p, 1, "s1");
-      orc_program_add_constant (p, 4, 0x00000080, "c1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subw", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_splat_u8_ns */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_splat_u8_ns:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_splat_u8_ns");
-    orc_program_set_backup_function (p, _backup_orc_splat_u8_ns);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_parameter (p, 1, "p1");
-
-      orc_program_append_2 (p, "copyb", 0, ORC_VAR_D1, ORC_VAR_P1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_splat_s16_ns */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_splat_s16_ns:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_splat_s16_ns");
-    orc_program_set_backup_function (p, _backup_orc_splat_s16_ns);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_parameter (p, 2, "p1");
-
-      orc_program_append_2 (p, "copyw", 0, ORC_VAR_D1, ORC_VAR_P1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_matrix2_u8 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_matrix2_u8:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_matrix2_u8");
-    orc_program_set_backup_function (p, _backup_orc_matrix2_u8);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-      orc_program_add_constant (p, 4, 0x00000006, "c1");
-    orc_program_add_parameter (p, 2, "p1");
-    orc_program_add_parameter (p, 2, "p2");
-    orc_program_add_parameter (p, 2, "p3");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P3, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_matrix2_11_u8 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_matrix2_11_u8:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_matrix2_11_u8");
-    orc_program_set_backup_function (p, _backup_orc_matrix2_11_u8);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-      orc_program_add_constant (p, 4, 0x00000010, "c1");
-      orc_program_add_constant (p, 4, 0x00000080, "c2");
-      orc_program_add_constant (p, 4, 0x00000008, "c3");
-    orc_program_add_parameter (p, 2, "p1");
-    orc_program_add_parameter (p, 2, "p2");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-    orc_program_add_temporary (p, 2, "t4");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_P1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T4, ORC_VAR_T2, ORC_VAR_P2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C3, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_matrix2_12_u8 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_matrix2_12_u8:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_matrix2_12_u8");
-    orc_program_set_backup_function (p, _backup_orc_matrix2_12_u8);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-      orc_program_add_constant (p, 4, 0x00000010, "c1");
-      orc_program_add_constant (p, 4, 0x00000080, "c2");
-      orc_program_add_constant (p, 4, 0x00000008, "c3");
-    orc_program_add_parameter (p, 2, "p1");
-    orc_program_add_parameter (p, 2, "p2");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-    orc_program_add_temporary (p, 2, "t4");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_P1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T4, ORC_VAR_T2, ORC_VAR_P2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C3, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_matrix3_u8 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_matrix3_u8:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_matrix3_u8");
-    orc_program_set_backup_function (p, _backup_orc_matrix3_u8);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-      orc_program_add_constant (p, 4, 0x00000006, "c1");
-    orc_program_add_parameter (p, 2, "p1");
-    orc_program_add_parameter (p, 2, "p2");
-    orc_program_add_parameter (p, 2, "p3");
-    orc_program_add_parameter (p, 2, "p4");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P3, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P4, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_matrix3_100_u8 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_matrix3_100_u8:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_matrix3_100_u8");
-    orc_program_set_backup_function (p, _backup_orc_matrix3_100_u8);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-      orc_program_add_constant (p, 4, 0x00000010, "c1");
-      orc_program_add_constant (p, 4, 0x00000080, "c2");
-      orc_program_add_constant (p, 4, 0x00000008, "c3");
-    orc_program_add_parameter (p, 2, "p1");
-    orc_program_add_parameter (p, 2, "p2");
-    orc_program_add_parameter (p, 2, "p3");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_P1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P3, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C3, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_matrix3_100_offset_u8 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_matrix3_100_offset_u8:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_matrix3_100_offset_u8");
-    orc_program_set_backup_function (p, _backup_orc_matrix3_100_offset_u8);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_parameter (p, 2, "p1");
-    orc_program_add_parameter (p, 2, "p2");
-    orc_program_add_parameter (p, 2, "p3");
-    orc_program_add_parameter (p, 2, "p4");
-    orc_program_add_parameter (p, 2, "p5");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T3, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T3, ORC_VAR_P1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P3, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P4, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P5, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T3, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_matrix3_000_u8 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_matrix3_000_u8:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_matrix3_000_u8");
-    orc_program_set_backup_function (p, _backup_orc_matrix3_000_u8);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_parameter (p, 2, "p1");
-    orc_program_add_parameter (p, 2, "p2");
-    orc_program_add_parameter (p, 2, "p3");
-    orc_program_add_parameter (p, 2, "p4");
-    orc_program_add_parameter (p, 2, "p5");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P3, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P4, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P5, ORC_VAR_D1);
-      orc_program_append_2 (p, "convwb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_pack_123x */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_pack_123x:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_pack_123x");
-    orc_program_set_backup_function (p, _backup_orc_pack_123x);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_parameter (p, 1, "p1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_S2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_S3, ORC_VAR_P1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* orc_pack_x123 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("orc_pack_x123:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "orc_pack_x123");
-    orc_program_set_backup_function (p, _backup_orc_pack_x123);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_parameter (p, 1, "p1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_P1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_S3, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_combine2_u8 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_combine2_u8:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_combine2_u8");
-    orc_program_set_backup_function (p, _backup_cogorc_combine2_u8);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-      orc_program_add_constant (p, 4, 0x00000008, "c1");
-    orc_program_add_parameter (p, 2, "p1");
-    orc_program_add_parameter (p, 2, "p2");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "shruw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_combine4_u8 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_combine4_u8:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_combine4_u8");
-    orc_program_set_backup_function (p, _backup_cogorc_combine4_u8);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_source (p, 1, "s4");
-      orc_program_add_constant (p, 4, 0x00000020, "c1");
-      orc_program_add_constant (p, 4, 0x00000006, "c2");
-    orc_program_add_parameter (p, 2, "p1");
-    orc_program_add_parameter (p, 2, "p2");
-    orc_program_add_parameter (p, 2, "p3");
-    orc_program_add_parameter (p, 2, "p4");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_P1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P3, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T2, ORC_VAR_S4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_P4, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsuswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_unpack_axyz_0 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_unpack_axyz_0:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_unpack_axyz_0");
-    orc_program_set_backup_function (p, _backup_cogorc_unpack_axyz_0);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "select0lw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_unpack_axyz_1 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_unpack_axyz_1:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_unpack_axyz_1");
-    orc_program_set_backup_function (p, _backup_cogorc_unpack_axyz_1);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "select0lw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_unpack_axyz_2 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_unpack_axyz_2:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_unpack_axyz_2");
-    orc_program_set_backup_function (p, _backup_cogorc_unpack_axyz_2);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "select1lw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select0wb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_unpack_axyz_3 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_unpack_axyz_3:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_unpack_axyz_3");
-    orc_program_set_backup_function (p, _backup_cogorc_unpack_axyz_3);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "select1lw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_resample_horiz_1tap */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_resample_horiz_1tap:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_resample_horiz_1tap");
-    orc_program_set_backup_function (p, _backup_cogorc_resample_horiz_1tap);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_parameter (p, 4, "p1");
-    orc_program_add_parameter (p, 4, "p2");
-
-      orc_program_append_2 (p, "ldresnearb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_P2);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_resample_horiz_2tap */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_resample_horiz_2tap:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_resample_horiz_2tap");
-    orc_program_set_backup_function (p, _backup_cogorc_resample_horiz_2tap);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_parameter (p, 4, "p1");
-    orc_program_add_parameter (p, 4, "p2");
-
-      orc_program_append_2 (p, "ldreslinb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_P2);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_I420_UYVY */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_I420_UYVY:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_convert_I420_UYVY");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_I420_UYVY);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_destination (p, 4, "d2");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 2, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_source (p, 1, "s4");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_S3, ORC_VAR_S4, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_D2, ORC_VAR_T1, ORC_VAR_S2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_I420_YUY2 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_I420_YUY2:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_convert_I420_YUY2");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_I420_YUY2);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_destination (p, 4, "d2");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 2, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_source (p, 1, "s4");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_S3, ORC_VAR_S4, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_D2, ORC_VAR_S2, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_I420_AYUV */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_I420_AYUV:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_convert_I420_AYUV");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_I420_AYUV);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_destination (p, 4, "d2");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_source (p, 1, "s4");
-      orc_program_add_constant (p, 1, 0x000000ff, "c1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-    orc_program_add_temporary (p, 1, "t4");
-
-      orc_program_append_2 (p, "loadupdb", 0, ORC_VAR_T3, ORC_VAR_S3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "loadupdb", 0, ORC_VAR_T4, ORC_VAR_S4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_C1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_C1, ORC_VAR_S2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_D2, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_YUY2_I420 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_YUY2_I420:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_convert_YUY2_I420");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_YUY2_I420);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_destination (p, 2, "d2");
-    orc_program_add_destination (p, 1, "d3");
-    orc_program_add_destination (p, 1, "d4");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_source (p, 4, "s2");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_T1, ORC_VAR_T3, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "storew", 0, ORC_VAR_D1, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_T2, ORC_VAR_T3, ORC_VAR_S2, ORC_VAR_D1);
-      orc_program_append_2 (p, "storew", 0, ORC_VAR_D2, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 1, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_D4, ORC_VAR_D3, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_UYVY_YUY2 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_UYVY_YUY2:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_UYVY_YUY2");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_UYVY_YUY2);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 4, "s1");
-
-      orc_program_append_2 (p, "swapw", 1, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_planar_chroma_420_422 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_planar_chroma_420_422:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_planar_chroma_420_422");
-    orc_program_set_backup_function (p, _backup_cogorc_planar_chroma_420_422);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_destination (p, 1, "d2");
-    orc_program_add_source (p, 1, "s1");
-
-      orc_program_append_2 (p, "copyb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "copyb", 0, ORC_VAR_D2, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_planar_chroma_420_444 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_planar_chroma_420_444:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_planar_chroma_420_444");
-    orc_program_set_backup_function (p, _backup_cogorc_planar_chroma_420_444);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_destination (p, 2, "d2");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "splatbw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "storew", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "storew", 0, ORC_VAR_D2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_planar_chroma_422_444 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_planar_chroma_422_444:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_planar_chroma_422_444");
-    orc_program_set_backup_function (p, _backup_cogorc_planar_chroma_422_444);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "splatbw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "storew", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_planar_chroma_444_422 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_planar_chroma_444_422:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_planar_chroma_444_422");
-    orc_program_set_backup_function (p, _backup_cogorc_planar_chroma_444_422);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_temporary (p, 1, "t1");
-    orc_program_add_temporary (p, 1, "t2");
-
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_planar_chroma_444_420 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_planar_chroma_444_420:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_planar_chroma_444_420");
-    orc_program_set_backup_function (p, _backup_cogorc_planar_chroma_444_420);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 2, "s2");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 1, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-
-      orc_program_append_2 (p, "avgub", 1, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_S2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T2, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_T3, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_planar_chroma_422_420 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_planar_chroma_422_420:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_planar_chroma_422_420");
-    orc_program_set_backup_function (p, _backup_cogorc_planar_chroma_422_420);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_S2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_YUY2_AYUV */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_YUY2_AYUV:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_YUY2_AYUV");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_YUY2_AYUV);
-    orc_program_add_destination (p, 8, "d1");
-    orc_program_add_source (p, 4, "s1");
-      orc_program_add_constant (p, 2, 0x000000ff, "c1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 4, "t3");
-    orc_program_add_temporary (p, 4, "t4");
-
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_T3, ORC_VAR_C1, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_T4, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 1, ORC_VAR_D1, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_UYVY_AYUV */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_UYVY_AYUV:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_UYVY_AYUV");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_UYVY_AYUV);
-    orc_program_add_destination (p, 8, "d1");
-    orc_program_add_source (p, 4, "s1");
-      orc_program_add_constant (p, 2, 0x000000ff, "c1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 4, "t3");
-    orc_program_add_temporary (p, 4, "t4");
-
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_T3, ORC_VAR_C1, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_T4, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 1, ORC_VAR_D1, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_YUY2_Y42B */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_YUY2_Y42B:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_YUY2_Y42B");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_YUY2_Y42B);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_destination (p, 1, "d2");
-    orc_program_add_destination (p, 1, "d3");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_D3, ORC_VAR_D2, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_UYVY_Y42B */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_UYVY_Y42B:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_UYVY_Y42B");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_UYVY_Y42B);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_destination (p, 1, "d2");
-    orc_program_add_destination (p, 1, "d3");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_D3, ORC_VAR_D2, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_YUY2_Y444 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_YUY2_Y444:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_YUY2_Y444");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_YUY2_Y444);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_destination (p, 2, "d2");
-    orc_program_add_destination (p, 2, "d3");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 1, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splatbw", 0, ORC_VAR_D2, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splatbw", 0, ORC_VAR_D3, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_UYVY_Y444 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_UYVY_Y444:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_UYVY_Y444");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_UYVY_Y444);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_destination (p, 2, "d2");
-    orc_program_add_destination (p, 2, "d3");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 1, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splatbw", 0, ORC_VAR_D2, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splatbw", 0, ORC_VAR_D3, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_UYVY_I420 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_UYVY_I420:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_convert_UYVY_I420");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_UYVY_I420);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_destination (p, 2, "d2");
-    orc_program_add_destination (p, 1, "d3");
-    orc_program_add_destination (p, 1, "d4");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_source (p, 4, "s2");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "storew", 0, ORC_VAR_D1, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_D1);
-      orc_program_append_2 (p, "storew", 0, ORC_VAR_D2, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 1, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_D4, ORC_VAR_D3, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_AYUV_I420 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_AYUV_I420:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_AYUV_I420");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_AYUV_I420);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_destination (p, 2, "d2");
-    orc_program_add_destination (p, 1, "d3");
-    orc_program_add_destination (p, 1, "d4");
-    orc_program_add_source (p, 8, "s1");
-    orc_program_add_source (p, 8, "s2");
-    orc_program_add_temporary (p, 4, "t1");
-    orc_program_add_temporary (p, 4, "t2");
-    orc_program_add_temporary (p, 4, "t3");
-    orc_program_add_temporary (p, 4, "t4");
-    orc_program_add_temporary (p, 2, "t5");
-    orc_program_add_temporary (p, 2, "t6");
-    orc_program_add_temporary (p, 1, "t7");
-    orc_program_add_temporary (p, 1, "t8");
-
-      orc_program_append_2 (p, "splitlw", 1, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 1, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitlw", 1, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_S2, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 1, ORC_VAR_D2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 2, ORC_VAR_T4, ORC_VAR_T2, ORC_VAR_T3, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 1, ORC_VAR_T6, ORC_VAR_T5, ORC_VAR_T4, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T7, ORC_VAR_T8, ORC_VAR_T5, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_D3, ORC_VAR_T7, ORC_VAR_T8, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T7, ORC_VAR_T8, ORC_VAR_T6, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_D4, ORC_VAR_T7, ORC_VAR_T8, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_AYUV_YUY2 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_AYUV_YUY2:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_AYUV_YUY2");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_AYUV_YUY2);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 8, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-    orc_program_add_temporary (p, 4, "t4");
-    orc_program_add_temporary (p, 4, "t5");
-
-      orc_program_append_2 (p, "splitlw", 1, ORC_VAR_T5, ORC_VAR_T4, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitlw", 0, ORC_VAR_T2, ORC_VAR_T3, ORC_VAR_T5, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 1, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_T3, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 1, ORC_VAR_T1, ORC_VAR_T4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_AYUV_UYVY */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_AYUV_UYVY:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_AYUV_UYVY");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_AYUV_UYVY);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 8, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-    orc_program_add_temporary (p, 4, "t4");
-    orc_program_add_temporary (p, 4, "t5");
-
-      orc_program_append_2 (p, "splitlw", 1, ORC_VAR_T5, ORC_VAR_T4, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitlw", 0, ORC_VAR_T2, ORC_VAR_T3, ORC_VAR_T5, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 1, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_T3, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 1, ORC_VAR_T1, ORC_VAR_T4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_AYUV_Y42B */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_AYUV_Y42B:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_AYUV_Y42B");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_AYUV_Y42B);
-    orc_program_add_destination (p, 2, "d1");
-    orc_program_add_destination (p, 1, "d2");
-    orc_program_add_destination (p, 1, "d3");
-    orc_program_add_source (p, 8, "s1");
-    orc_program_add_temporary (p, 4, "t1");
-    orc_program_add_temporary (p, 4, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-    orc_program_add_temporary (p, 2, "t4");
-
-      orc_program_append_2 (p, "splitlw", 1, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitlw", 0, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 1, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_D3, ORC_VAR_D2, ORC_VAR_T3, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 1, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_AYUV_Y444 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_AYUV_Y444:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_AYUV_Y444");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_AYUV_Y444);
-    orc_program_add_destination (p, 1, "d1");
-    orc_program_add_destination (p, 1, "d2");
-    orc_program_add_destination (p, 1, "d3");
-    orc_program_add_source (p, 4, "s1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-
-      orc_program_append_2 (p, "splitlw", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_D3, ORC_VAR_D2, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "select1wb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_Y42B_YUY2 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_Y42B_YUY2:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_Y42B_YUY2");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_Y42B_YUY2);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_S2, ORC_VAR_S3, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_Y42B_UYVY */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_Y42B_UYVY:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_Y42B_UYVY");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_Y42B_UYVY);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_temporary (p, 2, "t1");
-
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_S2, ORC_VAR_S3, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_Y42B_AYUV */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_Y42B_AYUV:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_Y42B_AYUV");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_Y42B_AYUV);
-    orc_program_add_destination (p, 8, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-      orc_program_add_constant (p, 1, 0x000000ff, "c1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 4, "t3");
-    orc_program_add_temporary (p, 4, "t4");
-
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_S2, ORC_VAR_S3, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_T4, ORC_VAR_C1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 1, ORC_VAR_D1, ORC_VAR_T4, ORC_VAR_T3, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_Y444_YUY2 */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_Y444_YUY2:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_Y444_YUY2");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_Y444_YUY2);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 2, "s2");
-    orc_program_add_source (p, 2, "s3");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 4, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-    orc_program_add_temporary (p, 2, "t4");
-
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_S3, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitlw", 0, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 1, ORC_VAR_T1, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_Y444_UYVY */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_Y444_UYVY:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_Y444_UYVY");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_Y444_UYVY);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 2, "s1");
-    orc_program_add_source (p, 2, "s2");
-    orc_program_add_source (p, 2, "s3");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 4, "t2");
-    orc_program_add_temporary (p, 2, "t3");
-    orc_program_add_temporary (p, 2, "t4");
-
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_T2, ORC_VAR_S2, ORC_VAR_S3, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitlw", 0, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 1, ORC_VAR_T1, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 1, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_Y444_AYUV */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_Y444_AYUV:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_Y444_AYUV");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_Y444_AYUV);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-      orc_program_add_constant (p, 1, 0x000000ff, "c1");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_S2, ORC_VAR_S3, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_C1, ORC_VAR_S1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_AYUV_ARGB */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_AYUV_ARGB:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_AYUV_ARGB");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_AYUV_ARGB);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 4, "s1");
-      orc_program_add_constant (p, 1, 0x00000008, "c1");
-      orc_program_add_constant (p, 4, 0x00000080, "c2");
-      orc_program_add_constant (p, 4, 0x0000002a, "c3");
-      orc_program_add_constant (p, 4, 0x00000067, "c4");
-      orc_program_add_constant (p, 4, 0x00000004, "c5");
-      orc_program_add_constant (p, 4, 0x00000064, "c6");
-      orc_program_add_constant (p, 4, 0x00000068, "c7");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-    orc_program_add_temporary (p, 1, "t4");
-    orc_program_add_temporary (p, 1, "t5");
-    orc_program_add_temporary (p, 1, "t6");
-    orc_program_add_temporary (p, 2, "t7");
-    orc_program_add_temporary (p, 2, "t8");
-    orc_program_add_temporary (p, 2, "t9");
-    orc_program_add_temporary (p, 2, "t10");
-    orc_program_add_temporary (p, 2, "t11");
-    orc_program_add_temporary (p, 2, "t12");
-    orc_program_add_temporary (p, 1, "t13");
-    orc_program_add_temporary (p, 1, "t14");
-    orc_program_add_temporary (p, 1, "t15");
-    orc_program_add_temporary (p, 4, "t16");
-
-      orc_program_append_2 (p, "subb", 2, 47, ORC_VAR_S1, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitlw", 0, ORC_VAR_T1, ORC_VAR_T2, 47, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T4, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T6, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T7, ORC_VAR_T4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T8, ORC_VAR_T5, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T9, ORC_VAR_T6, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T7, ORC_VAR_C3, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T7, ORC_VAR_T7, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T7, ORC_VAR_T9, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T9, ORC_VAR_C4, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T10, ORC_VAR_T10, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T10, ORC_VAR_T9, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T7, ORC_VAR_T8, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T12, ORC_VAR_T8, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T8, ORC_VAR_C5, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T12, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T8, ORC_VAR_C6, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T7, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T9, ORC_VAR_C7, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T11, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T11, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T13, ORC_VAR_T10, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T14, ORC_VAR_T11, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T15, ORC_VAR_T12, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_T3, ORC_VAR_T13, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_T14, ORC_VAR_T15, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, 47, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addb", 2, ORC_VAR_D1, 47, ORC_VAR_C2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_AYUV_BGRA */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_AYUV_BGRA:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_AYUV_BGRA");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_AYUV_BGRA);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 4, "s1");
-      orc_program_add_constant (p, 1, 0x00000008, "c1");
-      orc_program_add_constant (p, 4, 0x00000080, "c2");
-      orc_program_add_constant (p, 4, 0x0000002a, "c3");
-      orc_program_add_constant (p, 4, 0x00000067, "c4");
-      orc_program_add_constant (p, 4, 0x00000004, "c5");
-      orc_program_add_constant (p, 4, 0x00000064, "c6");
-      orc_program_add_constant (p, 4, 0x00000068, "c7");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-    orc_program_add_temporary (p, 1, "t4");
-    orc_program_add_temporary (p, 1, "t5");
-    orc_program_add_temporary (p, 1, "t6");
-    orc_program_add_temporary (p, 2, "t7");
-    orc_program_add_temporary (p, 2, "t8");
-    orc_program_add_temporary (p, 2, "t9");
-    orc_program_add_temporary (p, 2, "t10");
-    orc_program_add_temporary (p, 2, "t11");
-    orc_program_add_temporary (p, 2, "t12");
-    orc_program_add_temporary (p, 1, "t13");
-    orc_program_add_temporary (p, 1, "t14");
-    orc_program_add_temporary (p, 1, "t15");
-    orc_program_add_temporary (p, 4, "t16");
-
-      orc_program_append_2 (p, "subb", 2, 47, ORC_VAR_S1, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitlw", 0, ORC_VAR_T1, ORC_VAR_T2, 47, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T4, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T6, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T7, ORC_VAR_T4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T8, ORC_VAR_T5, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T9, ORC_VAR_T6, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T7, ORC_VAR_C3, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T7, ORC_VAR_T7, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T7, ORC_VAR_T9, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T9, ORC_VAR_C4, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T10, ORC_VAR_T10, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T10, ORC_VAR_T9, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T7, ORC_VAR_T8, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T12, ORC_VAR_T8, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T8, ORC_VAR_C5, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T12, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T8, ORC_VAR_C6, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T7, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T9, ORC_VAR_C7, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T11, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T11, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T13, ORC_VAR_T10, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T14, ORC_VAR_T11, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T15, ORC_VAR_T12, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_T15, ORC_VAR_T14, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_T13, ORC_VAR_T3, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, 47, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addb", 2, ORC_VAR_D1, 47, ORC_VAR_C2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_AYUV_ABGR */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_AYUV_ABGR:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_AYUV_ABGR");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_AYUV_ABGR);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 4, "s1");
-      orc_program_add_constant (p, 1, 0x00000008, "c1");
-      orc_program_add_constant (p, 4, 0x00000080, "c2");
-      orc_program_add_constant (p, 4, 0x0000002a, "c3");
-      orc_program_add_constant (p, 4, 0x00000067, "c4");
-      orc_program_add_constant (p, 4, 0x00000004, "c5");
-      orc_program_add_constant (p, 4, 0x00000064, "c6");
-      orc_program_add_constant (p, 4, 0x00000068, "c7");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-    orc_program_add_temporary (p, 1, "t4");
-    orc_program_add_temporary (p, 1, "t5");
-    orc_program_add_temporary (p, 1, "t6");
-    orc_program_add_temporary (p, 2, "t7");
-    orc_program_add_temporary (p, 2, "t8");
-    orc_program_add_temporary (p, 2, "t9");
-    orc_program_add_temporary (p, 2, "t10");
-    orc_program_add_temporary (p, 2, "t11");
-    orc_program_add_temporary (p, 2, "t12");
-    orc_program_add_temporary (p, 1, "t13");
-    orc_program_add_temporary (p, 1, "t14");
-    orc_program_add_temporary (p, 1, "t15");
-    orc_program_add_temporary (p, 4, "t16");
-
-      orc_program_append_2 (p, "subb", 2, 47, ORC_VAR_S1, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitlw", 0, ORC_VAR_T1, ORC_VAR_T2, 47, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T4, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T6, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T7, ORC_VAR_T4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T8, ORC_VAR_T5, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T9, ORC_VAR_T6, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T7, ORC_VAR_C3, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T7, ORC_VAR_T7, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T7, ORC_VAR_T9, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T9, ORC_VAR_C4, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T10, ORC_VAR_T10, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T10, ORC_VAR_T9, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T7, ORC_VAR_T8, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T12, ORC_VAR_T8, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T8, ORC_VAR_C5, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T12, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T8, ORC_VAR_C6, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T7, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T9, ORC_VAR_C7, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T11, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T11, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T13, ORC_VAR_T10, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T14, ORC_VAR_T11, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T15, ORC_VAR_T12, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_T3, ORC_VAR_T15, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_T14, ORC_VAR_T13, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, 47, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addb", 2, ORC_VAR_D1, 47, ORC_VAR_C2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_AYUV_RGBA */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_AYUV_RGBA:\n");
-    p = orc_program_new ();
-      orc_program_set_2d (p);
-    orc_program_set_name (p, "cogorc_convert_AYUV_RGBA");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_AYUV_RGBA);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 4, "s1");
-      orc_program_add_constant (p, 1, 0x00000008, "c1");
-      orc_program_add_constant (p, 4, 0x00000080, "c2");
-      orc_program_add_constant (p, 4, 0x0000002a, "c3");
-      orc_program_add_constant (p, 4, 0x00000067, "c4");
-      orc_program_add_constant (p, 4, 0x00000004, "c5");
-      orc_program_add_constant (p, 4, 0x00000064, "c6");
-      orc_program_add_constant (p, 4, 0x00000068, "c7");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-    orc_program_add_temporary (p, 1, "t4");
-    orc_program_add_temporary (p, 1, "t5");
-    orc_program_add_temporary (p, 1, "t6");
-    orc_program_add_temporary (p, 2, "t7");
-    orc_program_add_temporary (p, 2, "t8");
-    orc_program_add_temporary (p, 2, "t9");
-    orc_program_add_temporary (p, 2, "t10");
-    orc_program_add_temporary (p, 2, "t11");
-    orc_program_add_temporary (p, 2, "t12");
-    orc_program_add_temporary (p, 1, "t13");
-    orc_program_add_temporary (p, 1, "t14");
-    orc_program_add_temporary (p, 1, "t15");
-    orc_program_add_temporary (p, 4, "t16");
-
-      orc_program_append_2 (p, "subb", 2, 47, ORC_VAR_S1, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitlw", 0, ORC_VAR_T1, ORC_VAR_T2, 47, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T4, ORC_VAR_T3, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "splitwb", 0, ORC_VAR_T6, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T7, ORC_VAR_T4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T8, ORC_VAR_T5, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T9, ORC_VAR_T6, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T7, ORC_VAR_C3, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T7, ORC_VAR_T7, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T7, ORC_VAR_T9, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T9, ORC_VAR_C4, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T10, ORC_VAR_T10, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T10, ORC_VAR_T9, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T7, ORC_VAR_T8, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T12, ORC_VAR_T8, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T8, ORC_VAR_C5, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T12, ORC_VAR_T12, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T8, ORC_VAR_C6, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T7, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T9, ORC_VAR_C7, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T11, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T11, ORC_VAR_T11, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T13, ORC_VAR_T10, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T14, ORC_VAR_T11, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T15, ORC_VAR_T12, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_T13, ORC_VAR_T14, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_T15, ORC_VAR_T3, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, 47, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addb", 2, ORC_VAR_D1, 47, ORC_VAR_C2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_I420_BGRA */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_I420_BGRA:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_convert_I420_BGRA");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_I420_BGRA);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-      orc_program_add_constant (p, 1, 0x00000008, "c1");
-      orc_program_add_constant (p, 1, 0x00000080, "c2");
-      orc_program_add_constant (p, 4, 0x0000002a, "c3");
-      orc_program_add_constant (p, 4, 0x00000067, "c4");
-      orc_program_add_constant (p, 4, 0x00000004, "c5");
-      orc_program_add_constant (p, 4, 0x00000064, "c6");
-      orc_program_add_constant (p, 4, 0x00000068, "c7");
-      orc_program_add_constant (p, 4, 0x000000ff, "c8");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-    orc_program_add_temporary (p, 2, "t4");
-    orc_program_add_temporary (p, 2, "t5");
-    orc_program_add_temporary (p, 2, "t6");
-    orc_program_add_temporary (p, 2, "t7");
-    orc_program_add_temporary (p, 2, "t8");
-    orc_program_add_temporary (p, 2, "t9");
-    orc_program_add_temporary (p, 1, "t10");
-    orc_program_add_temporary (p, 1, "t11");
-    orc_program_add_temporary (p, 1, "t12");
-    orc_program_add_temporary (p, 4, "t13");
-
-      orc_program_append_2 (p, "subb", 0, ORC_VAR_T3, ORC_VAR_S1, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T4, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "loadupib", 0, ORC_VAR_T3, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subb", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T5, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "loadupib", 0, ORC_VAR_T3, ORC_VAR_S3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subb", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T6, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T4, ORC_VAR_C3, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T4, ORC_VAR_T4, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T7, ORC_VAR_T4, ORC_VAR_T6, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T6, ORC_VAR_C4, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T7, ORC_VAR_T7, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T7, ORC_VAR_T7, ORC_VAR_T6, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T9, ORC_VAR_T4, ORC_VAR_T5, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T9, ORC_VAR_T9, ORC_VAR_T5, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T5, ORC_VAR_C5, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T9, ORC_VAR_T9, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T5, ORC_VAR_C6, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T8, ORC_VAR_T4, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T6, ORC_VAR_C7, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T8, ORC_VAR_T8, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T8, ORC_VAR_T8, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T10, ORC_VAR_T7, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T11, ORC_VAR_T8, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T12, ORC_VAR_T9, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_T12, ORC_VAR_T11, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_T10, ORC_VAR_C8, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_T13, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addb", 2, ORC_VAR_D1, ORC_VAR_T13, ORC_VAR_C2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-  /* cogorc_convert_I420_BGRA_avg */
-  {
-    OrcProgram *p = NULL;
-    int ret;
-
-    if (!quiet)      printf ("cogorc_convert_I420_BGRA_avg:\n");
-    p = orc_program_new ();
-    orc_program_set_name (p, "cogorc_convert_I420_BGRA_avg");
-    orc_program_set_backup_function (p, _backup_cogorc_convert_I420_BGRA_avg);
-    orc_program_add_destination (p, 4, "d1");
-    orc_program_add_source (p, 1, "s1");
-    orc_program_add_source (p, 1, "s2");
-    orc_program_add_source (p, 1, "s3");
-    orc_program_add_source (p, 1, "s4");
-    orc_program_add_source (p, 1, "s5");
-      orc_program_add_constant (p, 1, 0x00000008, "c1");
-      orc_program_add_constant (p, 1, 0x00000080, "c2");
-      orc_program_add_constant (p, 4, 0x0000002a, "c3");
-      orc_program_add_constant (p, 4, 0x00000067, "c4");
-      orc_program_add_constant (p, 4, 0x00000004, "c5");
-      orc_program_add_constant (p, 4, 0x00000064, "c6");
-      orc_program_add_constant (p, 4, 0x00000068, "c7");
-      orc_program_add_constant (p, 4, 0x000000ff, "c8");
-    orc_program_add_temporary (p, 2, "t1");
-    orc_program_add_temporary (p, 2, "t2");
-    orc_program_add_temporary (p, 1, "t3");
-    orc_program_add_temporary (p, 1, "t4");
-    orc_program_add_temporary (p, 2, "t5");
-    orc_program_add_temporary (p, 2, "t6");
-    orc_program_add_temporary (p, 2, "t7");
-    orc_program_add_temporary (p, 2, "t8");
-    orc_program_add_temporary (p, 2, "t9");
-    orc_program_add_temporary (p, 2, "t10");
-    orc_program_add_temporary (p, 1, "t11");
-    orc_program_add_temporary (p, 1, "t12");
-    orc_program_add_temporary (p, 1, "t13");
-    orc_program_add_temporary (p, 4, "t14");
-
-      orc_program_append_2 (p, "subb", 0, ORC_VAR_T3, ORC_VAR_S1, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T5, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "loadupib", 0, ORC_VAR_T3, ORC_VAR_S2, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "loadupib", 0, ORC_VAR_T4, ORC_VAR_S3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-      orc_program_append_2 (p, "subb", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T6, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "loadupib", 0, ORC_VAR_T3, ORC_VAR_S4, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "loadupib", 0, ORC_VAR_T4, ORC_VAR_S5, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "avgub", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_T4, ORC_VAR_D1);
-      orc_program_append_2 (p, "subb", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C2, ORC_VAR_D1);
-      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T7, ORC_VAR_T3, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T5, ORC_VAR_C3, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T5, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T8, ORC_VAR_T5, ORC_VAR_T7, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T7, ORC_VAR_C4, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T8, ORC_VAR_T8, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T8, ORC_VAR_T8, ORC_VAR_T7, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T5, ORC_VAR_T6, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T10, ORC_VAR_T6, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T6, ORC_VAR_C5, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "addssw", 0, ORC_VAR_T10, ORC_VAR_T10, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T6, ORC_VAR_C6, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T9, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mullw", 0, ORC_VAR_T1, ORC_VAR_T7, ORC_VAR_C7, ORC_VAR_D1);
-      orc_program_append_2 (p, "shrsw", 0, ORC_VAR_T1, ORC_VAR_T1, ORC_VAR_C1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T9, ORC_VAR_T9, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "subssw", 0, ORC_VAR_T9, ORC_VAR_T9, ORC_VAR_T1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T11, ORC_VAR_T8, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T12, ORC_VAR_T9, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_T13, ORC_VAR_T10, ORC_VAR_D1, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T1, ORC_VAR_T13, ORC_VAR_T12, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergebw", 0, ORC_VAR_T2, ORC_VAR_T11, ORC_VAR_C8, ORC_VAR_D1);
-      orc_program_append_2 (p, "mergewl", 0, ORC_VAR_T14, ORC_VAR_T1, ORC_VAR_T2, ORC_VAR_D1);
-      orc_program_append_2 (p, "addb", 2, ORC_VAR_D1, ORC_VAR_T14, ORC_VAR_C2, ORC_VAR_D1);
-
-    if (benchmark) {
-      printf ("    cycles (emulate) :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_EMULATE, NULL));
-    }
-
-    ret = orc_test_compare_output_backup (p);
-    if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    backup function  :   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (backup)  :   %g\n",
-          orc_test_performance_full (p, ORC_TEST_FLAGS_BACKUP, NULL));
-    }
-
-    ret = orc_test_compare_output (p);
-    if (ret == ORC_TEST_INDETERMINATE && !quiet) {
-      printf ("    compiled function:   COMPILE FAILED\n");
-    } else if (!ret) {
-      error = TRUE;
-    } else if (!quiet) {
-      printf ("    compiled function:   PASSED\n");
-    }
-
-    if (benchmark) {
-      printf ("    cycles (compiled):   %g\n",
-          orc_test_performance_full (p, 0, NULL));
-    }
-
-    orc_program_free (p);
-  }
-
-
-  if (error) {
-    return 1;
-  };
-  return 0;
-}
diff --git a/tests/examples/Makefile.am b/tests/examples/Makefile.am
index 5183dfe..57a9182 100644
--- a/tests/examples/Makefile.am
+++ b/tests/examples/Makefile.am
@@ -1,5 +1,11 @@
+if USE_UVCH264
+UVCH264_DIR=uvch264
+else
+UVCH264_DIR=
+endif
+
 if HAVE_GTK
-GTK_EXAMPLES=camerabin mxf scaletempo camerabin2
+GTK_EXAMPLES=camerabin mxf scaletempo camerabin2 $(UVCH264_DIR)
 else
 GTK_EXAMPLES=
 endif
@@ -13,6 +19,6 @@ endif
 OPENCV_EXAMPLES=opencv
 
 SUBDIRS= $(DIRECTFB_DIR) $(GTK_EXAMPLES) $(OPENCV_EXAMPLES)
-DIST_SUBDIRS= camerabin camerabin2 directfb mxf scaletempo opencv
+DIST_SUBDIRS= camerabin camerabin2 directfb mxf scaletempo opencv uvch264
 
 include $(top_srcdir)/common/parallel-subdirs.mak
diff --git a/tests/examples/Makefile.in b/tests/examples/Makefile.in
index f8a3522..cda9ca1 100644
--- a/tests/examples/Makefile.in
+++ b/tests/examples/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -20,6 +19,23 @@
 # descending into all subdirectories a second time, but only after the first
 # (parallel) run has finished, so it should go right through the second time.
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -38,6 +54,7 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
 	$(top_srcdir)/common/parallel-subdirs.mak
 subdir = tests/examples
@@ -46,7 +63,6 @@ am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -83,12 +99,18 @@ mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
 AM_V_GEN = $(am__v_GEN_@AM_V@)
 am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
 AM_V_at = $(am__v_at_@AM_V@)
 am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
 am__v_at_0 = @
+am__v_at_1 = 
 SOURCES =
 DIST_SOURCES =
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
@@ -98,6 +120,11 @@ RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	install-pdf-recursive install-ps-recursive install-recursive \
 	installcheck-recursive installdirs-recursive pdf-recursive \
 	ps-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
 AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
@@ -162,6 +189,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -186,10 +215,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -204,9 +235,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -264,13 +298,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -289,13 +326,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -305,6 +348,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -332,6 +376,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -369,7 +417,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -378,6 +426,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -411,6 +460,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -427,6 +478,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -455,12 +507,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -528,17 +583,23 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
+@USE_UVCH264_FALSE@UVCH264_DIR = 
+@USE_UVCH264_TRUE@UVCH264_DIR = uvch264
 @HAVE_GTK_FALSE@GTK_EXAMPLES = 
-@HAVE_GTK_TRUE@GTK_EXAMPLES = camerabin mxf scaletempo camerabin2
+@HAVE_GTK_TRUE@GTK_EXAMPLES = camerabin mxf scaletempo camerabin2 $(UVCH264_DIR)
 @USE_DIRECTFB_FALSE@DIRECTFB_DIR = 
 @USE_DIRECTFB_TRUE@DIRECTFB_DIR = directfb
 OPENCV_EXAMPLES = opencv
 SUBDIRS = $(DIRECTFB_DIR) $(GTK_EXAMPLES) $(OPENCV_EXAMPLES)
-DIST_SUBDIRS = camerabin camerabin2 directfb mxf scaletempo opencv
+DIST_SUBDIRS = camerabin camerabin2 directfb mxf scaletempo opencv uvch264
 all: all-recursive
 
 .SUFFIXES:
@@ -581,12 +642,12 @@ clean-libtool:
 	-rm -rf .libs _libs
 
 # This directory's subdirectories are mostly independent; you can cd
-# into them and run `make' without going through this Makefile.
-# To change the values of `make' variables: instead of editing Makefiles,
-# (1) if the variable is set in `config.status', edit `config.status'
-#     (which will cause the Makefiles to be regenerated when you run `make');
-# (2) otherwise, pass the desired values on the `make' command line.
-$(RECURSIVE_TARGETS):
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(RECURSIVE_TARGETS) $(RECURSIVE_CLEAN_TARGETS):
 	@fail= failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
@@ -596,7 +657,11 @@ $(RECURSIVE_TARGETS):
 	done; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
 	  echo "Making $$target in $$subdir"; \
 	  if test "$$subdir" = "."; then \
 	    dot_seen=yes; \
@@ -610,37 +675,6 @@ $(RECURSIVE_TARGETS):
 	if test "$$dot_seen" = "no"; then \
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
-
-$(RECURSIVE_CLEAN_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
-	dot_seen=no; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	rev=''; for subdir in $$list; do \
-	  if test "$$subdir" = "."; then :; else \
-	    rev="$$subdir $$rev"; \
-	  fi; \
-	done; \
-	rev="$$rev ."; \
-	target=`echo $@ | sed s/-recursive//`; \
-	for subdir in $$rev; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done && test -z "$$fail"
 tags-recursive:
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
@@ -649,6 +683,10 @@ ctags-recursive:
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
 	done
+cscopelist-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) cscopelist); \
+	done
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -712,6 +750,20 @@ GTAGS:
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscopelist: cscopelist-recursive $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
@@ -747,13 +799,10 @@ distdir: $(DISTFILES)
 	done
 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
 	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
 	    $(am__relativize); \
 	    new_distdir=$$reldir; \
@@ -874,22 +923,23 @@ ps-am:
 
 uninstall-am:
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \
-	install-am install-strip tags-recursive
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) \
+	cscopelist-recursive ctags-recursive install-am install-strip \
+	tags-recursive
 
 .PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
 	all all-am check check-am clean clean-generic clean-libtool \
-	ctags ctags-recursive distclean distclean-generic \
-	distclean-libtool distclean-tags distdir dvi dvi-am html \
-	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs installdirs-am maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-generic \
-	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
-	uninstall uninstall-am
+	cscopelist cscopelist-recursive ctags ctags-recursive \
+	distclean distclean-generic distclean-libtool distclean-tags \
+	distdir dvi dvi-am html html-am info info-am install \
+	install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	installdirs-am maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
+	ps ps-am tags tags-recursive uninstall uninstall-am
 
 
 .PHONY: independent-subdirs $(SUBDIRS)
diff --git a/tests/examples/camerabin/Makefile.in b/tests/examples/camerabin/Makefile.in
index c80a3a7..bbfaf20 100644
--- a/tests/examples/camerabin/Makefile.in
+++ b/tests/examples/camerabin/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -17,6 +16,23 @@
 
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -35,16 +51,17 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 noinst_PROGRAMS = gst-camera-perf$(EXEEXT) $(am__EXEEXT_1) \
 	$(am__EXEEXT_2)
 subdir = tests/examples/camerabin
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(top_srcdir)/depcomp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -95,6 +112,7 @@ am__DEPENDENCIES_1 =
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
+am__v_lt_1 = 
 gst_camera_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(gst_camera_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
@@ -116,6 +134,18 @@ gst_camerabin_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(gst_camerabin_test_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
 	$(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -128,25 +158,26 @@ LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(gst_camera_SOURCES) $(gst_camera_perf_SOURCES) \
 	$(gst_camerabin_test_SOURCES)
 DIST_SOURCES = $(am__gst_camera_SOURCES_DIST) \
 	$(gst_camera_perf_SOURCES) \
 	$(am__gst_camerabin_test_SOURCES_DIST)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 DATA = $(noinst_DATA)
 ETAGS = etags
 CTAGS = ctags
@@ -182,6 +213,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -206,10 +239,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -224,9 +259,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -284,13 +322,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -309,13 +350,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -325,6 +372,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -352,6 +400,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -389,7 +441,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -398,6 +450,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -431,6 +484,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -447,6 +502,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -475,12 +531,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -548,7 +607,11 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
@@ -769,6 +832,20 @@ GTAGS:
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
@@ -910,7 +987,7 @@ uninstall-am:
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstPROGRAMS ctags distclean \
+	clean-libtool clean-noinstPROGRAMS cscopelist ctags distclean \
 	distclean-compile distclean-generic distclean-libtool \
 	distclean-tags distdir dvi dvi-am html html-am info info-am \
 	install install-am install-data install-data-am install-dvi \
diff --git a/tests/examples/camerabin/gst-camera-perf.c b/tests/examples/camerabin/gst-camera-perf.c
index c5554a0..0c56ee6 100644
--- a/tests/examples/camerabin/gst-camera-perf.c
+++ b/tests/examples/camerabin/gst-camera-perf.c
@@ -979,8 +979,10 @@ main (int argc, char *argv[])
   GOptionContext *ctx;
   GError *err = NULL;
 
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
   ctx = g_option_context_new (NULL);
   g_option_context_add_main_entries (ctx, options, NULL);
diff --git a/tests/examples/camerabin/gst-camera-perf.ui b/tests/examples/camerabin/gst-camera-perf.ui
new file mode 100644
index 0000000..9a3885a
--- /dev/null
+++ b/tests/examples/camerabin/gst-camera-perf.ui
@@ -0,0 +1,80 @@
+<?xml version="1.0"?>
+<interface>
+  <!-- interface-requires gtk+ 2.8 -->
+  <!-- interface-naming-policy project-wide -->
+  <object class="GtkWindow" id="wndMain">
+    <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+    <property name="default_width">400</property>
+    <property name="default_height">600</property>
+    <signal name="delete_event" handler="on_wndMain_delete_event"/>
+    <child>
+      <object class="GtkVPaned" id="vpnMain">
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="position">200</property>
+        <child>
+          <object class="GtkDrawingArea" id="daMain">
+            <property name="height_request">100</property>
+            <property name="visible">True</property>
+            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+          </object>
+          <packing>
+            <property name="resize">False</property>
+            <property name="shrink">True</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkVBox" id="vboxMain">
+            <property name="visible">True</property>
+            <child>
+              <object class="GtkButton" id="btnStart">
+                <property name="label" translatable="yes">start</property>
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="receives_default">False</property>
+                <property name="use_underline">True</property>
+                <signal name="clicked" handler="on_btnStart_clicked"/>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="position">0</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkScrolledWindow" id="scrwndMain">
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="hscrollbar_policy">never</property>
+                <property name="vscrollbar_policy">automatic</property>
+                <child>
+                  <object class="GtkViewport" id="vpMain">
+                    <property name="visible">True</property>
+                    <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                    <child>
+                      <object class="GtkLabel" id="lbMain">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="yalign">0</property>
+                        <property name="label" translatable="yes">== Please wait few seconds after press start ==</property>
+                        <property name="use_markup">True</property>
+                        <property name="wrap">True</property>
+                        <property name="selectable">True</property>
+                      </object>
+                    </child>
+                  </object>
+                </child>
+              </object>
+              <packing>
+                <property name="position">1</property>
+              </packing>
+            </child>
+          </object>
+          <packing>
+            <property name="resize">True</property>
+            <property name="shrink">True</property>
+          </packing>
+        </child>
+      </object>
+    </child>
+  </object>
+</interface>
diff --git a/tests/examples/camerabin/gst-camerabin-test.c b/tests/examples/camerabin/gst-camerabin-test.c
index 27037fa..3f16a7f 100644
--- a/tests/examples/camerabin/gst-camerabin-test.c
+++ b/tests/examples/camerabin/gst-camerabin-test.c
@@ -786,8 +786,10 @@ main (int argc, char *argv[])
   GOptionContext *ctx;
   GError *err = NULL;
 
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
   ctx = g_option_context_new ("\n\ncamerabin command line test application.");
   g_option_context_add_main_entries (ctx, options, NULL);
diff --git a/tests/examples/camerabin2/Makefile.in b/tests/examples/camerabin2/Makefile.in
index 3849e73..a749bc3 100644
--- a/tests/examples/camerabin2/Makefile.in
+++ b/tests/examples/camerabin2/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -17,6 +16,23 @@
 
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -35,15 +51,16 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 noinst_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2)
 subdir = tests/examples/camerabin2
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(top_srcdir)/depcomp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -94,6 +111,7 @@ am__DEPENDENCIES_1 =
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
+am__v_lt_1 = 
 gst_camera2_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(gst_camera2_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
@@ -107,6 +125,18 @@ gst_camerabin2_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(gst_camerabin2_test_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
 	$(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -119,23 +149,24 @@ LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(gst_camera2_SOURCES) $(gst_camerabin2_test_SOURCES)
 DIST_SOURCES = $(am__gst_camera2_SOURCES_DIST) \
 	$(am__gst_camerabin2_test_SOURCES_DIST)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 DATA = $(noinst_DATA)
 ETAGS = etags
 CTAGS = ctags
@@ -171,6 +202,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -195,10 +228,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -213,9 +248,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -273,13 +311,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -298,13 +339,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -314,6 +361,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -341,6 +389,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -378,7 +430,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -387,6 +439,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -420,6 +473,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -436,6 +491,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -464,12 +520,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -537,7 +596,11 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
@@ -741,6 +804,20 @@ GTAGS:
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
@@ -882,7 +959,7 @@ uninstall-am:
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstPROGRAMS ctags distclean \
+	clean-libtool clean-noinstPROGRAMS cscopelist ctags distclean \
 	distclean-compile distclean-generic distclean-libtool \
 	distclean-tags distdir dvi dvi-am html html-am info info-am \
 	install install-am install-data install-data-am install-dvi \
diff --git a/tests/examples/camerabin2/gst-camerabin2-test.c b/tests/examples/camerabin2/gst-camerabin2-test.c
index f112dbc..cb4b008 100644
--- a/tests/examples/camerabin2/gst-camerabin2-test.c
+++ b/tests/examples/camerabin2/gst-camerabin2-test.c
@@ -1257,8 +1257,10 @@ main (int argc, char *argv[])
   GOptionContext *ctx;
   GError *err = NULL;
 
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
   ctx = g_option_context_new ("\n\ncamerabin command line test application.");
   g_option_context_add_main_entries (ctx, options, NULL);
diff --git a/tests/examples/capsfilter/Makefile.am b/tests/examples/capsfilter/Makefile.am
new file mode 100644
index 0000000..f8562fe
--- /dev/null
+++ b/tests/examples/capsfilter/Makefile.am
@@ -0,0 +1,6 @@
+noinst_PROGRAMS = capsfilter1
+
+LDADD = $(GST_LIBS)
+AM_CFLAGS = $(GST_CFLAGS)
+
+
diff --git a/tests/examples/capsfilter/capsfilter1.c b/tests/examples/capsfilter/capsfilter1.c
new file mode 100644
index 0000000..a59f728
--- /dev/null
+++ b/tests/examples/capsfilter/capsfilter1.c
@@ -0,0 +1,87 @@
+#include <string.h>
+#include <gst/gst.h>
+
+/* This app uses a filter to connect colorspace and videosink
+ * so that only RGB data can pass the connection, colorspace will use
+ * a converter to convert the I420 data to RGB. Without a filter, this
+ * connection would use the I420 format (assuming Xv is enabled) */
+
+static void
+new_pad_func (GstElement * element, GstPad * newpad, gpointer data)
+{
+  GstElement *pipeline = (GstElement *) data;
+  GstElement *queue = gst_bin_get_by_name (GST_BIN (pipeline), "queue");
+
+  if (!strcmp (gst_pad_get_name (newpad), "video_00")) {
+    gst_element_set_state (pipeline, GST_STATE_PAUSED);
+    gst_pad_link (newpad, gst_element_get_pad (queue, "sink"));
+    gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  }
+}
+
+gint
+main (gint argc, gchar * argv[])
+{
+  GstElement *pipeline;
+  GstElement *filesrc;
+  GstElement *demux;
+  GstElement *thread;
+  GstElement *queue;
+  GstElement *mpeg2dec;
+  GstElement *colorspace;
+  GstElement *videosink;
+  gboolean res;
+
+  gst_init (&argc, &argv);
+
+  if (argc < 2) {
+    g_print ("usage: %s <mpeg1 system stream>\n", argv[0]);
+    return (-1);
+  }
+
+  pipeline = gst_pipeline_new ("main_pipeline");
+  filesrc = gst_element_factory_make ("filesrc", "filesrc");
+  g_return_val_if_fail (filesrc, -1);
+  g_object_set (G_OBJECT (filesrc), "location", argv[1], NULL);
+  demux = gst_element_factory_make ("mpegdemux", "demux");
+  g_return_val_if_fail (demux, -1);
+  g_signal_connect (G_OBJECT (demux), "new_pad", G_CALLBACK (new_pad_func),
+      pipeline);
+
+  thread = gst_thread_new ("thread");
+  queue = gst_element_factory_make ("queue", "queue");
+  mpeg2dec = gst_element_factory_make ("mpeg2dec", "mpeg2dec");
+  g_return_val_if_fail (mpeg2dec, -1);
+  colorspace = gst_element_factory_make ("ffmpegcolorspace", "colorspace");
+  g_return_val_if_fail (colorspace, -1);
+  videosink = gst_element_factory_make (DEFAULT_VIDEOSINK, "videosink");
+  g_return_val_if_fail (videosink, -1);
+
+  gst_bin_add (GST_BIN (pipeline), filesrc);
+  gst_bin_add (GST_BIN (pipeline), demux);
+
+  gst_bin_add (GST_BIN (thread), queue);
+  gst_bin_add (GST_BIN (thread), mpeg2dec);
+  gst_bin_add (GST_BIN (thread), colorspace);
+  gst_bin_add (GST_BIN (thread), videosink);
+  gst_bin_add (GST_BIN (pipeline), thread);
+
+  gst_element_link_pads (filesrc, "src", demux, "sink");
+  gst_element_link_pads (queue, "src", mpeg2dec, "sink");
+  gst_element_link_pads (mpeg2dec, "src", colorspace, "sink");
+  /* force RGB data passing between colorspace and videosink */
+  res = gst_element_link_pads_filtered (colorspace, "src", videosink, "sink",
+      gst_caps_new_simple ("video/x-raw-rgb", NULL));
+  if (!res) {
+    g_print ("could not connect colorspace and videosink\n");
+    return -1;
+  }
+
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+
+  while (gst_bin_iterate (GST_BIN (pipeline)));
+
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+
+  return 0;
+}
diff --git a/tests/examples/directfb/Makefile.in b/tests/examples/directfb/Makefile.in
index 1b784b2..07d2923 100644
--- a/tests/examples/directfb/Makefile.in
+++ b/tests/examples/directfb/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,23 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -34,15 +50,16 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 noinst_PROGRAMS = gstdfb$(EXEEXT)
 subdir = tests/examples/directfb
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(top_srcdir)/depcomp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -86,9 +103,22 @@ gstdfb_LDADD = $(LDADD)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
+am__v_lt_1 = 
 gstdfb_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(gstdfb_CFLAGS) $(CFLAGS) \
 	$(gstdfb_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -101,22 +131,23 @@ LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(gstdfb_SOURCES)
 DIST_SOURCES = $(gstdfb_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -151,6 +182,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -175,10 +208,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -193,9 +228,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -253,13 +291,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -278,13 +319,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -294,6 +341,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -321,6 +369,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -358,7 +410,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -367,6 +419,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -400,6 +453,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -416,6 +471,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -444,12 +500,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -517,7 +576,11 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
@@ -672,6 +735,20 @@ GTAGS:
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
@@ -813,7 +890,7 @@ uninstall-am:
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstPROGRAMS ctags distclean \
+	clean-libtool clean-noinstPROGRAMS cscopelist ctags distclean \
 	distclean-compile distclean-generic distclean-libtool \
 	distclean-tags distdir dvi dvi-am html html-am info info-am \
 	install install-am install-data install-data-am install-dvi \
diff --git a/tests/examples/gstplay/.gitignore b/tests/examples/gstplay/.gitignore
new file mode 100644
index 0000000..a1eb1c4
--- /dev/null
+++ b/tests/examples/gstplay/.gitignore
@@ -0,0 +1 @@
+player
diff --git a/tests/examples/gstplay/Makefile.am b/tests/examples/gstplay/Makefile.am
new file mode 100644
index 0000000..cbae9cb
--- /dev/null
+++ b/tests/examples/gstplay/Makefile.am
@@ -0,0 +1,11 @@
+
+noinst_PROGRAMS = player
+
+player_SOURCES = player.c
+player_CFLAGS = $(GST_CFLAGS) $(GCONF_CFLAGS)
+player_LDFLAGS = \
+    $(GST_LIBS) \
+    $(top_builddir)/gst-libs/gst/gconf/libgstgconf-@GST_MAJORMINOR@.la \
+    $(top_builddir)/gst-libs/gst/play/libgstplay-@GST_MAJORMINOR@.la \
+    $(top_builddir)/gst-libs/gst/libgstinterfaces-$(GST_MAJORMINOR).la
+
diff --git a/tests/examples/gstplay/player.c b/tests/examples/gstplay/player.c
new file mode 100644
index 0000000..7645378
--- /dev/null
+++ b/tests/examples/gstplay/player.c
@@ -0,0 +1,176 @@
+/* GStreamer
+ * Copyright (C) 2003 Julien Moutte <julien@moutte.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <gst/play/play.h>
+#include <gst/gconf/gconf.h>
+
+static GMainLoop *loop = NULL;
+static gint64 length = 0;
+
+static void
+print_tag (const GstTagList * list, const gchar * tag, gpointer unused)
+{
+  gint i, count;
+
+  count = gst_tag_list_get_tag_size (list, tag);
+
+  for (i = 0; i < count; i++) {
+    gchar *str;
+
+    if (gst_tag_get_type (tag) == G_TYPE_STRING) {
+      if (!gst_tag_list_get_string_index (list, tag, i, &str))
+        g_assert_not_reached ();
+    } else {
+      str =
+          g_strdup_value_contents (gst_tag_list_get_value_index (list, tag, i));
+    }
+
+    if (i == 0) {
+      g_print ("%15s: %s\n", gst_tag_get_nick (tag), str);
+    } else {
+      g_print ("               : %s\n", str);
+    }
+
+    g_free (str);
+  }
+}
+
+static void
+got_found_tag (GstPlay * play, GstElement * source, GstTagList * tag_list)
+{
+  gst_tag_list_foreach (tag_list, print_tag, NULL);
+}
+
+static void
+got_time_tick (GstPlay * play, gint64 time_nanos)
+{
+  g_print ("time tick %f\n", time_nanos / (float) GST_SECOND);
+}
+
+static void
+got_stream_length (GstPlay * play, gint64 length_nanos)
+{
+  g_print ("got length %" G_GUINT64_FORMAT "\n", length_nanos);
+  length = length_nanos;
+}
+
+static void
+got_video_size (GstPlay * play, gint width, gint height)
+{
+  g_print ("got video size %d, %d\n", width, height);
+}
+
+static void
+got_eos (GstPlay * play)
+{
+  g_print ("End Of Stream\n");
+  g_main_loop_quit (loop);
+}
+
+static gboolean
+seek_timer (GstPlay * play)
+{
+  gst_play_seek_to_time (play, length / 2);
+  return FALSE;
+}
+
+int
+main (int argc, char *argv[])
+{
+  GstPlay *play;
+  GstElement *data_src, *video_sink, *audio_sink, *vis_element;
+  GError *error = NULL;
+
+  /* Initing GStreamer library */
+  gst_init (&argc, &argv);
+
+  if (argc != 2) {
+    g_print ("usage: %s <video filename>\n", argv[0]);
+    exit (-1);
+  }
+
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* Creating the GstPlay object */
+  play = gst_play_new (&error);
+  if (error) {
+    g_print ("Error: could not create play object:\n%s\n", error->message);
+    g_error_free (error);
+    return 1;
+  }
+
+  /* Getting default audio and video plugins from GConf */
+  vis_element = gst_element_factory_make ("goom", "vis_element");
+  data_src = gst_element_factory_make ("gnomevfssrc", "source");
+
+  audio_sink = gst_gconf_get_default_audio_sink ();
+  if (!GST_IS_ELEMENT (audio_sink))
+    g_error ("Could not get default audio sink from GConf");
+  video_sink = gst_gconf_get_default_video_sink ();
+  if (!GST_IS_ELEMENT (video_sink))
+    g_error ("Could not get default video sink from GConf");
+
+
+  /* Let's send them to GstPlay object */
+  if (!gst_play_set_audio_sink (play, audio_sink))
+    g_warning ("Could not set audio sink");
+  if (!gst_play_set_video_sink (play, video_sink))
+    g_warning ("Could not set video sink");
+  if (!gst_play_set_data_src (play, data_src))
+    g_warning ("Could not set data src");
+  if (!gst_play_set_visualization (play, vis_element))
+    g_warning ("Could not set visualisation");
+
+  /* Setting location we want to play */
+  if (!gst_play_set_location (play, argv[1]))
+    g_warning ("Could not set location");
+
+  /* Uncomment that line to get an XML dump of the pipeline */
+  /* gst_xml_write_file (GST_ELEMENT (play), stdout); */
+
+  g_signal_connect (G_OBJECT (play), "time_tick",
+      G_CALLBACK (got_time_tick), NULL);
+  g_signal_connect (G_OBJECT (play), "stream_length",
+      G_CALLBACK (got_stream_length), NULL);
+  g_signal_connect (G_OBJECT (play), "have_video_size",
+      G_CALLBACK (got_video_size), NULL);
+  g_signal_connect (G_OBJECT (play), "found_tag",
+      G_CALLBACK (got_found_tag), NULL);
+  g_signal_connect (G_OBJECT (play), "error",
+      G_CALLBACK (gst_element_default_error), NULL);
+  g_signal_connect (G_OBJECT (play), "eos", G_CALLBACK (got_eos), NULL);
+
+  /* Change state to PLAYING */
+  if (gst_element_set_state (GST_ELEMENT (play),
+          GST_STATE_PLAYING) == GST_STATE_CHANGE_FAILURE)
+    g_error ("Could not set state to PLAYING");
+
+  g_timeout_add (20000, (GSourceFunc) seek_timer, play);
+
+  g_main_loop_run (loop);
+
+  g_print ("setting pipeline to ready\n");
+
+  gst_element_set_state (GST_ELEMENT (play), GST_STATE_READY);
+
+  /* unref 
+     gst_object_unref (GST_OBJECT (play)); */
+
+  exit (0);
+}
diff --git a/tests/examples/indexing/.gitignore b/tests/examples/indexing/.gitignore
new file mode 100644
index 0000000..5ce0947
--- /dev/null
+++ b/tests/examples/indexing/.gitignore
@@ -0,0 +1 @@
+indexmpeg
diff --git a/tests/examples/indexing/Makefile.am b/tests/examples/indexing/Makefile.am
new file mode 100644
index 0000000..022bfc8
--- /dev/null
+++ b/tests/examples/indexing/Makefile.am
@@ -0,0 +1,7 @@
+examples = indexmpeg
+
+noinst_PROGRAMS = $(examples)
+
+# we have nothing but apps here, we can do this safely
+LIBS = $(GST_LIBS) $(GTK_LIBS)
+AM_CFLAGS = $(GST_CFLAGS) $(GTK_CFLAGS)
diff --git a/tests/examples/indexing/indexmpeg.c b/tests/examples/indexing/indexmpeg.c
new file mode 100644
index 0000000..c7d4473
--- /dev/null
+++ b/tests/examples/indexing/indexmpeg.c
@@ -0,0 +1,321 @@
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <string.h>
+#include <gst/gst.h>
+
+static gboolean verbose = FALSE;
+static gboolean quiet = FALSE;
+
+static void
+entry_added (GstIndex * index, GstIndexEntry * entry)
+{
+  switch (entry->type) {
+    case GST_INDEX_ENTRY_ID:
+      g_print ("id %d describes writer %s\n", entry->id,
+          GST_INDEX_ID_DESCRIPTION (entry));
+      break;
+    case GST_INDEX_ENTRY_FORMAT:
+      g_print ("%d: registered format %d for %s\n", entry->id,
+          GST_INDEX_FORMAT_FORMAT (entry), GST_INDEX_FORMAT_KEY (entry));
+      break;
+    case GST_INDEX_ENTRY_ASSOCIATION:
+    {
+      gint i;
+
+      g_print ("%p, %d: %08x ", entry, entry->id,
+          GST_INDEX_ASSOC_FLAGS (entry));
+      for (i = 0; i < GST_INDEX_NASSOCS (entry); i++) {
+        g_print ("%d %" G_GINT64_FORMAT " ", GST_INDEX_ASSOC_FORMAT (entry, i),
+            GST_INDEX_ASSOC_VALUE (entry, i));
+      }
+      g_print ("\n");
+      break;
+    }
+    default:
+      break;
+  }
+}
+
+typedef struct
+{
+  const gchar *padname;
+  GstPad *target;
+  GstElement *bin;
+  GstElement *pipeline;
+  GstIndex *index;
+}
+dyn_link;
+
+static void
+dynamic_link (GstPadTemplate * templ, GstPad * newpad, gpointer data)
+{
+  dyn_link *link = (dyn_link *) data;
+
+  if (!strcmp (gst_pad_get_name (newpad), link->padname)) {
+    gst_element_set_state (link->pipeline, GST_STATE_PAUSED);
+    gst_bin_add (GST_BIN (link->pipeline), link->bin);
+    gst_pad_link (newpad, link->target);
+    gst_element_set_index (link->bin, link->index);
+    gst_element_set_state (link->pipeline, GST_STATE_PLAYING);
+  }
+}
+
+static void
+setup_dynamic_linking (GstElement * pipeline,
+    GstElement * element,
+    const gchar * padname, GstPad * target, GstElement * bin, GstIndex * index)
+{
+  dyn_link *link;
+
+  link = g_new0 (dyn_link, 1);
+  link->padname = g_strdup (padname);
+  link->target = target;
+  link->bin = bin;
+  link->pipeline = pipeline;
+  link->index = index;
+
+  g_signal_connect (G_OBJECT (element), "new-pad", G_CALLBACK (dynamic_link),
+      link);
+}
+
+static GstElement *
+make_mpeg_systems_pipeline (const gchar * path, GstIndex * index)
+{
+  GstElement *pipeline;
+  GstElement *src, *demux;
+
+  pipeline = gst_pipeline_new ("pipeline");
+
+  src = gst_element_factory_make ("filesrc", "src");
+  g_object_set (G_OBJECT (src), "location", path, NULL);
+
+  demux = gst_element_factory_make ("mpegdemux", "demux");
+
+  gst_bin_add (GST_BIN (pipeline), src);
+  gst_bin_add (GST_BIN (pipeline), demux);
+
+  if (index) {
+    gst_element_set_index (pipeline, index);
+  }
+
+  gst_element_link_pads (src, "src", demux, "sink");
+
+  return pipeline;
+}
+
+static GstElement *
+make_mpeg_decoder_pipeline (const gchar * path, GstIndex * index)
+{
+  GstElement *pipeline;
+  GstElement *src, *demux;
+  GstElement *video_bin, *audio_bin;
+  GstElement *video_decoder, *audio_decoder;
+
+  pipeline = gst_pipeline_new ("pipeline");
+
+  src = gst_element_factory_make ("filesrc", "src");
+  g_object_set (G_OBJECT (src), "location", path, NULL);
+
+  demux = gst_element_factory_make ("mpegdemux", "demux");
+
+  gst_bin_add (GST_BIN (pipeline), src);
+  gst_bin_add (GST_BIN (pipeline), demux);
+
+  gst_element_link_pads (src, "src", demux, "sink");
+
+  video_bin = gst_bin_new ("video_bin");
+  video_decoder = gst_element_factory_make ("mpeg2dec", "video_decoder");
+
+  gst_bin_add (GST_BIN (video_bin), video_decoder);
+
+  setup_dynamic_linking (pipeline, demux, "video_00",
+      gst_element_get_pad (video_decoder, "sink"), video_bin, index);
+
+  audio_bin = gst_bin_new ("audio_bin");
+  audio_decoder = gst_element_factory_make ("mad", "audio_decoder");
+
+  setup_dynamic_linking (pipeline, demux, "audio_00",
+      gst_element_get_pad (audio_decoder, "sink"), audio_bin, index);
+
+  gst_bin_add (GST_BIN (audio_bin), audio_decoder);
+
+  if (index) {
+    gst_element_set_index (pipeline, index);
+  }
+
+  return pipeline;
+}
+
+static void
+print_progress (GstPad * pad)
+{
+  gint i = 0;
+  gchar status[53];
+  GstFormat format;
+  gboolean res;
+  gint64 value;
+  gint percent = 0;
+
+  status[0] = '|';
+
+  format = GST_FORMAT_PERCENT;
+  res = gst_pad_query (pad, GST_QUERY_POSITION, &format, &value);
+  if (res) {
+    percent = value / (2 * GST_FORMAT_PERCENT_SCALE);
+  }
+
+  for (i = 0; i < percent; i++) {
+    status[i + 1] = '=';
+  }
+  for (i = percent; i < 50; i++) {
+    status[i + 1] = ' ';
+  }
+  status[51] = '|';
+  status[52] = 0;
+
+  g_print ("%s\r", status);
+}
+
+gint
+main (gint argc, gchar * argv[])
+{
+  GstElement *pipeline;
+  GstElement *src;
+  GstPad *pad;
+  GstIndex *index;
+  gint count = 0;
+  GstEvent *event;
+  gboolean res;
+  GstElement *sink;
+  struct poptOption options[] = {
+    {"verbose", 'v', POPT_ARG_NONE | POPT_ARGFLAG_STRIP, &verbose, 0,
+        "Print index entries", NULL},
+    {"quiet", 'q', POPT_ARG_NONE | POPT_ARGFLAG_STRIP, &quiet, 0,
+        "don't print progress bar", NULL},
+    POPT_TABLEEND
+  };
+
+  if (!gst_init_check_with_popt_table (&argc, &argv, options) || argc < 3) {
+    g_print ("usage: %s [-v] <type> <filename>  \n"
+        "  type can be: 0 mpeg_systems\n"
+        "               1 mpeg_decoder\n"
+        "  -v : report added index entries\n"
+        "  -q : don't print progress\n", argv[0]);
+    return -1;
+  }
+
+  /* create index that elements can fill */
+  index = gst_index_factory_make ("memindex");
+  if (index) {
+    if (verbose)
+      g_signal_connect (G_OBJECT (index), "entry-added",
+          G_CALLBACK (entry_added), NULL);
+
+    g_object_set (G_OBJECT (index), "resolver", 1, NULL);
+  }
+
+  /* construct pipeline */
+  switch (atoi (argv[1])) {
+    case 0:
+      pipeline = make_mpeg_systems_pipeline (argv[2], index);
+      break;
+    case 1:
+      pipeline = make_mpeg_decoder_pipeline (argv[2], index);
+      break;
+    default:
+      g_print ("unknown type %d\n", atoi (argv[1]));
+      return -1;
+  }
+
+  /* setup some default info/error handlers */
+  g_signal_connect (G_OBJECT (pipeline), "deep-notify",
+      G_CALLBACK (gst_element_default_deep_notify), NULL);
+  g_signal_connect (G_OBJECT (pipeline), "error",
+      G_CALLBACK (gst_element_default_error), NULL);
+
+  /* get a pad to perform progress reporting on */
+  src = gst_bin_get_by_name (GST_BIN (pipeline), "src");
+  pad = gst_element_get_pad (src, "src");
+
+  /* prepare for iteration */
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+
+  g_print ("indexing %s...\n", argv[2]);
+  /* run through the complete stream to let it generate an index */
+  while (gst_bin_iterate (GST_BIN (pipeline))) {
+    if (!quiet && (count % 1000 == 0)) {
+      print_progress (pad);
+    }
+    count++;
+  }
+  g_print ("\n");
+
+  /* bring to ready to restart the pipeline */
+  gst_element_set_state (pipeline, GST_STATE_READY);
+  gst_element_set_state (pipeline, GST_STATE_PAUSED);
+
+  if (index)
+    GST_OBJECT_FLAG_UNSET (index, GST_INDEX_WRITABLE);
+
+  src = gst_bin_get_by_name (GST_BIN (pipeline), "video_decoder");
+
+  {
+    gint id;
+    GstIndexEntry *entry;
+    gint64 result;
+    gint total_tm;
+
+    gst_index_get_writer_id (index, GST_OBJECT (src), &id);
+
+    entry = gst_index_get_assoc_entry (index, id, GST_INDEX_LOOKUP_BEFORE, 0,
+        GST_FORMAT_TIME, G_MAXINT64);
+    g_assert (entry);
+    gst_index_entry_assoc_map (entry, GST_FORMAT_TIME, &result);
+    total_tm = result * 60 / GST_SECOND;
+    g_print ("total time = %.2fs\n", total_tm / 60.0);
+  }
+
+  pad = gst_element_get_pad (src, "src");
+  sink = gst_element_factory_make ("fakesink", "sink");
+  gst_element_link_pads (src, "src", sink, "sink");
+  gst_bin_add (GST_BIN (pipeline), sink);
+
+  g_print ("seeking %s...\n", argv[2]);
+  event = gst_event_new_seek (GST_FORMAT_TIME |
+      GST_SEEK_METHOD_SET | GST_SEEK_FLAG_FLUSH, 5 * GST_SECOND);
+
+  res = gst_pad_send_event (pad, event);
+  if (!res) {
+    g_warning ("seek failed");
+  }
+
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  count = 0;
+  while (gst_bin_iterate (GST_BIN (pipeline))) {
+    if (!quiet && (count % 1000 == 0)) {
+      print_progress (pad);
+    }
+    count++;
+  }
+
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+
+  return 1;
+}
diff --git a/tests/examples/level/Makefile.am b/tests/examples/level/Makefile.am
new file mode 100644
index 0000000..bf76136
--- /dev/null
+++ b/tests/examples/level/Makefile.am
@@ -0,0 +1,11 @@
+noinst_PROGRAMS = demo plot
+
+demo_SOURCES = demo.c
+demo_CFLAGS = $(GTK_CFLAGS) $(GST_CFLAGS)
+demo_LDFLAGS = $(GTK_LIBS) $(GST_LIBS)
+
+plot_SOURCES = plot.c
+plot_CFLAGS = $(GTK_CFLAGS) $(GST_CFLAGS)
+plot_LDFLAGS = $(GTK_LIBS) $(GST_LIBS)
+
+EXTRA_DIST = README
diff --git a/tests/examples/level/README b/tests/examples/level/README
new file mode 100644
index 0000000..0ae8418
--- /dev/null
+++ b/tests/examples/level/README
@@ -0,0 +1,39 @@
+level plugin by thomas <thomas@apestaart.org>
+
+this plugin signals:
+  - running time since last EOS/start
+  - channel
+  - RMS level
+  - peak level
+  - decaying peak level
+over the given interval.
+
+This is useful for a VU meter display and for plotting out the signal graph.
+The VU meter can either display RMS, or display immediate peak level and
+have the falloff decaying peak level displayed as a line.
+
+The interval for signal emission, ttl of decay peak, and falloff of decay peak
+can all be set.
+
+The element only takes unsigned data in; it could be extended to signed as
+well, if separate fast chain functions are made that displaces the incoming
+data to its midpoint (ie, 0,65535 should be mapped to -32768, 32767)
+
+There are two demo apps, apps and plot.  apps will create some GTK sliders
+to display the volume.  plot will output data readable by gnuplot.
+
+Here is a sample plot script to plot output of the plot command that was
+stored to plot.dat
+
+set xlabel "Seconds"
+set ylabel "dB"
+set yrange [-60:0]
+plot 'plot.dat' using 1:2 title 'L RMS' with lines, \
+     'plot.dat' using 1:3 title 'L peak' with lines, \
+     'plot.dat' using 1:4 title 'L decay' with lines
+
+plot 'plot.dat' using 1:5 title 'R RMS' with lines, \
+     'plot.dat' using 1:6 title 'R peak' with lines, \
+     'plot.dat' using 1:7 title 'R decay' with lines
+
+
diff --git a/tests/examples/level/demo.c b/tests/examples/level/demo.c
new file mode 100644
index 0000000..502f50f
--- /dev/null
+++ b/tests/examples/level/demo.c
@@ -0,0 +1,155 @@
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ *
+ * demo.c: sample application to display VU meter-like output of level
+ * Copyright (C) 2003
+ *           Thomas Vander Stichele <thomas at apestaart dot org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gtk/gtk.h>
+
+/* global array for the scale widgets, we'll assume stereo */
+GtkWidget *elapsed;
+GtkWidget *scale[2][3];
+
+static void
+level_callback (GstElement * element, gdouble time, gint channel,
+    gdouble rms, gdouble peak, gdouble decay)
+{
+  gchar *label;
+
+  label = g_strdup_printf ("%.3f", time);
+  gtk_label_set (GTK_LABEL (elapsed), label);
+  g_free (label);
+  gtk_range_set_value (GTK_RANGE (scale[channel][0]), rms);
+  gtk_range_set_value (GTK_RANGE (scale[channel][1]), peak);
+  gtk_range_set_value (GTK_RANGE (scale[channel][2]), decay);
+}
+
+static gboolean
+idler (gpointer data)
+{
+  GstElement *pipeline = GST_ELEMENT (data);
+
+  g_print ("+");
+  if (gst_bin_iterate (GST_BIN (pipeline)))
+    return TRUE;
+  gtk_main_quit ();
+  return FALSE;
+}
+
+static void
+setup_gui ()
+{
+  GtkWidget *window;
+  GtkWidget *vbox;
+  GtkWidget *label, *hbox;
+  int c;
+
+  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+  g_signal_connect (window, "destroy", gtk_main_quit, NULL);
+
+  vbox = gtk_vbox_new (TRUE, 0);
+  gtk_container_add (GTK_CONTAINER (window), vbox);
+
+  /* elapsed widget */
+  hbox = gtk_hbox_new (TRUE, 0);
+  label = gtk_label_new ("Elapsed");
+  elapsed = gtk_label_new ("0.000");
+  gtk_container_add (GTK_CONTAINER (hbox), label);
+  gtk_container_add (GTK_CONTAINER (hbox), elapsed);
+  gtk_container_add (GTK_CONTAINER (vbox), hbox);
+
+  for (c = 0; c < 2; ++c) {
+    /* RMS */
+    hbox = gtk_hbox_new (TRUE, 0);
+    label = gtk_label_new ("RMS");
+    gtk_container_add (GTK_CONTAINER (hbox), label);
+    scale[c][0] = gtk_hscale_new_with_range (-90.0, 0.0, 0.2);
+    gtk_widget_set_size_request (scale[c][0], 100, -1);
+    gtk_container_add (GTK_CONTAINER (hbox), scale[c][0]);
+    gtk_container_add (GTK_CONTAINER (vbox), hbox);
+    /* peak */
+    hbox = gtk_hbox_new (TRUE, 0);
+    label = gtk_label_new ("peak");
+    gtk_container_add (GTK_CONTAINER (hbox), label);
+    scale[c][1] = gtk_hscale_new_with_range (-90.0, 0.0, 0.2);
+    gtk_widget_set_size_request (scale[c][1], 100, -1);
+    gtk_container_add (GTK_CONTAINER (hbox), scale[c][1]);
+    gtk_container_add (GTK_CONTAINER (vbox), hbox);
+    /* decay */
+    hbox = gtk_hbox_new (TRUE, 0);
+    label = gtk_label_new ("decaying peek");
+    gtk_container_add (GTK_CONTAINER (hbox), label);
+    scale[c][2] = gtk_hscale_new_with_range (-90.0, 0.0, 0.2);
+    gtk_widget_set_size_request (scale[c][2], 100, -1);
+    gtk_container_add (GTK_CONTAINER (hbox), scale[c][2]);
+    gtk_container_add (GTK_CONTAINER (vbox), hbox);
+  }
+
+  gtk_widget_show_all (GTK_WIDGET (window));
+}
+
+int
+main (int argc, char *argv[])
+{
+
+  GstElement *pipeline = NULL;
+  GError *error = NULL;
+  GstElement *level;
+
+  gst_init (&argc, &argv);
+  gtk_init (&argc, &argv);
+
+  pipeline = gst_parse_launchv ((const gchar **) &argv[1], &error);
+  if (error) {
+    g_print ("pipeline could not be constructed: %s\n", error->message);
+    g_print ("Please give a complete pipeline  with a 'level' element.\n");
+    g_print ("Example: sinesrc ! level ! %s\n", DEFAULT_AUDIOSINK);
+    g_error_free (error);
+    return 1;
+  }
+
+  level = gst_bin_get_by_name (GST_BIN (pipeline), "level0");
+  if (level == NULL) {
+    g_print ("Please give a pipeline with a 'level' element in it\n");
+    return 1;
+  }
+
+  g_object_set (level, "signal", TRUE, NULL);
+  g_signal_connect (level, "level", G_CALLBACK (level_callback), NULL);
+
+
+  /* setup GUI */
+  setup_gui ();
+
+  /* connect level signal */
+
+  /* go to main loop */
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_idle_add (idler, pipeline);
+
+  gtk_main ();
+
+  return 0;
+}
diff --git a/tests/examples/level/plot.c b/tests/examples/level/plot.c
new file mode 100644
index 0000000..4459158
--- /dev/null
+++ b/tests/examples/level/plot.c
@@ -0,0 +1,124 @@
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ *
+ * plot.c: output data points to be graphed with gnuplot
+ * Copyright (C) 2003
+ *           Thomas Vander Stichele <thomas at apestaart dot org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gtk/gtk.h>
+
+gboolean got_channel[2] = { FALSE, FALSE };     /* to see if we got the signal for this one yet */
+
+gint channels = 0;              /* guess at how many channels there are */
+gdouble last_time = 0.0;        /* time of last signal */
+gdouble values[2][3];           /* array of levels from which to print */
+
+static void
+level_callback (GstElement * element, gdouble time, gint channel,
+    gdouble rms, gdouble peak, gdouble decay)
+{
+  int i = 0, j = 0;
+  gboolean got_all = FALSE;
+
+  if (channel + 1 > channels)
+    channels = channel + 1;
+
+  /* reset got_channel if this is a new time point */
+  if (time > last_time) {
+    for (i = 0; i < channels; ++i)
+      got_channel[i] = FALSE;
+    last_time = time;
+  }
+
+  /* store values */
+  got_channel[channel] = TRUE;
+  values[channel][0] = rms;
+  values[channel][1] = peak;
+  values[channel][2] = decay;
+
+  /* check if we have all channels, and output if we do */
+  /* FIXME: this fails on the first, no ? */
+  got_all = TRUE;
+  for (i = 0; i < channels; ++i)
+    if (!got_channel[i])
+      got_all = FALSE;
+  if (got_all) {
+    g_print ("%f ", time);
+    for (i = 0; i < channels; ++i)
+      for (j = 0; j < 3; ++j)
+        g_print ("%f ", values[i][j]);
+    g_print ("\n");
+  }
+}
+
+static gboolean
+idler (gpointer data)
+{
+  GstElement *pipeline = GST_ELEMENT (data);
+
+  if (gst_bin_iterate (GST_BIN (pipeline)))
+    return TRUE;
+
+  gtk_main_quit ();
+  return FALSE;
+}
+
+int
+main (int argc, char *argv[])
+{
+
+  GstElement *pipeline = NULL;
+  GError *error = NULL;
+  GstElement *level;
+
+  gst_init (&argc, &argv);
+  gtk_init (&argc, &argv);
+
+  pipeline = gst_parse_launchv ((const gchar **) &argv[1], &error);
+  if (error) {
+    g_print ("pipeline could not be constructed: %s\n", error->message);
+    g_print ("Please give a complete pipeline  with a 'level' element.\n");
+    g_print ("Example: sinesrc ! level ! %s\n", DEFAULT_AUDIOSINK);
+    g_error_free (error);
+    return 1;
+  }
+
+  level = gst_bin_get_by_name (GST_BIN (pipeline), "level0");
+  if (level == NULL) {
+    g_print ("Please give a pipeline with a 'level' element in it\n");
+    return 1;
+  }
+
+  g_object_set (level, "signal", TRUE, NULL);
+  g_signal_connect (level, "level", G_CALLBACK (level_callback), NULL);
+
+
+  /* go to main loop */
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_idle_add (idler, pipeline);
+
+  gtk_main ();
+
+  return 0;
+}
diff --git a/tests/examples/mpegtsmux/mpts_test2.c b/tests/examples/mpegtsmux/mpts_test2.c
new file mode 100644
index 0000000..25d0a98
--- /dev/null
+++ b/tests/examples/mpegtsmux/mpts_test2.c
@@ -0,0 +1,199 @@
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+
+    case GST_MESSAGE_EOS:
+      g_print ("End of stream\n");
+      g_main_loop_quit (loop);
+      break;
+
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *error;
+
+      gst_message_parse_error (msg, &error, &debug);
+      g_free (debug);
+
+      g_printerr ("Error: %s\n", error->message);
+      g_error_free (error);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+static void
+on_pad_added (GstElement * element, GstPad * pad, gpointer data)
+{
+  GstPad *sinkpad;
+  GstElement *decoder = (GstElement *) data;
+
+  /* We can now link this pad with the vorbis-decoder sink pad */
+  g_print ("Dynamic pad created, linking demuxer/decoder\n");
+
+  sinkpad = gst_element_get_static_pad (decoder, "sink");
+
+  gst_pad_link (pad, sinkpad);
+
+  gst_object_unref (sinkpad);
+}
+
+
+#define NR_PROG 3
+
+int
+main (int argc, char *argv[])
+{
+  GMainLoop *loop;
+  GstElement *pipeline, *sink, *mux;
+  GstElement *vsrc[NR_PROG];
+  GstElement *asrc[NR_PROG];
+  GstElement *vparse[NR_PROG];
+  GstElement *vdemux[NR_PROG];
+  GstElement *aparse[NR_PROG];
+  GstPad *tl_pad, *pad;
+  GstStructure *pm;
+  GstBus *bus;
+
+  FILE *xml_of;
+
+  gchar vname[][60] = {
+    "/Users/lyang/src/res/mpts.test/mpts110.mpv",
+    "/Users/lyang/src/res/mpts.test/mpts120.mpv",
+    "/Users/lyang/src/res/mpts.test/mpts130.mpv",
+    "/Users/lyang/src/res/mpts.test/mpts140.mpv",
+    "/Users/lyang/src/res/mpts.test/mpts150.mpv",
+    "/Users/lyang/src/res/mpts.test/mpts160.mpv",
+    "/Users/lyang/src/res/mpts.test/mpts170.mpv"
+  };
+  gchar aname[][60] = {
+    "/Users/lyang/src/res/mpts.test/mpts113.mpa",
+    "/Users/lyang/src/res/mpts.test/mpts123.mpa",
+    "/Users/lyang/src/res/mpts.test/mpts133.mpa",
+    "/Users/lyang/src/res/mpts.test/mpts143.mpa",
+    "/Users/lyang/src/res/mpts.test/mpts153.mpa",
+    "/Users/lyang/src/res/mpts.test/mpts163.mpa",
+    "/Users/lyang/src/res/mpts.test/mpts173.mpa"
+  };
+  gchar dest_dir[60];
+  gchar dest_xml[60];
+
+  gint i;
+
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  pipeline = gst_pipeline_new ("mpeg-ts-muxer");
+  mux = gst_element_factory_make ("mpegtsmux", "muxer");
+  sink = gst_element_factory_make ("filesink", "sink");
+  if (!pipeline || !mux || !sink) {
+    g_printerr ("Some element could not be created.\n");
+    return -1;
+  }
+
+  for (i = 0; i < NR_PROG; i++) {
+    vsrc[i] = gst_element_factory_make ("filesrc", NULL);
+    vdemux[i] = gst_element_factory_make ("mpegpsdemux", NULL);
+    vparse[i] = gst_element_factory_make ("mpegvideoparse", NULL);
+
+    asrc[i] = gst_element_factory_make ("filesrc", NULL);
+    aparse[i] = gst_element_factory_make ("mp3parse", NULL);
+
+    if (!vsrc[i] || !vparse[i] || !vdemux[i] || !asrc[i] || !aparse[i]) {
+      g_printerr ("Some element could not be created. i=%d.\n", i);
+      return -1;
+    }
+  }
+
+  /* Setting paths */
+  for (i = 0; i < NR_PROG; i++) {
+    g_object_set (G_OBJECT (vsrc[i]), "location", vname[i], NULL);
+    g_object_set (G_OBJECT (asrc[i]), "location", aname[i], NULL);
+  }
+
+  sprintf (dest_dir, "/Users/lyang/src/res/mpts.test/mpts_%02d.ts", NR_PROG);
+  g_object_set (G_OBJECT (sink), "location", dest_dir, NULL);
+
+  /* construct the pipeline */
+  gst_bin_add_many (GST_BIN (pipeline), mux, sink, NULL);
+  gst_element_link (mux, sink);
+  for (i = 0; i < NR_PROG; i++) {
+    gst_bin_add_many (GST_BIN (pipeline), vsrc[i], vdemux[i], vparse[i], NULL);
+    gst_element_link (vsrc[i], vdemux[i]);
+
+    g_signal_connect (vdemux[i], "pad-added", G_CALLBACK (on_pad_added),
+        vparse[i]);
+
+    gst_bin_add_many (GST_BIN (pipeline), asrc[i], aparse[i], NULL);
+    gst_element_link (asrc[i], aparse[i]);
+  }
+
+  /* construct the program map */
+  pm = gst_structure_empty_new ("program_map");
+
+  /* Program 1 */
+  for (i = 0; i < NR_PROG; i++) {
+    /* vparse <-> mux */
+    tl_pad = gst_element_get_static_pad (vparse[i], "src");
+    if (tl_pad == NULL) {
+      g_printerr ("vparse[%d] src pad getting failed.\n", i);
+      return -1;
+    }
+    pad = gst_element_get_compatible_pad (mux, tl_pad, NULL);
+    gst_pad_link (tl_pad, pad);
+    gst_structure_set (pm, gst_pad_get_name (pad), G_TYPE_INT, i, NULL);
+    gst_object_unref (GST_OBJECT (tl_pad));
+    gst_object_unref (GST_OBJECT (pad));
+
+    /* aparse <-> mux */
+    tl_pad = gst_element_get_static_pad (aparse[i], "src");
+    if (tl_pad == NULL) {
+      g_printerr ("aparse[%d] src pad getting failed.\n", i);
+      return -1;
+    }
+    pad = gst_element_get_compatible_pad (mux, tl_pad, NULL);
+    gst_pad_link (tl_pad, pad);
+    gst_structure_set (pm, gst_pad_get_name (pad), G_TYPE_INT, i, NULL);
+    gst_object_unref (GST_OBJECT (tl_pad));
+    gst_object_unref (GST_OBJECT (pad));
+  }
+
+  /* set the program map */
+  g_object_set (G_OBJECT (mux), "prog-map", pm, NULL);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* Write the pipeline to XML */
+  sprintf (dest_xml, "/Users/lyang/src/res/mpts.test/mpts_%02d.xml", NR_PROG);
+  xml_of = fopen (dest_xml, "w");
+  gst_xml_write_file (GST_ELEMENT (pipeline), xml_of);
+
+  g_print ("Now playing: %s\n", dest_dir);
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+
+  /* Run! */
+  g_print ("Running...\n");
+  g_main_loop_run (loop);
+
+  /* Out of the main loop, clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+
+}
diff --git a/tests/examples/mxf/Makefile.in b/tests/examples/mxf/Makefile.in
index adbae3d..9576250 100644
--- a/tests/examples/mxf/Makefile.in
+++ b/tests/examples/mxf/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -17,6 +16,23 @@
 
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -35,16 +51,16 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 noinst_PROGRAMS = mxfdemux-structure$(EXEEXT)
 subdir = tests/examples/mxf
 DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in
+	$(srcdir)/Makefile.in $(top_srcdir)/depcomp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -89,10 +105,23 @@ mxfdemux_structure_LDADD = $(LDADD)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
+am__v_lt_1 = 
 mxfdemux_structure_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(mxfdemux_structure_CFLAGS) $(CFLAGS) \
 	$(mxfdemux_structure_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -105,22 +134,23 @@ LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(mxfdemux_structure_SOURCES)
 DIST_SOURCES = $(mxfdemux_structure_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 HEADERS = $(noinst_HEADERS)
 ETAGS = etags
 CTAGS = ctags
@@ -156,6 +186,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -180,10 +212,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -198,9 +232,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -258,13 +295,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -283,13 +323,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -299,6 +345,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -326,6 +373,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -363,7 +414,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -372,6 +423,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -405,6 +457,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -421,6 +475,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -449,12 +504,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -522,7 +580,11 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
@@ -675,6 +737,20 @@ GTAGS:
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
@@ -816,7 +892,7 @@ uninstall-am:
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstPROGRAMS ctags distclean \
+	clean-libtool clean-noinstPROGRAMS cscopelist ctags distclean \
 	distclean-compile distclean-generic distclean-libtool \
 	distclean-tags distdir dvi dvi-am html html-am info info-am \
 	install install-am install-data install-data-am install-dvi \
diff --git a/tests/examples/mxf/mxfdemux-structure.c b/tests/examples/mxf/mxfdemux-structure.c
index 6f735c4..049f4ef 100644
--- a/tests/examples/mxf/mxfdemux-structure.c
+++ b/tests/examples/mxf/mxfdemux-structure.c
@@ -183,9 +183,10 @@ main (gint argc, gchar ** argv)
     g_print ("usage: %s MXF-FILE\n", argv[0]);
     return -1;
   }
-
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
   gst_init (NULL, NULL);
   gtk_init (NULL, NULL);
diff --git a/tests/examples/opencv/Makefile.in b/tests/examples/opencv/Makefile.in
index 80bba46..ac7b418 100644
--- a/tests/examples/opencv/Makefile.in
+++ b/tests/examples/opencv/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -17,6 +16,23 @@
 
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -35,16 +51,16 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 noinst_PROGRAMS = gstmotioncells_dynamic_test$(EXEEXT)
 subdir = tests/examples/opencv
 DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in
+	$(srcdir)/Makefile.in $(top_srcdir)/depcomp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -90,10 +106,23 @@ gstmotioncells_dynamic_test_LDADD = $(LDADD)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
+am__v_lt_1 = 
 gstmotioncells_dynamic_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(gstmotioncells_dynamic_test_CFLAGS) $(CFLAGS) \
 	$(gstmotioncells_dynamic_test_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -106,22 +135,23 @@ LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(gstmotioncells_dynamic_test_SOURCES)
 DIST_SOURCES = $(gstmotioncells_dynamic_test_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 HEADERS = $(noinst_HEADERS)
 ETAGS = etags
 CTAGS = ctags
@@ -157,6 +187,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -181,10 +213,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -199,9 +233,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -259,13 +296,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -284,13 +324,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -300,6 +346,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -327,6 +374,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -364,7 +415,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -373,6 +424,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -406,6 +458,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -422,6 +476,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -450,12 +505,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -523,7 +581,11 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
@@ -697,6 +759,20 @@ GTAGS:
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
@@ -838,7 +914,7 @@ uninstall-am:
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstPROGRAMS ctags distclean \
+	clean-libtool clean-noinstPROGRAMS cscopelist ctags distclean \
 	distclean-compile distclean-generic distclean-libtool \
 	distclean-tags distdir dvi dvi-am html html-am info info-am \
 	install install-am install-data install-data-am install-dvi \
diff --git a/tests/examples/opencv/gst_element_print_properties.c b/tests/examples/opencv/gst_element_print_properties.c
index 4192fe8..3d7ae78 100644
--- a/tests/examples/opencv/gst_element_print_properties.c
+++ b/tests/examples/opencv/gst_element_print_properties.c
@@ -20,6 +20,10 @@
  *
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 
 #include <gst/gst.h>
 #include <string.h>
diff --git a/tests/examples/scaletempo/Makefile.am b/tests/examples/scaletempo/Makefile.am
index 5cdf3c7..aec2f29 100644
--- a/tests/examples/scaletempo/Makefile.am
+++ b/tests/examples/scaletempo/Makefile.am
@@ -1,8 +1,8 @@
 noinst_PROGRAMS = scaletempo-demo
 
 scaletempo_demo_SOURCES = demo-main.c demo-player.c demo-gui.c
-scaletempo_demo_CFLAGS = $(GST_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GTK_CFLAGS) 
-scaletempo_demo_LDFLAGS = $(GST_LIBS) $(GST_PLUGINS_BASE_LIBS) $(GTK_LIBS) -lgstinterfaces-@GST_MAJORMINOR@
+scaletempo_demo_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS) $(GTK_CFLAGS)
+scaletempo_demo_LDFLAGS = $(GST_PLUGINS_BASE_LIBS) -lgstinterfaces-@GST_MAJORMINOR@ $(GST_LIBS) $(GTK_LIBS)
 
 noinst_HEADERS = demo-player.h demo-gui.h
 
diff --git a/tests/examples/scaletempo/Makefile.in b/tests/examples/scaletempo/Makefile.in
index 0162793..4883391 100644
--- a/tests/examples/scaletempo/Makefile.in
+++ b/tests/examples/scaletempo/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -17,6 +16,23 @@
 
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -35,16 +51,16 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 noinst_PROGRAMS = scaletempo-demo$(EXEEXT)
 subdir = tests/examples/scaletempo
 DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in
+	$(srcdir)/Makefile.in $(top_srcdir)/depcomp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -90,10 +106,23 @@ scaletempo_demo_LDADD = $(LDADD)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
+am__v_lt_1 = 
 scaletempo_demo_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(scaletempo_demo_CFLAGS) $(CFLAGS) $(scaletempo_demo_LDFLAGS) \
 	$(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -106,22 +135,23 @@ LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(scaletempo_demo_SOURCES)
 DIST_SOURCES = $(scaletempo_demo_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 HEADERS = $(noinst_HEADERS)
 ETAGS = etags
 CTAGS = ctags
@@ -157,6 +187,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -181,10 +213,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -199,9 +233,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -259,13 +296,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -284,13 +324,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -300,6 +346,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -327,6 +374,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -364,7 +415,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -373,6 +424,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -406,6 +458,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -422,6 +476,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -450,12 +505,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -523,13 +581,17 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 scaletempo_demo_SOURCES = demo-main.c demo-player.c demo-gui.c
-scaletempo_demo_CFLAGS = $(GST_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GTK_CFLAGS) 
-scaletempo_demo_LDFLAGS = $(GST_LIBS) $(GST_PLUGINS_BASE_LIBS) $(GTK_LIBS) -lgstinterfaces-@GST_MAJORMINOR@
+scaletempo_demo_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS) $(GTK_CFLAGS)
+scaletempo_demo_LDFLAGS = $(GST_PLUGINS_BASE_LIBS) -lgstinterfaces-@GST_MAJORMINOR@ $(GST_LIBS) $(GTK_LIBS)
 noinst_HEADERS = demo-player.h demo-gui.h
 all: all-am
 
@@ -706,6 +768,20 @@ GTAGS:
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
@@ -847,7 +923,7 @@ uninstall-am:
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstPROGRAMS ctags distclean \
+	clean-libtool clean-noinstPROGRAMS cscopelist ctags distclean \
 	distclean-compile distclean-generic distclean-libtool \
 	distclean-tags distdir dvi dvi-am html html-am info info-am \
 	install install-am install-data install-data-am install-dvi \
diff --git a/tests/examples/scaletempo/demo-gui.c b/tests/examples/scaletempo/demo-gui.c
index c31c2bf..9afce89 100644
--- a/tests/examples/scaletempo/demo-gui.c
+++ b/tests/examples/scaletempo/demo-gui.c
@@ -19,6 +19,11 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
+#include <gst/glib-compat-private.h>
 #include <gtk/gtk.h>
 #include <glib/gprintf.h>
 #include <math.h>
diff --git a/tests/examples/scaletempo/demo-main.c b/tests/examples/scaletempo/demo-main.c
index 6ddcde7..d2ed0df 100644
--- a/tests/examples/scaletempo/demo-main.c
+++ b/tests/examples/scaletempo/demo-main.c
@@ -60,8 +60,10 @@ main (int argc, char *argv[])
     {NULL,}
   };
 
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
   ctx = g_option_context_new ("uri ...");
   g_option_context_add_group (ctx, gst_init_get_option_group ());
diff --git a/tests/examples/stats/Makefile.am b/tests/examples/stats/Makefile.am
new file mode 100644
index 0000000..0f7d81c
--- /dev/null
+++ b/tests/examples/stats/Makefile.am
@@ -0,0 +1,6 @@
+noinst_PROGRAMS = mp2ogg
+
+LDADD = $(GST_LIBS)
+AM_CFLAGS = $(GST_CFLAGS)
+
+
diff --git a/tests/examples/stats/mp2ogg.c b/tests/examples/stats/mp2ogg.c
new file mode 100644
index 0000000..fc56d5b
--- /dev/null
+++ b/tests/examples/stats/mp2ogg.c
@@ -0,0 +1,102 @@
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <gst/gst.h>
+
+/* This example app demonstartes the use of pad query and convert to
+ * get useful statistics about a plugin. In this case we monitor the
+ * compression status of mpeg audio to ogg vorbis transcoding.
+ */
+
+gint
+main (gint argc, gchar * argv[])
+{
+  GstElement *pipeline;
+  GError *error = NULL;
+  gchar *description;
+  GstElement *encoder, *decoder;
+  GstPad *dec_sink, *enc_src;
+
+  gst_init (&argc, &argv);
+
+  if (argc < 3) {
+    g_print ("usage: %s <inputfile> <outputfile>\n", argv[0]);
+    return -1;
+  }
+
+  description = g_strdup_printf ("filesrc location=\"%s\" ! mad name=decoder ! "
+      "vorbisenc name=encoder ! filesink location=\"%s\"", argv[1], argv[2]);
+
+  pipeline = GST_ELEMENT (gst_parse_launch (description, &error));
+  if (!pipeline) {
+    if (error)
+      g_print ("ERROR: pipeline could not be constructed: %s\n",
+          error->message);
+    else
+      g_print ("ERROR: pipeline could not be constructed\n");
+    return -1;
+  }
+
+  decoder = gst_bin_get_by_name (GST_BIN (pipeline), "decoder");
+  encoder = gst_bin_get_by_name (GST_BIN (pipeline), "encoder");
+
+  dec_sink = gst_element_get_pad (decoder, "sink");
+  enc_src = gst_element_get_pad (encoder, "src");
+
+  if (gst_element_set_state (pipeline,
+          GST_STATE_PLAYING) != GST_STATE_CHANGE_SUCCESS) {
+    g_print ("pipeline doesn't want to play\n");
+    return -1;
+  }
+
+  while (gst_bin_iterate (GST_BIN (pipeline))) {
+    gint64 position;
+    gint64 duration;
+    gint64 bitrate_enc, bitrate_dec;
+    GstFormat format;
+
+    format = GST_FORMAT_TIME;
+    /* get the position */
+    gst_pad_query (enc_src, GST_QUERY_POSITION, &format, &position);
+
+    /* get the total duration */
+    gst_pad_query (enc_src, GST_QUERY_TOTAL, &format, &duration);
+
+    format = GST_FORMAT_BYTES;
+    /* see how many bytes are genereated per 8 seconds (== bitrate) */
+    gst_pad_convert (enc_src, GST_FORMAT_TIME, 8 * GST_SECOND,
+        &format, &bitrate_enc);
+
+    gst_pad_convert (dec_sink, GST_FORMAT_TIME, 8 * GST_SECOND,
+        &format, &bitrate_dec);
+
+    g_print ("[%2dm %.2ds] of [%2dm %.2ds], "
+        "src avg bitrate: %" G_GINT64_FORMAT ", dest avg birate: %"
+        G_GINT64_FORMAT ", ratio [%02.2f]    \r",
+        (gint) (position / (GST_SECOND * 60)),
+        (gint) (position / (GST_SECOND)) % 60,
+        (gint) (duration / (GST_SECOND * 60)),
+        (gint) (duration / (GST_SECOND)) % 60, bitrate_dec, bitrate_enc,
+        (gfloat) bitrate_dec / bitrate_enc);
+  }
+
+  g_print ("\n");
+
+  return 0;
+}
diff --git a/tests/examples/uvch264/Makefile.am b/tests/examples/uvch264/Makefile.am
new file mode 100644
index 0000000..e02b888
--- /dev/null
+++ b/tests/examples/uvch264/Makefile.am
@@ -0,0 +1,36 @@
+TEST_UVCH264_GLADE_FILES = window.glade \
+			boolean_property.glade \
+			enum_property.glade \
+			int_property.glade
+
+if HAVE_GTK
+
+TEST_UVCH264_EXAMPLES = test-uvch264
+
+test_uvch264_SOURCES = test-uvch264.c
+test_uvch264_CFLAGS  = \
+        $(GST_PLUGINS_BAD_CFLAGS) \
+        $(GST_PLUGINS_BASE_CFLAGS) \
+	$(GST_VIDEO_CFLAGS) \
+	$(GST_CFLAGS) \
+	$(GTK_CFLAGS) \
+	$(GMODULE_EXPORT_CFLAGS) \
+        -DGST_USE_UNSTABLE_API
+test_uvch264_LDADD   = \
+        $(GST_PLUGINS_BASE_LIBS) \
+	$(GST_VIDEO_LIBS) \
+        $(GST_LIBS) \
+        -lgstinterfaces-@GST_MAJORMINOR@ \
+	$(GTK_LIBS) \
+	$(GMODULE_EXPORT_LIBS)
+
+noinst_DATA = $(TEST_UVCH264_GLADE_FILES)
+
+else
+TEST_UVCH264_EXAMPLES =
+endif
+
+noinst_PROGRAMS = $(TEST_UVCH264_EXAMPLES)
+
+EXTRA_DIST = $(TEST_UVCH264_GLADE_FILES)
+
diff --git a/tests/examples/uvch264/Makefile.in b/tests/examples/uvch264/Makefile.in
new file mode 100644
index 0000000..3cab7d6
--- /dev/null
+++ b/tests/examples/uvch264/Makefile.in
@@ -0,0 +1,937 @@
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+noinst_PROGRAMS = $(am__EXEEXT_1)
+subdir = tests/examples/uvch264
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(top_srcdir)/depcomp
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
+	$(top_srcdir)/common/m4/as-auto-alt.m4 \
+	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
+	$(top_srcdir)/common/m4/as-libtool.m4 \
+	$(top_srcdir)/common/m4/as-python.m4 \
+	$(top_srcdir)/common/m4/as-scrub-include.m4 \
+	$(top_srcdir)/common/m4/as-version.m4 \
+	$(top_srcdir)/common/m4/ax_create_stdint_h.m4 \
+	$(top_srcdir)/common/m4/gst-arch.m4 \
+	$(top_srcdir)/common/m4/gst-args.m4 \
+	$(top_srcdir)/common/m4/gst-check.m4 \
+	$(top_srcdir)/common/m4/gst-default.m4 \
+	$(top_srcdir)/common/m4/gst-dowhile.m4 \
+	$(top_srcdir)/common/m4/gst-error.m4 \
+	$(top_srcdir)/common/m4/gst-feature.m4 \
+	$(top_srcdir)/common/m4/gst-gettext.m4 \
+	$(top_srcdir)/common/m4/gst-glib2.m4 \
+	$(top_srcdir)/common/m4/gst-package-release-datetime.m4 \
+	$(top_srcdir)/common/m4/gst-platform.m4 \
+	$(top_srcdir)/common/m4/gst-plugin-docs.m4 \
+	$(top_srcdir)/common/m4/gst-plugindir.m4 \
+	$(top_srcdir)/common/m4/gst-x11.m4 \
+	$(top_srcdir)/common/m4/gst.m4 \
+	$(top_srcdir)/common/m4/gtk-doc.m4 \
+	$(top_srcdir)/common/m4/orc.m4 $(top_srcdir)/common/m4/pkg.m4 \
+	$(top_srcdir)/m4/gettext.m4 $(top_srcdir)/m4/gsettings.m4 \
+	$(top_srcdir)/m4/gst-fionread.m4 $(top_srcdir)/m4/gst-sdl.m4 \
+	$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/intlmacosx.m4 \
+	$(top_srcdir)/m4/lib-ld.m4 $(top_srcdir)/m4/lib-link.m4 \
+	$(top_srcdir)/m4/lib-prefix.m4 $(top_srcdir)/m4/libtool.m4 \
+	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
+	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
+	$(top_srcdir)/m4/nls.m4 $(top_srcdir)/m4/po.m4 \
+	$(top_srcdir)/m4/progtest.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+@HAVE_GTK_TRUE@am__EXEEXT_1 = test-uvch264$(EXEEXT)
+PROGRAMS = $(noinst_PROGRAMS)
+am__test_uvch264_SOURCES_DIST = test-uvch264.c
+@HAVE_GTK_TRUE@am_test_uvch264_OBJECTS =  \
+@HAVE_GTK_TRUE@	test_uvch264-test-uvch264.$(OBJEXT)
+test_uvch264_OBJECTS = $(am_test_uvch264_OBJECTS)
+am__DEPENDENCIES_1 =
+@HAVE_GTK_TRUE@test_uvch264_DEPENDENCIES = $(am__DEPENDENCIES_1) \
+@HAVE_GTK_TRUE@	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+@HAVE_GTK_TRUE@	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+test_uvch264_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(test_uvch264_CFLAGS) \
+	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = $(test_uvch264_SOURCES)
+DIST_SOURCES = $(am__test_uvch264_SOURCES_DIST)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+DATA = $(noinst_DATA)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ACLOCAL_AMFLAGS = @ACLOCAL_AMFLAGS@
+ACMENC_CFLAGS = @ACMENC_CFLAGS@
+ACMMP3DEC_CFLAGS = @ACMMP3DEC_CFLAGS@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+APEXSINK_CFLAGS = @APEXSINK_CFLAGS@
+APEXSINK_LIBS = @APEXSINK_LIBS@
+AR = @AR@
+AS = @AS@
+ASSRENDER_CFLAGS = @ASSRENDER_CFLAGS@
+ASSRENDER_LIBS = @ASSRENDER_LIBS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BZ2_LIBS = @BZ2_LIBS@
+CC = @CC@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CDAUDIO_CFLAGS = @CDAUDIO_CFLAGS@
+CDAUDIO_LIBS = @CDAUDIO_LIBS@
+CELT_0_11_CFLAGS = @CELT_0_11_CFLAGS@
+CELT_0_11_LIBS = @CELT_0_11_LIBS@
+CELT_0_7_CFLAGS = @CELT_0_7_CFLAGS@
+CELT_0_7_LIBS = @CELT_0_7_LIBS@
+CELT_0_8_CFLAGS = @CELT_0_8_CFLAGS@
+CELT_0_8_LIBS = @CELT_0_8_LIBS@
+CELT_CFLAGS = @CELT_CFLAGS@
+CELT_LIBS = @CELT_LIBS@
+CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
+COG_CFLAGS = @COG_CFLAGS@
+COG_LIBS = @COG_LIBS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CURL_CFLAGS = @CURL_CFLAGS@
+CURL_LIBS = @CURL_LIBS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DCCP_LIBS = @DCCP_LIBS@
+DECKLINK_CXXFLAGS = @DECKLINK_CXXFLAGS@
+DECKLINK_LIBS = @DECKLINK_LIBS@
+DEFAULT_AUDIOSINK = @DEFAULT_AUDIOSINK@
+DEFAULT_AUDIOSRC = @DEFAULT_AUDIOSRC@
+DEFAULT_VIDEOSINK = @DEFAULT_VIDEOSINK@
+DEFAULT_VIDEOSRC = @DEFAULT_VIDEOSRC@
+DEFAULT_VISUALIZER = @DEFAULT_VISUALIZER@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
+DIRAC_CFLAGS = @DIRAC_CFLAGS@
+DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
+DIRECT3D_LIBS = @DIRECT3D_LIBS@
+DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
+DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
+DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
+DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
+DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
+DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
+DIVXDEC_LIBS = @DIVXDEC_LIBS@
+DIVXENC_LIBS = @DIVXENC_LIBS@
+DLLTOOL = @DLLTOOL@
+DSYMUTIL = @DSYMUTIL@
+DTS_LIBS = @DTS_LIBS@
+DUMPBIN = @DUMPBIN@
+DVDNAV_CFLAGS = @DVDNAV_CFLAGS@
+DVDNAV_LIBS = @DVDNAV_LIBS@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
+EGREP = @EGREP@
+ERROR_CFLAGS = @ERROR_CFLAGS@
+ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
+EXEEXT = @EXEEXT@
+EXIF_CFLAGS = @EXIF_CFLAGS@
+EXIF_LIBS = @EXIF_LIBS@
+FAAC_LIBS = @FAAC_LIBS@
+FAAD_IS_NEAAC = @FAAD_IS_NEAAC@
+FAAD_LIBS = @FAAD_LIBS@
+FFLAGS = @FFLAGS@
+FGREP = @FGREP@
+FLITE_CFLAGS = @FLITE_CFLAGS@
+FLITE_LIBS = @FLITE_LIBS@
+GCOV = @GCOV@
+GCOV_CFLAGS = @GCOV_CFLAGS@
+GCOV_LIBS = @GCOV_LIBS@
+GETTEXT_MACRO_VERSION = @GETTEXT_MACRO_VERSION@
+GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
+GIO_CFLAGS = @GIO_CFLAGS@
+GIO_LIBS = @GIO_LIBS@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_COMPILE_SCHEMAS = @GLIB_COMPILE_SCHEMAS@
+GLIB_EXTRA_CFLAGS = @GLIB_EXTRA_CFLAGS@
+GLIB_LIBS = @GLIB_LIBS@
+GLIB_PREFIX = @GLIB_PREFIX@
+GLIB_REQ = @GLIB_REQ@
+GME_LIBS = @GME_LIBS@
+GMODULE_EXPORT_CFLAGS = @GMODULE_EXPORT_CFLAGS@
+GMODULE_EXPORT_LIBS = @GMODULE_EXPORT_LIBS@
+GMSGFMT = @GMSGFMT@
+GMSGFMT_015 = @GMSGFMT_015@
+GMYTH_CFLAGS = @GMYTH_CFLAGS@
+GMYTH_LIBS = @GMYTH_LIBS@
+GREP = @GREP@
+GSETTINGS_CFLAGS = @GSETTINGS_CFLAGS@
+GSETTINGS_DISABLE_SCHEMAS_COMPILE = @GSETTINGS_DISABLE_SCHEMAS_COMPILE@
+GSETTINGS_LIBS = @GSETTINGS_LIBS@
+GSM_LIBS = @GSM_LIBS@
+GSTPB_PLUGINS_DIR = @GSTPB_PLUGINS_DIR@
+GSTPB_PREFIX = @GSTPB_PREFIX@
+GST_AGE = @GST_AGE@
+GST_ALL_LDFLAGS = @GST_ALL_LDFLAGS@
+GST_BASE_CFLAGS = @GST_BASE_CFLAGS@
+GST_BASE_LIBS = @GST_BASE_LIBS@
+GST_CFLAGS = @GST_CFLAGS@
+GST_CHECK_CFLAGS = @GST_CHECK_CFLAGS@
+GST_CHECK_LIBS = @GST_CHECK_LIBS@
+GST_CONTROLLER_CFLAGS = @GST_CONTROLLER_CFLAGS@
+GST_CONTROLLER_LIBS = @GST_CONTROLLER_LIBS@
+GST_CURRENT = @GST_CURRENT@
+GST_CXXFLAGS = @GST_CXXFLAGS@
+GST_GDP_CFLAGS = @GST_GDP_CFLAGS@
+GST_GDP_LIBS = @GST_GDP_LIBS@
+GST_LEVEL_DEFAULT = @GST_LEVEL_DEFAULT@
+GST_LIBS = @GST_LIBS@
+GST_LIBVERSION = @GST_LIBVERSION@
+GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
+GST_LICENSE = @GST_LICENSE@
+GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
+GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
+GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
+GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
+GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
+GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
+GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
+GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
+GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
+GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
+GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
+GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
+GST_PLUGINS_DIR = @GST_PLUGINS_DIR@
+GST_PLUGINS_FFMPEG_CFLAGS = @GST_PLUGINS_FFMPEG_CFLAGS@
+GST_PLUGINS_FFMPEG_DIR = @GST_PLUGINS_FFMPEG_DIR@
+GST_PLUGINS_FFMPEG_LIBS = @GST_PLUGINS_FFMPEG_LIBS@
+GST_PLUGINS_GOOD_CFLAGS = @GST_PLUGINS_GOOD_CFLAGS@
+GST_PLUGINS_GOOD_DIR = @GST_PLUGINS_GOOD_DIR@
+GST_PLUGINS_GOOD_LIBS = @GST_PLUGINS_GOOD_LIBS@
+GST_PLUGINS_SELECTED = @GST_PLUGINS_SELECTED@
+GST_PLUGINS_UGLY_CFLAGS = @GST_PLUGINS_UGLY_CFLAGS@
+GST_PLUGINS_UGLY_DIR = @GST_PLUGINS_UGLY_DIR@
+GST_PLUGINS_UGLY_LIBS = @GST_PLUGINS_UGLY_LIBS@
+GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
+GST_PREFIX = @GST_PREFIX@
+GST_REVISION = @GST_REVISION@
+GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
+GTKDOC_CHECK = @GTKDOC_CHECK@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
+HAVE_BZ2 = @HAVE_BZ2@
+HAVE_CXX = @HAVE_CXX@
+HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
+HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
+HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
+HAVE_DTS = @HAVE_DTS@
+HAVE_FAAC = @HAVE_FAAC@
+HAVE_FAAD = @HAVE_FAAD@
+HAVE_FLITE = @HAVE_FLITE@
+HAVE_GSM = @HAVE_GSM@
+HAVE_JP2K = @HAVE_JP2K@
+HAVE_NAS = @HAVE_NAS@
+HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
+HAVE_WILDMIDI = @HAVE_WILDMIDI@
+HAVE_X = @HAVE_X@
+HAVE_X11 = @HAVE_X11@
+HTML_DIR = @HTML_DIR@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INTLLIBS = @INTLLIBS@
+INTL_MACOSX_LIBS = @INTL_MACOSX_LIBS@
+JP2K_LIBS = @JP2K_LIBS@
+KATE_CFLAGS = @KATE_CFLAGS@
+KATE_LIBS = @KATE_LIBS@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBDC1394_CFLAGS = @LIBDC1394_CFLAGS@
+LIBDC1394_LIBS = @LIBDC1394_LIBS@
+LIBDIR = @LIBDIR@
+LIBICONV = @LIBICONV@
+LIBINTL = @LIBINTL@
+LIBM = @LIBM@
+LIBMMS_CFLAGS = @LIBMMS_CFLAGS@
+LIBMMS_LIBS = @LIBMMS_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LOCALEDIR = @LOCALEDIR@
+LRDF_CFLAGS = @LRDF_CFLAGS@
+LRDF_LIBS = @LRDF_LIBS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MIMIC_CFLAGS = @MIMIC_CFLAGS@
+MIMIC_LIBS = @MIMIC_LIBS@
+MJPEG_CFLAGS = @MJPEG_CFLAGS@
+MJPEG_LIBS = @MJPEG_LIBS@
+MKDIR_P = @MKDIR_P@
+MODPLUG_CFLAGS = @MODPLUG_CFLAGS@
+MODPLUG_LIBS = @MODPLUG_LIBS@
+MPEG2ENC_CFLAGS = @MPEG2ENC_CFLAGS@
+MPEG2ENC_LIBS = @MPEG2ENC_LIBS@
+MPLEX_CFLAGS = @MPLEX_CFLAGS@
+MPLEX_LDFLAGS = @MPLEX_LDFLAGS@
+MPLEX_LIBS = @MPLEX_LIBS@
+MSGFMT = @MSGFMT@
+MSGFMT_015 = @MSGFMT_015@
+MSGMERGE = @MSGMERGE@
+MUSEPACK_LIBS = @MUSEPACK_LIBS@
+MUSICBRAINZ_CFLAGS = @MUSICBRAINZ_CFLAGS@
+MUSICBRAINZ_LIBS = @MUSICBRAINZ_LIBS@
+NAS_CFLAGS = @NAS_CFLAGS@
+NAS_LIBS = @NAS_LIBS@
+NEON_CFLAGS = @NEON_CFLAGS@
+NEON_LIBS = @NEON_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJC = @OBJC@
+OBJCDEPMODE = @OBJCDEPMODE@
+OBJCFLAGS = @OBJCFLAGS@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OFA_CFLAGS = @OFA_CFLAGS@
+OFA_LIBS = @OFA_LIBS@
+OPENAL_CFLAGS = @OPENAL_CFLAGS@
+OPENAL_LIBS = @OPENAL_LIBS@
+OPENCV_CFLAGS = @OPENCV_CFLAGS@
+OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
+OPUS_CFLAGS = @OPUS_CFLAGS@
+OPUS_LIBS = @OPUS_LIBS@
+ORCC = @ORCC@
+ORCC_FLAGS = @ORCC_FLAGS@
+ORC_CFLAGS = @ORC_CFLAGS@
+ORC_LIBS = @ORC_LIBS@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PACKAGE_VERSION_MAJOR = @PACKAGE_VERSION_MAJOR@
+PACKAGE_VERSION_MICRO = @PACKAGE_VERSION_MICRO@
+PACKAGE_VERSION_MINOR = @PACKAGE_VERSION_MINOR@
+PACKAGE_VERSION_NANO = @PACKAGE_VERSION_NANO@
+PACKAGE_VERSION_RELEASE = @PACKAGE_VERSION_RELEASE@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PLUGINDIR = @PLUGINDIR@
+POSUB = @POSUB@
+PROFILE_CFLAGS = @PROFILE_CFLAGS@
+PVR_CFLAGS = @PVR_CFLAGS@
+PVR_LIBS = @PVR_LIBS@
+PYTHON = @PYTHON@
+PYTHON_EXEC_PREFIX = @PYTHON_EXEC_PREFIX@
+PYTHON_PLATFORM = @PYTHON_PLATFORM@
+PYTHON_PREFIX = @PYTHON_PREFIX@
+PYTHON_VERSION = @PYTHON_VERSION@
+RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
+RSVG_CFLAGS = @RSVG_CFLAGS@
+RSVG_LIBS = @RSVG_LIBS@
+RTMP_CFLAGS = @RTMP_CFLAGS@
+RTMP_LIBS = @RTMP_LIBS@
+SCHRO_CFLAGS = @SCHRO_CFLAGS@
+SCHRO_LIBS = @SCHRO_LIBS@
+SDL_CFLAGS = @SDL_CFLAGS@
+SDL_CONFIG = @SDL_CONFIG@
+SDL_LIBS = @SDL_LIBS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SLV2_CFLAGS = @SLV2_CFLAGS@
+SLV2_LIBS = @SLV2_LIBS@
+SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
+SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
+SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
+SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
+SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
+SPANDSP_LIBS = @SPANDSP_LIBS@
+SPC_LIBS = @SPC_LIBS@
+STRIP = @STRIP@
+SWFDEC_CFLAGS = @SWFDEC_CFLAGS@
+SWFDEC_LIBS = @SWFDEC_LIBS@
+TELETEXTDEC_CFLAGS = @TELETEXTDEC_CFLAGS@
+TELETEXTDEC_LIBS = @TELETEXTDEC_LIBS@
+TIGER_CFLAGS = @TIGER_CFLAGS@
+TIGER_LIBS = @TIGER_LIBS@
+TIMIDITY_CFLAGS = @TIMIDITY_CFLAGS@
+TIMIDITY_LIBS = @TIMIDITY_LIBS@
+USE_NLS = @USE_NLS@
+VALGRIND_CFLAGS = @VALGRIND_CFLAGS@
+VALGRIND_LIBS = @VALGRIND_LIBS@
+VALGRIND_PATH = @VALGRIND_PATH@
+VDPAU_CFLAGS = @VDPAU_CFLAGS@
+VDPAU_LIBS = @VDPAU_LIBS@
+VERSION = @VERSION@
+VOAACENC_CFLAGS = @VOAACENC_CFLAGS@
+VOAACENC_LIBS = @VOAACENC_LIBS@
+VOAMRWBENC_CFLAGS = @VOAMRWBENC_CFLAGS@
+VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
+VPX_LIBS = @VPX_LIBS@
+WARNING_CFLAGS = @WARNING_CFLAGS@
+WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
+WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
+WILDMIDI_LIBS = @WILDMIDI_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
+X11_CFLAGS = @X11_CFLAGS@
+X11_LIBS = @X11_LIBS@
+XGETTEXT = @XGETTEXT@
+XGETTEXT_015 = @XGETTEXT_015@
+XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
+XMKMF = @XMKMF@
+XVID_LIBS = @XVID_LIBS@
+X_CFLAGS = @X_CFLAGS@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_LIBS = @X_LIBS@
+X_PRE_LIBS = @X_PRE_LIBS@
+ZBAR_CFLAGS = @ZBAR_CFLAGS@
+ZBAR_LIBS = @ZBAR_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+ac_ct_OBJC = @ac_ct_OBJC@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+gsettingsschemadir = @gsettingsschemadir@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+pkgpyexecdir = @pkgpyexecdir@
+pkgpythondir = @pkgpythondir@
+plugindir = @plugindir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+pyexecdir = @pyexecdir@
+pythondir = @pythondir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+TEST_UVCH264_GLADE_FILES = window.glade \
+			boolean_property.glade \
+			enum_property.glade \
+			int_property.glade
+
+@HAVE_GTK_FALSE@TEST_UVCH264_EXAMPLES = 
+@HAVE_GTK_TRUE@TEST_UVCH264_EXAMPLES = test-uvch264
+@HAVE_GTK_TRUE@test_uvch264_SOURCES = test-uvch264.c
+@HAVE_GTK_TRUE@test_uvch264_CFLAGS = \
+@HAVE_GTK_TRUE@        $(GST_PLUGINS_BAD_CFLAGS) \
+@HAVE_GTK_TRUE@        $(GST_PLUGINS_BASE_CFLAGS) \
+@HAVE_GTK_TRUE@	$(GST_VIDEO_CFLAGS) \
+@HAVE_GTK_TRUE@	$(GST_CFLAGS) \
+@HAVE_GTK_TRUE@	$(GTK_CFLAGS) \
+@HAVE_GTK_TRUE@	$(GMODULE_EXPORT_CFLAGS) \
+@HAVE_GTK_TRUE@        -DGST_USE_UNSTABLE_API
+
+@HAVE_GTK_TRUE@test_uvch264_LDADD = \
+@HAVE_GTK_TRUE@        $(GST_PLUGINS_BASE_LIBS) \
+@HAVE_GTK_TRUE@	$(GST_VIDEO_LIBS) \
+@HAVE_GTK_TRUE@        $(GST_LIBS) \
+@HAVE_GTK_TRUE@        -lgstinterfaces-@GST_MAJORMINOR@ \
+@HAVE_GTK_TRUE@	$(GTK_LIBS) \
+@HAVE_GTK_TRUE@	$(GMODULE_EXPORT_LIBS)
+
+@HAVE_GTK_TRUE@noinst_DATA = $(TEST_UVCH264_GLADE_FILES)
+EXTRA_DIST = $(TEST_UVCH264_GLADE_FILES)
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu tests/examples/uvch264/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu tests/examples/uvch264/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstPROGRAMS:
+	@list='$(noinst_PROGRAMS)'; test -n "$$list" || exit 0; \
+	echo " rm -f" $$list; \
+	rm -f $$list || exit $$?; \
+	test -n "$(EXEEXT)" || exit 0; \
+	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
+	echo " rm -f" $$list; \
+	rm -f $$list
+test-uvch264$(EXEEXT): $(test_uvch264_OBJECTS) $(test_uvch264_DEPENDENCIES) $(EXTRA_test_uvch264_DEPENDENCIES) 
+	@rm -f test-uvch264$(EXEEXT)
+	$(AM_V_CCLD)$(test_uvch264_LINK) $(test_uvch264_OBJECTS) $(test_uvch264_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_uvch264-test-uvch264.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
+
+test_uvch264-test-uvch264.o: test-uvch264.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_uvch264_CFLAGS) $(CFLAGS) -MT test_uvch264-test-uvch264.o -MD -MP -MF $(DEPDIR)/test_uvch264-test-uvch264.Tpo -c -o test_uvch264-test-uvch264.o `test -f 'test-uvch264.c' || echo '$(srcdir)/'`test-uvch264.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_uvch264-test-uvch264.Tpo $(DEPDIR)/test_uvch264-test-uvch264.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='test-uvch264.c' object='test_uvch264-test-uvch264.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_uvch264_CFLAGS) $(CFLAGS) -c -o test_uvch264-test-uvch264.o `test -f 'test-uvch264.c' || echo '$(srcdir)/'`test-uvch264.c
+
+test_uvch264-test-uvch264.obj: test-uvch264.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_uvch264_CFLAGS) $(CFLAGS) -MT test_uvch264-test-uvch264.obj -MD -MP -MF $(DEPDIR)/test_uvch264-test-uvch264.Tpo -c -o test_uvch264-test-uvch264.obj `if test -f 'test-uvch264.c'; then $(CYGPATH_W) 'test-uvch264.c'; else $(CYGPATH_W) '$(srcdir)/test-uvch264.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_uvch264-test-uvch264.Tpo $(DEPDIR)/test_uvch264-test-uvch264.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='test-uvch264.c' object='test_uvch264-test-uvch264.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_uvch264_CFLAGS) $(CFLAGS) -c -o test_uvch264-test-uvch264.obj `if test -f 'test-uvch264.c'; then $(CYGPATH_W) 'test-uvch264.c'; else $(CYGPATH_W) '$(srcdir)/test-uvch264.c'; fi`
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS) $(DATA)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstPROGRAMS \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstPROGRAMS cscopelist ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/tests/examples/uvch264/boolean_property.glade b/tests/examples/uvch264/boolean_property.glade
new file mode 100644
index 0000000..d391a58
--- /dev/null
+++ b/tests/examples/uvch264/boolean_property.glade
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<interface>
+  <!-- interface-requires gtk+ 3.0 -->
+  <object class="GtkHBox" id="boolean-property">
+    <property name="visible">True</property>
+    <property name="can_focus">False</property>
+    <child>
+      <object class="GtkLabel" id="label">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="width_chars">18</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">0</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkToggleButton" id="value">
+        <property name="label" translatable="yes">  Disabled   </property>
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="use_action_appearance">False</property>
+        <signal name="toggled" handler="on_button_toggled" swapped="no"/>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">1</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkButton" id="get">
+        <property name="label" translatable="yes">Get</property>
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="use_action_appearance">False</property>
+        <signal name="clicked" handler="on_get_button_clicked" swapped="no"/>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">2</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkButton" id="set">
+        <property name="label" translatable="yes">Set</property>
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="use_action_appearance">False</property>
+        <signal name="clicked" handler="on_set_button_clicked" swapped="no"/>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">3</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="label66">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="label" translatable="yes">Default</property>
+        <property name="width_chars">8</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">4</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkToggleButton" id="default">
+        <property name="label" translatable="yes">  Disabled   </property>
+        <property name="visible">True</property>
+        <property name="sensitive">False</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="use_action_appearance">False</property>
+        <signal name="toggled" handler="on_button_toggled" swapped="no"/>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">5</property>
+      </packing>
+    </child>
+  </object>
+</interface>
diff --git a/tests/examples/uvch264/enum_property.glade b/tests/examples/uvch264/enum_property.glade
new file mode 100644
index 0000000..0dfb974
--- /dev/null
+++ b/tests/examples/uvch264/enum_property.glade
@@ -0,0 +1,88 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<interface>
+  <!-- interface-requires gtk+ 3.0 -->
+  <object class="GtkHBox" id="enum-property">
+    <property name="visible">True</property>
+    <property name="can_focus">False</property>
+    <child>
+      <object class="GtkLabel" id="label">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="width_chars">18</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">0</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkComboBoxText" id="value">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">1</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkButton" id="get">
+        <property name="label" translatable="yes">Get</property>
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="use_action_appearance">False</property>
+        <signal name="clicked" handler="on_get_button_clicked" swapped="no"/>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">2</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkButton" id="set">
+        <property name="label" translatable="yes">Set</property>
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="use_action_appearance">False</property>
+        <signal name="clicked" handler="on_set_button_clicked" swapped="no"/>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">3</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="label72">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="label" translatable="yes">Default</property>
+        <property name="width_chars">8</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">4</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkEntry" id="default">
+        <property name="visible">True</property>
+        <property name="sensitive">False</property>
+        <property name="can_focus">True</property>
+        <property name="invisible_char">●</property>
+        <property name="invisible_char_set">True</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">5</property>
+      </packing>
+    </child>
+  </object>
+</interface>
diff --git a/tests/examples/uvch264/enum_property_gtk2.glade b/tests/examples/uvch264/enum_property_gtk2.glade
new file mode 100644
index 0000000..487efbe
--- /dev/null
+++ b/tests/examples/uvch264/enum_property_gtk2.glade
@@ -0,0 +1,88 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<interface>
+  <!-- interface-requires gtk+ 3.0 -->
+  <object class="GtkHBox" id="enum-property">
+    <property name="visible">True</property>
+    <property name="can_focus">False</property>
+    <child>
+      <object class="GtkLabel" id="label">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="width_chars">18</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">0</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkComboBox" id="value">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">1</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkButton" id="get">
+        <property name="label" translatable="yes">Get</property>
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="use_action_appearance">False</property>
+        <signal name="clicked" handler="on_get_button_clicked" swapped="no"/>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">2</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkButton" id="set">
+        <property name="label" translatable="yes">Set</property>
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="use_action_appearance">False</property>
+        <signal name="clicked" handler="on_set_button_clicked" swapped="no"/>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">3</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="label72">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="label" translatable="yes">Default</property>
+        <property name="width_chars">8</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">4</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkEntry" id="default">
+        <property name="visible">True</property>
+        <property name="sensitive">False</property>
+        <property name="can_focus">True</property>
+        <property name="invisible_char">●</property>
+        <property name="invisible_char_set">True</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">5</property>
+      </packing>
+    </child>
+  </object>
+</interface>
diff --git a/tests/examples/uvch264/int_property.glade b/tests/examples/uvch264/int_property.glade
new file mode 100644
index 0000000..422ce1c
--- /dev/null
+++ b/tests/examples/uvch264/int_property.glade
@@ -0,0 +1,147 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<interface>
+  <!-- interface-requires gtk+ 3.0 -->
+  <object class="GtkHBox" id="int-property">
+    <property name="visible">True</property>
+    <property name="can_focus">False</property>
+    <child>
+      <object class="GtkLabel" id="label">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="width_chars">18</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">0</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkEntry" id="value">
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="invisible_char">●</property>
+        <property name="width_chars">10</property>
+        <property name="invisible_char_set">True</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">1</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkButton" id="get">
+        <property name="label" translatable="yes">Get</property>
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="use_action_appearance">False</property>
+        <signal name="clicked" handler="on_get_button_clicked" swapped="no"/>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">2</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkButton" id="set">
+        <property name="label" translatable="yes">Set</property>
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="receives_default">True</property>
+        <property name="use_action_appearance">False</property>
+        <signal name="clicked" handler="on_set_button_clicked" swapped="no"/>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">3</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="label2">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="label" translatable="yes">Minimum</property>
+        <property name="width_chars">8</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">4</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkEntry" id="minimum">
+        <property name="visible">True</property>
+        <property name="sensitive">False</property>
+        <property name="can_focus">True</property>
+        <property name="invisible_char">●</property>
+        <property name="width_chars">10</property>
+        <property name="invisible_char_set">True</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">5</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="label3">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="label" translatable="yes">Default</property>
+        <property name="width_chars">8</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">6</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkEntry" id="default">
+        <property name="visible">True</property>
+        <property name="sensitive">False</property>
+        <property name="can_focus">True</property>
+        <property name="invisible_char">●</property>
+        <property name="width_chars">10</property>
+        <property name="invisible_char_set">True</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">7</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="label4">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="label" translatable="yes">Maximum</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">8</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkEntry" id="maximum">
+        <property name="visible">True</property>
+        <property name="sensitive">False</property>
+        <property name="can_focus">True</property>
+        <property name="invisible_char">●</property>
+        <property name="width_chars">10</property>
+        <property name="invisible_char_set">True</property>
+      </object>
+      <packing>
+        <property name="expand">False</property>
+        <property name="fill">True</property>
+        <property name="position">9</property>
+      </packing>
+    </child>
+  </object>
+</interface>
diff --git a/tests/examples/uvch264/test-uvch264.c b/tests/examples/uvch264/test-uvch264.c
new file mode 100644
index 0000000..78d8ac1
--- /dev/null
+++ b/tests/examples/uvch264/test-uvch264.c
@@ -0,0 +1,673 @@
+#include <gst/gst.h>
+#include <gtk/gtk.h>
+#include <gdk/gdkx.h>
+#include <gst/interfaces/xoverlay.h>
+#include <gst/video/video.h>
+
+#define WINDOW_GLADE "window.glade"
+#define INT_PROPERTY_GLADE "int_property.glade"
+#define ENUM_PROPERTY_GLADE "enum_property.glade"
+#define BOOL_PROPERTY_GLADE "boolean_property.glade"
+
+#define PROPERTY_TO_VBOX                                                \
+  properties[i].dynamic ? GTK_BOX (dynamic_vbox) : GTK_BOX (static_vbox)
+
+#define GET_WIDGET(object, type, name)                          \
+  type (gtk_builder_get_object ((object)->builder, name))
+
+#define GET_PROP_WIDGET(type, name) GET_WIDGET (&(properties[i]), type, name)
+
+static guint h264_xid, preview_xid;
+
+typedef struct
+{
+  GtkBuilder *builder;
+  GstElement *src;
+  enum
+  { NONE, INT, ENUM, BOOL } type;
+  const gchar *property_name;
+  gboolean readonly;
+  gboolean dynamic;
+} Prop;
+
+typedef struct
+{
+  GtkBuilder *builder;
+  GstElement *bin;
+  GstElement *src;
+  GstElement *identity;
+  GstElement *vid_capsfilter;
+  GstElement *vf_capsfilter;
+} Main;
+
+Prop properties[] = {
+  {NULL, NULL, INT, "initial-bitrate", FALSE, FALSE},
+  {NULL, NULL, INT, "slice-units", FALSE, FALSE},
+  {NULL, NULL, ENUM, "slice-mode", FALSE, FALSE},
+  {NULL, NULL, INT, "iframe-period", FALSE, FALSE},
+  {NULL, NULL, ENUM, "usage-type", FALSE, FALSE},
+  {NULL, NULL, ENUM, "entropy", FALSE, FALSE},
+  {NULL, NULL, BOOL, "enable-sei", FALSE, FALSE},
+  {NULL, NULL, INT, "num-reorder-frames", FALSE, FALSE},
+  {NULL, NULL, BOOL, "preview-flipped", FALSE, FALSE},
+  {NULL, NULL, INT, "leaky-bucket-size", FALSE, FALSE},
+  {NULL, NULL, INT, "num-clock-samples", FALSE, TRUE},
+  {NULL, NULL, ENUM, "rate-control", FALSE, TRUE},
+  {NULL, NULL, BOOL, "fixed-framerate", FALSE, TRUE},
+  {NULL, NULL, INT, "max-mbps", TRUE, TRUE},
+  {NULL, NULL, INT, "level-idc", FALSE, TRUE},
+  {NULL, NULL, INT, "peak-bitrate", FALSE, TRUE},
+  {NULL, NULL, INT, "average-bitrate", FALSE, TRUE},
+  {NULL, NULL, INT, "min-iframe-qp", FALSE, TRUE},
+  {NULL, NULL, INT, "max-iframe-qp", FALSE, TRUE},
+  {NULL, NULL, INT, "min-pframe-qp", FALSE, TRUE},
+  {NULL, NULL, INT, "max-pframe-qp", FALSE, TRUE},
+  {NULL, NULL, INT, "min-bframe-qp", FALSE, TRUE},
+  {NULL, NULL, INT, "max-bframe-qp", FALSE, TRUE},
+  {NULL, NULL, INT, "ltr-buffer-size", FALSE, TRUE},
+  {NULL, NULL, INT, "ltr-encoder-control", FALSE, TRUE},
+};
+
+static void set_drop_probability (Main * self);
+static void get_all_properties (void);
+static void probe_all_properties (gboolean playing);
+
+/* Callbacks */
+void on_button_toggled (GtkToggleButton * button, gpointer user_data);
+void on_get_button_clicked (GtkButton * button, gpointer user_data);
+void on_set_button_clicked (GtkButton * button, gpointer user_data);
+void on_button_ready_clicked (GtkButton * button, gpointer user_data);
+void on_button_null_clicked (GtkButton * button, gpointer user_data);
+void on_button_playing_clicked (GtkButton * button, gpointer user_data);
+void on_iframe_button_clicked (GtkButton * button, gpointer user_data);
+void on_renegotiate_button_clicked (GtkButton * button, gpointer user_data);
+void on_start_capture_button_clicked (GtkButton * button, gpointer user_data);
+void on_stop_capture_button_clicked (GtkButton * button, gpointer user_data);
+void on_window_destroyed (GtkWindow * window, gpointer user_data);
+
+static GstEvent *
+new_upstream_force_key_unit (GstClockTime running_time,
+    gboolean all_headers, guint count)
+{
+  GstEvent *force_key_unit_event;
+  GstStructure *s;
+
+  s = gst_structure_new ("GstForceKeyUnit",
+      "running-time", GST_TYPE_CLOCK_TIME, running_time,
+      "all-headers", G_TYPE_BOOLEAN, all_headers,
+      "count", G_TYPE_UINT, count, NULL);
+  force_key_unit_event = gst_event_new_custom (GST_EVENT_CUSTOM_UPSTREAM, s);
+
+  return force_key_unit_event;
+}
+
+void
+on_get_button_clicked (GtkButton * button, gpointer user_data)
+{
+  Prop *property = user_data;
+
+  switch (property->type) {
+    case INT:
+    {
+      gchar *val;
+      gint val_int;
+      g_object_get (property->src, property->property_name, &val_int, NULL);
+      val = g_strdup_printf ("%d", val_int);
+      gtk_entry_set_text (GET_WIDGET (property, GTK_ENTRY, "value"), val);
+      g_free (val);
+    }
+      break;
+    case ENUM:
+    {
+      GParamSpec *param;
+      gint val;
+
+      g_object_get (property->src, property->property_name, &val, NULL);
+      param = g_object_class_find_property (G_OBJECT_GET_CLASS (property->src),
+          property->property_name);
+      if (G_IS_PARAM_SPEC_ENUM (param)) {
+        GEnumValue *values;
+        guint i = 0;
+
+        values = G_ENUM_CLASS (g_type_class_ref (param->value_type))->values;
+
+        while (values[i].value_name) {
+          if (values[i].value == val) {
+            gtk_combo_box_set_active (GET_WIDGET (property,
+                    (GtkComboBox *), "value"), i);
+            break;
+          }
+          i++;
+        }
+      }
+    }
+      break;
+    case BOOL:
+    {
+      gboolean val;
+
+      g_object_get (property->src, property->property_name, &val, NULL);
+      gtk_toggle_button_set_active (GET_WIDGET (property,
+              (GtkToggleButton *), "value"), val);
+    }
+      break;
+    case NONE:
+    default:
+      break;
+  }
+}
+
+void
+on_set_button_clicked (GtkButton * button, gpointer user_data)
+{
+  Prop *property = user_data;
+
+  switch (property->type) {
+    case INT:
+    {
+      int val_int;
+      const gchar *val;
+
+      val = gtk_entry_get_text (GET_WIDGET (property, GTK_ENTRY, "value"));
+      val_int = (int) g_ascii_strtoll (val, NULL, 0);
+      g_object_set (property->src, property->property_name, val_int, NULL);
+    }
+      break;
+    case ENUM:
+    {
+      GParamSpec *param;
+
+      param = g_object_class_find_property (G_OBJECT_GET_CLASS (property->src),
+          property->property_name);
+      if (G_IS_PARAM_SPEC_ENUM (param)) {
+        GEnumValue *values;
+        guint val = 0;
+
+        values = G_ENUM_CLASS (g_type_class_ref (param->value_type))->values;
+
+        val = gtk_combo_box_get_active (GET_WIDGET (property,
+                (GtkComboBox *), "value"));
+        g_object_set (property->src, property->property_name,
+            values[val].value, NULL);
+      }
+    }
+      break;
+    case BOOL:
+    {
+      gboolean val;
+
+      val = gtk_toggle_button_get_active (GET_WIDGET (property,
+              (GtkToggleButton *), "value"));
+      g_object_set (property->src, property->property_name, val, NULL);
+    }
+      break;
+    case NONE:
+    default:
+      break;
+  }
+  get_all_properties ();
+}
+
+void
+on_button_toggled (GtkToggleButton * button, gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (button))
+    gtk_button_set_label (GTK_BUTTON (button), "   Enabled   ");
+  else
+    gtk_button_set_label (GTK_BUTTON (button), "  Disabled   ");
+}
+
+static gboolean
+set_caps (Main * self, gboolean send_event)
+{
+  const gchar *h264_filter;
+  const gchar *raw_filter;
+  GstCaps *h264_caps = NULL;
+  GstCaps *raw_caps = NULL;
+  gboolean ret = TRUE;
+
+  h264_filter = gtk_entry_get_text (GET_WIDGET (self, GTK_ENTRY, "h264_caps"));
+  raw_filter =
+      gtk_entry_get_text (GET_WIDGET (self, GTK_ENTRY, "preview_caps"));
+  if (h264_filter)
+    h264_caps = gst_caps_from_string (h264_filter);
+  if (raw_filter)
+    raw_caps = gst_caps_from_string (raw_filter);
+
+  g_debug ("H264 caps : %s", gst_caps_to_string (h264_caps));
+  g_debug ("Preview caps : %s", gst_caps_to_string (raw_caps));
+  if (!h264_caps || !raw_caps) {
+    g_debug ("Invalid caps");
+    ret = FALSE;
+    goto end;
+  }
+
+  g_object_set (self->vid_capsfilter, "caps", h264_caps, NULL);
+  g_object_set (self->vf_capsfilter, "caps", raw_caps, NULL);
+
+  if (send_event) {
+    gst_element_send_event (GST_ELEMENT (self->src),
+        gst_event_new_custom (GST_EVENT_CUSTOM_UPSTREAM,
+            gst_structure_new ("renegotiate", NULL)));
+  }
+
+end:
+  if (h264_caps)
+    gst_caps_unref (h264_caps);
+  if (raw_caps)
+    gst_caps_unref (raw_caps);
+
+  return ret;
+}
+
+void
+on_button_ready_clicked (GtkButton * button, gpointer user_data)
+{
+  Main *self = user_data;
+
+  set_caps (self, FALSE);
+  gst_element_set_state (self->bin, GST_STATE_READY);
+  probe_all_properties (FALSE);
+  get_all_properties ();
+}
+
+void
+on_button_null_clicked (GtkButton * button, gpointer user_data)
+{
+  Main *self = user_data;
+
+  gst_element_set_state (self->bin, GST_STATE_NULL);
+  probe_all_properties (FALSE);
+  get_all_properties ();
+}
+
+void
+on_button_playing_clicked (GtkButton * button, gpointer user_data)
+{
+  Main *self = user_data;
+
+  if (gst_element_set_state (self->bin, GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    g_debug ("Unable to go to state PLAYING");
+  }
+  set_caps (self, FALSE);
+  probe_all_properties (TRUE);
+  get_all_properties ();
+
+  set_drop_probability (self);
+}
+
+void
+on_iframe_button_clicked (GtkButton * button, gpointer user_data)
+{
+  Main *self = user_data;
+  GstEvent *event;
+  gboolean pps_sps;
+
+  set_drop_probability (self);
+  pps_sps = gtk_toggle_button_get_active (GET_WIDGET (self, (GtkToggleButton *),
+          "pps_sps"));
+
+  event = new_upstream_force_key_unit (GST_CLOCK_TIME_NONE, pps_sps, 0);
+  gst_element_send_event (GST_ELEMENT (self->src), event);
+}
+
+void
+on_renegotiate_button_clicked (GtkButton * button, gpointer user_data)
+{
+  Main *self = user_data;
+
+  set_caps (self, TRUE);
+  probe_all_properties (GST_STATE (self->bin) >= GST_STATE_PAUSED);
+  get_all_properties ();
+}
+
+void
+on_start_capture_button_clicked (GtkButton * button, gpointer user_data)
+{
+  Main *self = user_data;
+
+  set_caps (self, FALSE);
+  g_signal_emit_by_name (G_OBJECT (self->src), "start-capture", NULL);
+  probe_all_properties (GST_STATE (self->bin) >= GST_STATE_PAUSED);
+  get_all_properties ();
+}
+
+void
+on_stop_capture_button_clicked (GtkButton * button, gpointer user_data)
+{
+  Main *self = user_data;
+
+  set_caps (self, FALSE);
+  g_signal_emit_by_name (G_OBJECT (self->src), "stop-capture", NULL);
+  probe_all_properties (GST_STATE (self->bin) >= GST_STATE_PAUSED);
+  get_all_properties ();
+}
+
+void
+on_window_destroyed (GtkWindow * window, gpointer user_data)
+{
+  gtk_main_quit ();
+}
+
+static gboolean
+_bus_callback (GstBus * bus, GstMessage * message, gpointer user_data)
+{
+  const GstStructure *s = gst_message_get_structure (message);
+  GstObject *source = NULL;
+
+  if (GST_MESSAGE_TYPE (message) == GST_MESSAGE_ELEMENT &&
+      gst_structure_has_name (s, "prepare-xwindow-id")) {
+    source = GST_MESSAGE_SRC (message);
+    if (!g_strcmp0 (gst_object_get_name (source), "h264_sink"))
+      gst_x_overlay_set_window_handle (GST_X_OVERLAY (source), h264_xid);
+    else
+      gst_x_overlay_set_window_handle (GST_X_OVERLAY (source), preview_xid);
+  }
+
+  return TRUE;
+}
+
+static void
+set_drop_probability (Main * self)
+{
+  const gchar *drop;
+  gdouble drop_probability = 0.0;
+
+  drop = gtk_entry_get_text (GET_WIDGET (self, GTK_ENTRY, "drop"));
+  drop_probability = g_ascii_strtod (drop, NULL);
+  g_debug ("Setting drop probability to : %f", drop_probability);
+  g_object_set (self->identity, "drop-probability", drop_probability, NULL);
+}
+
+static void
+get_all_properties (void)
+{
+  int i;
+
+  for (i = 0; i < G_N_ELEMENTS (properties); i++)
+    on_get_button_clicked (NULL, &properties[i]);
+
+}
+
+static void
+probe_all_properties (gboolean playing)
+{
+  int i;
+
+  for (i = 0; i < G_N_ELEMENTS (properties); i++) {
+    gboolean return_value, changeable, default_bool;
+    guint mask, minimum, maximum, default_int;
+    GParamSpec *param;
+
+    /* When playing, ignore static controls */
+    if (playing && !properties[i].dynamic)
+      continue;
+
+    switch (properties[i].type) {
+      case INT:
+        g_signal_emit_by_name (G_OBJECT (properties[i].src), "get-int-setting",
+            properties[i].property_name, &minimum, &default_int, &maximum,
+            &return_value, NULL);
+        if (return_value) {
+          gchar *min, *def, *max;
+
+          min = g_strdup_printf ("%d", minimum);
+          def = g_strdup_printf ("%d", default_int);
+          max = g_strdup_printf ("%d", maximum);
+          gtk_entry_set_text (GET_PROP_WIDGET (GTK_ENTRY, "minimum"), min);
+          gtk_entry_set_text (GET_PROP_WIDGET (GTK_ENTRY, "default"), def);
+          gtk_entry_set_text (GET_PROP_WIDGET (GTK_ENTRY, "maximum"), max);
+          g_free (min);
+          g_free (def);
+          g_free (max);
+        } else {
+          gtk_entry_set_text (GET_PROP_WIDGET (GTK_ENTRY, "minimum"), "");
+          gtk_entry_set_text (GET_PROP_WIDGET (GTK_ENTRY, "default"), "");
+          gtk_entry_set_text (GET_PROP_WIDGET (GTK_ENTRY, "maximum"), "");
+        }
+        break;
+      case ENUM:
+        g_signal_emit_by_name (G_OBJECT (properties[i].src), "get-enum-setting",
+            properties[i].property_name, &mask, &default_int, &return_value,
+            NULL);
+        param =
+            g_object_class_find_property (G_OBJECT_GET_CLASS (properties
+                [i].src), properties[i].property_name);
+        if (G_IS_PARAM_SPEC_ENUM (param)) {
+          GEnumValue *values;
+          guint j = 0;
+
+          values = G_ENUM_CLASS (g_type_class_ref (param->value_type))->values;
+
+          if (return_value) {
+            while (values[j].value_name) {
+              if (values[j].value == default_int) {
+                gtk_entry_set_text (GET_PROP_WIDGET (GTK_ENTRY, "default"),
+                    values[j].value_name);
+                break;
+              }
+              j++;
+            }
+          } else {
+            gtk_entry_set_text (GET_PROP_WIDGET (GTK_ENTRY, "default"), "");
+          }
+
+          j = 0;
+          while (values[j].value_name) {
+#if !GTK_CHECK_VERSION (2, 24, 0)
+            gtk_combo_box_remove_text (GET_PROP_WIDGET ((GtkComboBox *),
+                    "value"), 0);
+#else
+            gtk_combo_box_text_remove (GET_PROP_WIDGET ((GtkComboBoxText *),
+                    "value"), 0);
+#endif
+            j++;
+          }
+
+          j = 0;
+          while (values[j].value_name) {
+            gchar *val;
+            if (return_value && (mask & (1 << values[j].value)) != 0)
+              val = g_strdup_printf ("**%s**", values[j].value_name);
+            else
+              val = g_strdup (values[j].value_name);
+
+#if !GTK_CHECK_VERSION (2, 24, 0)
+            gtk_combo_box_append_text (GET_PROP_WIDGET ((GtkComboBox *),
+                    "value"), val);
+#else
+            gtk_combo_box_text_append_text (GET_PROP_WIDGET ((GtkComboBoxText
+                        *), "value"), val);
+#endif
+            g_free (val);
+            j++;
+          }
+        }
+        break;
+      case BOOL:
+        g_signal_emit_by_name (G_OBJECT (properties[i].src),
+            "get-boolean-setting", properties[i].property_name,
+            &changeable, &default_bool, &return_value, NULL);
+        if (return_value) {
+          gtk_widget_set_sensitive (GET_PROP_WIDGET (GTK_WIDGET, "value"),
+              changeable);
+          gtk_widget_set_sensitive (GET_PROP_WIDGET (GTK_WIDGET, "get"),
+              changeable);
+          gtk_widget_set_sensitive (GET_PROP_WIDGET (GTK_WIDGET, "set"),
+              changeable);
+          gtk_toggle_button_set_active (GET_PROP_WIDGET ((GtkToggleButton *),
+                  "default"), default_bool);
+        }
+        break;
+      case NONE:
+      default:
+        break;
+    }
+  }
+}
+
+int
+main (int argc, char *argv[])
+{
+  Main self = { NULL, NULL, NULL, NULL };
+  GstBus *bus = NULL;
+  GtkWidget *window, *static_vbox, *dynamic_vbox, *da;
+  gchar *drop;
+  gdouble drop_probability;
+  GdkWindow *gdk_win = NULL;
+  const char *device = "/dev/video0";
+  GError *error = NULL;
+  int i;
+
+  gtk_init (&argc, &argv);
+  gst_init (&argc, &argv);
+
+  if (argc > 1)
+    device = argv[1];
+  else
+    g_print ("Usage : %s [device]\nUsing default device : %s\n",
+        argv[0], device);
+
+
+  self.bin = gst_parse_launch ("uvch264_src name=src src.vidsrc ! queue ! "
+      "capsfilter name=vid_cf ! identity name=identity ! ffdec_h264 ! "
+      "xvimagesink name=h264_sink async=false "
+      "src.vfsrc ! queue ! capsfilter name=vf_cf ! "
+      "xvimagesink name=preview_sink async=false", NULL);
+
+  if (!self.bin)
+    return -1;
+
+  /* Listen to the bus for messages */
+  bus = gst_element_get_bus (self.bin);
+  gst_bus_add_watch (bus, _bus_callback, self.bin);
+  gst_object_unref (bus);
+
+  self.src = gst_bin_get_by_name (GST_BIN (self.bin), "src");
+  self.identity = gst_bin_get_by_name (GST_BIN (self.bin), "identity");
+  self.vid_capsfilter = gst_bin_get_by_name (GST_BIN (self.bin), "vid_cf");
+  self.vf_capsfilter = gst_bin_get_by_name (GST_BIN (self.bin), "vf_cf");
+
+  self.builder = gtk_builder_new ();
+  gtk_builder_add_from_file (self.builder, WINDOW_GLADE, &error);
+  if (error) {
+    g_debug ("Unable to load glade file : %s", error->message);
+    goto end;
+  }
+  gtk_builder_connect_signals (self.builder, &self);
+
+  g_object_get (self.identity, "drop-probability", &drop_probability, NULL);
+  drop = g_strdup_printf ("%f", drop_probability);
+  gtk_entry_set_text (GET_WIDGET (&self, GTK_ENTRY, "drop"), drop);
+  g_free (drop);
+  window = GET_WIDGET (&self, GTK_WIDGET, "window");
+  static_vbox = GET_WIDGET (&self, GTK_WIDGET, "static");
+  dynamic_vbox = GET_WIDGET (&self, GTK_WIDGET, "dynamic");
+  da = GET_WIDGET (&self, GTK_WIDGET, "h264");
+  gtk_widget_realize (da);
+  gdk_win = gtk_widget_get_window (da);
+  h264_xid = GDK_WINDOW_XID (gdk_win);
+  da = GET_WIDGET (&self, GTK_WIDGET, "preview");
+  gtk_widget_realize (da);
+  gdk_win = gtk_widget_get_window (da);
+  preview_xid = GDK_WINDOW_XID (gdk_win);
+
+  set_caps (&self, FALSE);
+
+  g_object_set (self.src, "device", device, NULL);
+  if (gst_element_set_state (self.bin, GST_STATE_READY) ==
+      GST_STATE_CHANGE_FAILURE) {
+    g_debug ("Unable to go to state READY");
+    goto end;
+  }
+
+  for (i = 0; i < G_N_ELEMENTS (properties); i++) {
+    switch (properties[i].type) {
+      case INT:
+        properties[i].src = self.src;
+        properties[i].builder = gtk_builder_new ();
+        gtk_builder_add_from_file (properties[i].builder, INT_PROPERTY_GLADE,
+            NULL);
+        gtk_builder_connect_signals (properties[i].builder, &properties[i]);
+        gtk_box_pack_start (PROPERTY_TO_VBOX,
+            GET_PROP_WIDGET (GTK_WIDGET, "int-property"), TRUE, TRUE, 2);
+        gtk_label_set_label (GET_PROP_WIDGET (GTK_LABEL, "label"),
+            properties[i].property_name);
+        if (properties[i].readonly)
+          gtk_widget_set_sensitive (GET_PROP_WIDGET (GTK_WIDGET, "set"), FALSE);
+        break;
+      case ENUM:
+        properties[i].src = self.src;
+        properties[i].builder = gtk_builder_new ();
+#if !GTK_CHECK_VERSION (2, 24, 0)
+        gtk_builder_add_from_file (properties[i].builder,
+            "enum_property_gtk2.glade", NULL);
+#else
+        gtk_builder_add_from_file (properties[i].builder, ENUM_PROPERTY_GLADE,
+            NULL);
+#endif
+        gtk_builder_connect_signals (properties[i].builder, &properties[i]);
+        gtk_box_pack_start (PROPERTY_TO_VBOX,
+            GET_PROP_WIDGET (GTK_WIDGET, "enum-property"), TRUE, TRUE, 2);
+        gtk_label_set_label (GET_PROP_WIDGET (GTK_LABEL, "label"),
+            properties[i].property_name);
+#if !GTK_CHECK_VERSION (2, 24, 0)
+        {
+          GtkComboBox *combo_box;
+          GtkCellRenderer *cell;
+          GtkListStore *store;
+
+          combo_box = GET_PROP_WIDGET ((GtkComboBox *), "value");
+          store = gtk_list_store_new (1, G_TYPE_STRING);
+          gtk_combo_box_set_model (combo_box, GTK_TREE_MODEL (store));
+          g_object_unref (store);
+
+          cell = gtk_cell_renderer_text_new ();
+          gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo_box), cell, TRUE);
+          gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo_box), cell,
+              "text", 0, NULL);
+        }
+#endif
+        if (properties[i].readonly)
+          gtk_widget_set_sensitive (GET_PROP_WIDGET (GTK_WIDGET, "set"), FALSE);
+        break;
+      case BOOL:
+        properties[i].src = self.src;
+        properties[i].builder = gtk_builder_new ();
+        gtk_builder_add_from_file (properties[i].builder, BOOL_PROPERTY_GLADE,
+            NULL);
+        gtk_builder_connect_signals (properties[i].builder, &properties[i]);
+        gtk_box_pack_start (PROPERTY_TO_VBOX,
+            GET_PROP_WIDGET (GTK_WIDGET, "boolean-property"), TRUE, TRUE, 2);
+        gtk_label_set_label (GET_PROP_WIDGET (GTK_LABEL, "label"),
+            properties[i].property_name);
+        if (properties[i].readonly)
+          gtk_widget_set_sensitive (GET_PROP_WIDGET (GTK_WIDGET, "set"), FALSE);
+        break;
+      case NONE:
+      default:
+        break;
+    }
+  }
+  probe_all_properties (FALSE);
+  get_all_properties ();
+
+  gtk_widget_show (window);
+  gtk_main ();
+
+end:
+  g_object_unref (G_OBJECT (self.builder));
+  for (i = 0; i < G_N_ELEMENTS (properties); i++) {
+    if (properties[i].builder)
+      g_object_unref (G_OBJECT (properties[i].builder));
+  }
+  gst_element_set_state (self.bin, GST_STATE_NULL);
+  gst_object_unref (self.src);
+  gst_object_unref (self.identity);
+  gst_object_unref (self.vid_capsfilter);
+  gst_object_unref (self.vf_capsfilter);
+  gst_object_unref (self.bin);
+
+  return 0;
+}
diff --git a/tests/examples/uvch264/window.glade b/tests/examples/uvch264/window.glade
new file mode 100644
index 0000000..8b7624a
--- /dev/null
+++ b/tests/examples/uvch264/window.glade
@@ -0,0 +1,345 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<interface>
+  <!-- interface-requires gtk+ 3.0 -->
+  <object class="GtkWindow" id="window">
+    <property name="can_focus">False</property>
+    <property name="title" translatable="yes">Test for uvch264_src</property>
+    <signal name="destroy" handler="on_window_destroyed" swapped="no"/>
+    <child>
+      <object class="GtkHBox" id="hbox1">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <child>
+          <object class="GtkVBox" id="vbox">
+            <property name="visible">True</property>
+            <property name="can_focus">False</property>
+            <property name="orientation">vertical</property>
+            <child>
+              <object class="GtkHBox" id="box26">
+                <property name="visible">True</property>
+                <property name="can_focus">False</property>
+                <property name="homogeneous">True</property>
+                <child>
+                  <object class="GtkButton" id="button2">
+                    <property name="label" translatable="yes">State NULL</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">True</property>
+                    <property name="use_action_appearance">False</property>
+                    <signal name="clicked" handler="on_button_null_clicked" swapped="no"/>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">True</property>
+                    <property name="position">0</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkButton" id="button51">
+                    <property name="label" translatable="yes">State READY</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">True</property>
+                    <property name="use_action_appearance">False</property>
+                    <signal name="clicked" handler="on_button_ready_clicked" swapped="no"/>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">True</property>
+                    <property name="position">1</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkButton" id="button52">
+                    <property name="label" translatable="yes">State PLAYING</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">True</property>
+                    <property name="use_action_appearance">False</property>
+                    <signal name="clicked" handler="on_button_playing_clicked" swapped="no"/>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">True</property>
+                    <property name="position">2</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkButton" id="button3">
+                    <property name="label" translatable="yes">Start capture</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">True</property>
+                    <property name="use_action_appearance">False</property>
+                    <signal name="clicked" handler="on_start_capture_button_clicked" swapped="no"/>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">True</property>
+                    <property name="position">3</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkButton" id="button4">
+                    <property name="label" translatable="yes">Stop capture</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">True</property>
+                    <property name="use_action_appearance">False</property>
+                    <signal name="clicked" handler="on_stop_capture_button_clicked" swapped="no"/>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">True</property>
+                    <property name="position">4</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkButton" id="button5">
+                    <property name="label" translatable="yes">Renegotiate</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">True</property>
+                    <property name="use_action_appearance">False</property>
+                    <signal name="clicked" handler="on_renegotiate_button_clicked" swapped="no"/>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">True</property>
+                    <property name="position">5</property>
+                  </packing>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">True</property>
+                <property name="position">0</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkLabel" id="label3">
+                <property name="visible">True</property>
+                <property name="can_focus">False</property>
+                <property name="label" translatable="yes">Static controls</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">True</property>
+                <property name="position">1</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkVBox" id="static">
+                <property name="visible">True</property>
+                <property name="can_focus">False</property>
+                <property name="orientation">vertical</property>
+                <child>
+                  <placeholder/>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">True</property>
+                <property name="fill">True</property>
+                <property name="position">2</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkLabel" id="label4">
+                <property name="visible">True</property>
+                <property name="can_focus">False</property>
+                <property name="label" translatable="yes">Dynamic controls</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">True</property>
+                <property name="position">3</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkVBox" id="dynamic">
+                <property name="visible">True</property>
+                <property name="can_focus">False</property>
+                <property name="orientation">vertical</property>
+                <child>
+                  <placeholder/>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">True</property>
+                <property name="fill">True</property>
+                <property name="position">4</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkHBox" id="box1">
+                <property name="visible">True</property>
+                <property name="can_focus">False</property>
+                <child>
+                  <object class="GtkLabel" id="label5">
+                    <property name="visible">True</property>
+                    <property name="can_focus">False</property>
+                    <property name="label" translatable="yes">Drop probability % (between 0.0 and 1.0)</property>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">True</property>
+                    <property name="position">0</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkEntry" id="drop">
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="invisible_char">●</property>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">True</property>
+                    <property name="position">1</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkCheckButton" id="pps_sps">
+                    <property name="label" translatable="yes">With SPS/PPS</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">False</property>
+                    <property name="use_action_appearance">False</property>
+                    <property name="xalign">0</property>
+                    <property name="draw_indicator">True</property>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">True</property>
+                    <property name="position">2</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkButton" id="button1">
+                    <property name="label" translatable="yes">Request keyframe</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">True</property>
+                    <property name="use_action_appearance">False</property>
+                    <signal name="clicked" handler="on_iframe_button_clicked" swapped="no"/>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">True</property>
+                    <property name="position">3</property>
+                  </packing>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">True</property>
+                <property name="position">5</property>
+              </packing>
+            </child>
+          </object>
+          <packing>
+            <property name="expand">False</property>
+            <property name="fill">True</property>
+            <property name="position">0</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkVBox" id="box2">
+            <property name="visible">True</property>
+            <property name="can_focus">False</property>
+            <property name="orientation">vertical</property>
+            <child>
+              <object class="GtkLabel" id="label1">
+                <property name="visible">True</property>
+                <property name="can_focus">False</property>
+                <property name="label" translatable="yes">H264</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">True</property>
+                <property name="position">0</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkEntry" id="h264_caps">
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="invisible_char">●</property>
+                <property name="text" translatable="yes">video/x-h264,width=640,height=480,profile=constrained-baseline,stream-format=bytestream,framerate=15/1</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">True</property>
+                <property name="position">1</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkDrawingArea" id="h264">
+                <property name="width_request">320</property>
+                <property name="height_request">240</property>
+                <property name="visible">True</property>
+                <property name="app_paintable">True</property>
+                <property name="can_focus">False</property>
+                <property name="double_buffered">False</property>
+                <property name="halign">center</property>
+                <property name="valign">center</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">False</property>
+                <property name="position">2</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkLabel" id="label2">
+                <property name="visible">True</property>
+                <property name="can_focus">False</property>
+                <property name="label" translatable="yes">Preview</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">True</property>
+                <property name="position">3</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkEntry" id="preview_caps">
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="invisible_char">●</property>
+                <property name="text" translatable="yes">video/x-raw-yuv,width=320,height=240,format=(fourcc)YUY2,framerate=15/1</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">True</property>
+                <property name="position">4</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkDrawingArea" id="preview">
+                <property name="width_request">320</property>
+                <property name="height_request">240</property>
+                <property name="visible">True</property>
+                <property name="app_paintable">True</property>
+                <property name="can_focus">False</property>
+                <property name="double_buffered">False</property>
+                <property name="halign">center</property>
+                <property name="valign">center</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">False</property>
+                <property name="position">5</property>
+              </packing>
+            </child>
+          </object>
+          <packing>
+            <property name="expand">True</property>
+            <property name="fill">True</property>
+            <property name="position">1</property>
+          </packing>
+        </child>
+      </object>
+    </child>
+  </object>
+</interface>
diff --git a/tests/files/Makefile.in b/tests/files/Makefile.in
index 4d6f81b..9cced44 100644
--- a/tests/files/Makefile.in
+++ b/tests/files/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,6 +14,23 @@
 
 @SET_MAKE@
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -33,6 +49,7 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 subdir = tests/files
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
@@ -40,7 +57,6 @@ am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -77,14 +93,25 @@ mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
 AM_V_GEN = $(am__v_GEN_@AM_V@)
 am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
 AM_V_at = $(am__v_at_@AM_V@)
 am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
 am__v_at_0 = @
+am__v_at_1 = 
 SOURCES =
 DIST_SOURCES =
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 ACLOCAL_AMFLAGS = @ACLOCAL_AMFLAGS@
@@ -117,6 +144,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -141,10 +170,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -159,9 +190,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -219,13 +253,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -244,13 +281,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -260,6 +303,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -287,6 +331,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -324,7 +372,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -333,6 +381,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -366,6 +415,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -382,6 +433,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -410,12 +462,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -483,7 +538,11 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
@@ -535,6 +594,8 @@ TAGS:
 ctags: CTAGS
 CTAGS:
 
+cscope cscopelist:
+
 
 distdir: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
diff --git a/tests/icles/Makefile.in b/tests/icles/Makefile.in
index adf438f..f950971 100644
--- a/tests/icles/Makefile.in
+++ b/tests/icles/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.12.6 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,23 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -34,15 +50,16 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+target_triplet = @target@
 noinst_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2)
 subdir = tests/icles
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(top_srcdir)/depcomp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
 	$(top_srcdir)/common/m4/as-auto-alt.m4 \
 	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
 	$(top_srcdir)/common/m4/as-libtool.m4 \
-	$(top_srcdir)/common/m4/as-objc.m4 \
 	$(top_srcdir)/common/m4/as-python.m4 \
 	$(top_srcdir)/common/m4/as-scrub-include.m4 \
 	$(top_srcdir)/common/m4/as-version.m4 \
@@ -91,9 +108,22 @@ am__DEPENDENCIES_1 =
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
+am__v_lt_1 = 
 pitch_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(pitch_test_CFLAGS) \
 	$(CFLAGS) $(pitch_test_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -106,22 +136,23 @@ LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(pitch_test_SOURCES)
 DIST_SOURCES = $(am__pitch_test_SOURCES_DIST)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -156,6 +187,8 @@ CELT_0_8_LIBS = @CELT_0_8_LIBS@
 CELT_CFLAGS = @CELT_CFLAGS@
 CELT_LIBS = @CELT_LIBS@
 CFLAGS = @CFLAGS@
+CHROMAPRINT_CFLAGS = @CHROMAPRINT_CFLAGS@
+CHROMAPRINT_LIBS = @CHROMAPRINT_LIBS@
 COG_CFLAGS = @COG_CFLAGS@
 COG_LIBS = @COG_LIBS@
 CPP = @CPP@
@@ -180,10 +213,12 @@ DEPDIR = @DEPDIR@
 DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
 DIRAC_CFLAGS = @DIRAC_CFLAGS@
 DIRAC_LIBS = @DIRAC_LIBS@
+DIRECT3D9_LIBS = @DIRECT3D9_LIBS@
 DIRECT3D_LIBS = @DIRECT3D_LIBS@
 DIRECTDRAW_LIBS = @DIRECTDRAW_LIBS@
 DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
 DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIRECTSHOW_LIBS = @DIRECTSHOW_LIBS@
 DIRECTSOUND_LIBS = @DIRECTSOUND_LIBS@
 DIRECTX_CFLAGS = @DIRECTX_CFLAGS@
 DIRECTX_LDFLAGS = @DIRECTX_LDFLAGS@
@@ -198,9 +233,12 @@ DVDNAV_LIBS = @DVDNAV_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
+EGLGLES_CFLAGS = @EGLGLES_CFLAGS@
+EGLGLES_LIBS = @EGLGLES_LIBS@
 EGREP = @EGREP@
 ERROR_CFLAGS = @ERROR_CFLAGS@
 ERROR_CXXFLAGS = @ERROR_CXXFLAGS@
+ERROR_OBJCFLAGS = @ERROR_OBJCFLAGS@
 EXEEXT = @EXEEXT@
 EXIF_CFLAGS = @EXIF_CFLAGS@
 EXIF_LIBS = @EXIF_LIBS@
@@ -258,13 +296,16 @@ GST_LIB_LDFLAGS = @GST_LIB_LDFLAGS@
 GST_LICENSE = @GST_LICENSE@
 GST_LT_LDFLAGS = @GST_LT_LDFLAGS@
 GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OBJCFLAGS = @GST_OBJCFLAGS@
 GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
 GST_OPTION_CXXFLAGS = @GST_OPTION_CXXFLAGS@
+GST_OPTION_OBJCFLAGS = @GST_OPTION_OBJCFLAGS@
 GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
 GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
 GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
 GST_PLUGINS_BAD_CFLAGS = @GST_PLUGINS_BAD_CFLAGS@
 GST_PLUGINS_BAD_CXXFLAGS = @GST_PLUGINS_BAD_CXXFLAGS@
+GST_PLUGINS_BAD_OBJCFLAGS = @GST_PLUGINS_BAD_OBJCFLAGS@
 GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
 GST_PLUGINS_BASE_DIR = @GST_PLUGINS_BASE_DIR@
 GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
@@ -283,13 +324,19 @@ GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
 GST_PREFIX = @GST_PREFIX@
 GST_REVISION = @GST_REVISION@
 GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GST_VIDEO_CFLAGS = @GST_VIDEO_CFLAGS@
+GST_VIDEO_LIBS = @GST_VIDEO_LIBS@
 GTKDOC_CHECK = @GTKDOC_CHECK@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
+G_UDEV_CFLAGS = @G_UDEV_CFLAGS@
+G_UDEV_LIBS = @G_UDEV_LIBS@
 HAVE_BZ2 = @HAVE_BZ2@
 HAVE_CXX = @HAVE_CXX@
 HAVE_DIRECT3D = @HAVE_DIRECT3D@
+HAVE_DIRECT3D9 = @HAVE_DIRECT3D9@
 HAVE_DIRECTDRAW = @HAVE_DIRECTDRAW@
+HAVE_DIRECTSHOW = @HAVE_DIRECTSHOW@
 HAVE_DIRECTSOUND = @HAVE_DIRECTSOUND@
 HAVE_DTS = @HAVE_DTS@
 HAVE_FAAC = @HAVE_FAAC@
@@ -299,6 +346,7 @@ HAVE_GSM = @HAVE_GSM@
 HAVE_JP2K = @HAVE_JP2K@
 HAVE_NAS = @HAVE_NAS@
 HAVE_VPX = @HAVE_VPX@
+HAVE_WASAPI = @HAVE_WASAPI@
 HAVE_WILDMIDI = @HAVE_WILDMIDI@
 HAVE_X = @HAVE_X@
 HAVE_X11 = @HAVE_X11@
@@ -326,6 +374,10 @@ LIBMMS_LIBS = @LIBMMS_LIBS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUDEV_CFLAGS = @LIBUDEV_CFLAGS@
+LIBUDEV_LIBS = @LIBUDEV_LIBS@
+LIBUSB_CFLAGS = @LIBUSB_CFLAGS@
+LIBUSB_LIBS = @LIBUSB_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LOCALEDIR = @LOCALEDIR@
@@ -363,7 +415,7 @@ NM = @NM@
 NMEDIT = @NMEDIT@
 OBJC = @OBJC@
 OBJCDEPMODE = @OBJCDEPMODE@
-OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJCFLAGS = @OBJCFLAGS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OFA_CFLAGS = @OFA_CFLAGS@
@@ -372,6 +424,7 @@ OPENAL_CFLAGS = @OPENAL_CFLAGS@
 OPENAL_LIBS = @OPENAL_LIBS@
 OPENCV_CFLAGS = @OPENCV_CFLAGS@
 OPENCV_LIBS = @OPENCV_LIBS@
+OPENCV_PREFIX = @OPENCV_PREFIX@
 OPUS_CFLAGS = @OPUS_CFLAGS@
 OPUS_LIBS = @OPUS_LIBS@
 ORCC = @ORCC@
@@ -405,6 +458,8 @@ PYTHON_PLATFORM = @PYTHON_PLATFORM@
 PYTHON_PREFIX = @PYTHON_PREFIX@
 PYTHON_VERSION = @PYTHON_VERSION@
 RANLIB = @RANLIB@
+RSVG_2_35_0_CFLAGS = @RSVG_2_35_0_CFLAGS@
+RSVG_2_35_0_LIBS = @RSVG_2_35_0_LIBS@
 RSVG_CFLAGS = @RSVG_CFLAGS@
 RSVG_LIBS = @RSVG_LIBS@
 RTMP_CFLAGS = @RTMP_CFLAGS@
@@ -421,6 +476,7 @@ SLV2_CFLAGS = @SLV2_CFLAGS@
 SLV2_LIBS = @SLV2_LIBS@
 SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
 SNDFILE_LIBS = @SNDFILE_LIBS@
+SNDIO_LIBS = @SNDIO_LIBS@
 SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
 SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
 SPANDSP_CFLAGS = @SPANDSP_CFLAGS@
@@ -449,12 +505,15 @@ VOAMRWBENC_LIBS = @VOAMRWBENC_LIBS@
 VPX_LIBS = @VPX_LIBS@
 WARNING_CFLAGS = @WARNING_CFLAGS@
 WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
+WARNING_OBJCFLAGS = @WARNING_OBJCFLAGS@
+WASAPI_LIBS = @WASAPI_LIBS@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_LIBS = @WAYLAND_LIBS@
 WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
 WILDMIDI_LIBS = @WILDMIDI_LIBS@
-WIN32_LIBS = @WIN32_LIBS@
+WINSOCK2_LIBS = @WINSOCK2_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
 X11_LIBS = @X11_LIBS@
-XDG_LIBS = @XDG_LIBS@
 XGETTEXT = @XGETTEXT@
 XGETTEXT_015 = @XGETTEXT_015@
 XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
@@ -522,7 +581,11 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
 sysconfdir = @sysconfdir@
+target = @target@
 target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
@@ -690,6 +753,20 @@ GTAGS:
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
@@ -831,7 +908,7 @@ uninstall-am:
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstPROGRAMS ctags distclean \
+	clean-libtool clean-noinstPROGRAMS cscopelist ctags distclean \
 	distclean-compile distclean-generic distclean-libtool \
 	distclean-tags distdir dvi dvi-am html html-am info info-am \
 	install install-am install-data install-data-am install-dvi \
diff --git a/tests/icles/dccp/README b/tests/icles/dccp/README
new file mode 100644
index 0000000..e76ead5
--- /dev/null
+++ b/tests/icles/dccp/README
@@ -0,0 +1,52 @@
+Applications
+
+If you want to compile the applications you will need to run this command-line:
+gcc -Wall $(pkg-config --cflags --libs gstreamer-0.10) <applicationName>.c -o <applicationName>
+
+To run:
+./<applicationName>
+
+
+Command-line
+
+###### Pipe to transmit a file #
+
+* Server:
+gst-launch -v filesrc location=file ! dccpserversink port=9011 ccid=2
+
+* Client:
+gst-launch -v dccpclientsrc host=localhost port=9011 ccid=2 ! filesink location=fileDist
+
+###### Pipe to transmit from the microphone #
+
+* Server:
+gst-launch -v alsasrc ! dccpserversink port=9011 ccid=2
+
+* Client:
+gst-launch -v dccpclientsrc host=localhost port=9011 ccid=2 caps="audio/x-raw-int, endianness=(int)1234, signed=(boolean)true, width=(int)32, depth=(int)32, rate=(int)44100, channels=(int)2" ! alsasink
+
+###### Pipe to transmit a MP3 #
+
+* Server:
+gst-launch -v filesrc location=music.mp3 ! mad ! dccpserversink port=9011 ccid=2
+
+* Client:
+gst-launch -v dccpclientsrc host=localhost port=9011 ccid=2 caps="audio/x-raw-int, endianness=(int)1234, signed=(boolean)true, width=(int)32, depth=(int)32, rate=(int)44100, channels=(int)2" ! alsasink
+
+###### Pipe to stream a MP3 #
+
+* Server:
+gst-launch -v filesrc location=music.mp3 ! mp3parse ! dccpserversink port=9011 ccid=2
+
+* Client:
+gst-launch -v dccpclientsrc host=localhost port=9011 ccid=2 ! decodebin ! alsasink
+-- We also tested with mpg123, to use it: mpg123 dccp://localhost:9011
+
+###### Pipe to transmit a MP3 with dccp, speex and rtp #
+
+* Server:
+gst-launch -v filesrc location=music.mp3 ! mad ! audioconvert ! capsfilter caps="audio/x-raw-int, endianness=(int)1234, signed=(boolean)true, width=(int)16, depth=(int)16, rate=(int)44100, channels=(int)1" ! speexenc ! rtpspeexpay ! dccpserversink port=9011 ccid=2
+
+* Client:
+gst-launch -v dccpclientsrc host=localhost port=9011 ccid=2 caps="application/x-rtp, media=(string)audio, payload=(int)110, clock-rate=(int)44100, encoding-name=(string)SPEEX, ssrc=(guint)152981653, clock-base=(guint)1553719649, seqnum-base=(guint)3680, encoding-params=(string)1" ! rtpspeexdepay ! speexdec ! alsasink
+
diff --git a/tests/icles/dccp/call/DCCPClient.c b/tests/icles/dccp/call/DCCPClient.c
new file mode 100644
index 0000000..5266f78
--- /dev/null
+++ b/tests/icles/dccp/call/DCCPClient.c
@@ -0,0 +1,151 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+void
+start_dccpserversink_pipe (GstElement * object, gint socket, gpointer data)
+{
+  GstElement *dccpserversink = (GstElement *) data;
+  g_object_set (G_OBJECT (dccpserversink), "sockfd", socket, NULL);
+
+  g_print ("Setting pipelinesink to PLAYING\n");
+  GstElement *pipelinesink =
+      (GstElement *) gst_element_get_parent (dccpserversink);
+  gst_element_set_state (pipelinesink, GST_STATE_PLAYING);
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GstElement *pipelinesink, *alsasrc, *dccpserversink;
+  GstElement *pipelinesrc, *alsasink, *dccpclientsrc;
+  GMainLoop *loop;
+  GstBus *bus;
+  GstCaps *caps;
+
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 2) {
+    g_print ("%s\n", "see usage: serverHost");
+    return -1;
+  }
+
+  /* create elements */
+  pipelinesink = gst_pipeline_new ("audio-sender");
+  alsasrc = gst_element_factory_make ("alsasrc", "alsa-source");
+  dccpserversink = gst_element_factory_make ("dccpserversink", "server-sink");
+  pipelinesrc = gst_pipeline_new ("audio-receiver");
+  alsasink = gst_element_factory_make ("alsasink", "alsa-sink");
+  dccpclientsrc = gst_element_factory_make ("dccpclientsrc", "client-source");
+
+
+  if (!pipelinesink || !alsasrc || !dccpserversink || !pipelinesrc || !alsasink
+      || !dccpclientsrc) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  caps =
+      gst_caps_from_string
+      ("audio/x-raw-int, endianness=(int)1234, signed=(boolean)true, width=(int)32, depth=(int)32, rate=(int)44100, channels=(int)2");
+  g_object_set (G_OBJECT (dccpclientsrc), "caps", caps, NULL);
+
+  g_object_set (G_OBJECT (dccpclientsrc), "host", argv[1], NULL);
+  /*g_object_set (G_OBJECT (dccpclientsrc), "ccid", 3, NULL);
+     g_object_set (G_OBJECT (dccpserversink), "ccid", 3, NULL); */
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipelinesink));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipelinesrc));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipelinesink), alsasrc, dccpserversink, NULL);
+  gst_element_link_many (alsasrc, dccpserversink, NULL);
+
+  gst_bin_add_many (GST_BIN (pipelinesrc), dccpclientsrc, alsasink, NULL);
+  gst_element_link (dccpclientsrc, alsasink);
+
+  g_signal_connect (dccpclientsrc, "connected",
+      (GCallback) start_dccpserversink_pipe, dccpserversink);
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting pipelinesrc to PLAYING\n");
+  gst_element_set_state (pipelinesrc, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipelinesink, GST_STATE_NULL);
+  g_print ("Deleting pipelinesink\n");
+  gst_object_unref (GST_OBJECT (pipelinesink));
+
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipelinesrc, GST_STATE_NULL);
+  g_print ("Deleting pipelinesrc\n");
+  gst_object_unref (GST_OBJECT (pipelinesrc));
+
+
+  return 0;
+}
diff --git a/tests/icles/dccp/call/DCCPServer.c b/tests/icles/dccp/call/DCCPServer.c
new file mode 100644
index 0000000..dc1b497
--- /dev/null
+++ b/tests/icles/dccp/call/DCCPServer.c
@@ -0,0 +1,144 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+void
+start_dccpclientsrc_pipe (GstElement * object, gint socket, gpointer data)
+{
+  GstElement *dccpclientsrc = (GstElement *) data;
+  g_object_set (G_OBJECT (dccpclientsrc), "sockfd", socket, NULL);
+
+  g_print ("Setting pipelinesrc to PLAYING\n");
+  GstElement *pipelinesrc =
+      (GstElement *) gst_element_get_parent (dccpclientsrc);
+  gst_element_set_state (pipelinesrc, GST_STATE_PLAYING);
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GstElement *pipelinesink, *alsasrc, *dccpserversink;
+  GstElement *pipelinesrc, *alsasink, *dccpclientsrc;
+  GMainLoop *loop;
+  GstBus *bus;
+  GstCaps *caps;
+
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* create elements */
+  pipelinesink = gst_pipeline_new ("audio-sender");
+  alsasrc = gst_element_factory_make ("alsasrc", "alsa-source");
+  dccpserversink = gst_element_factory_make ("dccpserversink", "server-sink");
+  pipelinesrc = gst_pipeline_new ("audio-receiver");
+  alsasink = gst_element_factory_make ("alsasink", "alsa-sink");
+  dccpclientsrc = gst_element_factory_make ("dccpclientsrc", "client-source");
+
+
+  if (!pipelinesink || !alsasrc || !dccpserversink || !pipelinesrc || !alsasink
+      || !dccpclientsrc) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  caps =
+      gst_caps_from_string
+      ("audio/x-raw-int, endianness=(int)1234, signed=(boolean)true, width=(int)32, depth=(int)32, rate=(int)44100, channels=(int)2");
+  g_object_set (G_OBJECT (dccpclientsrc), "caps", caps, NULL);
+
+  /*g_object_set (G_OBJECT (dccpclientsrc), "ccid", 3, NULL);
+     g_object_set (G_OBJECT (dccpserversink), "ccid", 3, NULL); */
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipelinesink));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipelinesrc));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipelinesink), alsasrc, dccpserversink, NULL);
+  gst_element_link_many (alsasrc, dccpserversink, NULL);
+
+  gst_bin_add_many (GST_BIN (pipelinesrc), dccpclientsrc, alsasink, NULL);
+  gst_element_link (dccpclientsrc, alsasink);
+
+  g_signal_connect (dccpserversink, "connected",
+      (GCallback) start_dccpclientsrc_pipe, dccpclientsrc);
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting pipelinesink to PLAYING\n");
+  gst_element_set_state (pipelinesink, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipelinesink, GST_STATE_NULL);
+  g_print ("Deleting pipelinesink\n");
+  gst_object_unref (GST_OBJECT (pipelinesink));
+
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipelinesrc, GST_STATE_NULL);
+  g_print ("Deleting pipelinesrc\n");
+  gst_object_unref (GST_OBJECT (pipelinesrc));
+
+
+  return 0;
+}
diff --git a/tests/icles/dccp/call/README b/tests/icles/dccp/call/README
new file mode 100644
index 0000000..ed53abd
--- /dev/null
+++ b/tests/icles/dccp/call/README
@@ -0,0 +1 @@
+This application tests the socket sharing.
diff --git a/tests/icles/dccp/file/DCCPClientSaveFile.c b/tests/icles/dccp/file/DCCPClientSaveFile.c
new file mode 100644
index 0000000..99ac243
--- /dev/null
+++ b/tests/icles/dccp/file/DCCPClientSaveFile.c
@@ -0,0 +1,113 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GMainLoop *loop;
+  GstBus *bus;
+  GstElement *pipeline, *filesink, *dccpclientsrc;
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 4) {
+    g_print ("%s\n", "see usage: serverHost serverPort location");
+    return -1;
+  }
+
+  /* create elements */
+  pipeline = gst_pipeline_new ("audio-sender");
+  filesink = gst_element_factory_make ("filesink", "file-sink");
+  dccpclientsrc = gst_element_factory_make ("dccpclientsrc", "client-source");
+
+
+  if (!pipeline || !filesink || !dccpclientsrc) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  g_object_set (G_OBJECT (dccpclientsrc), "host", argv[1], NULL);
+  g_object_set (G_OBJECT (dccpclientsrc), "port", atoi (argv[2]), NULL);
+  /*g_object_set (G_OBJECT (dccpclientsrc), "ccid", 3, NULL); */
+  g_object_set (G_OBJECT (filesink), "location", argv[3], NULL);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipeline), dccpclientsrc, filesink, NULL);
+
+  gst_element_link (dccpclientsrc, filesink);
+
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting to PLAYING\n");
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+}
diff --git a/tests/icles/dccp/file/DCCPServerSendFile.c b/tests/icles/dccp/file/DCCPServerSendFile.c
new file mode 100644
index 0000000..a5de894
--- /dev/null
+++ b/tests/icles/dccp/file/DCCPServerSendFile.c
@@ -0,0 +1,112 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GMainLoop *loop;
+  GstBus *bus;
+  GstElement *pipeline, *filesrc, *dccpserversink;
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 3) {
+    g_print ("%s\n", "see usage: port mp3Location");
+    return -1;
+  }
+
+  /* create elements */
+  pipeline = gst_pipeline_new ("audio-sender");
+  filesrc = gst_element_factory_make ("filesrc", "file-source");
+  dccpserversink = gst_element_factory_make ("dccpserversink", "server-sink");
+
+
+  if (!pipeline || !filesrc || !dccpserversink) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  g_object_set (G_OBJECT (dccpserversink), "port", atoi (argv[1]), NULL);
+  /*g_object_set (G_OBJECT (dccpserversink), "ccid", 3, NULL); */
+  g_object_set (G_OBJECT (filesrc), "location", argv[2], NULL);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipeline), filesrc, dccpserversink, NULL);
+
+  gst_element_link_many (filesrc, dccpserversink, NULL);
+
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting to PLAYING\n");
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+}
diff --git a/tests/icles/dccp/mic/DCCPClientPlayMic.c b/tests/icles/dccp/mic/DCCPClientPlayMic.c
new file mode 100644
index 0000000..0a697fa
--- /dev/null
+++ b/tests/icles/dccp/mic/DCCPClientPlayMic.c
@@ -0,0 +1,116 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GMainLoop *loop;
+  GstBus *bus;
+  GstElement *pipeline, *alsasink, *dccpclientsrc;
+  GstCaps *caps;
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 3) {
+    g_print ("%s\n", "see usage: serverHost serverPort");
+    return -1;
+  }
+
+  /* create elements */
+  pipeline = gst_pipeline_new ("audio-receiver");
+  alsasink = gst_element_factory_make ("alsasink", "alsa-sink");
+  dccpclientsrc = gst_element_factory_make ("dccpclientsrc", "client-source");
+
+  if (!pipeline || !alsasink || !dccpclientsrc) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  caps =
+      gst_caps_from_string
+      ("audio/x-raw-int, endianness=(int)1234, signed=(boolean)true, width=(int)32, depth=(int)32, rate=(int)44100, channels=(int)2");
+
+  g_object_set (G_OBJECT (dccpclientsrc), "caps", caps, NULL);
+  g_object_set (G_OBJECT (dccpclientsrc), "host", argv[1], NULL);
+  g_object_set (G_OBJECT (dccpclientsrc), "port", atoi (argv[2]), NULL);
+  /*g_object_set (G_OBJECT (dccpclientsrc), "ccid", 3, NULL); */
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipeline), dccpclientsrc, alsasink, NULL);
+
+  gst_element_link (dccpclientsrc, alsasink);
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting to PLAYING\n");
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+}
diff --git a/tests/icles/dccp/mic/DCCPServerMic.c b/tests/icles/dccp/mic/DCCPServerMic.c
new file mode 100644
index 0000000..d282068
--- /dev/null
+++ b/tests/icles/dccp/mic/DCCPServerMic.c
@@ -0,0 +1,111 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GMainLoop *loop;
+  GstBus *bus;
+  GstElement *pipeline, *alsasrc, *dccpserversink;
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 2) {
+    g_print ("%s\n", "see usage: port");
+    return -1;
+  }
+
+  /* create elements */
+  pipeline = gst_pipeline_new ("audio-sender");
+  alsasrc = gst_element_factory_make ("alsasrc", "alsa-source");
+  dccpserversink = gst_element_factory_make ("dccpserversink", "server-sink");
+
+
+  if (!pipeline || !alsasrc || !dccpserversink) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  g_object_set (G_OBJECT (dccpserversink), "port", atoi (argv[1]), NULL);
+  /*g_object_set (G_OBJECT (dccpserversink), "ccid", 3, NULL); */
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipeline), alsasrc, dccpserversink, NULL);
+
+  gst_element_link_many (alsasrc, dccpserversink, NULL);
+
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting to PLAYING\n");
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+}
diff --git a/tests/icles/dccp/mp3/DCCPClientPlayMP3.c b/tests/icles/dccp/mp3/DCCPClientPlayMP3.c
new file mode 100644
index 0000000..e23c5a5
--- /dev/null
+++ b/tests/icles/dccp/mp3/DCCPClientPlayMP3.c
@@ -0,0 +1,117 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GMainLoop *loop;
+  GstBus *bus;
+  GstElement *pipeline, *alsasink, *dccpclientsrc;
+  GstCaps *caps;
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 3) {
+    g_print ("%s\n", "see usage: serverHost serverPort");
+    return -1;
+  }
+
+  /* create elements */
+  pipeline = gst_pipeline_new ("audio-sender");
+  alsasink = gst_element_factory_make ("alsasink", "alsa-sink");
+  dccpclientsrc = gst_element_factory_make ("dccpclientsrc", "client-source");
+
+  if (!pipeline || !alsasink || !dccpclientsrc) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  caps =
+      gst_caps_from_string
+      ("audio/x-raw-int, endianness=(int)1234, signed=(boolean)true, width=(int)32, depth=(int)32, rate=(int)44100, channels=(int)2");
+  g_object_set (G_OBJECT (dccpclientsrc), "caps", caps, NULL);
+  gst_object_unref (caps);
+
+  g_object_set (G_OBJECT (dccpclientsrc), "host", argv[1], NULL);
+  g_object_set (G_OBJECT (dccpclientsrc), "port", atoi (argv[2]), NULL);
+  /*g_object_set (G_OBJECT (dccpclientsrc), "ccid", 2, NULL); */
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipeline), dccpclientsrc, alsasink, NULL);
+
+  gst_element_link_many (dccpclientsrc, alsasink, NULL);
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting to PLAYING\n");
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+}
diff --git a/tests/icles/dccp/mp3/DCCPServerSendMP3.c b/tests/icles/dccp/mp3/DCCPServerSendMP3.c
new file mode 100644
index 0000000..6dba171
--- /dev/null
+++ b/tests/icles/dccp/mp3/DCCPServerSendMP3.c
@@ -0,0 +1,113 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GMainLoop *loop;
+  GstBus *bus;
+  GstElement *pipeline, *filesrc, *dccpserversink, *mad;
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 3) {
+    g_print ("%s\n", "see usage: port mp3Location");
+    return -1;
+  }
+
+  /* create elements */
+  pipeline = gst_pipeline_new ("audio-sender");
+  filesrc = gst_element_factory_make ("filesrc", "file-source");
+  mad = gst_element_factory_make ("mad", "mad");
+  dccpserversink = gst_element_factory_make ("dccpserversink", "server-sink");
+
+
+  if (!pipeline || !filesrc || !dccpserversink || !mad) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  g_object_set (G_OBJECT (dccpserversink), "port", atoi (argv[1]), NULL);
+  /*g_object_set (G_OBJECT (dccpserversink), "ccid", 2, NULL); */
+  g_object_set (G_OBJECT (filesrc), "location", argv[2], NULL);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipeline), filesrc, mad, dccpserversink, NULL);
+
+  gst_element_link_many (filesrc, mad, dccpserversink, NULL);
+
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting to PLAYING\n");
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+}
diff --git a/tests/icles/dccp/mp3Speex/DCCPClientPlaySpeexMP3.c b/tests/icles/dccp/mp3Speex/DCCPClientPlaySpeexMP3.c
new file mode 100644
index 0000000..d05b419
--- /dev/null
+++ b/tests/icles/dccp/mp3Speex/DCCPClientPlaySpeexMP3.c
@@ -0,0 +1,120 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GMainLoop *loop;
+  GstBus *bus;
+  GstElement *pipeline, *alsasink, *rtpspeexdepay, *speexdec, *dccpclientsrc;
+  GstCaps *caps;
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 3) {
+    g_print ("%s\n", "see usage: serverHost serverPort");
+    return -1;
+  }
+
+  /* create elements */
+  pipeline = gst_pipeline_new ("audio-sender");
+  alsasink = gst_element_factory_make ("alsasink", "alsa-sink");
+  rtpspeexdepay = gst_element_factory_make ("rtpspeexdepay", "rtpspeexdepay");
+  speexdec = gst_element_factory_make ("speexdec", "speexdec");
+  dccpclientsrc = gst_element_factory_make ("dccpclientsrc", "client-source");
+
+  if (!pipeline || !alsasink || !rtpspeexdepay || !speexdec || !dccpclientsrc) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  caps =
+      gst_caps_from_string
+      ("application/x-rtp, media=(string)audio, payload=(int)110, clock-rate=(int)44100, encoding-name=(string)SPEEX, ssrc=(guint)152981653, clock-base=(guint)1553719649, seqnum-base=(guint)3680, encoding-params=(string)1");
+  g_object_set (G_OBJECT (dccpclientsrc), "caps", caps, NULL);
+  gst_object_unref (caps);
+
+  g_object_set (G_OBJECT (dccpclientsrc), "host", argv[1], NULL);
+  g_object_set (G_OBJECT (dccpclientsrc), "port", atoi (argv[2]), NULL);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipeline), dccpclientsrc, rtpspeexdepay, speexdec,
+      alsasink, NULL);
+
+  gst_element_link_many (dccpclientsrc, rtpspeexdepay, speexdec, alsasink,
+      NULL);
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting to PLAYING\n");
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+}
diff --git a/tests/icles/dccp/mp3Speex/DCCPServerSendSpeexMP3.c b/tests/icles/dccp/mp3Speex/DCCPServerSendSpeexMP3.c
new file mode 100644
index 0000000..58166dd
--- /dev/null
+++ b/tests/icles/dccp/mp3Speex/DCCPServerSendSpeexMP3.c
@@ -0,0 +1,128 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GMainLoop *loop;
+  GstBus *bus;
+  GstElement *pipeline, *filesrc, *mad, *audioconvert, *capsfilter, *speexenc,
+      *rtpspeexpay, *dccpserversink;
+  GstCaps *caps;
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 3) {
+    g_print ("%s\n", "see usage: port mp3Location");
+    return -1;
+  }
+
+  /* create elements */
+  pipeline = gst_pipeline_new ("audio-sender");
+  filesrc = gst_element_factory_make ("filesrc", "file-source");
+  mad = gst_element_factory_make ("mad", "mad");
+  audioconvert = gst_element_factory_make ("audioconvert", "audioconvert");
+  capsfilter = gst_element_factory_make ("capsfilter", "capsfilter");
+  speexenc = gst_element_factory_make ("speexenc", "speexenc");
+  rtpspeexpay = gst_element_factory_make ("rtpspeexpay", "rtpspeexpay");
+  dccpserversink = gst_element_factory_make ("dccpserversink", "server-sink");
+
+
+  if (!pipeline || !filesrc || !dccpserversink || !mad || !audioconvert
+      || !capsfilter || !speexenc || !rtpspeexpay) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  g_object_set (G_OBJECT (dccpserversink), "port", atoi (argv[1]), NULL);
+  g_object_set (G_OBJECT (filesrc), "location", argv[2], NULL);
+
+  caps =
+      gst_caps_from_string
+      ("audio/x-raw-int, endianness=(int)1234, signed=(boolean)true, width=(int)16, depth=(int)16, rate=(int)44100, channels=(int)1");
+  g_object_set (G_OBJECT (capsfilter), "caps", caps, NULL);
+  gst_object_unref (caps);
+
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipeline), filesrc, mad, audioconvert, capsfilter,
+      speexenc, rtpspeexpay, dccpserversink, NULL);
+
+  gst_element_link_many (filesrc, mad, audioconvert, capsfilter, speexenc,
+      rtpspeexpay, dccpserversink, NULL);
+
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting to PLAYING\n");
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+}
diff --git a/tests/icles/dccp/mp3Stream/DCCPClientPlayMP3Stream.c b/tests/icles/dccp/mp3Stream/DCCPClientPlayMP3Stream.c
new file mode 100644
index 0000000..b4942be
--- /dev/null
+++ b/tests/icles/dccp/mp3Stream/DCCPClientPlayMP3Stream.c
@@ -0,0 +1,113 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GMainLoop *loop;
+  GstBus *bus;
+  GstElement *pipeline, *alsasink, *mad, *audioconvert, *dccpclientsrc;
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 3) {
+    g_print ("%s\n", "see usage: serverHost serverPort");
+    return -1;
+  }
+
+  /* create elements */
+  pipeline = gst_pipeline_new ("audio-sender");
+  dccpclientsrc = gst_element_factory_make ("dccpclientsrc", "client-source");
+  mad = gst_element_factory_make ("mad", "mad");
+  audioconvert = gst_element_factory_make ("audioconvert", "audioconvert");
+  alsasink = gst_element_factory_make ("alsasink", "alsa-sink");
+
+  if (!pipeline || !alsasink || !mad || !audioconvert || !dccpclientsrc) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  g_object_set (G_OBJECT (dccpclientsrc), "host", argv[1], NULL);
+  g_object_set (G_OBJECT (dccpclientsrc), "port", atoi (argv[2]), NULL);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipeline), dccpclientsrc, mad, audioconvert,
+      alsasink, NULL);
+
+  gst_element_link_many (dccpclientsrc, mad, audioconvert, alsasink, NULL);
+
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting to PLAYING\n");
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+}
diff --git a/tests/icles/dccp/mp3Stream/DCCPServerSendMP3Stream.c b/tests/icles/dccp/mp3Stream/DCCPServerSendMP3Stream.c
new file mode 100644
index 0000000..c17f79e
--- /dev/null
+++ b/tests/icles/dccp/mp3Stream/DCCPServerSendMP3Stream.c
@@ -0,0 +1,113 @@
+/* GStreamer
+ * Copyright (C) <2007> Leandro Melo de Sales <leandroal@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <gst/gst.h>
+
+static gboolean
+bus_call (GstBus * bus, GstMessage * msg, gpointer data)
+{
+
+  GMainLoop *loop = (GMainLoop *) data;
+
+  switch (GST_MESSAGE_TYPE (msg)) {
+    case GST_MESSAGE_EOS:
+      g_print ("End-of-stream\n");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ERROR:{
+      gchar *debug;
+      GError *err;
+
+      gst_message_parse_error (msg, &err, &debug);
+      g_free (debug);
+
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+
+  GMainLoop *loop;
+  GstBus *bus;
+  GstElement *pipeline, *filesrc, *mp3parse, *dccpserversink;
+
+  /* initialize GStreamer */
+  gst_init (&argc, &argv);
+  loop = g_main_loop_new (NULL, FALSE);
+
+  /* check input arguments */
+  if (argc != 3) {
+    g_print ("%s\n", "see usage: port mp3Location");
+    return -1;
+  }
+
+  /* create elements */
+  pipeline = gst_pipeline_new ("audio-sender"); /* create pipeline with the name audio-sender */
+  filesrc = gst_element_factory_make ("filesrc", "file-source");        /* create filesrc element with the name file-source */
+  mp3parse = gst_element_factory_make ("mp3parse", "mp3parse");
+  dccpserversink = gst_element_factory_make ("dccpserversink", "server-sink");
+
+
+  if (!pipeline || !filesrc || !mp3parse || !dccpserversink) {
+    g_print ("One element could not be created\n");
+    return -1;
+  }
+
+  g_object_set (G_OBJECT (dccpserversink), "port", atoi (argv[1]), NULL);
+  g_object_set (G_OBJECT (filesrc), "location", argv[2], NULL);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, bus_call, loop);
+  gst_object_unref (bus);
+
+  /* put all elements in a bin */
+  gst_bin_add_many (GST_BIN (pipeline), filesrc, mp3parse, dccpserversink,
+      NULL);
+  /* Link the elements at the pipeline */
+  gst_element_link_many (filesrc, mp3parse, dccpserversink, NULL);
+
+
+  /* Now set to playing and iterate. */
+  g_print ("Setting to PLAYING\n");
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_print ("Running\n");
+  g_main_loop_run (loop);
+
+  /* clean up nicely */
+  g_print ("Returned, stopping playback\n");
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  g_print ("Deleting pipeline\n");
+  gst_object_unref (GST_OBJECT (pipeline));
+
+  return 0;
+}
diff --git a/tests/icles/metadata_editor.c b/tests/icles/metadata_editor.c
new file mode 100644
index 0000000..a5d3e88
--- /dev/null
+++ b/tests/icles/metadata_editor.c
@@ -0,0 +1,1370 @@
+/*
+ * GStreamer
+ * Copyright 2007 Edgard Lima <edgard.lima@indt.org.br>
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Alternatively, the contents of this file may be used under the
+ * GNU Lesser General Public License Version 2.1 (the "LGPL"), in
+ * which case the following provisions apply instead of the ones
+ * mentioned above:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "metadata_editor.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <gst/gst.h>
+
+#if !GTK_CHECK_VERSION (2, 17, 7)
+static void
+gtk_widget_get_allocation (GtkWidget * w, GtkAllocation * a)
+{
+  *a = w->allocation;
+}
+#endif
+
+/*
+ * Global constants
+ */
+
+enum
+{
+  COL_TAG = 0,
+  COL_VALUE,
+  NUM_COLS
+};
+/* *INDENT-OFF* */
+typedef enum _AppOptions {
+  APP_OPT_DEMUX_EXIF = (1 << 0),
+  APP_OPT_DEMUX_IPTC = (1 << 1),
+  APP_OPT_DEMUX_XMP  = (1 << 2),
+  APP_OPT_MUX_EXIF   = (1 << 3),
+  APP_OPT_MUX_IPTC   = (1 << 4),
+  APP_OPT_MUX_XMP    = (1 << 5),
+  APP_OPT_ALL        = (1 << 6) - 1,
+} AppOptions;
+
+#define ENC_ERROR   (-1)
+#define ENC_DONE    (0)
+#define ENC_UNKNOWN (1)
+
+/* *INDENT-OFF* */
+
+/*
+ * functions prototypes
+ */
+
+/* gstreamer related functions */
+
+static void me_gst_cleanup_elements ();
+static int me_gst_setup_view_pipeline (const gchar * filename);
+static int
+me_gst_setup_capture_pipeline (const gchar * src_file, const gchar * dest_file,
+    gint * encode_status, gboolean use_v4l2);
+static int
+me_gst_setup_encode_pipeline (const gchar * src_file, const gchar * dest_file,
+    gint * encode_status);
+
+/* ui related functions */
+
+static void ui_refresh (void);
+static void process_file(void);
+
+/*
+ * Global Vars 
+ */
+
+GstElement *gst_source = NULL;
+GstElement *gst_metadata_demux = NULL;
+GstElement *gst_metadata_mux = NULL;
+GstElement *gst_image_dec = NULL;
+GstElement *gst_image_enc = NULL;
+GstElement *gst_video_scale = NULL;
+GstElement *gst_video_convert = NULL;
+GstElement *gst_video_sink = NULL;
+GstElement *gst_file_sink = NULL;
+GstElement *gst_pipeline = NULL;
+
+GdkPixbuf *last_pixbuf = NULL;  /* image as pixbuf at original size */
+GdkPixbuf *draw_pixbuf = NULL;  /* pixbuf resized for drawing       */
+
+AppOptions app_options = APP_OPT_ALL;
+
+GstTagList *tag_list = NULL;
+
+GtkBuilder *builder = NULL;
+GtkWidget *ui_main_window = NULL;
+GtkWidget *ui_drawing = NULL;
+GtkWidget *ui_tree = NULL;
+
+GtkEntry *ui_entry_insert_tag = NULL;
+GtkEntry *ui_entry_insert_value = NULL;
+
+GtkToggleButton *ui_chk_bnt_capture_v4l2 = NULL;
+GtkToggleButton *ui_chk_bnt_capture_test = NULL;
+
+GString *filename = NULL;
+
+/*
+ * Helper functions
+ */
+
+static void
+dump_tag_buffer(const char *tag, guint8 * buf, guint32 size)
+{
+  guint32 i;
+  printf("\nDumping %s (size = %u)\n\n", tag, size);
+
+  for(i=0; i<size; ++i) {
+
+    if (i % 16 == 0)
+      printf("%04x:%04x | ", i >> 16, i & 0xFFFF);
+
+    printf("%02x", buf[i]);
+
+    if (i % 16 != 15)
+      printf(" ");
+    else
+      printf("\n");
+
+  }
+
+  printf("\n\n");
+
+}
+
+static void
+insert_tag_on_tree (const GstTagList * list, const gchar * tag,
+    gpointer user_data)
+{
+  gchar *str = NULL;
+  GtkTreeView *tree_view = NULL;
+  GtkTreeStore *tree_store = NULL;
+  GtkTreeIter iter;
+
+  tree_view = GTK_TREE_VIEW (user_data);
+
+  if (gst_tag_get_type (tag) == G_TYPE_STRING) {
+    if (!gst_tag_list_get_string_index (list, tag, 0, &str))
+      g_assert_not_reached ();
+  } else if ( gst_tag_get_type (tag) == GST_TYPE_BUFFER ) {
+    const GValue *val = NULL;
+    GstBuffer *buf;
+    val = gst_tag_list_get_value_index (list, tag, 0);
+    buf = gst_value_get_buffer (val);
+    dump_tag_buffer(tag, GST_BUFFER_DATA(buf), GST_BUFFER_SIZE(buf));
+    str = g_strdup("It has been printed to stdout");
+  } else {
+    str = g_strdup_value_contents (gst_tag_list_get_value_index (list, tag, 0));
+  }
+
+  tree_store = GTK_TREE_STORE (gtk_tree_view_get_model (tree_view));
+  gtk_tree_store_append (tree_store, &iter, NULL);
+  gtk_tree_store_set (tree_store, &iter, COL_TAG, tag, COL_VALUE, str, -1);
+
+  if (str)
+    g_free (str);
+
+}
+
+static gboolean
+change_tag_list (GstTagList ** list, const gchar * tag, const gchar * value)
+{
+  GType type;
+  gboolean ret = FALSE;
+
+  if (list == NULL || tag == NULL || value == NULL)
+    goto done;
+
+  if (!gst_tag_exists (tag)) {
+    fprintf (stderr, "%s is not a GStreamer registered tag\n", tag);
+    goto done;
+  }
+
+  if (*list == NULL)
+    *list = gst_tag_list_new ();
+
+  type = gst_tag_get_type (tag);
+
+  if (type == GST_TYPE_FRACTION) {
+    /* FIXME: Ask GStreamer guys to add GST_FRACTION support to TAGS */
+    /* Even better: ask GLib guys to add this type */
+    gint n, d;
+
+    sscanf (value, "%d/%d", &n, &d);
+    gst_tag_list_add (*list, GST_TAG_MERGE_REPLACE, tag, n, d, NULL);
+    ret = TRUE;
+  } else {
+    switch (type) {
+      case G_TYPE_STRING:
+        gst_tag_list_add (*list, GST_TAG_MERGE_REPLACE, tag, value, NULL);
+        ret = TRUE;
+        break;
+      case G_TYPE_FLOAT:
+      {
+        gfloat fv = (gfloat) g_strtod (value, NULL);
+
+        gst_tag_list_add (*list, GST_TAG_MERGE_REPLACE, tag, fv, NULL);
+        ret = TRUE;
+      }
+        break;
+      case G_TYPE_INT:
+        /* fall through */
+      case G_TYPE_UINT:
+      {
+        gint iv = atoi (value);
+
+        gst_tag_list_add (*list, GST_TAG_MERGE_REPLACE, tag, iv, NULL);
+        ret = TRUE;
+      }
+        break;
+      default:
+        g_printerr ("Tags of type '%s' are not supported yet for editing"
+                    " by this application.\n",
+            g_type_name (type));
+        break;
+    }
+  }
+
+done:
+
+  return ret;
+
+}
+
+static void
+update_draw_pixbuf (guint max_width, guint max_height)
+{
+  gdouble wratio, hratio;
+  gint w = 0, h = 0;
+
+  if (last_pixbuf) {
+    w = gdk_pixbuf_get_width (last_pixbuf);
+    h = gdk_pixbuf_get_height (last_pixbuf);
+  }
+
+  g_print ("Allocation: %dx%d, pixbuf: %dx%d\n", max_width, max_height, w, h);
+
+  if (last_pixbuf == NULL)
+    return;
+
+  g_return_if_fail (max_width > 0 && max_height > 0);
+  wratio = w * 1.0 / max_width * 1.0;
+  hratio = h * 1.0 / max_height;
+  g_print ("ratios = %.2f / %.2f\n", wratio, hratio);
+
+  if (hratio > wratio) {
+    w = (gint) (w * 1.0 / hratio);
+    h = (gint) (h * 1.0 / hratio);
+  } else {
+    w = (gint) (w * 1.0 / wratio);
+    h = (gint) (h * 1.0 / wratio);
+  }
+
+  if (draw_pixbuf != NULL && gdk_pixbuf_get_width (draw_pixbuf) == w &&
+      gdk_pixbuf_get_height (last_pixbuf) == h) {
+    return; /* nothing to do */
+  }
+
+  g_print ("drawing pixbuf at %dx%d\n", w, h);
+
+  if (draw_pixbuf)
+    g_object_unref (draw_pixbuf);
+
+  draw_pixbuf =
+      gdk_pixbuf_scale_simple (last_pixbuf, w, h, GDK_INTERP_BILINEAR);
+  
+}
+
+static void
+ui_drawing_size_allocate_cb (GtkWidget * drawing_area,
+    GtkAllocation * allocation, gpointer data)
+{
+  update_draw_pixbuf (allocation->width, allocation->height);
+}
+
+/*
+ * UI handling functions (mapped by GtkBuilder)
+ */
+
+gboolean
+on_drawingMain_expose_event (GtkWidget * widget, GdkEventExpose * event,
+    gpointer data)
+{
+  GtkAllocation a;
+  cairo_t *cr;
+  GdkRectangle rect;
+
+  gtk_widget_get_allocation (widget, &a);
+
+  if (draw_pixbuf == NULL)
+    return FALSE;
+
+  rect.width = gdk_pixbuf_get_width (draw_pixbuf);
+  rect.height = gdk_pixbuf_get_height (draw_pixbuf);
+
+  /* center image */
+  rect.x = (a.width - rect.width) / 2;
+  rect.y = (a.height - rect.height) / 2;
+
+  /* sanity check, shouldn't happen */
+  if (rect.x < 0)
+    rect.x = 0;
+  if (rect.y < 0)
+    rect.y = 0;
+
+  cr = gdk_cairo_create (event->window);
+
+  gdk_cairo_set_source_pixbuf (cr, draw_pixbuf, 0, 0);
+  gdk_cairo_rectangle (cr, &rect);
+  cairo_fill (cr);
+
+  cairo_destroy (cr);
+
+  return TRUE; /* handled expose event */
+}
+
+void
+on_windowMain_delete_event (GtkWidget * widget, GdkEvent * event,
+    gpointer user_data)
+{
+  gst_element_set_state (gst_pipeline, GST_STATE_NULL);
+  gst_element_get_state (gst_pipeline, NULL, NULL, GST_CLOCK_TIME_NONE);
+  gtk_main_quit ();
+}
+
+void
+on_buttonInsert_clicked (GtkButton * button, gpointer user_data)
+{
+  GtkTreeStore *store = NULL;
+  GtkTreeIter iter;
+  const gchar *tag = gtk_entry_get_text (ui_entry_insert_tag);
+  const gchar *value = gtk_entry_get_text (ui_entry_insert_value);
+
+  if ( tag_list == NULL ) {
+    tag_list = gst_tag_list_new ();
+  }
+
+  if (tag && value && tag[0] != '\0') {
+
+    /* insert just new tags (the ones already in list should be modified) */
+    if (gst_tag_list_get_tag_size (tag_list, tag)) {
+      fprintf (stderr, "%s tag is already in the list try to modify it\n", tag);
+    } else {
+      if (change_tag_list (&tag_list, tag, value)) {
+        /* just add to ui_tree if it has been added to tag_list */
+        store =
+            GTK_TREE_STORE (gtk_tree_view_get_model (GTK_TREE_VIEW (ui_tree)));
+        gtk_tree_store_append (store, &iter, NULL);
+        gtk_tree_store_set (store, &iter, COL_TAG, tag, COL_VALUE, value, -1);
+      }
+    }
+
+  }
+
+  return;
+
+}
+
+static void
+setup_new_filename (GString * str, const gchar * ext)
+{
+  int i = 0;
+
+  for (i = str->len - 1; i > 0; --i) {
+    if (str->str[i] == '/') {
+      ++i;
+      break;
+    }
+  }
+  g_string_insert (str, i, "_new_");
+  if (ext) {
+    int len = strlen (ext);
+
+    if (len > str->len)
+      g_string_append (str, ext);
+    else if (strcasecmp (ext, &str->str[str->len - len]))
+      g_string_append (str, ext);
+
+  }
+}
+
+void
+on_buttonSaveFile_clicked (GtkButton * button, gpointer user_data)
+{
+
+  GString *src_file = NULL;
+  gint enc_status = ENC_UNKNOWN;
+  const gboolean use_v4l2 =
+    gtk_toggle_button_get_active (ui_chk_bnt_capture_v4l2);
+  const gboolean use_test =
+    gtk_toggle_button_get_active (ui_chk_bnt_capture_test);
+
+  gst_element_set_state (gst_pipeline, GST_STATE_NULL);
+  gst_element_get_state (gst_pipeline, NULL, NULL, GST_CLOCK_TIME_NONE);
+
+  src_file = g_string_new (filename->str);
+
+  if (use_v4l2 || use_test) {
+    setup_new_filename (filename, ".jpg");
+    if (me_gst_setup_capture_pipeline (src_file->str, filename->str,
+        &enc_status, use_v4l2)) {
+      goto done;
+    }
+  } else {
+    setup_new_filename (filename, NULL);
+    if (me_gst_setup_encode_pipeline (src_file->str, filename->str,
+            &enc_status)) {
+      goto done;
+    }
+  }
+
+  ui_refresh ();
+  remove (filename->str);
+
+  if (tag_list && gst_metadata_mux) {
+    GstTagSetter *setter = GST_TAG_SETTER (gst_metadata_mux);
+
+    if (setter) {
+      gst_element_set_state (gst_pipeline, GST_STATE_READY);
+      gst_element_get_state (gst_pipeline, NULL, NULL, GST_CLOCK_TIME_NONE);
+
+      gst_tag_setter_merge_tags (setter, tag_list, GST_TAG_MERGE_REPLACE);
+
+    }
+  }
+
+  gst_element_set_state (gst_pipeline, GST_STATE_PLAYING);
+  gst_element_get_state (gst_pipeline, NULL, NULL, GST_CLOCK_TIME_NONE);
+
+  /* wait until finished */
+  gtk_main ();
+
+  gst_element_set_state (gst_pipeline, GST_STATE_NULL);
+  gst_element_get_state (gst_pipeline, NULL, NULL, GST_CLOCK_TIME_NONE);
+
+  if (enc_status == ENC_DONE) {
+
+    /* view new file */
+    if (tag_list) {
+      gst_tag_list_free (tag_list);
+      tag_list = NULL;
+    }
+
+    me_gst_setup_view_pipeline (filename->str);
+
+    gst_element_set_state (gst_pipeline, GST_STATE_PLAYING);
+    gst_element_get_state (gst_pipeline, NULL, NULL, GST_CLOCK_TIME_NONE);
+
+  }
+
+done:
+
+  if (src_file)
+    g_string_free (src_file, TRUE);
+
+}
+
+void
+on_checkbuttonCaptureV4l2_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (togglebutton))
+    gtk_toggle_button_set_active(ui_chk_bnt_capture_test, FALSE);
+}
+
+void
+on_checkbuttonCaptureTest_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (togglebutton))
+    gtk_toggle_button_set_active(ui_chk_bnt_capture_v4l2, FALSE);
+}
+
+void
+on_checkbuttonOptionsDemuxExif_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (togglebutton))
+    app_options |= APP_OPT_DEMUX_EXIF;
+  else
+    app_options &= ~APP_OPT_DEMUX_EXIF;
+}
+
+void
+on_checkbuttonOptionsDemuxIptc_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (togglebutton))
+    app_options |= APP_OPT_DEMUX_IPTC;
+  else
+    app_options &= ~APP_OPT_DEMUX_IPTC;
+}
+
+void
+on_checkbuttonOptionsDemuxXmp_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (togglebutton))
+    app_options |= APP_OPT_DEMUX_XMP;
+  else
+    app_options &= ~APP_OPT_DEMUX_XMP;
+}
+
+void
+on_checkbuttonOptionsMuxExif_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (togglebutton))
+    app_options |= APP_OPT_MUX_EXIF;
+  else
+    app_options &= ~APP_OPT_MUX_EXIF;
+}
+
+void
+on_checkbuttonOptionsMuxIptc_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (togglebutton))
+    app_options |= APP_OPT_MUX_IPTC;
+  else
+    app_options &= ~APP_OPT_MUX_IPTC;
+}
+
+void
+on_checkbuttonOptionsMuxXmp_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (togglebutton))
+    app_options |= APP_OPT_MUX_XMP;
+  else
+    app_options &= ~APP_OPT_MUX_XMP;
+}
+
+void
+on_buttonOpenFile_clicked (GtkButton * button, gpointer user_data)
+{
+  GtkWidget *dialog;
+  gboolean open = FALSE;
+
+  dialog = gtk_file_chooser_dialog_new ("Open File",
+                                        GTK_WINDOW(ui_main_window),
+                                        GTK_FILE_CHOOSER_ACTION_OPEN,
+                                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+                                        GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+                                        NULL);
+
+  if (filename) {
+    const char *p = filename->str;
+    char *q = filename->str + filename->len - 1;
+    for (;p != q; --q) {
+      if ( *q == '/' )
+        break;
+    }
+    if ( p != q )
+      *q = '\0';
+    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER (dialog),
+        filename->str);
+    if ( p != q )
+      *q = '/';
+  }
+
+  open = gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT;
+
+  if (open) {
+    char *str;
+
+    str = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
+    if (filename)
+      g_string_free (filename, TRUE);
+    filename = g_string_new(str);
+    g_free (str);
+  }
+
+  gtk_widget_destroy (dialog);
+
+  if (open) {
+    process_file();
+  }
+
+}
+
+
+/*
+ * UI handling functions
+ */
+
+void
+on_cell_edited (GtkCellRendererText * renderer, gchar * str_path,
+    gchar * new_text, gpointer user_data)
+{
+  GtkTreePath *path = NULL;
+  GtkTreeIter iter;
+  GtkTreeModel *model = NULL;
+  const gint col_index = GPOINTER_TO_INT (user_data);
+  const gchar *tag = gtk_entry_get_text (ui_entry_insert_tag);
+
+  path = gtk_tree_path_new_from_string (str_path);
+  model = gtk_tree_view_get_model (GTK_TREE_VIEW (ui_tree));
+
+  if (change_tag_list (&tag_list, tag, new_text)) {
+
+    if (gtk_tree_model_get_iter (model, &iter, path)) {
+      gtk_tree_store_set (GTK_TREE_STORE (model), &iter, col_index, new_text,
+          -1);
+      gtk_entry_set_text (ui_entry_insert_value, new_text);
+    }
+
+  }
+
+  if (path)
+    gtk_tree_path_free (path);
+
+}
+
+static void
+on_tree_selection_changed (GtkTreeSelection * selection, gpointer data)
+{
+  GtkTreeIter iter;
+  GtkTreeModel *model;
+
+  if (gtk_tree_selection_get_selected (selection, &model, &iter)) {
+    gchar *tag;
+    gchar *value;
+
+    gtk_tree_model_get (model, &iter, COL_TAG, &tag, -1);
+    gtk_tree_model_get (model, &iter, COL_VALUE, &value, -1);
+
+    gtk_entry_set_text (ui_entry_insert_tag, tag);
+    gtk_entry_set_text (ui_entry_insert_value, value);
+
+    g_free (value);
+    g_free (tag);
+
+  }
+
+}
+
+/*
+ * UI helper functions
+ */
+
+static int
+ui_add_columns (GtkTreeView * tree_view, const gchar * title, gint col_index,
+    gboolean editable)
+{
+  GtkCellRenderer *renderer;
+  GtkTreeViewColumn *tree_col;
+  int ret = 0;
+
+  renderer = gtk_cell_renderer_text_new ();
+
+  if (editable) {
+    g_object_set (renderer, "editable", TRUE, NULL);
+    g_signal_connect (G_OBJECT (renderer), "edited",
+        G_CALLBACK (on_cell_edited), GINT_TO_POINTER (col_index));
+  }
+
+  if ((tree_col = gtk_tree_view_column_new_with_attributes (title, renderer,
+              "text", col_index, NULL))) {
+    gtk_tree_view_append_column (tree_view, tree_col);
+  } else {
+    fprintf (stderr, "UI: could not create column %s\n", title);
+    ret = -201;
+    goto done;
+  }
+
+done:
+
+  return ret;
+
+}
+
+
+static int
+ui_setup_tree_view (GtkTreeView * tree_view)
+{
+  int ret = 0;
+  GtkTreeStore *tree_store = NULL;
+  GtkTreeSelection *select;
+
+  if ((ret = ui_add_columns (tree_view, "tag", COL_TAG, FALSE)))
+    goto done;
+
+  if ((ret = ui_add_columns (tree_view, "value", COL_VALUE, TRUE)))
+    goto done;
+
+  tree_store = gtk_tree_store_new (NUM_COLS, G_TYPE_STRING, G_TYPE_STRING);
+
+  gtk_tree_view_set_model (tree_view, GTK_TREE_MODEL (tree_store));
+
+  select = gtk_tree_view_get_selection (tree_view);
+  gtk_tree_selection_set_mode (select, GTK_SELECTION_SINGLE);
+  g_signal_connect (G_OBJECT (select), "changed",
+      G_CALLBACK (on_tree_selection_changed), NULL);
+
+done:
+
+  if (tree_store)
+    g_object_unref (tree_store);
+
+  return ret;
+}
+
+static void
+ui_refresh (void)
+{
+  GtkTreeStore *store =
+      GTK_TREE_STORE (gtk_tree_view_get_model (GTK_TREE_VIEW (ui_tree)));
+  gtk_tree_store_clear (store);
+  if (filename)
+    gtk_window_set_title (GTK_WINDOW (ui_main_window), filename->str);
+}
+
+static int
+ui_create (void)
+{
+  GError *error = NULL;
+  int ret = 0;
+
+  builder = gtk_builder_new ();
+  if (!gtk_builder_add_from_file (builder, "metadata_editor.ui", &error))
+  {
+    g_warning ("Couldn't load builder file: %s", error->message);
+    g_error_free (error);
+    ret = -101;
+    goto done;
+  }
+
+  ui_main_window = GTK_WIDGET (gtk_builder_get_object (builder, "windowMain"));
+
+  ui_drawing = GTK_WIDGET (gtk_builder_get_object (builder, "drawingMain"));
+
+  ui_tree = GTK_WIDGET (gtk_builder_get_object (builder, "treeMain"));
+
+  ui_entry_insert_tag =
+          GTK_ENTRY (gtk_builder_get_object (builder, "entryTag"));
+
+  ui_entry_insert_value =
+          GTK_ENTRY (gtk_builder_get_object (builder, "entryValue"));
+
+  ui_chk_bnt_capture_v4l2 =
+          GTK_TOGGLE_BUTTON (gtk_builder_get_object (builder,
+                                                     "checkbuttonCaptureV4l2"));
+
+  ui_chk_bnt_capture_test =
+          GTK_TOGGLE_BUTTON (gtk_builder_get_object (builder,
+                                                     "checkbuttonCaptureTest"));
+
+  if (!(ui_main_window && ui_drawing && ui_tree
+          && ui_entry_insert_tag && ui_entry_insert_value
+          && ui_chk_bnt_capture_v4l2 && ui_chk_bnt_capture_test)) {
+    fprintf (stderr, "Some widgets couldn't be created\n");
+    ret = -105;
+    goto done;
+  }
+
+  g_signal_connect_after (ui_drawing, "size-allocate",
+      G_CALLBACK (ui_drawing_size_allocate_cb), NULL);
+
+  gtk_builder_connect_signals (builder, NULL);
+
+  ui_setup_tree_view (GTK_TREE_VIEW (ui_tree));
+
+  ui_refresh ();
+
+  gtk_widget_show_all (ui_main_window);
+
+done:
+
+  return ret;
+
+}
+
+/*
+ * GStreamer functions
+ */
+
+
+static gboolean
+me_gst_bus_callback_encode (GstBus * bus, GstMessage * message, gpointer data)
+{
+  gint *encode_status = (gint *) data;
+
+  fflush (stdout);
+
+  switch (GST_MESSAGE_TYPE (message)) {
+    case GST_MESSAGE_ERROR:
+    {
+      GError *err;
+      gchar *debug;
+
+      gst_message_parse_error (message, &err, &debug);
+      fprintf (stderr, "Error: %s\n", err->message);
+      g_error_free (err);
+      g_free (debug);
+
+      *encode_status = ENC_ERROR;
+      gtk_main_quit ();
+    }
+      break;
+    case GST_MESSAGE_TAG:
+    {
+      /* ignore, we alredy have the tag list */
+    }
+      break;
+    case GST_MESSAGE_EOS:
+    {
+      *encode_status = ENC_DONE;
+      gtk_main_quit ();
+    }
+      break;
+    default:
+      /* unhandled message */
+      break;
+  }
+
+  /* we want to be notified again the next time there is a message
+   * on the bus, so returning TRUE (FALSE means we want to stop watching
+   * for messages on the bus and our callback should not be called again)
+   */
+  return TRUE;
+}
+
+static gboolean
+me_gst_bus_callback_view (GstBus * bus, GstMessage * message, gpointer data)
+{
+  switch (GST_MESSAGE_TYPE (message)) {
+    case GST_MESSAGE_ERROR:
+    {
+      GError *err;
+      gchar *debug;
+
+      gst_message_parse_error (message, &err, &debug);
+      fprintf (stderr, "Error: %s\n", err->message);
+      g_error_free (err);
+      g_free (debug);
+
+      gtk_main_quit ();
+    }
+      break;
+    case GST_MESSAGE_TAG:
+    {
+      if (tag_list == NULL)
+        gst_message_parse_tag (message, &tag_list);
+      else {
+        GstTagList *tl = NULL;
+        GstTagList *ntl = NULL;
+
+        gst_message_parse_tag (message, &tl);
+        if (tl) {
+          ntl = gst_tag_list_merge (tag_list, tl, GST_TAG_MERGE_PREPEND);
+          if (ntl) {
+            gst_tag_list_free (tag_list);
+            tag_list = ntl;
+          }
+          gst_tag_list_free (tl);
+        }
+      }
+      /* remove whole chunk tags */
+      gst_tag_list_remove_tag (tag_list, "exif");
+      gst_tag_list_remove_tag (tag_list, "iptc");
+      gst_tag_list_remove_tag (tag_list, "xmp");
+    }
+      break;
+    case GST_MESSAGE_EOS:
+      if (tag_list) {
+        gst_tag_list_foreach (tag_list, insert_tag_on_tree, ui_tree);
+      }
+      break;
+    case GST_MESSAGE_ELEMENT: {
+      const GValue *val;
+      GtkAllocation a;
+
+      /* only interested in element messages from our gdkpixbufsink */
+      if (message->src != GST_OBJECT_CAST (gst_video_sink))
+        break;
+
+      /* only interested in the first image (not any smaller previews) */
+      if (gst_structure_has_name (message->structure, "pixbuf"))
+        break;
+
+      if (!gst_structure_has_name (message->structure, "preroll-pixbuf"))
+        break;
+
+      val = gst_structure_get_value (message->structure, "pixbuf");
+      g_return_val_if_fail (val != NULL, TRUE);
+
+      if (last_pixbuf)
+        g_object_unref (last_pixbuf);
+
+      last_pixbuf = GDK_PIXBUF (g_value_dup_object (val));
+
+      g_print ("Got image pixbuf: %dx%d\n", gdk_pixbuf_get_width (last_pixbuf),
+          gdk_pixbuf_get_height (last_pixbuf));
+
+      gtk_widget_get_allocation (GTK_WIDGET (ui_drawing), &a);
+      update_draw_pixbuf (a.width, a.height);
+
+      gtk_widget_queue_draw (ui_drawing);
+      break;
+    }
+    default:
+      /* unhandled message */
+      break;
+  }
+
+  /* we want to be notified again the next time there is a message
+   * on the bus, so returning TRUE (FALSE means we want to stop watching
+   * for messages on the bus and our callback should not be called again)
+   */
+  return TRUE;
+}
+
+static void
+me_gst_cleanup_elements (void)
+{
+  /* when adding an element to pipeline rember to set it to NULL or add extra ref */
+
+  if (gst_source) {
+    gst_object_unref (gst_source);
+    gst_source = NULL;
+  }
+  if (gst_metadata_demux) {
+    gst_object_unref (gst_metadata_demux);
+    gst_metadata_demux = NULL;
+  }
+  if (gst_metadata_mux) {
+    gst_object_unref (gst_metadata_mux);
+    gst_metadata_mux = NULL;
+  }
+  if (gst_image_dec) {
+    gst_object_unref (gst_image_dec);
+    gst_image_dec = NULL;
+  }
+  if (gst_image_enc) {
+    gst_object_unref (gst_image_enc);
+    gst_image_enc = NULL;
+  }
+  if (gst_video_scale) {
+    gst_object_unref (gst_video_scale);
+    gst_video_scale = NULL;
+  }
+  if (gst_video_convert) {
+    gst_object_unref (gst_video_convert);
+    gst_video_convert = NULL;
+  }
+  if (gst_video_sink) {
+    gst_object_unref (gst_video_sink);
+    gst_video_sink = NULL;
+  }
+  if (gst_file_sink) {
+    gst_object_unref (gst_file_sink);
+    gst_file_sink = NULL;
+  }
+
+  if (gst_pipeline) {
+    gst_element_set_state (gst_pipeline, GST_STATE_NULL);
+    gst_element_get_state (gst_pipeline, NULL, NULL, GST_CLOCK_TIME_NONE);
+    gst_object_unref (gst_pipeline);
+    gst_pipeline = NULL;
+  }
+
+}
+
+/* dummy function that looks the file extension */
+static gboolean
+is_png (const gchar * filename)
+{
+  gboolean ret = FALSE;
+  guint32 len;
+
+  if (!filename)
+    goto done;
+
+  if ((len = strlen (filename)) < 4)    /* at least ".png" */
+    goto done;
+
+  if (0 == strcasecmp (filename + (len - 4), ".png"))
+    ret = TRUE;
+
+done:
+
+  return ret;
+
+}
+
+static int
+me_gst_setup_capture_pipeline (const gchar * src_file, const gchar * dest_file,
+    gint * encode_status, gboolean use_v4l2)
+{
+  int ret = 0;
+  GstBus *bus = NULL;
+  gboolean linked;
+
+  *encode_status = ENC_ERROR;
+
+  me_gst_cleanup_elements ();
+
+  /* create elements */
+  if ( use_v4l2 )
+    gst_source = gst_element_factory_make ("v4l2src", NULL);
+  else
+    gst_source = gst_element_factory_make ("videotestsrc", NULL);
+  gst_video_convert = gst_element_factory_make ("ffmpegcolorspace", NULL);
+  gst_image_enc = gst_element_factory_make ("jpegenc", NULL);
+  gst_metadata_mux = gst_element_factory_make ("metadatamux", NULL);
+  gst_file_sink = gst_element_factory_make ("filesink", NULL);
+
+  if (!(gst_source && gst_video_convert && gst_image_enc && gst_metadata_mux
+          && gst_file_sink)) {
+    fprintf (stderr, "An element couldn't be created for ecoding\n");
+    ret = -300;
+    goto done;
+  }
+
+  /* create gst_pipeline */
+  gst_pipeline = gst_pipeline_new (NULL);
+
+  if (NULL == gst_pipeline) {
+    fprintf (stderr, "Pipeline couldn't be created\n");
+    ret = -305;
+    goto done;
+  }
+
+  /* set elements's properties */
+  g_object_set (gst_source, "num-buffers", 1, NULL);
+  g_object_set (gst_file_sink, "location", dest_file, NULL);
+  if ( app_options & APP_OPT_MUX_EXIF )
+    g_object_set (gst_metadata_mux, "exif", TRUE, NULL);
+  else
+    g_object_set (gst_metadata_mux, "exif", FALSE, NULL);
+
+  if ( app_options & APP_OPT_MUX_IPTC )
+    g_object_set (gst_metadata_mux, "iptc", TRUE, NULL);
+  else
+    g_object_set (gst_metadata_mux, "iptc", FALSE, NULL);
+
+  if ( app_options & APP_OPT_MUX_XMP )
+    g_object_set (gst_metadata_mux, "xmp", TRUE, NULL);
+  else
+    g_object_set (gst_metadata_mux, "xmp", FALSE, NULL);
+
+  /* adding and linking elements */
+  gst_bin_add_many (GST_BIN (gst_pipeline), gst_source, gst_video_convert,
+      gst_image_enc, gst_metadata_mux, gst_file_sink, NULL);
+
+  linked =
+      gst_element_link_many (gst_source, gst_video_convert, gst_image_enc,
+      gst_metadata_mux, gst_file_sink, NULL);
+
+  /* now element are owned by pipeline (for videosink we keep a extra ref) */
+  gst_source = gst_video_convert = gst_image_enc = gst_file_sink = NULL;
+  gst_object_ref (gst_metadata_mux);
+
+  if (!linked) {
+    fprintf (stderr, "Elements couldn't be linked\n");
+    ret = -310;
+    goto done;
+  }
+
+  *encode_status = ENC_UNKNOWN;
+
+  /* adding message bus */
+  bus = gst_pipeline_get_bus (GST_PIPELINE (gst_pipeline));
+  gst_bus_add_watch (bus, me_gst_bus_callback_encode, encode_status);
+  gst_object_unref (bus);
+
+done:
+
+  return ret;
+
+}
+
+static int
+me_gst_setup_encode_pipeline (const gchar * src_file, const gchar * dest_file,
+    gint * encode_status)
+{
+  int ret = 0;
+  GstBus *bus = NULL;
+  gboolean linked;
+
+  *encode_status = ENC_ERROR;
+
+  me_gst_cleanup_elements ();
+
+  /* create elements */
+  gst_source = gst_element_factory_make ("filesrc", NULL);
+  gst_metadata_demux = gst_element_factory_make ("metadatademux", NULL);
+  gst_metadata_mux = gst_element_factory_make ("metadatamux", NULL);
+  gst_file_sink = gst_element_factory_make ("filesink", NULL);
+
+
+  if (!(gst_source && gst_metadata_demux && gst_metadata_mux && gst_file_sink)) {
+    fprintf (stderr, "An element couldn't be created for ecoding\n");
+    ret = -300;
+    goto done;
+  }
+
+
+  /* create gst_pipeline */
+  gst_pipeline = gst_pipeline_new (NULL);
+
+  if (NULL == gst_pipeline) {
+    fprintf (stderr, "Pipeline couldn't be created\n");
+    ret = -305;
+    goto done;
+  }
+
+  /* set elements's properties */
+  g_object_set (gst_source, "location", src_file, NULL);
+  g_object_set (gst_file_sink, "location", dest_file, NULL);
+
+  if ( app_options & APP_OPT_DEMUX_EXIF )
+    g_object_set (gst_metadata_demux, "exif", TRUE, NULL);
+  else
+    g_object_set (gst_metadata_demux, "exif", FALSE, NULL);
+
+  if ( app_options & APP_OPT_DEMUX_IPTC )
+    g_object_set (gst_metadata_demux, "iptc", TRUE, NULL);
+  else
+    g_object_set (gst_metadata_demux, "iptc", FALSE, NULL);
+
+  if ( app_options & APP_OPT_DEMUX_XMP )
+    g_object_set (gst_metadata_demux, "xmp", TRUE, NULL);
+  else
+    g_object_set (gst_metadata_demux, "xmp", FALSE, NULL);
+
+  if ( app_options & APP_OPT_MUX_EXIF )
+    g_object_set (gst_metadata_mux, "exif", TRUE, NULL);
+  else
+    g_object_set (gst_metadata_mux, "exif", FALSE, NULL);
+
+  if ( app_options & APP_OPT_MUX_IPTC )
+    g_object_set (gst_metadata_mux, "iptc", TRUE, NULL);
+  else
+    g_object_set (gst_metadata_mux, "iptc", FALSE, NULL);
+
+  if ( app_options & APP_OPT_MUX_XMP )
+    g_object_set (gst_metadata_mux, "xmp", TRUE, NULL);
+  else
+    g_object_set (gst_metadata_mux, "xmp", FALSE, NULL);
+
+  /* adding and linking elements */
+  gst_bin_add_many (GST_BIN (gst_pipeline), gst_source, gst_metadata_demux,
+      gst_metadata_mux, gst_file_sink, NULL);
+
+  linked =
+      gst_element_link_many (gst_source, gst_metadata_demux, gst_metadata_mux,
+      gst_file_sink, NULL);
+
+  /* now element are owned by pipeline (for videosink we keep a extra ref) */
+  gst_source = gst_metadata_demux = gst_file_sink = NULL;
+  gst_object_ref (gst_metadata_mux);
+
+  if (!linked) {
+    fprintf (stderr, "Elements couldn't be linked\n");
+    ret = -310;
+    goto done;
+  }
+
+  *encode_status = ENC_UNKNOWN;
+
+  /* adding message bus */
+  bus = gst_pipeline_get_bus (GST_PIPELINE (gst_pipeline));
+  gst_bus_add_watch (bus, me_gst_bus_callback_encode, encode_status);
+  gst_object_unref (bus);
+
+done:
+
+  return ret;
+
+}
+
+static int
+me_gst_setup_view_pipeline (const gchar * filename)
+{
+  int ret = 0;
+  GstBus *bus = NULL;
+  gboolean linked;
+
+  me_gst_cleanup_elements ();
+
+  /* create elements */
+  gst_source = gst_element_factory_make ("filesrc", NULL);
+  gst_metadata_demux = gst_element_factory_make ("metadatademux", NULL);
+  /* let's do a dummy stuff to avoid decodebin */
+  if (is_png (filename))
+    gst_image_dec = gst_element_factory_make ("pngdec", NULL);
+  else
+    gst_image_dec = gst_element_factory_make ("jpegdec", NULL);
+  gst_video_scale = gst_element_factory_make ("videoscale", NULL);
+  gst_video_convert = gst_element_factory_make ("ffmpegcolorspace", NULL);
+  gst_video_sink = gst_element_factory_make ("gdkpixbufsink", NULL);
+
+  if (gst_video_sink == NULL) {
+    if (!gst_default_registry_check_feature_version ("gdkpixbufdec", 0, 10, 0))
+      g_warning ("Could not create 'gdkpixbufsink' element");
+    else {
+      g_warning ("Could not create 'gdkpixbufsink' element. "
+          "(May be your gst-plugins-good is too old?)");
+    ret = -400;
+    }
+    goto done;
+  }
+  if (!(gst_source && gst_metadata_demux && gst_image_dec && gst_video_scale
+          && gst_video_convert && gst_video_sink)) {
+    fprintf (stderr, "An element couldn't be created for viewing\n");
+    ret = -400;
+    goto done;
+  }
+
+  /* create gst_pipeline */
+  gst_pipeline = gst_pipeline_new (NULL);
+
+  if (NULL == gst_pipeline) {
+    fprintf (stderr, "Pipeline couldn't be created\n");
+    ret = -405;
+    goto done;
+  }
+
+  /* set elements's properties */
+  g_object_set (gst_source, "location", filename, NULL);
+  g_object_set (gst_metadata_demux, "parse-only", TRUE, NULL);
+
+
+  /* adding and linking elements */
+  gst_bin_add_many (GST_BIN (gst_pipeline), gst_source, gst_metadata_demux,
+      gst_image_dec, gst_video_scale, gst_video_convert, gst_video_sink, NULL);
+
+  linked = gst_element_link_many (gst_source, gst_metadata_demux, gst_image_dec,
+      gst_video_scale, gst_video_convert, gst_video_sink, NULL);
+
+  /* now element are owned by pipeline (for videosink we keep a extra ref) */
+  gst_source = gst_metadata_demux = gst_image_dec = gst_video_scale =
+      gst_video_convert = NULL;
+  gst_object_ref (gst_video_sink);
+
+  if (last_pixbuf) {
+    g_object_unref (last_pixbuf);
+    last_pixbuf = NULL;
+  }
+
+  if (!linked) {
+    fprintf (stderr, "Elements couldn't be linked\n");
+    ret = -410;
+    goto done;
+  }
+
+  /* adding message bus */
+  bus = gst_pipeline_get_bus (GST_PIPELINE (gst_pipeline));
+  gst_bus_add_watch (bus, me_gst_bus_callback_view, NULL);
+  gst_object_unref (bus);
+
+
+done:
+
+  return ret;
+
+}
+
+static void
+process_file(void)
+{
+  /* filename for future usage (title and file name to be created) */
+  me_gst_cleanup_elements ();
+
+  if (tag_list) {
+    gst_tag_list_free (tag_list);
+    tag_list = NULL;
+  }
+
+  /* create pipeline */
+  me_gst_setup_view_pipeline (filename->str);
+
+  gst_element_set_state (gst_pipeline, GST_STATE_PLAYING);
+
+  ui_refresh ();
+
+}
+
+int
+main (int argc, char *argv[])
+{
+  int ret = 0;
+
+  if (argc >= 2) {
+    if (filename)
+      g_string_free (filename, TRUE);
+    filename = g_string_new (argv[1]);
+  }
+
+  gst_init (&argc, &argv);
+  gtk_init (&argc, &argv);
+
+  /* create UI */
+  if ((ret = ui_create ())) {
+    goto done;
+  }
+
+  if (argc >= 2) {
+    process_file();
+  }
+
+  gtk_main ();
+
+done:
+
+  me_gst_cleanup_elements ();
+
+  if (tag_list) {
+    gst_tag_list_free (tag_list);
+    tag_list = NULL;
+  }
+
+  if (filename) {
+    g_string_free (filename, TRUE);
+    filename = NULL;
+  }
+
+  return ret;
+}
diff --git a/tests/icles/metadata_editor.h b/tests/icles/metadata_editor.h
new file mode 100644
index 0000000..fba52ab
--- /dev/null
+++ b/tests/icles/metadata_editor.h
@@ -0,0 +1,103 @@
+/*
+ * GStreamer
+ * Copyright 2007 Edgard Lima <edgard.lima@indt.org.br>
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Alternatively, the contents of this file may be used under the
+ * GNU Lesser General Public License Version 2.1 (the "LGPL"), in
+ * which case the following provisions apply instead of the ones
+ * mentioned above:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __METADATA_EDITOR__
+#define __METADATA_EDITOR__
+
+#include <gtk/gtk.h>
+
+
+gboolean
+on_drawingMain_expose_event (GtkWidget * widget, GdkEventExpose * event,
+    gpointer data);
+
+void
+on_windowMain_delete_event (GtkWidget * widget, GdkEvent * event,
+    gpointer user_data);
+
+void
+on_buttonInsert_clicked (GtkButton * button, gpointer user_data);
+
+void
+on_buttonSaveFile_clicked (GtkButton * button, gpointer user_data);
+
+void
+on_checkbuttonCaptureV4l2_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data);
+
+void
+on_checkbuttonCaptureTest_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data);
+
+void
+on_checkbuttonOptionsDemuxExif_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data);
+
+void
+on_checkbuttonOptionsDemuxIptc_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data);
+
+void
+on_checkbuttonOptionsDemuxXmp_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data);
+
+void
+on_checkbuttonOptionsMuxExif_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data);
+
+void
+on_checkbuttonOptionsMuxIptc_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data);
+
+void
+on_checkbuttonOptionsMuxXmp_toggled (GtkToggleButton * togglebutton,
+    gpointer user_data);
+
+void
+on_buttonOpenFile_clicked (GtkButton * button, gpointer user_data);
+
+void
+on_cell_edited (GtkCellRendererText * renderer, gchar * str_path,
+    gchar * new_text, gpointer user_data);
+
+#endif /* __METADATA_EDITOR__ */
diff --git a/tests/icles/metadata_editor.ui b/tests/icles/metadata_editor.ui
new file mode 100644
index 0000000..3cbe076
--- /dev/null
+++ b/tests/icles/metadata_editor.ui
@@ -0,0 +1,347 @@
+<?xml version="1.0"?>
+<interface>
+  <!-- interface-requires gtk+ 2.8 -->
+  <!-- interface-naming-policy project-wide -->
+  <object class="GtkWindow" id="windowMain">
+    <property name="width_request">800</property>
+    <property name="height_request">600</property>
+    <property name="events">GDK_EXPOSURE_MASK | GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+    <property name="title" translatable="yes">Metadata Editor</property>
+    <signal name="delete_event" handler="on_windowMain_delete_event"/>
+    <child>
+      <object class="GtkVPaned" id="vpanedMain">
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+        <child>
+          <object class="GtkDrawingArea" id="drawingMain">
+            <property name="width_request">200</property>
+            <property name="height_request">100</property>
+            <property name="visible">True</property>
+            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+            <signal name="expose_event" handler="on_drawingMain_expose_event"/>
+          </object>
+          <packing>
+            <property name="resize">False</property>
+            <property name="shrink">False</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkVBox" id="vboxMain">
+            <property name="visible">True</property>
+            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+            <child>
+              <object class="GtkScrolledWindow" id="scrolledwindow">
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                <property name="hscrollbar_policy">automatic</property>
+                <property name="vscrollbar_policy">automatic</property>
+                <child>
+                  <object class="GtkTreeView" id="treeMain">
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                    <property name="rules_hint">True</property>
+                    <property name="enable_search">False</property>
+                    <property name="hover_expand">True</property>
+                  </object>
+                </child>
+              </object>
+              <packing>
+                <property name="position">0</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkVBox" id="vboxEditBnt">
+                <property name="visible">True</property>
+                <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                <child>
+                  <object class="GtkHBox" id="hboxEdit">
+                    <property name="visible">True</property>
+                    <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                    <child>
+                      <object class="GtkEntry" id="entryTag">
+                        <property name="width_request">300</property>
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">0</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkEntry" id="entryValue">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                      </object>
+                      <packing>
+                        <property name="position">1</property>
+                      </packing>
+                    </child>
+                  </object>
+                  <packing>
+                    <property name="position">0</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkHButtonBox" id="hbuttonboxBnt">
+                    <property name="visible">True</property>
+                    <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                    <property name="homogeneous">True</property>
+                    <property name="layout_style">spread</property>
+                    <child>
+                      <object class="GtkButton" id="buttonInsert">
+                        <property name="label" translatable="yes">Insert</property>
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">True</property>
+                        <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                        <signal name="clicked" handler="on_buttonInsert_clicked"/>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">0</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonSaveFile">
+                        <property name="label" translatable="yes">Save File</property>
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">True</property>
+                        <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                        <signal name="clicked" handler="on_buttonSaveFile_clicked"/>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">1</property>
+                      </packing>
+                    </child>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">False</property>
+                    <property name="position">1</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkHBox" id="hboxOptions">
+                    <property name="visible">True</property>
+                    <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                    <child>
+                      <object class="GtkVBox" id="vboxCaptureOptions">
+                        <property name="visible">True</property>
+                        <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                        <child>
+                          <object class="GtkCheckButton" id="checkbuttonCaptureV4l2">
+                            <property name="label" translatable="yes">Capture image from camera</property>
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="receives_default">False</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <property name="draw_indicator">True</property>
+                            <signal name="toggled" handler="on_checkbuttonCaptureV4l2_toggled"/>
+                          </object>
+                          <packing>
+                            <property name="fill">False</property>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkCheckButton" id="checkbuttonCaptureTest">
+                            <property name="label" translatable="yes">Capture image from videotestsrc</property>
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="receives_default">False</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <property name="draw_indicator">True</property>
+                            <signal name="toggled" handler="on_checkbuttonCaptureTest_toggled"/>
+                          </object>
+                          <packing>
+                            <property name="fill">False</property>
+                            <property name="position">1</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkButton" id="buttonOpenFile">
+                            <property name="label" translatable="yes">Open File...</property>
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="receives_default">True</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <signal name="clicked" handler="on_buttonOpenFile_clicked"/>
+                          </object>
+                          <packing>
+                            <property name="position">2</property>
+                          </packing>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="position">0</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkVBox" id="vboxOptionsDemux">
+                        <property name="visible">True</property>
+                        <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                        <child>
+                          <object class="GtkLabel" id="labelDemux">
+                            <property name="visible">True</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <property name="xalign">0</property>
+                            <property name="label" translatable="yes">Demux options:</property>
+                          </object>
+                          <packing>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkCheckButton" id="checkbuttonOptionsDemuxExif">
+                            <property name="label" translatable="yes">exif</property>
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="receives_default">False</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <property name="active">True</property>
+                            <property name="draw_indicator">True</property>
+                            <signal name="toggled" handler="on_checkbuttonOptionsDemuxExif_toggled"/>
+                          </object>
+                          <packing>
+                            <property name="fill">False</property>
+                            <property name="position">1</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkCheckButton" id="checkbuttonOptionsDemuxIptc">
+                            <property name="label" translatable="yes">iptc</property>
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="receives_default">False</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <property name="active">True</property>
+                            <property name="draw_indicator">True</property>
+                            <signal name="toggled" handler="on_checkbuttonOptionsDemuxIptc_toggled"/>
+                          </object>
+                          <packing>
+                            <property name="fill">False</property>
+                            <property name="position">2</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkCheckButton" id="checkbuttonOptionsDemuxXmp">
+                            <property name="label" translatable="yes">xmp</property>
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="receives_default">False</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <property name="active">True</property>
+                            <property name="draw_indicator">True</property>
+                            <signal name="toggled" handler="on_checkbuttonOptionsDemuxXmp_toggled"/>
+                          </object>
+                          <packing>
+                            <property name="fill">False</property>
+                            <property name="position">3</property>
+                          </packing>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="position">1</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkVBox" id="vboxOptionsMux">
+                        <property name="visible">True</property>
+                        <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                        <child>
+                          <object class="GtkLabel" id="labelMux">
+                            <property name="visible">True</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <property name="xalign">0</property>
+                            <property name="label" translatable="yes">Mux options:</property>
+                          </object>
+                          <packing>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkCheckButton" id="checkbuttonOptionsMuxExif">
+                            <property name="label" translatable="yes">exif</property>
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="receives_default">False</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <property name="active">True</property>
+                            <property name="draw_indicator">True</property>
+                            <signal name="toggled" handler="on_checkbuttonOptionsMuxExif_toggled"/>
+                          </object>
+                          <packing>
+                            <property name="fill">False</property>
+                            <property name="position">1</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkCheckButton" id="checkbuttonOptionsMuxIptc">
+                            <property name="label" translatable="yes">iptc</property>
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="receives_default">False</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <property name="active">True</property>
+                            <property name="draw_indicator">True</property>
+                            <signal name="toggled" handler="on_checkbuttonOptionsMuxIptc_toggled"/>
+                          </object>
+                          <packing>
+                            <property name="fill">False</property>
+                            <property name="position">2</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkCheckButton" id="checkbuttonOptionsMuxXmp">
+                            <property name="label" translatable="yes">xmp</property>
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="receives_default">False</property>
+                            <property name="events">GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</property>
+                            <property name="active">True</property>
+                            <property name="draw_indicator">True</property>
+                            <signal name="toggled" handler="on_checkbuttonOptionsMuxXmp_toggled"/>
+                          </object>
+                          <packing>
+                            <property name="fill">False</property>
+                            <property name="position">3</property>
+                          </packing>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="position">2</property>
+                      </packing>
+                    </child>
+                  </object>
+                  <packing>
+                    <property name="position">2</property>
+                  </packing>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">False</property>
+                <property name="position">1</property>
+              </packing>
+            </child>
+          </object>
+          <packing>
+            <property name="resize">True</property>
+            <property name="shrink">False</property>
+          </packing>
+        </child>
+      </object>
+    </child>
+  </object>
+</interface>
-- 
1.8.1.4

