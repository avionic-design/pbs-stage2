diff --git a/ext/soup/gstsouphttpsrc.c b/ext/soup/gstsouphttpsrc.c
index 94eb98a..3e5efb2 100644
--- a/ext/soup/gstsouphttpsrc.c
+++ b/ext/soup/gstsouphttpsrc.c
@@ -17,7 +17,7 @@
  *
  * This plugin reads data from a remote location specified by a URI.
  * Supported protocols are 'http', 'https'.
- * 
+ *
  * An HTTP proxy must be specified by its URL.
  * If the "http_proxy" environment variable is set, its value is used.
  * If built with libsoup's GNOME integration features, the GNOME proxy
@@ -315,6 +315,8 @@ gst_soup_http_src_class_init (GstSoupHTTPSrcClass * klass)
 static void
 gst_soup_http_src_reset (GstSoupHTTPSrc * src)
 {
+  GST_DEBUG_OBJECT (src, "reset");
+
   src->interrupted = FALSE;
   src->retry = FALSE;
   src->have_size = FALSE;
@@ -564,6 +566,7 @@ gst_soup_http_src_unicodify (const gchar * str)
 static void
 gst_soup_http_src_cancel_message (GstSoupHTTPSrc * src)
 {
+  GST_DEBUG_OBJECT (src, "cancel message");
   if (src->msg != NULL) {
     src->session_io_status = GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_CANCELLED;
     soup_session_cancel_message (src->session, src->msg, SOUP_STATUS_CANCELLED);
@@ -575,6 +578,7 @@ gst_soup_http_src_cancel_message (GstSoupHTTPSrc * src)
 static void
 gst_soup_http_src_queue_message (GstSoupHTTPSrc * src)
 {
+  GST_DEBUG_OBJECT (src, "queue message");
   soup_session_queue_message (src->session, src->msg,
       (SoupSessionCallback) gst_soup_http_src_response_cb, src);
   src->session_io_status = GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_QUEUED;
@@ -689,6 +693,7 @@ gst_soup_http_src_session_pause_message (GstSoupHTTPSrc * src)
 static void
 gst_soup_http_src_session_close (GstSoupHTTPSrc * src)
 {
+  GST_DEBUG_OBJECT (src, "close session");
   if (src->session) {
     soup_session_abort (src->session);  /* This unrefs the message. */
     g_object_unref (src->session);
@@ -733,8 +738,10 @@ gst_soup_http_src_got_headers_cb (SoupMessage * msg, GstSoupHTTPSrc * src)
   soup_message_headers_foreach (msg->response_headers,
       gst_soup_http_src_headers_foreach, src);
 
-  if (msg->status_code == 407 && src->proxy_id && src->proxy_pw)
+  if (msg->status_code == 407 && src->proxy_id && src->proxy_pw) {
+    GST_DEBUG_OBJECT (src, "%u: Proxy authentication required\n", msg->status_code);
     return;
+  }
 
   if (src->automatic_redirect && SOUP_STATUS_IS_REDIRECTION (msg->status_code)) {
     GST_DEBUG_OBJECT (src, "%u redirect to \"%s\"", msg->status_code,
@@ -742,8 +749,10 @@ gst_soup_http_src_got_headers_cb (SoupMessage * msg, GstSoupHTTPSrc * src)
     return;
   }
 
-  if (msg->status_code == SOUP_STATUS_UNAUTHORIZED)
+  if (msg->status_code == SOUP_STATUS_UNAUTHORIZED) {
+    GST_DEBUG_OBJECT (src, "%u: Unauthorized\n", msg->status_code);
     return;
+  }
 
   src->session_io_status = GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_RUNNING;
 
@@ -887,6 +896,7 @@ gst_soup_http_src_got_body_cb (SoupMessage * msg, GstSoupHTTPSrc * src)
   if (G_UNLIKELY (src->session_io_status !=
           GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_RUNNING)) {
     /* Probably a redirect. */
+    GST_DEBUG_OBJECT (src, "Probably a redirect.");
     return;
   }
   GST_DEBUG_OBJECT (src, "got body");
@@ -921,7 +931,7 @@ gst_soup_http_src_finished_cb (SoupMessage * msg, GstSoupHTTPSrc * src)
     /* FIXME: reason_phrase is not translated, add proper error message */
     GST_ELEMENT_ERROR (src, RESOURCE, NOT_FOUND,
         ("%s", msg->reason_phrase),
-        ("libsoup status code %d", msg->status_code));
+        ("libsoup status code %u", msg->status_code));
   }
   if (src->loop)
     g_main_loop_quit (src->loop);
@@ -971,9 +981,8 @@ gst_soup_http_src_chunk_allocator (SoupMessage * msg, gsize max_len,
     length = MIN (basesrc->blocksize, max_len);
   else
     length = basesrc->blocksize;
-  GST_DEBUG_OBJECT (src, "alloc %" G_GSIZE_FORMAT " bytes <= %" G_GSIZE_FORMAT,
-      length, max_len);
-
+//  GST_DEBUG_OBJECT (src, "alloc %" G_GSIZE_FORMAT " bytes <= %" G_GSIZE_FORMAT,
+//      length, max_len);
 
   rc = gst_pad_alloc_buffer (GST_BASE_SRC_PAD (basesrc),
       GST_BUFFER_OFFSET_NONE, length,
@@ -1007,11 +1016,12 @@ gst_soup_http_src_got_chunk_cb (SoupMessage * msg, SoupBuffer * chunk,
   if (G_UNLIKELY (src->session_io_status !=
           GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_RUNNING)) {
     /* Probably a redirect. */
+    GST_DEBUG_OBJECT (src, "Probably a redirect.");
     return;
   }
   basesrc = GST_BASE_SRC_CAST (src);
-  GST_DEBUG_OBJECT (src, "got chunk of %" G_GSIZE_FORMAT " bytes",
-      chunk->length);
+//  GST_DEBUG_OBJECT (src, "got chunk of %" G_GSIZE_FORMAT " bytes",
+//      chunk->length);
 
   /* Extract the GstBuffer from the SoupBuffer and set its fields. */
   *src->outbuf = GST_BUFFER_CAST (soup_buffer_get_owner (chunk));
@@ -1040,7 +1050,7 @@ gst_soup_http_src_response_cb (SoupSession * session, SoupMessage * msg,
     GstSoupHTTPSrc * src)
 {
   if (G_UNLIKELY (msg != src->msg)) {
-    GST_DEBUG_OBJECT (src, "got response %d: %s, but not for current message",
+    GST_DEBUG_OBJECT (src, "got response %u: %s, but not for current message",
         msg->status_code, msg->reason_phrase);
     return;
   }
@@ -1048,9 +1058,10 @@ gst_soup_http_src_response_cb (SoupSession * session, SoupMessage * msg,
           GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_RUNNING)
       && SOUP_STATUS_IS_REDIRECTION (msg->status_code)) {
     /* Ignore redirections. */
+    GST_DEBUG_OBJECT (src, "Ignore redirections.");
     return;
   }
-  GST_DEBUG_OBJECT (src, "got response %d: %s", msg->status_code,
+  GST_DEBUG_OBJECT (src, "got response %u: %s", msg->status_code,
       msg->reason_phrase);
   if (src->session_io_status == GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_RUNNING &&
       src->read_position > 0) {
@@ -1066,7 +1077,7 @@ gst_soup_http_src_response_cb (SoupSession * session, SoupMessage * msg,
 
 #define SOUP_HTTP_SRC_ERROR(src,soup_msg,cat,code,error_message)     \
   GST_ELEMENT_ERROR ((src), cat, code, ("%s", error_message),        \
-      ("%s (%d), URL: %s", (soup_msg)->reason_phrase,                \
+      ("%s (%u), URL: %s", (soup_msg)->reason_phrase,                \
           (soup_msg)->status_code, (src)->location));
 
 static void
@@ -1104,6 +1115,11 @@ gst_soup_http_src_parse_status (SoupMessage * msg, GstSoupHTTPSrc * src)
         break;
       case SOUP_STATUS_CANCELLED:
         /* No error message when interrupted by program. */
+        GST_DEBUG_OBJECT (src, "SOUP_STATUS_CANCELLED\n");
+        break;
+
+      default:
+        GST_DEBUG_OBJECT (src, "%u: not handled\n", msg->status_code);
         break;
     }
   } else if (SOUP_STATUS_IS_CLIENT_ERROR (msg->status_code) ||
@@ -1115,9 +1131,12 @@ gst_soup_http_src_parse_status (SoupMessage * msg, GstSoupHTTPSrc * src)
      * FIXME: error code (OPEN_READ vs. READ) should depend on http status? */
     GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ,
         ("%s", msg->reason_phrase),
-        ("%s (%d), URL: %s", msg->reason_phrase, msg->status_code,
+        ("%s (%u), URL: %s", msg->reason_phrase, msg->status_code,
             src->location));
     src->ret = GST_FLOW_ERROR;
+  } else {
+    GST_DEBUG_OBJECT (src, "%u: is not transparent, client, server"
+                      " or redirection error\n", msg->status_code);
   }
 }
 
@@ -1145,8 +1164,11 @@ gst_soup_http_src_build_message (GstSoupHTTPSrc * src)
           *cookie);
     }
   }
-  soup_message_headers_append (src->msg->request_headers,
-      "transferMode.dlna.org", "Streaming");
+// see commit deb15d7bce649f06defc8aea2effae043e3efeb0
+//            Doup: Drop transferMode.dlna.org header
+//
+//  soup_message_headers_append (src->msg->request_headers,
+//      "transferMode.dlna.org", "Streaming");
   src->retry = FALSE;
 
   g_signal_connect (src->msg, "got_headers",
@@ -1193,10 +1215,12 @@ gst_soup_http_src_create (GstPushSrc * psrc, GstBuffer ** outbuf)
       gst_soup_http_src_cancel_message (src);
     }
   }
-  if (!src->msg)
-    if (!gst_soup_http_src_build_message (src))
+  if (!src->msg) {
+    if (!gst_soup_http_src_build_message (src)) {
+      GST_DEBUG_OBJECT (src, "failed to build message");
       return GST_FLOW_ERROR;
-
+    }
+  }
   src->ret = GST_FLOW_CUSTOM_ERROR;
   src->outbuf = outbuf;
   do {
@@ -1222,11 +1246,13 @@ gst_soup_http_src_create (GstPushSrc * psrc, GstBuffer ** outbuf)
         gst_soup_http_src_queue_message (src);
         break;
       case GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_QUEUED:
+        GST_DEBUG_OBJECT (src, "Status: queued");
         break;
       case GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_RUNNING:
         gst_soup_http_src_session_unpause_message (src);
         break;
       case GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_CANCELLED:
+        GST_DEBUG_OBJECT (src, "Status: canceled");
         /* Impossible. */
         break;
     }
@@ -1290,6 +1316,13 @@ gst_soup_http_src_start (GstBaseSrc * bsrc)
 
   g_signal_connect (src->session, "authenticate",
       G_CALLBACK (gst_soup_http_src_authenticate_cb), src);
+
+  {
+    SoupLogger *logger = soup_logger_new (SOUP_LOGGER_LOG_BODY, -1);
+    soup_session_add_feature (src->session, SOUP_SESSION_FEATURE (logger));
+    g_object_unref (logger);
+  }
+
   return TRUE;
 }
 
