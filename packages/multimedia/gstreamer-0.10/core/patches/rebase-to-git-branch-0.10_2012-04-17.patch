diff --git a/autogen.sh b/autogen.sh
index c0cd19e..b2e9ee4 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -1,6 +1,12 @@
 #!/bin/sh
 # Run this to generate all the initial makefiles, etc.
 
+test -n "$srcdir" || srcdir=`dirname "$0"`
+test -n "$srcdir" || srcdir=.
+
+olddir=`pwd`
+cd "$srcdir"
+
 DIE=0
 package=gstreamer
 srcfile=gst/gst.c
@@ -29,7 +35,9 @@ then
     ln -s ../../common/hooks/pre-commit.hook .git/hooks/pre-commit
 fi
 
-
+# GNU gettext automake support doesn't get along with git.
+# https://bugzilla.gnome.org/show_bug.cgi?id=661128
+touch -t 200001010000 po/gstreamer-0.10.pot
 
 CONFIGURE_DEF_OPT='--enable-maintainer-mode --enable-failing-tests --enable-poisoning --enable-gtk-doc --enable-docbook'
 
@@ -56,7 +64,7 @@ autoheader_check || DIE=1
 die_check $DIE
 
 # if no arguments specified then this will be printed
-if test -z "$*"; then
+if test -z "$*" && test -z "$NOCONFIGURE"; then
   echo "+ checking for autogen.sh options"
   echo "  This autogen script will automatically run ./configure as:"
   echo "  ./configure $CONFIGURE_DEF_OPT"
@@ -97,13 +105,15 @@ test -n "$NOCONFIGURE" && {
   exit 0
 }
 
+cd "$olddir"
+
 echo "+ running configure ... "
 test ! -z "$CONFIGURE_DEF_OPT" && echo "  ./configure default flags: $CONFIGURE_DEF_OPT"
 test ! -z "$CONFIGURE_EXT_OPT" && echo "  ./configure external flags: $CONFIGURE_EXT_OPT"
 echo
 
-echo ./configure $CONFIGURE_DEF_OPT $CONFIGURE_EXT_OPT
-./configure $CONFIGURE_DEF_OPT $CONFIGURE_EXT_OPT || {
+echo "$srcdir/configure" $CONFIGURE_DEF_OPT $CONFIGURE_EXT_OPT
+"$srcdir/configure" $CONFIGURE_DEF_OPT $CONFIGURE_EXT_OPT || {
         echo "  configure failed"
         exit 1
 }
diff --git a/configure.ac b/configure.ac
index 57c54da..8a67c36 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3,7 +3,7 @@ AC_PREREQ(2.60)
 dnl initialize autoconf
 dnl when going to/from release please set the nano (fourth number) right !
 dnl releases only do Wall, git and prerelease does Werror too
-AC_INIT(GStreamer, 0.10.36,
+AC_INIT(GStreamer, 0.10.36.1,
     http://bugzilla.gnome.org/enter_bug.cgi?product=GStreamer,
     gstreamer)
 AG_GST_INIT
@@ -48,7 +48,7 @@ dnl - interfaces added/removed/changed -> increment CURRENT, REVISION = 0
 dnl - interfaces added -> increment AGE
 dnl - interfaces removed -> AGE = 0
 dnl sets GST_LT_LDFLAGS
-AS_LIBTOOL(GST, 30, 0, 30)
+AS_LIBTOOL(GST, 31, 0, 31)
 
 dnl FIXME: this macro doesn't actually work;
 dnl the generated libtool script has no support for the listed tags.
@@ -646,7 +648,7 @@ if test "x${GST_DISABLE_GST_DEBUG}" = "xyes"; then
 fi
 
 dnl define an ERROR_CFLAGS Makefile variable
-AG_GST_SET_ERROR_CFLAGS($GST_GIT, [-Wmissing-declarations -Wmissing-prototypes -Wredundant-decls -Wundef -Wwrite-strings -Wformat-nonliteral -Wformat-security -Wold-style-definition -Winit-self -Wmissing-include-dirs -Waddress -Waggregate-return -Wno-multichar -Wnested-externs $NO_WARNINGS])
+AG_GST_SET_ERROR_CFLAGS($FATAL_WARNINGS, [-Wmissing-declarations -Wmissing-prototypes -Wredundant-decls -Wundef -Wwrite-strings -Wformat-nonliteral -Wformat-security -Wold-style-definition -Winit-self -Wmissing-include-dirs -Waddress -Waggregate-return -Wno-multichar -Wnested-externs $NO_WARNINGS])
 
 dnl define correct level for debugging messages
 AG_GST_SET_LEVEL_DEFAULT($GST_GIT)
diff --git a/docs/design/Makefile.am b/docs/design/Makefile.am
index b313c9d..087a3b0 100644
--- a/docs/design/Makefile.am
+++ b/docs/design/Makefile.am
@@ -44,6 +44,7 @@ EXTRA_DIST = \
 	part-stream-status.txt \
 	part-streams.txt \
 	part-synchronisation.txt \
+	part-toc.txt \
 	part-TODO.txt \
 	part-trickmodes.txt
 
diff --git a/docs/design/part-toc.txt b/docs/design/part-toc.txt
new file mode 100644
index 0000000..73231da
--- /dev/null
+++ b/docs/design/part-toc.txt
@@ -0,0 +1,89 @@
+Implementing GstToc support in GStreamer elements
+
+1. General info about GstToc structure
+
+GstToc introduces a general way to handle chapters within multimedia
+formats. GstToc can be represented as tree structure with arbitrary
+hierarchy. Tree item can be either of two types: chapter or edition.
+Chapter acts like a part of the media data, for example audio track
+in CUE sheet, or part of the movie. Edition acts like some kind of
+alternative way to process media content, for example DVD angles.
+GstToc has one limitation on tree structure: on the same level of
+hierarchy there couldn't be items of different type, i.e. you shouldn't
+have editions and chapters mixed together. Here is an example of right TOC:
+
+  -------  TOC  -------
+           /  \
+   edition1    edition2
+   |           |
+   -chapter1   -chapter3
+   -chapter2       
+
+Here are two editions, the first contains two chapters, and the second
+has only one chapter. And here is an example of invalid TOC:
+
+  -------  TOC  -------
+           /  \
+   edition1    chapter1
+   |                 
+   -chapter1
+   -chapter2    
+ 
+Here you have edition1 and chapter1 mixed on the same level of hierarchy,
+and such TOC will be considered broken.
+
+GstToc has 'entries' field of GList type which consists of children items.
+Each item is of type GstTocEntry. Also GstToc has list of tags and
+GstStructure called 'info'. Please, use GstToc.info and GstTocEntry.info
+fields this way: create a GstStructure, put all info related to your element
+there and put this structure into the 'info' field under the name of your
+element. Some fields in the 'info' structure can be used for internal
+purposes, so you should use it in the way described above to not to
+overwrite already existent fields.
+
+Let's look at GstTocEntry a bit closer. One of the most important fields
+is 'uid', which must be unique for each item within the TOC. This is used
+to identify each item inside TOC, especially when element receives TOC
+select event with UID to seek on. Field 'subentries' of type GList contains
+children items of type GstTocEntry. Thus you can achieve arbitrary hierarchy
+level. Field 'type' can be either GST_TOC_ENTRY_TYPE_CHAPTER or
+GST_TOC_ENTRY_TYPE_EDITION which corresponds to chapter or edition type of
+item respectively. Field 'pads' of type GList contains list of GStreamer
+pads related to the item. It can be used for example to link a TOC with
+specific pad. Field 'tags' is a list of tags related to the item. And field
+'info' is similar to GstToc.info described above.
+
+So, a little more about managing GstToc. Use gst_toc_new() and gst_toc_free()
+to create/free it. GstTocEntry can be created using gst_toc_entry_new() and
+gst_toc_entry_new_with_pad(). The latter method used to create GstTocEntry
+linked to particular pad. While building GstToc you can set start and stop
+timestamps for each item using gst_toc_entry_set_start_stop().
+The best way to process already created GstToc is to recursively go through
+the 'entries' and 'subentries' fields.
+
+2. Working with GstQuery
+
+GstQuery with GstToc can be created using gst_query_new_toc(). Use
+gst_query_set_toc() to set TOC into the query and parse it with
+gst_query_parse_toc(). The 'extend_uid' parameter (0 for root level) in two
+last methods should be used for TOC extending: get GstTocEntry with
+gst_toc_find_entry() by given UID and use it to add your own chapters/editions.
+The common action on such query is to set TOC for it.
+
+3. Working with GstMessage
+
+GstMessage with GstToc can be created using gst_message_new_toc() and parsed
+with gst_message_parse_toc(). The 'updated' parameter in these methods indicates
+whether the TOC was just discovered (set to false) or TOC was already found and
+have been updated (set to true). The common usage for such message is to post it
+to pipeline in case you have discovered TOC data within your element.
+
+4. Working with GstEvent
+
+GstToc supports select event through GstEvent infrastructure. The idea is the
+following: when you receive TOC select event, parse it with
+gst_event_parse_toc_select() and seek stream (if it is not streamable) for
+specified TOC UID (you can use gst_toc_find_entry() to find entry in TOC by UID).
+To create TOC select event use gst_event_new_toc_select(). The common action on
+such event is to seek to specified UID within your element. 
+
diff --git a/docs/faq/general.xml b/docs/faq/general.xml
index c6ccb6a..e85bec0 100644
--- a/docs/faq/general.xml
+++ b/docs/faq/general.xml
@@ -99,7 +99,7 @@ What are the exact licensing terms for GStreamer and its plugins ?
       <answer>
         <para>
 All of GStreamer, including our own plugin code, is licensed under the 
-<ulink url="http://www.gnu.org/licenses/lgpl.html">GNU LGPL</ulink> license.
+<ulink url="http://www.gnu.org/licenses/lgpl-2.1.html">GNU LGPL 2.1</ulink> license.
 Some of the libraries we use for some of the plugins are however under the 
 GPL, which means that those plugins can not be used by a non-GPL-compatible 
 application. 
diff --git a/docs/gst/gstreamer-docs.sgml b/docs/gst/gstreamer-docs.sgml
index ca969a1..deda41e 100644
--- a/docs/gst/gstreamer-docs.sgml
+++ b/docs/gst/gstreamer-docs.sgml
@@ -99,6 +99,8 @@ Windows.  It is released under the GNU Library General Public License
     <xi:include href="xml/gsttagsetter.xml" />
     <xi:include href="xml/gsttask.xml" />
     <xi:include href="xml/gsttaskpool.xml" />
+    <xi:include href="xml/gsttoc.xml" />
+    <xi:include href="xml/gsttocsetter.xml" />
     <xi:include href="xml/gsttypefind.xml" />
     <xi:include href="xml/gsttypefindfactory.xml" />
     <xi:include href="xml/gsturihandler.xml" />
diff --git a/docs/gst/gstreamer-sections.txt b/docs/gst/gstreamer-sections.txt
index 5fc6ec6..c52d5f1 100644
--- a/docs/gst/gstreamer-sections.txt
+++ b/docs/gst/gstreamer-sections.txt
@@ -847,6 +847,12 @@ gst_event_parse_step
 
 gst_event_new_sink_message
 gst_event_parse_sink_message
+
+gst_event_new_toc
+gst_event_parse_toc
+
+gst_event_new_toc_select
+gst_event_parse_toc_select
 <SUBSECTION Standard>
 GstEventClass
 GST_EVENT
@@ -1294,6 +1300,8 @@ gst_message_set_qos_stats
 gst_message_parse_qos
 gst_message_parse_qos_values
 gst_message_parse_qos_stats
+gst_message_new_toc
+gst_message_parse_toc
 
 GstStructureChangeType
 gst_message_new_structure_change
@@ -2078,6 +2086,10 @@ gst_query_parse_nth_buffering_range
 gst_query_new_uri
 gst_query_parse_uri
 gst_query_set_uri
+
+gst_query_new_toc
+gst_query_parse_toc
+gst_query_set_toc
 <SUBSECTION Standard>
 GstQueryClass
 GST_QUERY
@@ -2329,6 +2341,7 @@ GST_TAG_ALBUM_GAIN
 GST_TAG_ALBUM_PEAK
 GST_TAG_REFERENCE_LEVEL
 GST_TAG_LANGUAGE_CODE
+GST_TAG_LANGUAGE_NAME
 GST_TAG_IMAGE
 GST_TAG_PREVIEW_IMAGE
 GST_TAG_ATTACHMENT
@@ -2537,6 +2550,51 @@ gst_task_state_get_type
 
 
 <SECTION>
+<FILE>gsttoc</FILE>
+<TITLE>GstToc</TITLE>
+GstToc
+GstTocEntry
+GstTocEntryType
+gst_toc_entry_new
+gst_toc_entry_new_with_pad
+gst_toc_entry_free
+gst_toc_new
+gst_toc_free
+gst_toc_entry_copy
+gst_toc_copy
+gst_toc_find_entry
+gst_toc_entry_get_start_stop
+gst_toc_entry_set_start_stop
+<SUBSECTION Standard>
+GST_TYPE_TOC_ENTRY_TYPE
+<SUBSECTION Private>
+gst_toc_entry_type_get_type
+</SECTION>
+
+
+<SECTION>
+<FILE>gsttocsetter</FILE>
+<TITLE>GstTocSetter</TITLE>
+GstTocSetter
+GstTocSetterIFace
+gst_toc_setter_get_toc
+gst_toc_setter_get_toc_copy
+gst_toc_setter_reset_toc
+gst_toc_setter_set_toc
+gst_toc_setter_get_toc_entry
+gst_toc_setter_get_toc_entry_copy
+gst_toc_setter_add_toc_entry
+<SUBSECTION Standard>
+GST_IS_TOC_SETTER
+GST_TOC_SETTER
+GST_TOC_SETTER_GET_IFACE
+GST_TYPE_TOC_SETTER
+<SUBSECTION Private>
+gst_toc_setter_get_type
+</SECTION>
+
+
+<SECTION>
 <FILE>gsttrace</FILE>
 <TITLE>GstTrace</TITLE>
 GstTrace
diff --git a/docs/plugins/inspect/plugin-coreelements.xml b/docs/plugins/inspect/plugin-coreelements.xml
index fcd61ff..f67a60b 100644
--- a/docs/plugins/inspect/plugin-coreelements.xml
+++ b/docs/plugins/inspect/plugin-coreelements.xml
@@ -3,10 +3,10 @@
   <description>standard GStreamer elements</description>
   <filename>../../plugins/elements/.libs/libgstcoreelements.so</filename>
   <basename>libgstcoreelements.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gstreamer</source>
-  <package>GStreamer source release</package>
+  <package>GStreamer git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-coreindexers.xml b/docs/plugins/inspect/plugin-coreindexers.xml
index 9c43c63..8356f0c 100644
--- a/docs/plugins/inspect/plugin-coreindexers.xml
+++ b/docs/plugins/inspect/plugin-coreindexers.xml
@@ -3,10 +3,10 @@
   <description>GStreamer core indexers</description>
   <filename>../../plugins/indexers/.libs/libgstcoreindexers.so</filename>
   <basename>libgstcoreindexers.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gstreamer</source>
-  <package>GStreamer source release</package>
+  <package>GStreamer git</package>
   <origin>Unknown package origin</origin>
   <elements>
   </elements>
diff --git a/gst/Makefile.am b/gst/Makefile.am
index 60d4b11..0da40a0 100644
--- a/gst/Makefile.am
+++ b/gst/Makefile.am
@@ -98,6 +98,8 @@ libgstreamer_@GST_MAJORMINOR@_la_SOURCES = \
 	gsttagsetter.c		\
 	gsttask.c		\
 	gsttaskpool.c		\
+	gsttoc.c		\
+	gsttocsetter.c		\
 	$(GST_TRACE_SRC)	\
 	gsttypefind.c		\
 	gsttypefindfactory.c	\
@@ -188,6 +190,8 @@ gst_headers =			\
 	gsttagsetter.h		\
 	gsttask.h		\
 	gsttaskpool.h		\
+	gsttoc.h		\
+	gsttocsetter.h		\
 	gsttrace.h		\
 	gsttypefind.h		\
 	gsttypefindfactory.h	\
diff --git a/gst/gst.c b/gst/gst.c
index ff7f250..4875b13 100644
--- a/gst/gst.c
+++ b/gst/gst.c
@@ -756,6 +756,7 @@ init_post (GOptionContext * context, GOptionGroup * group, gpointer data,
   g_type_class_ref (gst_search_mode_get_type ());
   g_type_class_ref (gst_progress_type_get_type ());
   g_type_class_ref (gst_caps_intersect_mode_get_type ());
+  g_type_class_ref (gst_toc_entry_type_get_type ());
 
   gst_structure_get_type ();
   _gst_value_initialize ();
@@ -767,6 +768,7 @@ init_post (GOptionContext * context, GOptionGroup * group, gpointer data,
   gst_buffer_list_iterator_get_type ();
   _gst_message_initialize ();
   _gst_tag_initialize ();
+  priv_gst_toc_initialize ();
   gst_parse_context_get_type ();
 
   _gst_plugin_initialize ();
@@ -913,7 +915,7 @@ parse_one_option (gint opt, const gchar * arg, GError ** err)
       GstDebugLevel tmp = GST_LEVEL_NONE;
 
       tmp = (GstDebugLevel) strtol (arg, NULL, 0);
-      if (tmp >= 0 && tmp < GST_LEVEL_COUNT) {
+      if (((guint) tmp) < GST_LEVEL_COUNT) {
         gst_debug_set_default_threshold (tmp);
       }
       break;
@@ -1124,6 +1126,7 @@ gst_deinit (void)
   g_type_class_unref (g_type_class_peek (gst_param_spec_fraction_get_type ()));
   g_type_class_unref (g_type_class_peek (gst_progress_type_get_type ()));
   g_type_class_unref (g_type_class_peek (gst_caps_intersect_mode_get_type ()));
+  g_type_class_unref (g_type_class_peek (gst_toc_entry_type_get_type ()));
 
   gst_deinitialized = TRUE;
   GST_INFO ("deinitialized GStreamer");
diff --git a/gst/gst.h b/gst/gst.h
index 35ef290..422cbfb 100644
--- a/gst/gst.h
+++ b/gst/gst.h
@@ -68,6 +68,8 @@
 #include <gst/gsttagsetter.h>
 #include <gst/gsttask.h>
 #include <gst/gsttaskpool.h>
+#include <gst/gsttoc.h>
+#include <gst/gsttocsetter.h>
 #include <gst/gsttrace.h>
 #include <gst/gsttypefind.h>
 #include <gst/gsttypefindfactory.h>
diff --git a/gst/gst_private.h b/gst/gst_private.h
index 6bd6725..31f2580 100644
--- a/gst/gst_private.h
+++ b/gst/gst_private.h
@@ -54,6 +54,9 @@ extern const char             g_log_domain_gstreamer[];
 /* for GstElement */
 #include "gstelement.h"
 
+/* for GstToc */
+#include "gsttoc.h"
+
 G_BEGIN_DECLS
 
 /* used by gstparse.c and grammar.y */
@@ -109,6 +112,17 @@ void  _gst_query_initialize (void);
 void  _gst_tag_initialize (void);
 void  _gst_value_initialize (void);
 
+void  priv_gst_toc_initialize (void);
+
+/* TOC functions */
+/* These functions are used to parse TOC messages, events and queries */
+GstToc*        priv_gst_toc_from_structure (const GstStructure *toc);
+GstStructure*  priv_gst_toc_to_structure (const GstToc *toc);
+gboolean       priv_gst_toc_structure_get_updated (const GstStructure * toc);
+void           priv_gst_toc_structure_set_updated (GstStructure * toc, gboolean updated);
+gchar*         priv_gst_toc_structure_get_extend_uid (const GstStructure * toc);
+void           priv_gst_toc_structure_set_extend_uid (GstStructure * toc, const gchar * extend_uid);
+
 /* Private registry functions */
 gboolean _priv_gst_registry_remove_cache_plugins (GstRegistry *registry);
 void _priv_gst_registry_cleanup (void);
@@ -141,7 +155,7 @@ gint priv_gst_date_time_compare (gconstpointer dt1, gconstpointer dt2);
 
 #ifndef GST_DISABLE_REGISTRY
 /* Secret variable to initialise gst without registry cache */
-extern gboolean _gst_disable_registry_cache;
+GST_EXPORT gboolean _gst_disable_registry_cache;
 #endif
 
 /* provide inline gst_g_value_get_foo_unchecked(), used in gststructure.c */
diff --git a/gst/gstatomicqueue.c b/gst/gstatomicqueue.c
index 5b21be6..e7bfcca 100644
--- a/gst/gstatomicqueue.c
+++ b/gst/gstatomicqueue.c
@@ -56,7 +56,8 @@ struct _GstAQueueMem
   gint size;
   gpointer *array;
   volatile gint head;
-  volatile gint tail;
+  volatile gint tail_write;
+  volatile gint tail_read;
   GstAQueueMem *next;
   GstAQueueMem *free;
 };
@@ -83,7 +84,8 @@ new_queue_mem (guint size, gint pos)
   mem->size = clp2 (MAX (size, 16)) - 1;
   mem->array = g_new0 (gpointer, mem->size + 1);
   mem->head = pos;
-  mem->tail = pos;
+  mem->tail_write = pos;
+  mem->tail_read = pos;
   mem->next = NULL;
   mem->free = NULL;
 
@@ -234,7 +236,7 @@ gst_atomic_queue_peek (GstAtomicQueue * queue)
     head_mem = g_atomic_pointer_get (&queue->head_mem);
 
     head = g_atomic_int_get (&head_mem->head);
-    tail = g_atomic_int_get (&head_mem->tail);
+    tail = g_atomic_int_get (&head_mem->tail_read);
     size = head_mem->size;
 
     /* when we are not empty, we can continue */
@@ -291,12 +293,13 @@ gst_atomic_queue_pop (GstAtomicQueue * queue)
       head_mem = g_atomic_pointer_get (&queue->head_mem);
 
       head = g_atomic_int_get (&head_mem->head);
-      tail = g_atomic_int_get (&head_mem->tail);
+      tail = g_atomic_int_get (&head_mem->tail_read);
       size = head_mem->size;
 
       /* when we are not empty, we can continue */
-      if (G_LIKELY (head != tail))
-        break;
+      if G_LIKELY
+        (head != tail)
+            break;
 
       /* else array empty, try to take next */
       next = g_atomic_pointer_get (&head_mem->next);
@@ -305,9 +308,10 @@ gst_atomic_queue_pop (GstAtomicQueue * queue)
 
       /* now we try to move the next array as the head memory. If we fail to do that,
        * some other reader managed to do it first and we retry */
-      if (!G_ATOMIC_POINTER_COMPARE_AND_EXCHANGE (&queue->head_mem, head_mem,
-              next))
-        continue;
+      if G_UNLIKELY
+        (!G_ATOMIC_POINTER_COMPARE_AND_EXCHANGE (&queue->head_mem, head_mem,
+                next))
+            continue;
 
       /* when we managed to swing the head pointer the old head is now
        * useless and we add it to the freelist. We can't free the memory yet
@@ -316,8 +320,8 @@ gst_atomic_queue_pop (GstAtomicQueue * queue)
     }
 
     ret = head_mem->array[head & size];
-  } while (!g_atomic_int_compare_and_exchange (&head_mem->head, head,
-          head + 1));
+  } while G_UNLIKELY
+  (!g_atomic_int_compare_and_exchange (&head_mem->head, head, head + 1));
 
 #ifdef LOW_MEM
   /* decrement number of readers, when we reach 0 readers we can be sure that
@@ -352,34 +356,44 @@ gst_atomic_queue_push (GstAtomicQueue * queue, gpointer data)
 
       tail_mem = g_atomic_pointer_get (&queue->tail_mem);
       head = g_atomic_int_get (&tail_mem->head);
-      tail = g_atomic_int_get (&tail_mem->tail);
+      tail = g_atomic_int_get (&tail_mem->tail_write);
       size = tail_mem->size;
 
       /* we're not full, continue */
-      if (tail - head <= size)
-        break;
+      if G_LIKELY
+        (tail - head <= size)
+            break;
 
       /* else we need to grow the array, we store a mask so we have to add 1 */
       mem = new_queue_mem ((size << 1) + 1, tail);
 
       /* try to make our new array visible to other writers */
-      if (!G_ATOMIC_POINTER_COMPARE_AND_EXCHANGE (&queue->tail_mem, tail_mem,
-              mem)) {
+      if G_UNLIKELY
+        (!G_ATOMIC_POINTER_COMPARE_AND_EXCHANGE (&queue->tail_mem, tail_mem,
+                mem)) {
         /* we tried to swap the new writer array but something changed. This is
          * because some other writer beat us to it, we free our memory and try
          * again */
         free_queue_mem (mem);
         continue;
-      }
+        }
       /* make sure that readers can find our new array as well. The one who
        * manages to swap the pointer is the only one who can set the next
        * pointer to the new array */
       g_atomic_pointer_set (&tail_mem->next, mem);
     }
-  } while (!g_atomic_int_compare_and_exchange (&tail_mem->tail, tail,
-          tail + 1));
+  } while G_UNLIKELY
+  (!g_atomic_int_compare_and_exchange (&tail_mem->tail_write, tail, tail + 1));
 
   tail_mem->array[tail & size] = data;
+
+  /* now wait until all writers have completed their write before we move the
+   * tail_read to this new item. It is possible that other writers are still
+   * updating the previous array slots and we don't want to reveal their changes
+   * before they are done. FIXME, it would be nice if we didn't have to busy
+   * wait here. */
+  while G_UNLIKELY
+    (!g_atomic_int_compare_and_exchange (&tail_mem->tail_read, tail, tail + 1));
 }
 
 /**
@@ -408,7 +422,7 @@ gst_atomic_queue_length (GstAtomicQueue * queue)
   head = g_atomic_int_get (&head_mem->head);
 
   tail_mem = g_atomic_pointer_get (&queue->tail_mem);
-  tail = g_atomic_int_get (&tail_mem->tail);
+  tail = g_atomic_int_get (&tail_mem->tail_read);
 
 #ifdef LOW_MEM
   if (g_atomic_int_dec_and_test (&queue->num_readers))
diff --git a/gst/gstconfig.h.in b/gst/gstconfig.h.in
index 4138b18..37db17e 100644
--- a/gst/gstconfig.h.in
+++ b/gst/gstconfig.h.in
@@ -229,7 +229,11 @@
 #endif
 #else /* not _MSC_VER */
 #define GST_PLUGIN_EXPORT
+#if (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#define GST_EXPORT extern __attribute__ ((visibility ("default")))
+#else
 #define GST_EXPORT extern
 #endif
+#endif
 
 #endif /* __GST_CONFIG_H__ */
diff --git a/gst/gstelement.c b/gst/gstelement.c
index 9328dfe..60734a3 100644
--- a/gst/gstelement.c
+++ b/gst/gstelement.c
@@ -1180,6 +1180,7 @@ gst_element_request_pad (GstElement * element,
 {
   g_return_val_if_fail (GST_IS_ELEMENT (element), NULL);
   g_return_val_if_fail (templ != NULL, NULL);
+  g_return_val_if_fail (templ->presence == GST_PAD_REQUEST, NULL);
 
   return _gst_element_request_pad (element, templ, name, caps);
 }
diff --git a/gst/gstevent.c b/gst/gstevent.c
index 8c323aa..c56f669 100644
--- a/gst/gstevent.c
+++ b/gst/gstevent.c
@@ -114,6 +114,7 @@ static GstEventQuarks event_quarks[] = {
   {GST_EVENT_EOS, "eos", 0},
   {GST_EVENT_NEWSEGMENT, "newsegment", 0},
   {GST_EVENT_TAG, "tag", 0},
+  {GST_EVENT_TOC, "toc", 0},
   {GST_EVENT_BUFFERSIZE, "buffersize", 0},
   {GST_EVENT_SINK_MESSAGE, "sink-message", 0},
   {GST_EVENT_QOS, "qos", 0},
@@ -121,6 +122,7 @@ static GstEventQuarks event_quarks[] = {
   {GST_EVENT_NAVIGATION, "navigation", 0},
   {GST_EVENT_LATENCY, "latency", 0},
   {GST_EVENT_STEP, "step", 0},
+  {GST_EVENT_TOC_SELECT, "toc-select", 0},
   {GST_EVENT_CUSTOM_UPSTREAM, "custom-upstream", 0},
   {GST_EVENT_CUSTOM_DOWNSTREAM, "custom-downstream", 0},
   {GST_EVENT_CUSTOM_DOWNSTREAM_OOB, "custom-downstream-oob", 0},
@@ -1303,3 +1305,112 @@ gst_event_parse_sink_message (GstEvent * event, GstMessage ** msg)
         GST_MESSAGE (gst_value_dup_mini_object (gst_structure_id_get_value
             (event->structure, GST_QUARK (MESSAGE))));
 }
+
+/**
+ * gst_event_new_toc:
+ * @toc: #GstToc structure.
+ * @updated: whether @toc was updated or not.
+ *
+ * Generate a TOC event from the given @toc. The purpose of the TOC event is to
+ * inform elements that some kind of the TOC was found.
+ *
+ * Returns: a new #GstEvent.
+ *
+ * Since: 0.10.37
+ */
+GstEvent *
+gst_event_new_toc (GstToc * toc, gboolean updated)
+{
+  GstStructure *toc_struct;
+
+  g_return_val_if_fail (toc != NULL, NULL);
+
+  GST_CAT_INFO (GST_CAT_EVENT, "creating toc event");
+
+  toc_struct = priv_gst_toc_to_structure (toc);
+
+  if (G_LIKELY (toc_struct != NULL)) {
+    priv_gst_toc_structure_set_updated (toc_struct, updated);
+    return gst_event_new_custom (GST_EVENT_TOC, toc_struct);
+  } else
+    return NULL;
+}
+
+/**
+ * gst_event_parse_toc:
+ * @event: a TOC event.
+ * @toc: (out): pointer to #GstToc structure.
+ * @updated: (out): pointer to store TOC updated flag.
+ *
+ * Parse a TOC @event and store the results in the given @toc and @updated locations.
+ *
+ * Since: 0.10.37
+ */
+void
+gst_event_parse_toc (GstEvent * event, GstToc ** toc, gboolean * updated)
+{
+  const GstStructure *structure;
+
+  g_return_if_fail (event != NULL);
+  g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_TOC);
+  g_return_if_fail (toc != NULL);
+
+  structure = gst_event_get_structure (event);
+  *toc = priv_gst_toc_from_structure (structure);
+
+  if (updated != NULL)
+    *updated = priv_gst_toc_structure_get_updated (structure);
+}
+
+/**
+ * gst_event_new_toc_select:
+ * @uid: UID in the TOC to start playback from.
+ *
+ * Generate a TOC select event with the given @uid. The purpose of the
+ * TOC select event is to start playback based on the TOC's entry with the
+ * given @uid.
+ *
+ * Returns: a new #GstEvent.
+ *
+ * Since: 0.10.37
+ */
+GstEvent *
+gst_event_new_toc_select (const gchar * uid)
+{
+  GstStructure *structure;
+
+  g_return_val_if_fail (uid != NULL, NULL);
+
+  GST_CAT_INFO (GST_CAT_EVENT, "creating toc select event for UID: %s", uid);
+
+  structure = gst_structure_id_new (GST_QUARK (EVENT_TOC_SELECT),
+      GST_QUARK (UID), G_TYPE_STRING, uid, NULL);
+
+  return gst_event_new_custom (GST_EVENT_TOC_SELECT, structure);
+}
+
+/**
+ * gst_event_parse_toc_select:
+ * @event: a TOC select event.
+ * @uid: (out): storage for the selection UID.
+ *
+ * Parse a TOC select @event and store the results in the given @uid location.
+ *
+ * Since: 0.10.37
+ */
+void
+gst_event_parse_toc_select (GstEvent * event, gchar ** uid)
+{
+  const GstStructure *structure;
+  const GValue *val;
+
+  g_return_if_fail (event != NULL);
+  g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_TOC_SELECT);
+
+  structure = gst_event_get_structure (event);
+  val = gst_structure_id_get_value (structure, GST_QUARK (UID));
+
+  if (uid != NULL)
+    *uid = g_strdup (g_value_get_string (val));
+
+}
diff --git a/gst/gstevent.h b/gst/gstevent.h
index 20e8ef0..2321be5 100644
--- a/gst/gstevent.h
+++ b/gst/gstevent.h
@@ -31,6 +31,7 @@
 #include <gst/gstclock.h>
 #include <gst/gststructure.h>
 #include <gst/gsttaglist.h>
+#include <gst/gsttoc.h>
 
 G_BEGIN_DECLS
 
@@ -94,6 +95,8 @@ typedef enum {
  *                          send messages that should be emitted in sync with
  *                          rendering.
  *                          Since: 0.10.26
+ * @GST_EVENT_TOC: An event which indicates that a new table of contents (TOC)
+                   was found or updated. Since: 0.10.37
  * @GST_EVENT_QOS: A quality message. Used to indicate to upstream elements
  *                 that the downstream elements should adjust their processing
  *                 rate.
@@ -106,6 +109,8 @@ typedef enum {
  *                     Since: 0.10.12
  * @GST_EVENT_STEP: A request for stepping through the media. Sinks will usually
  *                  execute the step operation. Since: 0.10.24
+ * @GST_EVENT_TOC_SELECT: A request for a new playback position based on TOC
+ *                        entry's UID. Since 0.10.37
  * @GST_EVENT_CUSTOM_UPSTREAM: Upstream custom event
  * @GST_EVENT_CUSTOM_DOWNSTREAM: Downstream custom event that travels in the
  *                        data flow.
@@ -134,12 +139,14 @@ typedef enum {
   GST_EVENT_TAG                   = GST_EVENT_MAKE_TYPE (7, FLAG(DOWNSTREAM) | FLAG(SERIALIZED)),
   GST_EVENT_BUFFERSIZE            = GST_EVENT_MAKE_TYPE (8, FLAG(DOWNSTREAM) | FLAG(SERIALIZED)),
   GST_EVENT_SINK_MESSAGE          = GST_EVENT_MAKE_TYPE (9, FLAG(DOWNSTREAM) | FLAG(SERIALIZED)),
+  GST_EVENT_TOC                   = GST_EVENT_MAKE_TYPE (10, FLAG(DOWNSTREAM) | FLAG(SERIALIZED)),
   /* upstream events */
   GST_EVENT_QOS                   = GST_EVENT_MAKE_TYPE (15, FLAG(UPSTREAM)),
   GST_EVENT_SEEK                  = GST_EVENT_MAKE_TYPE (16, FLAG(UPSTREAM)),
   GST_EVENT_NAVIGATION            = GST_EVENT_MAKE_TYPE (17, FLAG(UPSTREAM)),
   GST_EVENT_LATENCY               = GST_EVENT_MAKE_TYPE (18, FLAG(UPSTREAM)),
   GST_EVENT_STEP                  = GST_EVENT_MAKE_TYPE (19, FLAG(UPSTREAM)),
+  GST_EVENT_TOC_SELECT            = GST_EVENT_MAKE_TYPE (20, FLAG(UPSTREAM)),
 
   /* custom events start here */
   GST_EVENT_CUSTOM_UPSTREAM       = GST_EVENT_MAKE_TYPE (32, FLAG(UPSTREAM)),
@@ -487,6 +494,11 @@ void            gst_event_parse_new_segment_full (GstEvent *event,
 GstEvent*       gst_event_new_tag               (GstTagList *taglist) G_GNUC_MALLOC;
 void            gst_event_parse_tag             (GstEvent *event, GstTagList **taglist);
 
+/* TOC event */
+GstEvent*      gst_event_new_toc                (GstToc *toc, gboolean updated);
+void           gst_event_parse_toc              (GstEvent *event, GstToc **toc, gboolean *updated);
+
+
 /* buffer */
 GstEvent *      gst_event_new_buffer_size       (GstFormat format, gint64 minsize, gint64 maxsize,
                                                  gboolean async) G_GNUC_MALLOC;
@@ -524,6 +536,10 @@ GstEvent*       gst_event_new_step              (GstFormat format, guint64 amoun
 void            gst_event_parse_step            (GstEvent *event, GstFormat *format, guint64 *amount,
                                                  gdouble *rate, gboolean *flush, gboolean *intermediate);
 
+/* TOC select event */
+GstEvent*       gst_event_new_toc_select        (const gchar *uid);
+void            gst_event_parse_toc_select      (GstEvent *event, gchar **uid);
+
 G_END_DECLS
 
 #endif /* __GST_EVENT_H__ */
diff --git a/gst/gstghostpad.c b/gst/gstghostpad.c
index d8fb3ea..284be98 100644
--- a/gst/gstghostpad.c
+++ b/gst/gstghostpad.c
@@ -166,7 +166,7 @@ gst_proxy_pad_query_default (GstPad * pad, GstQuery * query)
 }
 
 /**
- * gst_proyx_pad_iterate_internal_links_default:
+ * gst_proxy_pad_iterate_internal_links_default:
  * @pad: the #GstPad to get the internal links of.
  *
  * Invoke the default iterate internal links function of the proxy pad.
diff --git a/gst/gstmessage.c b/gst/gstmessage.c
index 423ebc2..feabbf0 100644
--- a/gst/gstmessage.c
+++ b/gst/gstmessage.c
@@ -113,6 +113,7 @@ static GstMessageQuarks message_quarks[] = {
   {GST_MESSAGE_STEP_START, "step-start", 0},
   {GST_MESSAGE_QOS, "qos", 0},
   {GST_MESSAGE_PROGRESS, "progress", 0},
+  {GST_MESSAGE_TOC, "toc", 0},
   {0, NULL, 0}
 };
 
@@ -2154,3 +2155,61 @@ gst_message_parse_progress (GstMessage * message, GstProgressType * type,
       GST_QUARK (CODE), G_TYPE_STRING, code,
       GST_QUARK (TEXT), G_TYPE_STRING, text, NULL);
 }
+
+/**
+ * gst_message_new_toc:
+ * @src: the object originating the message.
+ * @toc: #GstToc structure for the message.
+ * @updated: whether TOC was updated or not.
+ *
+ * Create a new TOC message. The message is posted by elements
+ * that discovered or updated a TOC.
+ *
+ * Returns: a new TOC message.
+ *
+ * MT safe.
+ *
+ * Since: 0.10.37
+ */
+GstMessage *
+gst_message_new_toc (GstObject * src, GstToc * toc, gboolean updated)
+{
+  GstStructure *toc_struct;
+
+  g_return_val_if_fail (toc != NULL, NULL);
+
+  toc_struct = priv_gst_toc_to_structure (toc);
+
+  if (G_LIKELY (toc_struct != NULL)) {
+    priv_gst_toc_structure_set_updated (toc_struct, updated);
+    return gst_message_new_custom (GST_MESSAGE_TOC, src, toc_struct);
+  } else
+    return NULL;
+}
+
+/**
+ * gst_message_parse_toc:
+ * @message: a valid #GstMessage of type GST_MESSAGE_TOC.
+ * @toc: (out): return location for the TOC.
+ * @updated: (out): return location for the updated flag.
+ *
+ * Extract the TOC from the #GstMessage. The TOC returned in the
+ * output argument is a copy; the caller must free it with
+ * gst_toc_free() when done.
+ *
+ * MT safe.
+ *
+ * Since: 0.10.37
+ */
+void
+gst_message_parse_toc (GstMessage * message, GstToc ** toc, gboolean * updated)
+{
+  g_return_if_fail (GST_IS_MESSAGE (message));
+  g_return_if_fail (GST_MESSAGE_TYPE (message) == GST_MESSAGE_TOC);
+  g_return_if_fail (toc != NULL);
+
+  *toc = priv_gst_toc_from_structure (message->structure);
+
+  if (updated != NULL)
+    *updated = priv_gst_toc_structure_get_updated (message->structure);
+}
diff --git a/gst/gstmessage.h b/gst/gstmessage.h
index f0fcc7a..ae5fc19 100644
--- a/gst/gstmessage.h
+++ b/gst/gstmessage.h
@@ -89,6 +89,8 @@ typedef struct _GstMessageClass GstMessageClass;
  * @GST_MESSAGE_QOS: A buffer was dropped or an element changed its processing
  * strategy for Quality of Service reasons. Since: 0.10.29
  * @GST_MESSAGE_PROGRESS: A progress message. Since: 0.10.33
+ * @GST_MESSAGE_TOC: A new table of contents (TOC) was found or previously found TOC
+ * was updated. Since: 0.10.37
  * @GST_MESSAGE_ANY: mask for all of the above messages.
  *
  * The different message types that are available.
@@ -125,6 +127,7 @@ typedef enum
   GST_MESSAGE_STEP_START        = (1 << 23),
   GST_MESSAGE_QOS               = (1 << 24),
   GST_MESSAGE_PROGRESS          = (1 << 25),
+  GST_MESSAGE_TOC               = (1 << 26),
   GST_MESSAGE_ANY               = ~0
 } GstMessageType;
 
@@ -133,6 +136,7 @@ typedef enum
 #include <gst/gstelement.h>
 #include <gst/gsttaglist.h>
 #include <gst/gststructure.h>
+#include <gst/gsttoc.h>
 
 /**
  * GST_MESSAGE_TRACE_NAME:
@@ -522,6 +526,9 @@ GstMessage *    gst_message_new_progress           (GstObject * src, GstProgress
 void            gst_message_parse_progress         (GstMessage * message, GstProgressType * type, gchar ** code,
                                                     gchar ** text);
 
+/* TOC */
+GstMessage *    gst_message_new_toc             (GstObject *src, GstToc *toc, gboolean updated);
+void            gst_message_parse_toc           (GstMessage *message, GstToc **toc, gboolean *updated);
 
 /* custom messages */
 GstMessage *    gst_message_new_custom          (GstMessageType type,
diff --git a/gst/gstpad.c b/gst/gstpad.c
index ef28bf5..f99bd7d 100644
--- a/gst/gstpad.c
+++ b/gst/gstpad.c
@@ -5596,7 +5596,7 @@ gst_pad_start_task (GstPad * pad, GstTaskFunction func, gpointer data)
     task = gst_task_create (func, data);
     gst_task_set_lock (task, GST_PAD_GET_STREAM_LOCK (pad));
     gst_task_set_thread_callbacks (task, &thr_callbacks, pad, NULL);
-    GST_DEBUG_OBJECT (pad, "created task");
+    GST_INFO_OBJECT (pad, "created task %p", task);
     GST_PAD_TASK (pad) = task;
     gst_object_ref (task);
     /* release lock to post the message */
diff --git a/gst/gstpad.h b/gst/gstpad.h
index 8990fdc..ef0c146 100644
--- a/gst/gstpad.h
+++ b/gst/gstpad.h
@@ -828,7 +828,7 @@ struct _GstPadClass {
  *
  * Lock the stream lock of @pad.
  */
-#define GST_PAD_STREAM_LOCK(pad)        (g_static_rec_mutex_lock(GST_PAD_GET_STREAM_LOCK(pad)))
+#define GST_PAD_STREAM_LOCK(pad)        g_static_rec_mutex_lock(GST_PAD_GET_STREAM_LOCK(pad))
 /**
  * GST_PAD_STREAM_LOCK_FULL:
  * @pad: a #GstPad
@@ -836,7 +836,7 @@ struct _GstPadClass {
  *
  * Lock the stream lock of @pad @t times.
  */
-#define GST_PAD_STREAM_LOCK_FULL(pad,t) (g_static_rec_mutex_lock_full(GST_PAD_GET_STREAM_LOCK(pad), t))
+#define GST_PAD_STREAM_LOCK_FULL(pad,t) g_static_rec_mutex_lock_full(GST_PAD_GET_STREAM_LOCK(pad), t)
 /**
  * GST_PAD_STREAM_TRYLOCK:
  * @pad: a #GstPad
@@ -844,14 +844,14 @@ struct _GstPadClass {
  * Try to Lock the stream lock of the pad, return TRUE if the lock could be
  * taken.
  */
-#define GST_PAD_STREAM_TRYLOCK(pad)     (g_static_rec_mutex_trylock(GST_PAD_GET_STREAM_LOCK(pad)))
+#define GST_PAD_STREAM_TRYLOCK(pad)     g_static_rec_mutex_trylock(GST_PAD_GET_STREAM_LOCK(pad))
 /**
  * GST_PAD_STREAM_UNLOCK:
  * @pad: a #GstPad
  *
  * Unlock the stream lock of @pad.
  */
-#define GST_PAD_STREAM_UNLOCK(pad)      (g_static_rec_mutex_unlock(GST_PAD_GET_STREAM_LOCK(pad)))
+#define GST_PAD_STREAM_UNLOCK(pad)      g_static_rec_mutex_unlock(GST_PAD_GET_STREAM_LOCK(pad))
 /**
  * GST_PAD_STREAM_UNLOCK_FULL:
  * @pad: a #GstPad
@@ -859,7 +859,7 @@ struct _GstPadClass {
  * Fully unlock the recursive stream lock of @pad, return the number of times
  * @pad was locked.
  */
-#define GST_PAD_STREAM_UNLOCK_FULL(pad) (g_static_rec_mutex_unlock_full(GST_PAD_GET_STREAM_LOCK(pad)))
+#define GST_PAD_STREAM_UNLOCK_FULL(pad) g_static_rec_mutex_unlock_full(GST_PAD_GET_STREAM_LOCK(pad))
 
 #define GST_PAD_GET_PREROLL_LOCK(pad)   (GST_PAD_CAST(pad)->preroll_lock)
 #define GST_PAD_PREROLL_LOCK(pad)       (g_mutex_lock(GST_PAD_GET_PREROLL_LOCK(pad)))
diff --git a/gst/gstpipeline.c b/gst/gstpipeline.c
index b032c2f..8612ae3 100644
--- a/gst/gstpipeline.c
+++ b/gst/gstpipeline.c
@@ -408,7 +408,9 @@ gst_pipeline_change_state (GstElement * element, GstStateChange transition)
 
       /* running time changed, either with a PAUSED or a flush, we need to check
        * if there is a new clock & update the base time */
-      if (update_clock || last_start_time != start_time) {
+      /* only do this for top-level, however */
+      if (GST_OBJECT_PARENT (element) == NULL &&
+          (update_clock || last_start_time != start_time)) {
         GST_DEBUG_OBJECT (pipeline, "Need to update start_time");
 
         /* when going to PLAYING, select a clock when needed. If we just got
diff --git a/gst/gstplugin.c b/gst/gstplugin.c
index 02e5cc9..693bc0f 100644
--- a/gst/gstplugin.c
+++ b/gst/gstplugin.c
@@ -90,7 +90,7 @@ static char *_gst_plugin_fault_handler_filename = NULL;
  * MIT/X11: http://www.opensource.org/licenses/mit-license.php
  * 3-clause BSD: http://www.opensource.org/licenses/bsd-license.php
  */
-static const gchar *valid_licenses[] = {
+static const gchar *const valid_licenses[] = {
   "LGPL",                       /* GNU Lesser General Public License */
   "GPL",                        /* GNU General Public License */
   "QPL",                        /* Trolltech Qt Public License */
@@ -487,7 +487,7 @@ priv_gst_plugin_loading_get_whitelist_hash (void)
 static gboolean
 gst_plugin_check_license (const gchar * license)
 {
-  const gchar **check_license = valid_licenses;
+  const gchar *const *check_license = valid_licenses;
 
   g_assert (check_license);
 
diff --git a/gst/gstquark.c b/gst/gstquark.c
index 91a2012..f8b54da 100644
--- a/gst/gstquark.c
+++ b/gst/gstquark.c
@@ -50,7 +50,7 @@ static const gchar *_quark_strings[] = {
   "intermediate", "GstMessageStepStart", "active", "eos", "sink-message",
   "message", "GstMessageQOS", "running-time", "stream-time", "jitter",
   "quality", "processed", "dropped", "buffering-ranges", "GstMessageProgress",
-  "code", "text", "percent", "timeout"
+  "code", "text", "percent", "timeout", "toc-select", "uid"
 };
 
 GQuark _priv_gst_quark_table[GST_QUARK_MAX];
diff --git a/gst/gstquark.h b/gst/gstquark.h
index 6e16ee5..b3cfb45 100644
--- a/gst/gstquark.h
+++ b/gst/gstquark.h
@@ -132,8 +132,10 @@ typedef enum _GstQuarkId
   GST_QUARK_TEXT = 103,
   GST_QUARK_PERCENT = 104,
   GST_QUARK_TIMEOUT = 105,
+  GST_QUARK_EVENT_TOC_SELECT = 106,
+  GST_QUARK_UID = 107,
 
-  GST_QUARK_MAX = 106
+  GST_QUARK_MAX = 108
 } GstQuarkId;
 
 extern GQuark _priv_gst_quark_table[GST_QUARK_MAX];
diff --git a/gst/gstquery.c b/gst/gstquery.c
index 2b1c382..84a8809 100644
--- a/gst/gstquery.c
+++ b/gst/gstquery.c
@@ -61,6 +61,11 @@
  * Last reviewed on 2006-02-14 (0.10.4)
  */
 
+
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include "gst_private.h"
 #include "gstinfo.h"
 #include "gstquery.h"
@@ -96,6 +101,7 @@ static GstQueryTypeDefinition standard_definitions[] = {
   {GST_QUERY_BUFFERING, "buffering", "Buffering status", 0},
   {GST_QUERY_CUSTOM, "custom", "Custom query", 0},
   {GST_QUERY_URI, "uri", "URI of the source or sink", 0},
+  {GST_QUERY_TOC, "toc", "Full table of contents", 0},
   {GST_QUERY_NONE, NULL, NULL, 0}
 };
 
@@ -1490,3 +1496,94 @@ gst_query_parse_uri (GstQuery * query, gchar ** uri)
     *uri = g_value_dup_string (gst_structure_id_get_value (query->structure,
             GST_QUARK (URI)));
 }
+
+/**
+ * gst_query_new_toc:
+ *
+ * Constructs a new query TOC query object. Use gst_query_unref()
+ * when done with it. A TOC query is used to query the full TOC with
+ * the UID marker for TOC extending (to insert some new entries).
+ *
+ * Returns: A #GstQuery.
+ *
+ * Since: 0.10.37
+ */
+GstQuery *
+gst_query_new_toc (void)
+{
+  GstQuery *query;
+
+  query = gst_query_new (GST_QUERY_TOC, NULL);
+
+  return query;
+}
+
+/**
+ * gst_query_set_toc:
+ * @query: a #GstQuery with query type GST_QUERY_TOC.
+ * @toc: the GstToc to set.
+ * @extend_uid: UID which can be used for TOC extending (may be NULL),
+ * 0 means root TOC level.
+ *
+ * Answer a TOC query by setting appropriate #GstToc structure.
+ *
+ * Since: 0.10.37
+ */
+void
+gst_query_set_toc (GstQuery * query, GstToc * toc, const gchar * extend_uid)
+{
+  GstStructure *structure;
+
+  g_return_if_fail (query != NULL);
+  g_return_if_fail (GST_QUERY_TYPE (query) == GST_QUERY_TOC);
+  g_return_if_fail (toc != NULL);
+
+  structure = priv_gst_toc_to_structure (toc);
+
+  g_return_if_fail (structure != NULL);
+
+  /* that shouldn't be happen in normal usage */
+  if (query->structure != NULL)
+    gst_structure_free (query->structure);
+
+  if (extend_uid != NULL)
+    priv_gst_toc_structure_set_extend_uid (structure, extend_uid);
+
+  query->structure = structure;
+  gst_structure_set_parent_refcount (query->structure,
+      &(query->mini_object.refcount));
+}
+
+/**
+ * gst_query_parse_toc:
+ * @query: a #GstQuery.
+ * @toc: (out): the storage for the received TOC (may be NULL).
+ * @extend_uid: (out): the storage for the received extend UID marker (may be NULL),
+ * 0 means root TOC level.
+ *
+ * Parse a TOC query, writing the TOC into @toc as a newly
+ * allocated #GstToc and extend UID into @extend_uid, if the respective parameters
+ * are non-NULL. Use @extend_uid value to insert new entries into the TOC (@extend_uid will
+ * act as root entry for newly inserted entries).
+ * Free @toc with gst_toc_free() and @extend_uid with g_free() after usage.
+ *
+ * Since: 0.10.37
+ */
+void
+gst_query_parse_toc (GstQuery * query, GstToc ** toc, gchar ** extend_uid)
+{
+  const GstStructure *structure;
+
+  g_return_if_fail (query != NULL);
+  g_return_if_fail (GST_QUERY_TYPE (query) == GST_QUERY_TOC);
+
+  structure = gst_query_get_structure (query);
+
+  g_return_if_fail (structure != NULL);
+
+  if (toc != NULL)
+    *toc = priv_gst_toc_from_structure (structure);
+
+  if (extend_uid != NULL)
+    *extend_uid = priv_gst_toc_structure_get_extend_uid (structure);
+}
diff --git a/gst/gstquery.h b/gst/gstquery.h
index 2166537..9a1a0f9 100644
--- a/gst/gstquery.h
+++ b/gst/gstquery.h
@@ -51,6 +51,8 @@ G_BEGIN_DECLS
  * @GST_QUERY_CUSTOM: a custom application or element defined query. Since
  * 0.10.22.
  * @GST_QUERY_URI: query the URI of the source or sink. Since 0.10.22.
+ * @GST_QUERY_TOC: query the full table of contents (TOC) with the marker
+ * for an entry which can be used to extend received TOC. Since 0.10.37.
  *
  * Standard predefined Query types
  */
@@ -69,7 +71,8 @@ typedef enum {
   GST_QUERY_FORMATS,
   GST_QUERY_BUFFERING,
   GST_QUERY_CUSTOM,
-  GST_QUERY_URI
+  GST_QUERY_URI,
+  GST_QUERY_TOC
 } GstQueryType;
 
 /**
@@ -336,6 +339,11 @@ GstQuery *      gst_query_new_uri                 (void) G_GNUC_MALLOC;
 void            gst_query_parse_uri               (GstQuery *query, gchar **uri);
 void            gst_query_set_uri                 (GstQuery *query, const gchar *uri);
 
+/* TOC query */
+GstQuery *      gst_query_new_toc                 (void);
+void            gst_query_set_toc                 (GstQuery *query, GstToc *toc, const gchar *extend_uid);
+void            gst_query_parse_toc               (GstQuery *query, GstToc **toc, gchar **extend_uid);
+
 G_END_DECLS
 
 #endif /* __GST_QUERY_H__ */
diff --git a/gst/gstregistrybinary.c b/gst/gstregistrybinary.c
index 1a58837..5848066 100644
--- a/gst/gstregistrybinary.c
+++ b/gst/gstregistrybinary.c
@@ -219,10 +219,11 @@ gst_registry_binary_cache_write (BinaryRegistryCache * cache,
 {
   long written;
   if (offset != cache->currentoffset) {
-    if (lseek (cache->cache_fd, offset, SEEK_SET) != 0) {
-      GST_ERROR ("Seeking to new offset failed");
-      return FALSE;
+    if (lseek (cache->cache_fd, offset, SEEK_SET) < 0) {
+      GST_ERROR ("Seeking to new offset failed: %s", g_strerror (errno));
+      return -1;
     }
+    GST_LOG ("Seeked from offset %lu to %lu", offset, cache->currentoffset);
     cache->currentoffset = offset;
   }
 
@@ -245,12 +246,13 @@ gst_registry_binary_cache_finish (BinaryRegistryCache * cache, gboolean success)
   if (close (cache->cache_fd) < 0)
     goto close_failed;
 
-  if (success) {
-    /* Only do the rename if we wrote the entire file successfully */
-    if (g_rename (cache->tmp_location, cache->location) < 0) {
-      GST_ERROR ("g_rename() failed: %s", g_strerror (errno));
-      goto rename_failed;
-    }
+  if (!success)
+    goto fail_after_close;
+
+  /* Only do the rename if we wrote the entire file successfully */
+  if (g_rename (cache->tmp_location, cache->location) < 0) {
+    GST_ERROR ("g_rename() failed: %s", g_strerror (errno));
+    goto rename_failed;
   }
 
   g_free (cache->tmp_location);
diff --git a/gst/gsttaglist.c b/gst/gsttaglist.c
index 282c920..ac88c79 100644
--- a/gst/gsttaglist.c
+++ b/gst/gsttaglist.c
@@ -274,7 +274,11 @@ _gst_tag_initialize (void)
       _("reference level of track and album gain values"), NULL);
   gst_tag_register (GST_TAG_LANGUAGE_CODE, GST_TAG_FLAG_META, G_TYPE_STRING,
       _("language code"),
-      _("language code for this stream, conforming to ISO-639-1"), NULL);
+      _("language code for this stream, conforming to ISO-639-1 or ISO-639-2"),
+      NULL);
+  gst_tag_register (GST_TAG_LANGUAGE_NAME, GST_TAG_FLAG_META, G_TYPE_STRING,
+      _("language name"),
+      _("freeform name of the language this stream is in"), NULL);
   gst_tag_register (GST_TAG_IMAGE, GST_TAG_FLAG_META, GST_TYPE_BUFFER,
       _("image"), _("image related to this stream"), gst_tag_merge_use_first);
   gst_tag_register (GST_TAG_PREVIEW_IMAGE, GST_TAG_FLAG_META, GST_TYPE_BUFFER,
diff --git a/gst/gsttaglist.h b/gst/gsttaglist.h
index 0cec033..96fcdb5 100644
--- a/gst/gsttaglist.h
+++ b/gst/gsttaglist.h
@@ -741,10 +741,25 @@ gboolean     gst_tag_list_get_buffer_index  (const GstTagList * list,
 /**
  * GST_TAG_LANGUAGE_CODE:
  *
- * Language code (ISO-639-1) (string) of the content
+ * ISO-639-2 or ISO-639-1 code for the language the content is in (string)
+ *
+ * There is utility API in libgsttag in gst-plugins-base to obtain a translated
+ * language name from the language code: gst_tag_get_language_name()
  */
 #define GST_TAG_LANGUAGE_CODE          "language-code"
 /**
+ * GST_TAG_LANGUAGE_NAME:
+ *
+ * Name of the language the content is in (string)
+ *
+ * Free-form name of the language the content is in, if a language code
+ * is not available. This tag should not be set in addition to a language
+ * code. It is undefined what language or locale the language name is in.
+ *
+ * Since: 0.10.37
+ */
+#define GST_TAG_LANGUAGE_NAME          "language-name"
+/**
  * GST_TAG_IMAGE:
  *
  * image (buffer) (buffer caps should specify the content type and preferably
diff --git a/gst/gsttask.c b/gst/gsttask.c
index 4aae349..1f72e92 100644
--- a/gst/gsttask.c
+++ b/gst/gsttask.c
@@ -306,7 +306,8 @@ gst_task_func (GstTask * task)
 
         t = g_static_rec_mutex_unlock_full (lock);
         if (t <= 0) {
-          g_warning ("wrong STREAM_LOCK count %d", t);
+          g_warning ("wrong STREAM_LOCK count %d for lock %p on task %p", t,
+              lock, task);
         }
         GST_TASK_SIGNAL (task);
         GST_TASK_WAIT (task);
@@ -443,6 +444,7 @@ gst_task_set_lock (GstTask * task, GStaticRecMutex * mutex)
   GST_OBJECT_LOCK (task);
   if (G_UNLIKELY (task->running))
     goto is_running;
+  GST_INFO ("setting stream lock %p on task %p", mutex, task);
   GST_TASK_GET_LOCK (task) = mutex;
   GST_OBJECT_UNLOCK (task);
 
diff --git a/gst/gsttoc.c b/gst/gsttoc.c
new file mode 100644
index 0000000..c997c22
--- /dev/null
+++ b/gst/gsttoc.c
@@ -0,0 +1,1038 @@
+/* GStreamer
+ * (c) 2010, 2012 Alexander Saprykin <xelfium@gmail.com>
+ *
+ * gsttoc.c: GstToc initialization and parsing/creation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:gsttoc
+ * @short_description: Generic table of contents support
+ * @see_also: #GstStructure, #GstEvent, #GstMessage, #GstQuery, #GstPad
+ *
+ * #GstToc functions are used to create/free #GstToc and #GstTocEntry structures.
+ * Also they are used to convert #GstToc into #GstStructure and vice versa.
+ *
+ * #GstToc lets you to inform other elements in pipeline or application that playing
+ * source has some kind of table of contents (TOC). These may be chapters, editions,
+ * angles or other types. For example: DVD chapters, Matroska chapters or cue sheet
+ * TOC. Such TOC will be useful for applications to display instead of just a
+ * playlist.
+ *
+ * Using TOC is very easy. Firstly, create #GstToc structure which represents root
+ * contents of the source. You can also attach TOC-specific tags to it. Then fill
+ * it with #GstTocEntry entries by appending them to #GstToc.entries #GstTocEntry.subentries
+ * lists. You should use GST_TOC_ENTRY_TYPE_CHAPTER for generic TOC entry and
+ * GST_TOC_ENTRY_TYPE_EDITION for the entries which are considered to be alternatives
+ * (like DVD angles, Matroska editions and so on).
+ *
+ * Note that root level of the TOC can contain only either editions or chapters. You
+ * should not mix them together at the same level. Otherwise you will get serialization
+ * /deserialization errors. Make sure that no one of the entries has negative start and
+ *  stop values.
+ *
+ * Please, use #GstToc.info and #GstTocEntry.info fields in that way: create a #GstStructure,
+ * put all info related to your element there and put this structure into the info field under
+ * the name of your element. Some fields in the info structure can be used for internal purposes,
+ * so you should use it in the way described above to not to overwrite already existent fields.
+ *
+ * Use gst_event_new_toc() to create a new TOC #GstEvent, and gst_event_parse_toc() to
+ * parse received TOC event. Use gst_event_new_toc_select() to create a new TOC select #GstEvent,
+ * and gst_event_parse_toc_select() to parse received TOC select event. The same rule for
+ * the #GstMessage: gst_message_new_toc() to create new TOC #GstMessage, and
+ * gst_message_parse_toc() to parse received TOC message. Also you can create a new TOC query
+ * with gst_query_new_toc(), set it with gst_query_set_toc() and parse it with
+ * gst_query_parse_toc().
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "gst_private.h"
+#include "gstenumtypes.h"
+#include "gsttaglist.h"
+#include "gststructure.h"
+#include "gstvalue.h"
+#include "gsttoc.h"
+#include "gstpad.h"
+
+#define GST_TOC_TOC_NAME            "toc"
+#define GST_TOC_ENTRY_NAME          "entry"
+
+#define GST_TOC_TOC_UPDATED_FIELD   "updated"
+#define GST_TOC_TOC_EXTENDUID_FIELD "extenduid"
+#define GST_TOC_INFO_FIELD          "info"
+
+#define GST_TOC_ENTRY_UID_FIELD     "uid"
+#define GST_TOC_ENTRY_TYPE_FIELD    "type"
+#define GST_TOC_ENTRY_TAGS_FIELD    "tags"
+
+#define GST_TOC_TOC_ENTRIES_FIELD   "subentries"
+
+#define GST_TOC_INFO_NAME           "info-structure"
+#define GST_TOC_INFO_TIME_FIELD     "time"
+
+#define GST_TOC_TIME_NAME           "time-structure"
+#define GST_TOC_TIME_START_FIELD    "start"
+#define GST_TOC_TIME_STOP_FIELD     "stop"
+
+
+enum
+{
+  GST_TOC_TOC = 0,
+  GST_TOC_ENTRY = 1,
+  GST_TOC_UPDATED = 2,
+  GST_TOC_EXTENDUID = 3,
+  GST_TOC_UID = 4,
+  GST_TOC_TYPE = 5,
+  GST_TOC_TAGS = 6,
+  GST_TOC_SUBENTRIES = 7,
+  GST_TOC_INFO = 8,
+  GST_TOC_INFONAME = 9,
+  GST_TOC_TIME = 10,
+  GST_TOC_TIMENAME = 11,
+  GST_TOC_TIME_START = 12,
+  GST_TOC_TIME_STOP = 13,
+  GST_TOC_LAST = 14
+};
+
+static GQuark gst_toc_fields[GST_TOC_LAST] = { 0 };
+
+void
+priv_gst_toc_initialize (void)
+{
+  static gboolean inited = FALSE;
+
+  if (G_LIKELY (!inited)) {
+    gst_toc_fields[GST_TOC_TOC] = g_quark_from_static_string (GST_TOC_TOC_NAME);
+    gst_toc_fields[GST_TOC_ENTRY] =
+        g_quark_from_static_string (GST_TOC_ENTRY_NAME);
+
+    gst_toc_fields[GST_TOC_UPDATED] =
+        g_quark_from_static_string (GST_TOC_TOC_UPDATED_FIELD);
+    gst_toc_fields[GST_TOC_EXTENDUID] =
+        g_quark_from_static_string (GST_TOC_TOC_EXTENDUID_FIELD);
+    gst_toc_fields[GST_TOC_INFO] =
+        g_quark_from_static_string (GST_TOC_INFO_FIELD);
+
+    gst_toc_fields[GST_TOC_UID] =
+        g_quark_from_static_string (GST_TOC_ENTRY_UID_FIELD);
+    gst_toc_fields[GST_TOC_TYPE] =
+        g_quark_from_static_string (GST_TOC_ENTRY_TYPE_FIELD);
+    gst_toc_fields[GST_TOC_TAGS] =
+        g_quark_from_static_string (GST_TOC_ENTRY_TAGS_FIELD);
+
+    gst_toc_fields[GST_TOC_SUBENTRIES] =
+        g_quark_from_static_string (GST_TOC_TOC_ENTRIES_FIELD);
+
+    gst_toc_fields[GST_TOC_INFONAME] =
+        g_quark_from_static_string (GST_TOC_INFO_NAME);
+    gst_toc_fields[GST_TOC_TIME] =
+        g_quark_from_static_string (GST_TOC_INFO_TIME_FIELD);
+    gst_toc_fields[GST_TOC_TIMENAME] =
+        g_quark_from_static_string (GST_TOC_TIME_NAME);
+    gst_toc_fields[GST_TOC_TIME_START] =
+        g_quark_from_static_string (GST_TOC_TIME_START_FIELD);
+    gst_toc_fields[GST_TOC_TIME_STOP] =
+        g_quark_from_static_string (GST_TOC_TIME_STOP_FIELD);
+
+    inited = TRUE;
+  }
+}
+
+/**
+ * gst_toc_new:
+ *
+ * Create new #GstToc structure.
+ *
+ * Returns: newly allocated #GstToc structure, free it with gst_toc_free().
+ *
+ * Since: 0.10.37
+ */
+GstToc *
+gst_toc_new (void)
+{
+  GstToc *toc;
+
+  toc = g_slice_new0 (GstToc);
+  toc->tags = gst_tag_list_new ();
+  toc->info = gst_structure_id_empty_new (gst_toc_fields[GST_TOC_INFONAME]);
+
+  return toc;
+}
+
+/**
+ * gst_toc_entry_new:
+ * @type: entry type.
+ * @uid: unique ID (UID) in the whole TOC.
+ *
+ * Create new #GstTocEntry structure.
+ *
+ * Returns: newly allocated #GstTocEntry structure, free it with gst_toc_entry_free().
+ *
+ * Since: 0.10.37
+ */
+GstTocEntry *
+gst_toc_entry_new (GstTocEntryType type, const gchar * uid)
+{
+  GstTocEntry *entry;
+
+  g_return_val_if_fail (uid != NULL, NULL);
+
+  entry = g_slice_new0 (GstTocEntry);
+  entry->uid = g_strdup (uid);
+  entry->type = type;
+  entry->tags = gst_tag_list_new ();
+  entry->info = gst_structure_id_empty_new (gst_toc_fields[GST_TOC_INFONAME]);
+
+  return entry;
+}
+
+/**
+ * gst_toc_entry_new_with_pad:
+ * @type: entry type.
+ * @uid: unique ID (UID) in the whole TOC.
+ * @pad: #GstPad related to this entry.
+ *
+ * Create new #GstTocEntry structure with #GstPad related.
+ *
+ * Returns: newly allocated #GstTocEntry structure, free it with gst_toc_entry_free()
+ * when done.
+ *
+ * Since: 0.10.37
+ */
+GstTocEntry *
+gst_toc_entry_new_with_pad (GstTocEntryType type, const gchar * uid,
+    gpointer pad)
+{
+  GstTocEntry *entry;
+
+  g_return_val_if_fail (uid != NULL, NULL);
+
+  entry = g_slice_new0 (GstTocEntry);
+  entry->uid = g_strdup (uid);
+  entry->type = type;
+  entry->tags = gst_tag_list_new ();
+  entry->info = gst_structure_id_empty_new (gst_toc_fields[GST_TOC_INFONAME]);
+
+  if (pad != NULL && GST_IS_PAD (pad))
+    entry->pads = g_list_append (entry->pads, gst_object_ref (pad));
+
+  return entry;
+}
+
+/**
+ * gst_toc_free:
+ * @toc: #GstToc structure to free.
+ *
+ * Free unused #GstToc structure.
+ *
+ * Since: 0.10.37
+ */
+void
+gst_toc_free (GstToc * toc)
+{
+  g_return_if_fail (toc != NULL);
+
+  g_list_foreach (toc->entries, (GFunc) gst_toc_entry_free, NULL);
+  g_list_free (toc->entries);
+
+  if (toc->tags != NULL)
+    gst_tag_list_free (toc->tags);
+
+  if (toc->info != NULL)
+    gst_structure_free (toc->info);
+
+  g_slice_free (GstToc, toc);
+}
+
+/**
+ * gst_toc_entry_free:
+ * @entry: #GstTocEntry structure to free.
+ *
+ * Free unused #GstTocEntry structure. Note that #GstTocEntry.uid will
+ * be freed with g_free() and all #GstPad objects in the #GstTocEntry.pads
+ * list will be unrefed with gst_object_unref().
+ *
+ * Since: 0.10.37
+ */
+void
+gst_toc_entry_free (GstTocEntry * entry)
+{
+  GList *cur;
+
+  g_return_if_fail (entry != NULL);
+
+  g_list_foreach (entry->subentries, (GFunc) gst_toc_entry_free, NULL);
+  g_list_free (entry->subentries);
+
+  g_free (entry->uid);
+
+  if (entry->tags != NULL)
+    gst_tag_list_free (entry->tags);
+
+  if (entry->info != NULL)
+    gst_structure_free (entry->info);
+
+  cur = entry->pads;
+  while (cur != NULL) {
+    if (GST_IS_PAD (cur->data))
+      gst_object_unref (cur->data);
+    cur = cur->next;
+  }
+
+  g_list_free (entry->pads);
+
+  g_slice_free (GstTocEntry, entry);
+}
+
+static GstStructure *
+gst_toc_structure_new (GstTagList * tags, GstStructure * info)
+{
+  GstStructure *ret;
+  GValue val = { 0 };
+
+  ret = gst_structure_id_empty_new (gst_toc_fields[GST_TOC_TOC]);
+
+  if (tags != NULL) {
+    g_value_init (&val, GST_TYPE_STRUCTURE);
+    gst_value_set_structure (&val, GST_STRUCTURE (tags));
+    gst_structure_id_set_value (ret, gst_toc_fields[GST_TOC_TAGS], &val);
+    g_value_unset (&val);
+  }
+
+  if (info != NULL) {
+    g_value_init (&val, GST_TYPE_STRUCTURE);
+    gst_value_set_structure (&val, info);
+    gst_structure_id_set_value (ret, gst_toc_fields[GST_TOC_INFO], &val);
+    g_value_unset (&val);
+  }
+
+  return ret;
+}
+
+static GstStructure *
+gst_toc_entry_structure_new (GstTocEntryType type, const gchar * uid,
+    GstTagList * tags, GstStructure * info)
+{
+  GValue val = { 0 };
+  GstStructure *ret;
+
+  ret = gst_structure_id_empty_new (gst_toc_fields[GST_TOC_ENTRY]);
+
+  gst_structure_id_set (ret, gst_toc_fields[GST_TOC_TYPE],
+      GST_TYPE_TOC_ENTRY_TYPE, type, NULL);
+
+  g_value_init (&val, G_TYPE_STRING);
+  g_value_set_string (&val, uid);
+  gst_structure_id_set_value (ret, gst_toc_fields[GST_TOC_UID], &val);
+  g_value_unset (&val);
+
+  if (tags != NULL) {
+    g_value_init (&val, GST_TYPE_STRUCTURE);
+    gst_value_set_structure (&val, GST_STRUCTURE (tags));
+    gst_structure_id_set_value (ret, gst_toc_fields[GST_TOC_TAGS], &val);
+    g_value_unset (&val);
+  }
+
+  if (info != NULL) {
+    g_value_init (&val, GST_TYPE_STRUCTURE);
+    gst_value_set_structure (&val, info);
+    gst_structure_id_set_value (ret, gst_toc_fields[GST_TOC_INFO], &val);
+    g_value_unset (&val);
+  }
+
+  return ret;
+}
+
+static guint
+gst_toc_entry_structure_n_subentries (const GstStructure * entry)
+{
+  if (G_UNLIKELY (!gst_structure_id_has_field_typed (entry,
+              gst_toc_fields[GST_TOC_SUBENTRIES], GST_TYPE_ARRAY)))
+    return 0;
+  else
+    return gst_value_array_get_size ((gst_structure_id_get_value (entry,
+                gst_toc_fields[GST_TOC_SUBENTRIES])));
+}
+
+static const GstStructure *
+gst_toc_entry_structure_nth_subentry (const GstStructure * entry, guint nth)
+{
+  guint count;
+  const GValue *array;
+
+  count = gst_toc_entry_structure_n_subentries (entry);
+
+  if (count < nth)
+    return NULL;
+
+  if (G_UNLIKELY (!gst_structure_id_has_field_typed (entry,
+              gst_toc_fields[GST_TOC_SUBENTRIES], GST_TYPE_ARRAY)))
+    return NULL;
+  else {
+    array =
+        gst_value_array_get_value (gst_structure_id_get_value (entry,
+            gst_toc_fields[GST_TOC_SUBENTRIES]), nth);
+    return gst_value_get_structure (array);
+  }
+}
+
+static GstTocEntry *
+gst_toc_entry_from_structure (const GstStructure * entry, guint level)
+{
+  GstTocEntry *ret, *subentry;
+  const GValue *val;
+  const GstStructure *subentry_struct;
+  GstTagList *list;
+  GstStructure *st;
+  gint count, i;
+  const gchar *uid;
+  guint chapters_count = 0, editions_count = 0;
+
+  g_return_val_if_fail (entry != NULL, NULL);
+  g_return_val_if_fail (gst_structure_id_has_field_typed (entry,
+          gst_toc_fields[GST_TOC_UID], G_TYPE_STRING), NULL);
+  g_return_val_if_fail (gst_structure_id_has_field_typed (entry,
+          gst_toc_fields[GST_TOC_TYPE], GST_TYPE_TOC_ENTRY_TYPE), NULL);
+
+  val = gst_structure_id_get_value (entry, gst_toc_fields[GST_TOC_UID]);
+  uid = g_value_get_string (val);
+
+  ret = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_CHAPTER, uid);
+
+  gst_structure_get_enum (entry, GST_TOC_ENTRY_TYPE_FIELD,
+      GST_TYPE_TOC_ENTRY_TYPE, (gint *) & (ret->type));
+
+  if (gst_structure_id_has_field_typed (entry,
+          gst_toc_fields[GST_TOC_SUBENTRIES], GST_TYPE_ARRAY)) {
+    count = gst_toc_entry_structure_n_subentries (entry);
+
+    for (i = 0; i < count; ++i) {
+      subentry_struct = gst_toc_entry_structure_nth_subentry (entry, i);
+      subentry = gst_toc_entry_from_structure (subentry_struct, level + 1);
+
+      /* skip empty editions */
+      if (G_UNLIKELY (subentry->type == GST_TOC_ENTRY_TYPE_EDITION
+              && subentry->subentries == NULL)) {
+        g_warning
+            ("Empty edition found while deserializing TOC from GstStructure, skipping");
+        continue;
+      }
+
+      if (subentry->type == GST_TOC_ENTRY_TYPE_EDITION)
+        ++editions_count;
+      else
+        ++chapters_count;
+
+      /* check for mixed content */
+      if (G_UNLIKELY (chapters_count > 0 && editions_count > 0)) {
+        g_critical
+            ("Mixed editions and chapters in the TOC contents, the TOC is broken");
+        gst_toc_entry_free (subentry);
+        gst_toc_entry_free (ret);
+        return NULL;
+      }
+
+      if (G_UNLIKELY (subentry == NULL)) {
+        gst_toc_entry_free (ret);
+        return NULL;
+      }
+
+      ret->subentries = g_list_prepend (ret->subentries, subentry);
+    }
+
+    ret->subentries = g_list_reverse (ret->subentries);
+  }
+
+  if (gst_structure_id_has_field_typed (entry,
+          gst_toc_fields[GST_TOC_TAGS], GST_TYPE_STRUCTURE)) {
+    val = gst_structure_id_get_value (entry, gst_toc_fields[GST_TOC_TAGS]);
+
+    if (G_LIKELY (GST_IS_TAG_LIST (gst_value_get_structure (val)))) {
+      list = gst_tag_list_copy (GST_TAG_LIST (gst_value_get_structure (val)));
+      gst_tag_list_free (ret->tags);
+      ret->tags = list;
+    }
+  }
+
+  if (gst_structure_id_has_field_typed (entry,
+          gst_toc_fields[GST_TOC_INFO], GST_TYPE_STRUCTURE)) {
+    val = gst_structure_id_get_value (entry, gst_toc_fields[GST_TOC_INFO]);
+
+    if (G_LIKELY (GST_IS_STRUCTURE (gst_value_get_structure (val)))) {
+      st = gst_structure_copy (gst_value_get_structure (val));
+      gst_structure_free (ret->info);
+      ret->info = st;
+    }
+  }
+
+  return ret;
+}
+
+GstToc *
+priv_gst_toc_from_structure (const GstStructure * toc)
+{
+  GstToc *ret;
+  GstTocEntry *subentry;
+  const GstStructure *subentry_struct;
+  const GValue *val;
+  GstTagList *list;
+  GstStructure *st;
+  guint count, i;
+  guint editions_count = 0, chapters_count = 0;
+
+  g_return_val_if_fail (toc != NULL, NULL);
+
+  ret = gst_toc_new ();
+
+  if (gst_structure_id_has_field_typed (toc,
+          gst_toc_fields[GST_TOC_SUBENTRIES], GST_TYPE_ARRAY)) {
+    count = gst_toc_entry_structure_n_subentries (toc);
+
+    for (i = 0; i < count; ++i) {
+      subentry_struct = gst_toc_entry_structure_nth_subentry (toc, i);
+      subentry = gst_toc_entry_from_structure (subentry_struct, 0);
+
+      /* skip empty editions */
+      if (G_UNLIKELY (subentry->type == GST_TOC_ENTRY_TYPE_EDITION
+              && subentry->subentries == NULL)) {
+        g_warning
+            ("Empty edition found while deserializing TOC from GstStructure, skipping");
+        continue;
+      }
+
+      /* check for success */
+      if (G_UNLIKELY (subentry == NULL)) {
+        g_critical ("Couldn't serialize deserializing TOC from GstStructure");
+        gst_toc_free (ret);
+        return NULL;
+      }
+
+      if (subentry->type == GST_TOC_ENTRY_TYPE_EDITION)
+        ++editions_count;
+      else
+        ++chapters_count;
+
+      /* check for mixed content */
+      if (G_UNLIKELY (chapters_count > 0 && editions_count > 0)) {
+        g_critical
+            ("Mixed editions and chapters in the TOC contents, the TOC is broken");
+        gst_toc_entry_free (subentry);
+        gst_toc_free (ret);
+        return NULL;
+      }
+
+      ret->entries = g_list_prepend (ret->entries, subentry);
+    }
+
+    ret->entries = g_list_reverse (ret->entries);
+  }
+
+  if (gst_structure_id_has_field_typed (toc,
+          gst_toc_fields[GST_TOC_TAGS], GST_TYPE_STRUCTURE)) {
+    val = gst_structure_id_get_value (toc, gst_toc_fields[GST_TOC_TAGS]);
+
+    if (G_LIKELY (GST_IS_TAG_LIST (gst_value_get_structure (val)))) {
+      list = gst_tag_list_copy (GST_TAG_LIST (gst_value_get_structure (val)));
+      gst_tag_list_free (ret->tags);
+      ret->tags = list;
+    }
+  }
+
+  if (gst_structure_id_has_field_typed (toc,
+          gst_toc_fields[GST_TOC_INFO], GST_TYPE_STRUCTURE)) {
+    val = gst_structure_id_get_value (toc, gst_toc_fields[GST_TOC_INFO]);
+
+    if (G_LIKELY (GST_IS_STRUCTURE (gst_value_get_structure (val)))) {
+      st = gst_structure_copy (gst_value_get_structure (val));
+      gst_structure_free (ret->info);
+      ret->info = st;
+    }
+  }
+
+  if (G_UNLIKELY (ret->entries == NULL)) {
+    gst_toc_free (ret);
+    return NULL;
+  }
+
+  return ret;
+}
+
+static GstStructure *
+gst_toc_entry_to_structure (const GstTocEntry * entry, guint level)
+{
+  GstStructure *ret, *subentry_struct;
+  GstTocEntry *subentry;
+  GList *cur;
+  GValue subentries_val = { 0 };
+  GValue entry_val = { 0 };
+  guint chapters_count = 0, editions_count = 0;
+
+  g_return_val_if_fail (entry != NULL, NULL);
+
+  ret =
+      gst_toc_entry_structure_new (entry->type, entry->uid, entry->tags,
+      entry->info);
+
+  g_value_init (&subentries_val, GST_TYPE_ARRAY);
+  g_value_init (&entry_val, GST_TYPE_STRUCTURE);
+
+  cur = entry->subentries;
+  while (cur != NULL) {
+    subentry = cur->data;
+
+    if (subentry->type == GST_TOC_ENTRY_TYPE_EDITION)
+      ++editions_count;
+    else
+      ++chapters_count;
+
+    /* check for mixed content */
+    if (G_UNLIKELY (chapters_count > 0 && editions_count > 0)) {
+      g_critical
+          ("Mixed editions and chapters in the TOC contents, the TOC is broken");
+      gst_structure_free (ret);
+      g_value_unset (&entry_val);
+      g_value_unset (&subentries_val);
+      return NULL;
+    }
+
+    /* skip empty editions */
+    if (G_UNLIKELY (subentry->type == GST_TOC_ENTRY_TYPE_EDITION
+            && subentry->subentries == NULL)) {
+      g_warning
+          ("Empty edition found while serializing TOC to GstStructure, skipping");
+      cur = cur->next;
+      continue;
+    }
+
+    subentry_struct = gst_toc_entry_to_structure (subentry, level + 1);
+
+    /* check for success */
+    if (G_UNLIKELY (subentry_struct == NULL)) {
+      gst_structure_free (ret);
+      g_value_unset (&subentries_val);
+      g_value_unset (&entry_val);
+      return NULL;
+    }
+
+    /* skip empty editions */
+    if (G_UNLIKELY (subentry->type == GST_TOC_ENTRY_TYPE_EDITION
+            && subentry->subentries == NULL)) {
+      g_warning
+          ("Empty edition found while serializing TOC to GstStructure, skipping");
+      cur = cur->next;
+      continue;
+    }
+
+    gst_value_set_structure (&entry_val, subentry_struct);
+    gst_value_array_append_value (&subentries_val, &entry_val);
+    gst_structure_free (subentry_struct);
+
+    cur = cur->next;
+  }
+
+  gst_structure_id_set_value (ret, gst_toc_fields[GST_TOC_SUBENTRIES],
+      &subentries_val);
+
+  g_value_unset (&subentries_val);
+  g_value_unset (&entry_val);
+  return ret;
+}
+
+GstStructure *
+priv_gst_toc_to_structure (const GstToc * toc)
+{
+  GValue val = { 0 };
+  GValue subentries_val = { 0 };
+  GstStructure *ret, *subentry_struct;
+  GstTocEntry *subentry;
+  GList *cur;
+  guint editions_count = 0, chapters_count = 0;
+
+  g_return_val_if_fail (toc != NULL, NULL);
+  g_return_val_if_fail (toc->entries != NULL, NULL);
+
+  ret = gst_toc_structure_new (toc->tags, toc->info);
+
+  g_value_init (&val, GST_TYPE_STRUCTURE);
+  g_value_init (&subentries_val, GST_TYPE_ARRAY);
+  cur = toc->entries;
+
+  while (cur != NULL) {
+    subentry = cur->data;
+
+    if (subentry->type == GST_TOC_ENTRY_TYPE_EDITION)
+      ++editions_count;
+    else
+      ++chapters_count;
+
+    /* check for mixed content */
+    if (G_UNLIKELY (chapters_count > 0 && editions_count > 0)) {
+      g_critical
+          ("Mixed editions and chapters in the TOC contents, the TOC is broken");
+      gst_structure_free (ret);
+      g_value_unset (&val);
+      g_value_unset (&subentries_val);
+      return NULL;
+    }
+
+    /* skip empty editions */
+    if (G_UNLIKELY (subentry->type == GST_TOC_ENTRY_TYPE_EDITION
+            && subentry->subentries == NULL)) {
+      g_warning
+          ("Empty edition found while serializing TOC to GstStructure, skipping");
+      cur = cur->next;
+      continue;
+    }
+
+    subentry_struct = gst_toc_entry_to_structure (subentry, 0);
+
+    /* check for success */
+    if (G_UNLIKELY (subentry_struct == NULL)) {
+      g_critical ("Couldn't serialize TOC to GstStructure");
+      gst_structure_free (ret);
+      g_value_unset (&val);
+      g_value_unset (&subentries_val);
+      return NULL;
+    }
+
+    gst_value_set_structure (&val, subentry_struct);
+    gst_value_array_append_value (&subentries_val, &val);
+    gst_structure_free (subentry_struct);
+
+    cur = cur->next;
+  }
+
+  gst_structure_id_set_value (ret, gst_toc_fields[GST_TOC_SUBENTRIES],
+      &subentries_val);
+
+  g_value_unset (&val);
+  g_value_unset (&subentries_val);
+  return ret;
+}
+
+static gboolean
+gst_toc_check_entry_for_uid (const GstTocEntry * entry, const gchar * uid)
+{
+  GList *cur;
+
+  g_return_val_if_fail (entry != NULL, FALSE);
+  g_return_val_if_fail (uid != NULL, FALSE);
+
+  if (g_strcmp0 (entry->uid, uid) == 0)
+    return TRUE;
+
+  cur = entry->subentries;
+  while (cur != NULL) {
+    if (gst_toc_check_entry_for_uid (cur->data, uid))
+      return TRUE;
+    cur = cur->next;
+  }
+
+  return FALSE;
+}
+
+/**
+ * gst_toc_find_entry:
+ * @toc: #GstToc to search in.
+ * @uid: UID to find #GstTocEntry with.
+ *
+ * Find #GstTocEntry with given @uid in the @toc.
+ *
+ * Returns: #GstTocEntry with specified @uid from the @toc, or NULL if not found.
+ *
+ * Since: 0.10.37
+ */
+GstTocEntry *
+gst_toc_find_entry (const GstToc * toc, const gchar * uid)
+{
+  GList *cur;
+
+  g_return_val_if_fail (toc != NULL, NULL);
+  g_return_val_if_fail (uid != NULL, NULL);
+
+  cur = toc->entries;
+  while (cur != NULL) {
+    if (gst_toc_check_entry_for_uid (cur->data, uid))
+      return cur->data;
+    cur = cur->next;
+  }
+
+  return NULL;
+}
+
+/**
+ * gst_toc_entry_copy:
+ * @entry: #GstTocEntry to copy.
+ *
+ * Copy #GstTocEntry with all subentries (deep copy).
+ *
+ * Returns: newly allocated #GstTocEntry in case of success, NULL otherwise;
+ * free it when done with gst_toc_entry_free().
+ *
+ * Since: 0.10.37
+ */
+GstTocEntry *
+gst_toc_entry_copy (const GstTocEntry * entry)
+{
+  GstTocEntry *ret, *sub;
+  GList *cur;
+  GstTagList *list;
+  GstStructure *st;
+
+  g_return_val_if_fail (entry != NULL, NULL);
+
+  ret = gst_toc_entry_new (entry->type, entry->uid);
+
+  if (GST_IS_STRUCTURE (entry->info)) {
+    st = gst_structure_copy (entry->info);
+    gst_structure_free (ret->info);
+    ret->info = st;
+  }
+
+  if (GST_IS_TAG_LIST (entry->tags)) {
+    list = gst_tag_list_copy (entry->tags);
+    gst_tag_list_free (ret->tags);
+    ret->tags = list;
+  }
+
+  cur = entry->pads;
+  while (cur != NULL) {
+    if (GST_IS_PAD (cur->data))
+      ret->pads = g_list_prepend (ret->pads, gst_object_ref (cur->data));
+    cur = cur->next;
+  }
+  ret->pads = g_list_reverse (ret->pads);
+
+  cur = entry->subentries;
+  while (cur != NULL) {
+    sub = gst_toc_entry_copy (cur->data);
+
+    if (sub != NULL)
+      ret->subentries = g_list_prepend (ret->subentries, sub);
+
+    cur = cur->next;
+  }
+  ret->subentries = g_list_reverse (ret->subentries);
+
+  return ret;
+}
+
+/**
+ * gst_toc_copy:
+ * @toc: #GstToc to copy.
+ *
+ * Copy #GstToc with all subentries (deep copy).
+ *
+ * Returns: newly allocated #GstToc in case of success, NULL otherwise;
+ * free it when done with gst_toc_free().
+ *
+ * Since: 0.10.37
+ */
+GstToc *
+gst_toc_copy (const GstToc * toc)
+{
+  GstToc *ret;
+  GstTocEntry *entry;
+  GList *cur;
+  GstTagList *list;
+  GstStructure *st;
+
+  g_return_val_if_fail (toc != NULL, NULL);
+
+  ret = gst_toc_new ();
+
+  if (GST_IS_STRUCTURE (toc->info)) {
+    st = gst_structure_copy (toc->info);
+    gst_structure_free (ret->info);
+    ret->info = st;
+  }
+
+  if (GST_IS_TAG_LIST (toc->tags)) {
+    list = gst_tag_list_copy (toc->tags);
+    gst_tag_list_free (ret->tags);
+    ret->tags = list;
+  }
+
+  cur = toc->entries;
+  while (cur != NULL) {
+    entry = gst_toc_entry_copy (cur->data);
+
+    if (entry != NULL)
+      ret->entries = g_list_prepend (ret->entries, entry);
+
+    cur = cur->next;
+  }
+  ret->entries = g_list_reverse (ret->entries);
+
+  return ret;
+}
+
+/**
+ * gst_toc_entry_set_start_stop:
+ * @entry: #GstTocEntry to set values.
+ * @start: start value to set.
+ * @stop: stop value to set.
+ *
+ * Set @start and @stop values for the @entry.
+ *
+ * Since: 0.10.37
+ */
+void
+gst_toc_entry_set_start_stop (GstTocEntry * entry, gint64 start, gint64 stop)
+{
+  const GValue *val;
+  GstStructure *structure = NULL;
+
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GST_IS_STRUCTURE (entry->info));
+
+  if (gst_structure_id_has_field_typed (entry->info,
+          gst_toc_fields[GST_TOC_TIME], GST_TYPE_STRUCTURE)) {
+    val =
+        gst_structure_id_get_value (entry->info, gst_toc_fields[GST_TOC_TIME]);
+    structure = gst_structure_copy (gst_value_get_structure (val));
+  }
+
+  if (structure == NULL)
+    structure = gst_structure_id_empty_new (gst_toc_fields[GST_TOC_TIMENAME]);
+
+  gst_structure_id_set (structure, gst_toc_fields[GST_TOC_TIME_START],
+      G_TYPE_INT64, start, gst_toc_fields[GST_TOC_TIME_STOP], G_TYPE_INT64,
+      stop, NULL);
+
+  gst_structure_id_set (entry->info, gst_toc_fields[GST_TOC_TIME],
+      GST_TYPE_STRUCTURE, structure, NULL);
+
+  gst_structure_free (structure);
+}
+
+/**
+ * gst_toc_entry_get_start_stop:
+ * @entry: #GstTocEntry to get values from.
+ * @start: (out): the storage for the start value, leave #NULL if not need.
+ * @stop: (out): the storage for the stop value, leave #NULL if not need.
+ *
+ * Get start and stop values from the @entry and write them into appropriate storages.
+ *
+ * Returns: TRUE if all non-NULL storage pointers were filled with appropriate values,
+ * FALSE otherwise.
+ *
+ * Since: 0.10.37
+ */
+gboolean
+gst_toc_entry_get_start_stop (const GstTocEntry * entry, gint64 * start,
+    gint64 * stop)
+{
+  gboolean ret = TRUE;
+  const GValue *val;
+  const GstStructure *structure;
+
+  g_return_val_if_fail (entry != NULL, FALSE);
+  g_return_val_if_fail (GST_IS_STRUCTURE (entry->info), FALSE);
+
+  if (!gst_structure_id_has_field_typed (entry->info,
+          gst_toc_fields[GST_TOC_TIME], GST_TYPE_STRUCTURE))
+    return FALSE;
+
+  val = gst_structure_id_get_value (entry->info, gst_toc_fields[GST_TOC_TIME]);
+  structure = gst_value_get_structure (val);
+
+  if (start != NULL) {
+    if (gst_structure_id_has_field_typed (structure,
+            gst_toc_fields[GST_TOC_TIME_START], G_TYPE_INT64))
+      *start =
+          g_value_get_int64 (gst_structure_id_get_value (structure,
+              gst_toc_fields[GST_TOC_TIME_START]));
+    else
+      ret = FALSE;
+  }
+
+  if (stop != NULL) {
+    if (gst_structure_id_has_field_typed (structure,
+            gst_toc_fields[GST_TOC_TIME_STOP], G_TYPE_INT64))
+      *stop =
+          g_value_get_int64 (gst_structure_id_get_value (structure,
+              gst_toc_fields[GST_TOC_TIME_STOP]));
+    else
+      ret = FALSE;
+  }
+
+  return ret;
+}
+
+gboolean
+priv_gst_toc_structure_get_updated (const GstStructure * toc)
+{
+  const GValue *val;
+
+  g_return_val_if_fail (GST_IS_STRUCTURE (toc), FALSE);
+
+  if (G_LIKELY (gst_structure_id_has_field_typed (toc,
+              gst_toc_fields[GST_TOC_UPDATED], G_TYPE_BOOLEAN))) {
+    val = gst_structure_id_get_value (toc, gst_toc_fields[GST_TOC_UPDATED]);
+    return g_value_get_boolean (val);
+  }
+
+  return FALSE;
+}
+
+void
+priv_gst_toc_structure_set_updated (GstStructure * toc, gboolean updated)
+{
+  GValue val = { 0 };
+
+  g_return_if_fail (toc != NULL);
+
+  g_value_init (&val, G_TYPE_BOOLEAN);
+  g_value_set_boolean (&val, updated);
+  gst_structure_id_set_value (toc, gst_toc_fields[GST_TOC_UPDATED], &val);
+  g_value_unset (&val);
+}
+
+gchar *
+priv_gst_toc_structure_get_extend_uid (const GstStructure * toc)
+{
+  const GValue *val;
+
+  g_return_val_if_fail (GST_IS_STRUCTURE (toc), NULL);
+
+  if (G_LIKELY (gst_structure_id_has_field_typed (toc,
+              gst_toc_fields[GST_TOC_EXTENDUID], G_TYPE_STRING))) {
+    val = gst_structure_id_get_value (toc, gst_toc_fields[GST_TOC_EXTENDUID]);
+    return g_strdup (g_value_get_string (val));
+  }
+
+  return NULL;
+}
+
+void
+priv_gst_toc_structure_set_extend_uid (GstStructure * toc,
+    const gchar * extend_uid)
+{
+  GValue val = { 0 };
+
+  g_return_if_fail (toc != NULL);
+  g_return_if_fail (extend_uid != NULL);
+
+  g_value_init (&val, G_TYPE_STRING);
+  g_value_set_string (&val, extend_uid);
+  gst_structure_id_set_value (toc, gst_toc_fields[GST_TOC_EXTENDUID], &val);
+  g_value_unset (&val);
+}
diff --git a/gst/gsttoc.h b/gst/gsttoc.h
new file mode 100644
index 0000000..a817efe
--- /dev/null
+++ b/gst/gsttoc.h
@@ -0,0 +1,111 @@
+/* GStreamer
+ * (c) 2010, 2012 Alexander Saprykin <xelfium@gmail.com>
+ *
+ * gsttoc.h: generic TOC API declaration
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_TOC_H__
+#define __GST_TOC_H__
+
+#include <gst/gstconfig.h>
+#include <gst/gsttaglist.h>
+#include <gst/gstformat.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GstTocEntry GstTocEntry;
+typedef struct _GstToc GstToc;
+
+/**
+ * GstTocEntryType:
+ * @GST_TOC_ENTRY_TYPE_CHAPTER: a chapter type entry.
+ * @GST_TOC_ENTRY_TYPE_EDITION: an edition entry (angle or alternative in other terms).
+ *
+ * The different types of TOC entry.
+ */
+typedef enum {
+  GST_TOC_ENTRY_TYPE_CHAPTER     = 0,
+  GST_TOC_ENTRY_TYPE_EDITION     = 1
+} GstTocEntryType;
+
+/**
+ * GstTocEntry:
+ * @uid: unique (for a whole TOC) id of the entry. This value should be persistent and
+ * should not be changed while updating TOC. @uid should be handled as "opaque" value
+ * without meaning (e.g. applications should not assume the /editionX/chapterY/chapter/Z structure,
+ * other demuxers could do something else), it should help to track updates of certain entries.
+ * @type: #GstTocEntryType of this entry.
+ * @subentries: list of #GstTocEntry children.
+ * @pads: list of #GstPad objects, related to this #GstTocEntry.
+ * @tags: tags related to this entry.
+ * @info: extra information related to this entry.
+ *
+ * Definition of TOC entry structure.
+ */
+struct _GstTocEntry {
+  gchar *uid;
+  GstTocEntryType type;
+  GList *subentries;
+  GList *pads;
+  GstTagList *tags;
+  GstStructure *info;
+
+  /*< private >*/
+  gpointer _gst_reserved[GST_PADDING];
+};
+
+/* FIXME: pad member should be GstPad type, but that's
+ * impossible due to recursive includes */
+
+/**
+ * GstToc:
+ * @entries: list of #GstTocEntry entries of the TOC.
+ * @tags: tags related to the whole TOC.
+ * @info: extra information related to the TOC.
+ *
+ * Definition of TOC structure.
+ */
+struct _GstToc {
+  GList *entries;
+  GstTagList *tags;
+  GstStructure *info;
+
+  /*< private >*/
+  gpointer _gst_reserved[GST_PADDING];
+};
+
+/* functions to create new structures */
+GstToc *        gst_toc_new                     (void);
+GstTocEntry *   gst_toc_entry_new               (GstTocEntryType type, const gchar *uid);
+GstTocEntry *   gst_toc_entry_new_with_pad      (GstTocEntryType type, const gchar *uid, gpointer pad);
+
+/* functions to free structures */
+void            gst_toc_entry_free              (GstTocEntry *entry);
+void            gst_toc_free                    (GstToc *toc);
+
+GstTocEntry *   gst_toc_find_entry              (const GstToc *toc, const gchar *uid);
+GstTocEntry *   gst_toc_entry_copy              (const GstTocEntry *entry);
+GstToc      *   gst_toc_copy                    (const GstToc *toc);
+
+void            gst_toc_entry_set_start_stop    (GstTocEntry *entry, gint64 start, gint64 stop);
+gboolean        gst_toc_entry_get_start_stop    (const GstTocEntry *entry, gint64 *start, gint64 *stop);
+
+G_END_DECLS
+
+#endif /* __GST_TOC_H__ */
+
diff --git a/gst/gsttocsetter.c b/gst/gsttocsetter.c
new file mode 100644
index 0000000..bee9b34
--- /dev/null
+++ b/gst/gsttocsetter.c
@@ -0,0 +1,362 @@
+/* GStreamer
+ * Copyright (C) 2010, 2012 Alexander Saprykin <xelfium@gmail.com>
+ *
+ * gsttocsetter.c: interface for TOC setting on elements
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:gsttocsetter
+ * @short_description: Element interface that allows setting and retrieval
+ *                     of the TOC
+ *
+ * Element interface that allows setting of the TOC.
+ *
+ * Elements that support some kind of chapters or editions (or tracks like in
+ * the FLAC cue sheet) will implement this interface.
+ * 
+ * If you just want to retrieve the TOC in your application then all you
+ * need to do is watch for TOC messages on your pipeline's bus (or you can
+ * perform TOC query). This interface is only for setting TOC data, not for
+ * extracting it. To set TOC from the application, find proper tocsetter element
+ * and set TOC using gst_toc_setter_set_toc().
+ * 
+ * Elements implementing the #GstTocSetter interface can extend existing TOC
+ * by getting extend UID for that (you can use gst_toc_find_entry() to retrieve it)
+ * with any TOC entries received from downstream.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "gst_private.h"
+#include "gsttocsetter.h"
+#include <gobject/gvaluecollector.h>
+#include <string.h>
+
+GST_DEBUG_CATEGORY_STATIC (gst_toc_interface_debug);
+#define GST_CAT_DEFAULT tag_toc_interface_debug
+
+static GQuark gst_toc_key;
+
+typedef struct
+{
+  GstToc *toc;
+  GStaticMutex lock;
+} GstTocData;
+
+GType
+gst_toc_setter_get_type (void)
+{
+  static volatile gsize toc_setter_type = 0;
+
+  if (g_once_init_enter (&toc_setter_type)) {
+    GType _type;
+    static const GTypeInfo toc_setter_info = {
+      sizeof (GstTocSetterIFace),       /* class_size */
+      NULL,                     /* base_init */
+      NULL,                     /* base_finalize */
+      NULL,
+      NULL,                     /* class_finalize */
+      NULL,                     /* class_data */
+      0,
+      0,
+      NULL
+    };
+
+    GST_DEBUG_CATEGORY_INIT (gst_toc_interface_debug, "GstTocInterface", 0,
+        "interfaces for the TOC");
+
+    _type = g_type_register_static (G_TYPE_INTERFACE, "GstTocSetter",
+        &toc_setter_info, 0);
+
+    g_type_interface_add_prerequisite (_type, GST_TYPE_ELEMENT);
+
+    gst_toc_key = g_quark_from_static_string ("GST_TOC_SETTER");
+    g_once_init_leave (&toc_setter_type, _type);
+  }
+
+  return toc_setter_type;
+}
+
+static void
+gst_toc_data_free (gpointer p)
+{
+  GstTocData *data = (GstTocData *) p;
+
+  if (data->toc)
+    gst_toc_free (data->toc);
+
+  g_static_mutex_free (&data->lock);
+
+  g_slice_free (GstTocData, data);
+}
+
+static GstTocData *
+gst_toc_setter_get_data (GstTocSetter * setter)
+{
+  GstTocData *data;
+
+  data = g_object_get_qdata (G_OBJECT (setter), gst_toc_key);
+  if (!data) {
+    static GStaticMutex create_mutex = G_STATIC_MUTEX_INIT;
+
+    /* make sure no other thread is creating a GstTocData at the same time */
+    g_static_mutex_lock (&create_mutex);
+    data = g_object_get_qdata (G_OBJECT (setter), gst_toc_key);
+    if (!data) {
+      data = g_slice_new (GstTocData);
+      g_static_mutex_init (&data->lock);
+      data->toc = NULL;
+      g_object_set_qdata_full (G_OBJECT (setter), gst_toc_key, data,
+          gst_toc_data_free);
+    }
+    g_static_mutex_unlock (&create_mutex);
+  }
+
+  return data;
+}
+
+/**
+ * gst_toc_setter_reset_toc:
+ * @setter: a #GstTocSetter.
+ *
+ * Reset the internal TOC. Elements should call this from within the
+ * state-change handler.
+ *
+ * Since: 0.10.37
+ */
+void
+gst_toc_setter_reset_toc (GstTocSetter * setter)
+{
+  GstTocData *data;
+
+  g_return_if_fail (GST_IS_TOC_SETTER (setter));
+
+  data = gst_toc_setter_get_data (setter);
+
+  g_static_mutex_lock (&data->lock);
+  if (data->toc) {
+    gst_toc_free (data->toc);
+    data->toc = NULL;
+  }
+  g_static_mutex_unlock (&data->lock);
+}
+
+/**
+ * gst_toc_setter_get_toc:
+ * @setter: a #GstTocSetter.
+ *
+ * Return current TOC the setter uses. The TOC should not be
+ * modified or freed.
+ *
+ * This function is not thread-safe. Use gst_toc_setter_get_toc_copy() instead.
+ *
+ * Returns: a current snapshot of the TOC used in the setter
+ *          or NULL if none is used.
+ *
+ * Since: 0.10.37
+ */
+const GstToc *
+gst_toc_setter_get_toc (GstTocSetter * setter)
+{
+  g_return_val_if_fail (GST_IS_TOC_SETTER (setter), NULL);
+
+  return gst_toc_setter_get_data (setter)->toc;
+}
+
+/**
+ * gst_toc_setter_get_toc_copy:
+ * @setter: a #GstTocSetter.
+ *
+ * Return current TOC the setter uses. The difference between this
+ * function and gst_toc_setter_get_toc() is that this function returns deep
+ * copy of the TOC, so you can modify it in any way. This function is thread-safe.
+ * Free it when done with gst_toc_free().
+ *
+ * Returns: a copy of the current snapshot of the TOC used in the setter
+ *          or NULL if none is used.
+ *
+ * Since: 0.10.37
+ */
+GstToc *
+gst_toc_setter_get_toc_copy (GstTocSetter * setter)
+{
+  GstTocData *data;
+  GstToc *ret = NULL;
+
+  g_return_val_if_fail (GST_IS_TOC_SETTER (setter), NULL);
+
+  data = gst_toc_setter_get_data (setter);
+  g_static_mutex_lock (&data->lock);
+
+  if (data->toc != NULL)
+    ret = gst_toc_copy (data->toc);
+
+  g_static_mutex_unlock (&data->lock);
+
+  return ret;
+}
+
+/**
+ * gst_toc_setter_set_toc:
+ * @setter: a #GstTocSetter.
+ * @toc: a #GstToc to set.
+ *
+ * Set the given TOC on the setter. Previously setted TOC will be
+ * freed before setting a new one.
+ *
+ * Since: 0.10.37
+ */
+void
+gst_toc_setter_set_toc (GstTocSetter * setter, const GstToc * toc)
+{
+  GstTocData *data;
+
+  g_return_if_fail (GST_IS_TOC_SETTER (setter));
+
+  data = gst_toc_setter_get_data (setter);
+
+  g_static_mutex_lock (&data->lock);
+  if (data->toc)
+    gst_toc_free (data->toc);
+
+  data->toc = gst_toc_copy (toc);
+
+  g_static_mutex_unlock (&data->lock);
+}
+
+/**
+ * gst_toc_setter_get_toc_entry:
+ * @setter: a #GstTocSetter.
+ * @uid: UID to find entry with.
+ *
+ * Return #GstTocEntry (if any) with given @uid. Returned entry should
+ * not be modified or freed.
+ *
+ * This function is not thread-safe. Use gst_toc_setter_get_toc_entry_copy() instead.
+ *
+ * Returns: a TOC entry with given @uid from the TOC in the setter
+ *          or NULL if none entry with such @uid was found.
+ *
+ * Since: 0.10.37
+ */
+const GstTocEntry *
+gst_toc_setter_get_toc_entry (GstTocSetter * setter, const gchar * uid)
+{
+  GstTocData *data;
+  const GstTocEntry *ret;
+
+  g_return_val_if_fail (GST_IS_TOC_SETTER (setter), NULL);
+  g_return_val_if_fail (uid != NULL, NULL);
+
+  data = gst_toc_setter_get_data (setter);
+
+  g_static_mutex_lock (&data->lock);
+
+  ret = gst_toc_find_entry (data->toc, uid);
+
+  g_static_mutex_unlock (&data->lock);
+
+  return ret;
+}
+
+/**
+ * gst_toc_setter_get_toc_entry_copy:
+ * @setter: a #GstTocSetter.
+ * @uid: UID to find entry with.
+ *
+ * Return #GstTocEntry (if any) with given @uid. It perform a deep copying,
+ * so you can modify returned value. Free it when done with gst_toc_entry_free().
+ * This function is thread-safe.
+ *
+ * Returns: a TOC entry with given @uid from the TOC in the setter
+ *          or NULL if none entry with such @uid was found.
+ *
+ * Since: 0.10.37
+ */
+GstTocEntry *
+gst_toc_setter_get_toc_entry_copy (GstTocSetter * setter, const gchar * uid)
+{
+  GstTocData *data;
+  GstTocEntry *ret = NULL;
+  const GstTocEntry *search;
+
+  g_return_val_if_fail (GST_IS_TOC_SETTER (setter), NULL);
+  g_return_val_if_fail (uid != NULL, NULL);
+
+  data = gst_toc_setter_get_data (setter);
+
+  g_static_mutex_lock (&data->lock);
+
+  search = gst_toc_find_entry (data->toc, uid);
+  if (search != NULL)
+    ret = gst_toc_entry_copy (search);
+
+  g_static_mutex_unlock (&data->lock);
+
+  return ret;
+}
+
+/**
+ * gst_toc_setter_add_toc_entry:
+ * @setter: a #GstTocSetter.
+ * @parent_uid: UID of the parent entry to append given @entry. Use 0 for the TOC root level.
+ * @entry: #GstTocEntry to append.
+ *
+ * Try to find entry with given @parent_uid and append an @entry to that #GstTocEntry.
+ *
+ * Returns: TRUE if entry with @parent_uid was found, FALSE otherwise.
+ *
+ * Since: 0.10.37
+ */
+gboolean
+gst_toc_setter_add_toc_entry (GstTocSetter * setter, const gchar * parent_uid,
+    const GstTocEntry * entry)
+{
+  GstTocData *data;
+  GstTocEntry *parent;
+  GstTocEntry *copy_entry;
+  gboolean ret = FALSE;
+
+  g_return_val_if_fail (GST_IS_TOC_SETTER (setter), FALSE);
+  g_return_val_if_fail (parent_uid != NULL, FALSE);
+  g_return_val_if_fail (entry != NULL, FALSE);
+
+  data = gst_toc_setter_get_data (setter);
+
+  g_static_mutex_lock (&data->lock);
+
+  copy_entry = gst_toc_entry_copy (entry);
+
+  if (g_strcmp0 (parent_uid, "0") == 0)
+    data->toc->entries = g_list_append (data->toc->entries, copy_entry);
+  else {
+    parent = gst_toc_find_entry (data->toc, parent_uid);
+
+    if (parent != NULL) {
+      parent->subentries = g_list_append (parent->subentries, copy_entry);
+      ret = TRUE;
+    }
+  }
+
+  g_static_mutex_unlock (&data->lock);
+
+  return ret;
+}
diff --git a/gst/gsttocsetter.h b/gst/gsttocsetter.h
new file mode 100644
index 0000000..2174e0d
--- /dev/null
+++ b/gst/gsttocsetter.h
@@ -0,0 +1,67 @@
+/* GStreamer
+ * Copyright (C) 2010, 2012 Alexander Saprykin <xelfium@gmail.com>
+ *
+ * gsttocsetter.h: Interfaces for TOC
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_TOC_SETTER_H__
+#define __GST_TOC_SETTER_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+#define GST_TYPE_TOC_SETTER		        (gst_toc_setter_get_type ())
+#define GST_TOC_SETTER(obj)		        (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TOC_SETTER, GstTocSetter))
+#define GST_IS_TOC_SETTER(obj)		    (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TOC_SETTER))
+#define GST_TOC_SETTER_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), GST_TYPE_TOC_SETTER, GstTocSetterIFace))
+/**
+ * GstTocSetter:
+ *
+ * Opaque #GstTocSetter data structure.
+ */
+typedef struct _GstTocSetter GstTocSetter;
+typedef struct _GstTocSetterIFace GstTocSetterIFace;
+
+/**
+ * GstTocSetterIFace:
+ * @g_iface: parent interface type.
+ *
+ * #GstTocSetterIFace interface.
+ */
+
+struct _GstTocSetterIFace
+{
+  GTypeInterface g_iface;
+
+  /* signals */
+
+  /* virtual table */
+};
+
+GType               gst_toc_setter_get_type (void);
+void                gst_toc_setter_reset_toc (GstTocSetter *setter);
+const GstToc *      gst_toc_setter_get_toc (GstTocSetter *setter);
+GstToc *            gst_toc_setter_get_toc_copy (GstTocSetter *setter);
+void                gst_toc_setter_set_toc (GstTocSetter *setter, const GstToc *toc);
+const GstTocEntry * gst_toc_setter_get_toc_entry (GstTocSetter *setter, const gchar *uid);
+GstTocEntry *       gst_toc_setter_get_toc_entry_copy (GstTocSetter *setter, const gchar *uid);
+gboolean            gst_toc_setter_add_toc_entry (GstTocSetter *setter, const gchar *parent_uid, const GstTocEntry *entry);
+
+G_END_DECLS
+#endif /* __GST_TOC_SETTER_H__ */
+
diff --git a/gst/gstvalue.c b/gst/gstvalue.c
index 4f2b80d..bf9bb13 100644
--- a/gst/gstvalue.c
+++ b/gst/gstvalue.c
@@ -1315,8 +1315,9 @@ gst_value_free_fraction_range (GValue * value)
   GValue *vals = (GValue *) value->data[0].v_pointer;
 
   if (vals != NULL) {
-    g_value_unset (&vals[0]);
-    g_value_unset (&vals[1]);
+    /* we know the two values contain fractions without internal allocs */
+    /* g_value_unset (&vals[0]); */
+    /* g_value_unset (&vals[1]); */
     g_slice_free1 (2 * sizeof (GValue), vals);
     value->data[0].v_pointer = NULL;
   }
@@ -1465,8 +1466,9 @@ gst_value_set_fraction_range_full (GValue * value,
   gst_value_set_fraction (&end, numerator_end, denominator_end);
   gst_value_set_fraction_range (value, &start, &end);
 
-  g_value_unset (&start);
-  g_value_unset (&end);
+  /* we know the two values contain fractions without internal allocs */
+  /* g_value_unset (&start); */
+  /* g_value_unset (&end);   */
 }
 
 /**
diff --git a/gstreamer.doap b/gstreamer.doap
index 63d4fdc..d569497 100644
--- a/gstreamer.doap
+++ b/gstreamer.doap
@@ -40,18 +40,6 @@ hierarchy, and a set of media-agnostic core elements.
 
  <release>
   <Version>
-   <revision>0.10.36</revision>
-   <branch>0.10</branch>
-   <name>Harder</name>
-   <created>2012-02-20</created>
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gstreamer/gstreamer-0.10.36.tar.bz2" />
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gstreamer/gstreamer-0.10.36.tar.gz" />
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gstreamer/gstreamer-0.10.36.tar.xz" />
-  </Version>
- </release>
-
- <release>
-  <Version>
    <revision>0.10.35</revision>
    <branch>0.10</branch>
    <name>Nuclear Fission</name>
diff --git a/libs/gst/base/gstbaseparse.c b/libs/gst/base/gstbaseparse.c
index 1da663c..56a0818 100644
--- a/libs/gst/base/gstbaseparse.c
+++ b/libs/gst/base/gstbaseparse.c
@@ -276,8 +276,6 @@ struct _GstBaseParsePrivate
   guint max_bitrate;
   guint posted_avg_bitrate;
 
-  GList *pending_events;
-
   /* frames/buffers that are queued and ready to go on OK */
   GQueue queued_frames;
 
@@ -316,9 +314,10 @@ struct _GstBaseParsePrivate
   GstClockTime last_ts;
   gint64 last_offset;
 
+  /* Pending serialized events */
+  GList *pending_events;
   /* Newsegment event to be sent after SEEK */
-  GstEvent *pending_segment;
-
+  gboolean pending_segment;
   /* Segment event that closes the running segment prior to SEEK */
   GstEvent *close_segment;
 
@@ -456,6 +455,19 @@ gst_base_parse_clear_queues (GstBaseParse * parse)
   g_list_free (parse->priv->detect_buffers);
   parse->priv->detect_buffers = NULL;
   parse->priv->detect_buffers_size = 0;
+
+  g_queue_foreach (&parse->priv->queued_frames,
+      (GFunc) gst_base_parse_frame_free, NULL);
+  g_queue_clear (&parse->priv->queued_frames);
+
+  gst_buffer_replace (&parse->priv->cache, NULL);
+
+  g_list_foreach (parse->priv->pending_events, (GFunc) gst_event_unref, NULL);
+  g_list_free (parse->priv->pending_events);
+  parse->priv->pending_events = NULL;
+  parse->priv->pending_segment = FALSE;
+
+  gst_event_replace (&parse->priv->close_segment, NULL);
 }
 
 static void
@@ -466,10 +478,6 @@ gst_base_parse_finalize (GObject * object)
 
   g_object_unref (parse->priv->adapter);
 
-  if (parse->priv->pending_segment) {
-    p_ev = &parse->priv->pending_segment;
-    gst_event_replace (p_ev, NULL);
-  }
   if (parse->priv->close_segment) {
     p_ev = &parse->priv->close_segment;
     gst_event_replace (p_ev, NULL);
@@ -484,10 +492,7 @@ gst_base_parse_finalize (GObject * object)
       NULL);
   g_list_free (parse->priv->pending_events);
   parse->priv->pending_events = NULL;
-
-  g_queue_foreach (&parse->priv->queued_frames,
-      (GFunc) gst_base_parse_frame_free, NULL);
-  g_queue_clear (&parse->priv->queued_frames);
+  parse->priv->pending_segment = FALSE;
 
   if (parse->priv->index) {
     gst_object_unref (parse->priv->index);
@@ -757,15 +762,13 @@ gst_base_parse_reset (GstBaseParse * parse)
   parse->priv->last_ts = GST_CLOCK_TIME_NONE;
   parse->priv->last_offset = 0;
 
-  if (parse->priv->pending_segment) {
-    gst_event_unref (parse->priv->pending_segment);
-    parse->priv->pending_segment = NULL;
-  }
-
   g_list_foreach (parse->priv->pending_events, (GFunc) gst_mini_object_unref,
       NULL);
   g_list_free (parse->priv->pending_events);
   parse->priv->pending_events = NULL;
+  parse->priv->pending_segment = FALSE;
+
+  gst_event_replace (&parse->priv->close_segment, NULL);
 
   if (parse->priv->cache) {
     gst_buffer_unref (parse->priv->cache);
@@ -910,9 +913,10 @@ gst_base_parse_sink_event (GstPad * pad, GstEvent * event)
   GST_DEBUG_OBJECT (parse, "handling event %d, %s", GST_EVENT_TYPE (event),
       GST_EVENT_TYPE_NAME (event));
 
-  /* Cache all events except EOS, NEWSEGMENT and FLUSH_STOP if we have a
+  /* Cache all serialized events except EOS, NEWSEGMENT and FLUSH_STOP if we have a
    * pending segment */
-  if (parse->priv->pending_segment && GST_EVENT_TYPE (event) != GST_EVENT_EOS
+  if (parse->priv->pending_segment && GST_EVENT_IS_SERIALIZED (event)
+      && GST_EVENT_TYPE (event) != GST_EVENT_EOS
       && GST_EVENT_TYPE (event) != GST_EVENT_NEWSEGMENT
       && GST_EVENT_TYPE (event) != GST_EVENT_FLUSH_START
       && GST_EVENT_TYPE (event) != GST_EVENT_FLUSH_STOP) {
@@ -925,7 +929,6 @@ gst_base_parse_sink_event (GstPad * pad, GstEvent * event)
         g_list_append (parse->priv->pending_events, event);
     ret = TRUE;
   } else {
-
     if (GST_EVENT_TYPE (event) == GST_EVENT_EOS &&
         parse->priv->framecount < MIN_FRAMES_TO_POST_BITRATE)
       /* We've not posted bitrate tags yet - do so now */
@@ -962,7 +965,6 @@ static gboolean
 gst_base_parse_sink_eventfunc (GstBaseParse * parse, GstEvent * event)
 {
   gboolean handled = FALSE;
-  GstEvent **eventp;
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_NEWSEGMENT:
@@ -1053,9 +1055,9 @@ gst_base_parse_sink_eventfunc (GstBaseParse * parse, GstEvent * event)
       /* save the segment for later, right before we push a new buffer so that
        * the caps are fixed and the next linked element can receive
        * the segment. */
-      eventp = &parse->priv->pending_segment;
-      gst_event_replace (eventp, event);
-      gst_event_unref (event);
+      parse->priv->pending_events =
+          g_list_append (parse->priv->pending_events, event);
+      parse->priv->pending_segment = TRUE;
       handled = TRUE;
 
       /* but finish the current segment */
@@ -1107,10 +1109,16 @@ gst_base_parse_sink_eventfunc (GstBaseParse * parse, GstEvent * event)
         GST_ELEMENT_ERROR (parse, STREAM, WRONG_TYPE,
             ("No valid frames found before end of stream"), (NULL));
       }
-      /* newsegment before eos */
-      if (parse->priv->pending_segment) {
-        gst_pad_push_event (parse->srcpad, parse->priv->pending_segment);
-        parse->priv->pending_segment = NULL;
+      /* newsegment and other serialized events before eos */
+      if (G_UNLIKELY (parse->priv->pending_events)) {
+        GList *l;
+
+        for (l = parse->priv->pending_events; l != NULL; l = l->next) {
+          gst_pad_push_event (parse->srcpad, GST_EVENT (l->data));
+        }
+        g_list_free (parse->priv->pending_events);
+        parse->priv->pending_events = NULL;
+        parse->priv->pending_segment = FALSE;
       }
       break;
 
@@ -1827,27 +1835,36 @@ gst_base_parse_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
   /* should have caps by now */
   g_return_val_if_fail (GST_PAD_CAPS (parse->srcpad), GST_FLOW_ERROR);
 
+  if (G_UNLIKELY (parse->priv->pending_segment)) {
+    /* have caps; check identity */
+    gst_base_parse_check_media (parse);
+  }
+
+  /* and should then also be linked downstream, so safe to send some events */
+  if (G_UNLIKELY (parse->priv->close_segment)) {
+    /* only set up by loop */
+    GST_DEBUG_OBJECT (parse, "loop sending close segment");
+    gst_pad_push_event (parse->srcpad, parse->priv->close_segment);
+    parse->priv->close_segment = NULL;
+  }
+
+  /* Push pending events, including NEWSEGMENT events */
+  if (G_UNLIKELY (parse->priv->pending_events)) {
+    GList *l;
+
+    for (l = parse->priv->pending_events; l != NULL; l = l->next) {
+      gst_pad_push_event (parse->srcpad, GST_EVENT (l->data));
+    }
+    g_list_free (parse->priv->pending_events);
+    parse->priv->pending_events = NULL;
+    parse->priv->pending_segment = FALSE;
+  }
+
   /* segment adjustment magic; only if we are running the whole show */
   if (!parse->priv->passthrough && parse->segment.rate > 0.0 &&
       (parse->priv->pad_mode == GST_ACTIVATE_PULL ||
           parse->priv->upstream_seekable)) {
-    /* segment times are typically estimates,
-     * actual frame data might lead subclass to different timestamps,
-     * so override segment start from what is supplied there */
-    if (G_UNLIKELY (parse->priv->pending_segment && !parse->priv->exact_position
-            && GST_CLOCK_TIME_IS_VALID (last_start))) {
-      gst_event_unref (parse->priv->pending_segment);
-      parse->segment.start =
-          MIN ((guint64) last_start, (guint64) parse->segment.stop);
-      GST_DEBUG_OBJECT (parse,
-          "adjusting pending segment start to %" GST_TIME_FORMAT,
-          GST_TIME_ARGS (parse->segment.start));
-      parse->priv->pending_segment =
-          gst_event_new_new_segment (FALSE, parse->segment.rate,
-          parse->segment.format, parse->segment.start,
-          parse->segment.stop, parse->segment.start);
-    }
-    /* handle gaps, e.g. non-zero start-time, in as much not handled by above */
+    /* handle gaps */
     if (GST_CLOCK_TIME_IS_VALID (parse->segment.last_stop) &&
         GST_CLOCK_TIME_IS_VALID (last_start)) {
       GstClockTimeDiff diff;
@@ -1866,27 +1883,20 @@ gst_base_parse_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
             "Sending updated NEWSEGMENT events", diff,
             GST_TIME_ARGS (parse->segment.last_stop),
             GST_TIME_ARGS (last_start));
-        if (G_UNLIKELY (parse->priv->pending_segment)) {
-          gst_event_unref (parse->priv->pending_segment);
-          parse->segment.start = last_start;
-          parse->priv->pending_segment =
-              gst_event_new_new_segment (FALSE, parse->segment.rate,
-              parse->segment.format, parse->segment.start,
-              parse->segment.stop, parse->segment.start);
-        } else {
-          /* send newsegment events such that the gap is not accounted in
-           * accum time, hence running_time */
-          /* close ahead of gap */
-          gst_pad_push_event (parse->srcpad,
-              gst_event_new_new_segment (TRUE, parse->segment.rate,
-                  parse->segment.format, parse->segment.last_stop,
-                  parse->segment.last_stop, parse->segment.last_stop));
-          /* skip gap */
-          gst_pad_push_event (parse->srcpad,
-              gst_event_new_new_segment (FALSE, parse->segment.rate,
-                  parse->segment.format, last_start,
-                  parse->segment.stop, last_start));
-        }
+
+        /* send newsegment events such that the gap is not accounted in
+         * accum time, hence running_time */
+        /* close ahead of gap */
+        gst_pad_push_event (parse->srcpad,
+            gst_event_new_new_segment (TRUE, parse->segment.rate,
+                parse->segment.format, parse->segment.last_stop,
+                parse->segment.last_stop, parse->segment.last_stop));
+        /* skip gap */
+        gst_pad_push_event (parse->srcpad,
+            gst_event_new_new_segment (FALSE, parse->segment.rate,
+                parse->segment.format, last_start,
+                parse->segment.stop, last_start));
+
         /* align segment view with downstream,
          * prevents double-counting accum when closing segment */
         gst_segment_set_newsegment (&parse->segment, FALSE,
@@ -1897,41 +1907,10 @@ gst_base_parse_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
     }
   }
 
-  /* and should then also be linked downstream, so safe to send some events */
-  if (G_UNLIKELY (parse->priv->close_segment)) {
-    /* only set up by loop */
-    GST_DEBUG_OBJECT (parse, "loop sending close segment");
-    gst_pad_push_event (parse->srcpad, parse->priv->close_segment);
-    parse->priv->close_segment = NULL;
-  }
-  if (G_UNLIKELY (parse->priv->pending_segment)) {
-    GstEvent *pending_segment;
-
-    pending_segment = parse->priv->pending_segment;
-    parse->priv->pending_segment = NULL;
-
-    GST_DEBUG_OBJECT (parse, "%s push pending segment",
-        parse->priv->pad_mode == GST_ACTIVATE_PULL ? "loop" : "chain");
-    gst_pad_push_event (parse->srcpad, pending_segment);
-
-    /* have caps; check identity */
-    gst_base_parse_check_media (parse);
-  }
-
   /* update bitrates and optionally post corresponding tags
    * (following newsegment) */
   gst_base_parse_update_bitrates (parse, frame);
 
-  if (G_UNLIKELY (parse->priv->pending_events)) {
-    GList *l;
-
-    for (l = parse->priv->pending_events; l != NULL; l = l->next) {
-      gst_pad_push_event (parse->srcpad, GST_EVENT (l->data));
-    }
-    g_list_free (parse->priv->pending_events);
-    parse->priv->pending_events = NULL;
-  }
-
   if (klass->pre_push_frame) {
     ret = klass->pre_push_frame (parse, frame);
   } else {
@@ -2487,7 +2466,7 @@ gst_base_parse_chain (GstPad * pad, GstBuffer * buffer)
     ret = gst_base_parse_handle_and_push_frame (parse, bclass, frame);
     GST_PAD_STREAM_UNLOCK (parse->srcpad);
 
-    if (ret != GST_FLOW_OK) {
+    if (ret != GST_FLOW_OK && ret != GST_FLOW_NOT_LINKED) {
       GST_LOG_OBJECT (parse, "push returned %d", ret);
       break;
     }
@@ -2891,11 +2870,18 @@ pause:
       push_eos = TRUE;
     }
     if (push_eos) {
-      /* newsegment before eos */
-      if (parse->priv->pending_segment) {
-        gst_pad_push_event (parse->srcpad, parse->priv->pending_segment);
-        parse->priv->pending_segment = NULL;
+      /* Push pending events, including NEWSEGMENT events */
+      if (G_UNLIKELY (parse->priv->pending_events)) {
+        GList *l;
+
+        for (l = parse->priv->pending_events; l != NULL; l = l->next) {
+          gst_pad_push_event (parse->srcpad, GST_EVENT (l->data));
+        }
+        g_list_free (parse->priv->pending_events);
+        parse->priv->pending_events = NULL;
+        parse->priv->pending_segment = FALSE;
       }
+
       gst_pad_push_event (parse->srcpad, gst_event_new_eos ());
     }
     gst_object_unref (parse);
@@ -2992,9 +2978,15 @@ gst_base_parse_sink_activate_pull (GstPad * sinkpad, gboolean active)
 
   if (result) {
     if (active) {
-      parse->priv->pending_segment = gst_event_new_new_segment (FALSE,
+      GstEvent *event;
+
+      event = gst_event_new_new_segment (FALSE,
           parse->segment.rate, parse->segment.format,
           parse->segment.start, parse->segment.stop, parse->segment.last_stop);
+      parse->priv->pending_events =
+          g_list_append (parse->priv->pending_events, event);
+      parse->priv->pending_segment = TRUE;
+
       result &=
           gst_pad_start_task (sinkpad, (GstTaskFunction) gst_base_parse_loop,
           sinkpad);
@@ -3845,14 +3837,11 @@ gst_base_parse_handle_seek (GstBaseParse * parse, GstEvent * event)
     memcpy (&parse->segment, &seeksegment, sizeof (GstSegment));
 
     /* store the newsegment event so it can be sent from the streaming thread. */
-    if (parse->priv->pending_segment)
-      gst_event_unref (parse->priv->pending_segment);
-
-    /* This will be sent later in _loop() */
-    parse->priv->pending_segment =
+    parse->priv->pending_segment = TRUE;
+    parse->priv->pending_events = g_list_append (parse->priv->pending_events,
         gst_event_new_new_segment (FALSE, parse->segment.rate,
-        parse->segment.format, parse->segment.start,
-        parse->segment.stop, parse->segment.start);
+            parse->segment.format, parse->segment.start,
+            parse->segment.stop, parse->segment.start));
 
     GST_DEBUG_OBJECT (parse, "Created newseg format %d, "
         "start = %" GST_TIME_FORMAT ", stop = %" GST_TIME_FORMAT
@@ -3910,7 +3899,7 @@ gst_base_parse_handle_seek (GstBaseParse * parse, GstEvent * event)
        seek event (in bytes) to upstream. Segment / flush handling happens
        in corresponding src event handlers */
     GST_DEBUG_OBJECT (parse, "seek in PUSH mode");
-    if (seekstop >= 0 && seekpos <= seekpos)
+    if (seekstop >= 0 && seekstop <= seekpos)
       seekstop = seekpos;
     new_event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags,
         GST_SEEK_TYPE_SET, seekpos, stop_type, seekstop);
diff --git a/libs/gst/base/gstbasetransform.c b/libs/gst/base/gstbasetransform.c
index 4408ef2..e1fbaa9 100644
--- a/libs/gst/base/gstbasetransform.c
+++ b/libs/gst/base/gstbasetransform.c
@@ -2220,6 +2220,19 @@ gst_base_transform_sink_event (GstPad * pad, GstEvent * event)
     } else {
       delay = GST_EVENT_IS_SERIALIZED (event) && !caps_set
           && GST_EVENT_TYPE (event) != GST_EVENT_EOS;
+
+      /* do not stall sparse stream update newsegment events */
+      if (delay && (GST_EVENT_TYPE (event) == GST_EVENT_NEWSEGMENT)) {
+        gboolean update;
+
+        gst_event_parse_new_segment_full (event, &update, NULL, NULL, NULL,
+            NULL, NULL, NULL);
+        if (update) {
+          GST_DEBUG_OBJECT (trans, "update segment; triggering delayed events");
+          delay = FALSE;
+          caps_set = TRUE;
+        }
+      }
     }
 
     if (delay) {
@@ -2642,7 +2655,7 @@ gst_base_transform_chain (GstPad * pad, GstBuffer * buffer)
   /* outbuf can be NULL, this means a dropped buffer, if we have a buffer but
    * GST_BASE_TRANSFORM_FLOW_DROPPED we will not push either. */
   if (outbuf != NULL) {
-    if ((ret == GST_FLOW_OK)) {
+    if (ret == GST_FLOW_OK) {
       GstClockTime last_stop_out = GST_CLOCK_TIME_NONE;
 
       /* Remember last stop position */
diff --git a/libs/gst/base/gstcollectpads.c b/libs/gst/base/gstcollectpads.c
index 7fb0bf4..681102f 100644
--- a/libs/gst/base/gstcollectpads.c
+++ b/libs/gst/base/gstcollectpads.c
@@ -806,7 +806,7 @@ gst_collect_pads_pop (GstCollectPads * pads, GstCollectData * data)
 }
 
 /* pop and unref the currently queued buffer, should e called with the LOCK
- * helt. */
+ * held. */
 static void
 gst_collect_pads_clear (GstCollectPads * pads, GstCollectData * data)
 {
diff --git a/libs/gst/base/gstcollectpads2.c b/libs/gst/base/gstcollectpads2.c
index a2fdd6b..7bf4ec6 100644
--- a/libs/gst/base/gstcollectpads2.c
+++ b/libs/gst/base/gstcollectpads2.c
@@ -278,10 +278,10 @@ gst_collect_pads2_finalize (GObject * object)
  *
  * Create a new instance of #GstCollectsPads.
  *
- * Returns: a new #GstCollectPads2, or NULL in case of an error.
- *
  * MT safe.
  *
+ * Returns: (transfer full): a new #GstCollectPads2, or NULL in case of an error.
+ *
  * Since: 0.10.36
  */
 GstCollectPads2 *
@@ -307,7 +307,7 @@ gst_collect_pads2_set_buffer_function_locked (GstCollectPads2 * pads,
  * gst_collect_pads2_set_buffer_function:
  * @pads: the collectpads to use
  * @func: the function to set
- * @user_data: user data passed to the function
+ * @user_data: (closure): user data passed to the function
  *
  * Set the callback function and user data that will be called with
  * the oldest buffer when all pads have been collected.
@@ -332,7 +332,7 @@ gst_collect_pads2_set_buffer_function (GstCollectPads2 * pads,
  * gst_collect_pads2_set_compare_function:
  * @pads: the pads to use
  * @func: the function to set
- * @user_data: user data passed to the function
+ * @user_data: (closure): user data passed to the function
  *
  * Set the timestamp comparison function.
  *
@@ -449,6 +449,48 @@ gst_collect_pads2_set_event_function (GstCollectPads2 * pads,
   GST_OBJECT_UNLOCK (pads);
 }
 
+/**
+* gst_collect_pads2_clip_running_time:
+* @pads: the collectspads to use
+* @cdata: collect data of corresponding pad
+* @buf: buffer being clipped
+* @outbuf: output buffer with running time, or NULL if clipped
+* @user_data: user data (unused)
+*
+* Convenience clipping function that converts incoming buffer's timestamp
+* to running time, or clips the buffer if outside configured segment.
+*
+* Since: 0.10.37
+*/
+GstFlowReturn
+gst_collect_pads2_clip_running_time (GstCollectPads2 * pads,
+    GstCollectData2 * cdata, GstBuffer * buf, GstBuffer ** outbuf,
+    gpointer user_data)
+{
+  GstClockTime time;
+
+  *outbuf = buf;
+  time = GST_BUFFER_TIMESTAMP (buf);
+
+  /* invalid left alone and passed */
+  if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (time))) {
+    time = gst_segment_to_running_time (&cdata->segment, GST_FORMAT_TIME, time);
+    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time))) {
+      GST_DEBUG_OBJECT (cdata->pad, "clipping buffer on pad outside segment");
+      gst_buffer_unref (buf);
+      *outbuf = NULL;
+    } else {
+      GST_LOG_OBJECT (cdata->pad, "buffer ts %" GST_TIME_FORMAT " -> %"
+          GST_TIME_FORMAT " running time",
+          GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)), GST_TIME_ARGS (time));
+      *outbuf = gst_buffer_make_metadata_writable (buf);
+      GST_BUFFER_TIMESTAMP (*outbuf) = time;
+    }
+  }
+
+  return GST_FLOW_OK;
+}
+
  /**
  * gst_collect_pads2_set_clip_function:
  * @pads: the collectspads to use
@@ -474,7 +516,7 @@ gst_collect_pads2_set_clip_function (GstCollectPads2 * pads,
 /**
  * gst_collect_pads2_add_pad:
  * @pads: the collectspads to use
- * @pad: the pad to add
+ * @pad: (transfer none): the pad to add
  * @size: the size of the returned #GstCollectData2 structure
  *
  * Add a pad to the collection of collect pads. The pad has to be
@@ -488,14 +530,14 @@ gst_collect_pads2_set_clip_function (GstCollectPads2 * pads,
  * The pad will be automatically activated in push mode when @pads is
  * started.
  *
- * This function calls gst_collect_pads2_add_pad() passing a value of NULL
+ * This function calls gst_collect_pads2_add_pad_full() passing a value of NULL
  * for destroy_notify and TRUE for locked.
  *
+ * MT safe.
+ *
  * Returns: a new #GstCollectData2 to identify the new pad. Or NULL
  *   if wrong parameters are supplied.
  *
- * MT safe.
- *
  * Since: 0.10.36
  */
 GstCollectData2 *
@@ -507,7 +549,7 @@ gst_collect_pads2_add_pad (GstCollectPads2 * pads, GstPad * pad, guint size)
 /**
  * gst_collect_pads2_add_pad_full:
  * @pads: the collectspads to use
- * @pad: the pad to add
+ * @pad: (transfer none): the pad to add
  * @size: the size of the returned #GstCollectData2 structure
  * @destroy_notify: function to be called before the returned #GstCollectData2
  * structure is freed
@@ -537,12 +579,12 @@ gst_collect_pads2_add_pad (GstCollectPads2 * pads, GstPad * pad, guint size)
  * The pad will be automatically activated in push mode when @pads is
  * started.
  *
+ * MT safe.
+ *
  * Since: 0.10.36
  *
  * Returns: a new #GstCollectData2 to identify the new pad. Or NULL
  *   if wrong parameters are supplied.
- *
- * MT safe.
  */
 GstCollectData2 *
 gst_collect_pads2_add_pad_full (GstCollectPads2 * pads, GstPad * pad,
@@ -605,7 +647,7 @@ find_pad (GstCollectData2 * data, GstPad * pad)
 /**
  * gst_collect_pads2_remove_pad:
  * @pads: the collectspads to use
- * @pad: the pad to remove
+ * @pad: (transfer none): the pad to remove
  *
  * Remove a pad from the collection of collect pads. This function will also
  * free the #GstCollectData2 and all the resources that were allocated with
@@ -613,10 +655,10 @@ find_pad (GstCollectData2 * data, GstPad * pad)
  *
  * The pad will be deactivated automatically when @pads is stopped.
  *
- * Returns: %TRUE if the pad could be removed.
- *
  * MT safe.
  *
+ * Returns: %TRUE if the pad could be removed.
+ *
  * Since: 0.10.36
  */
 gboolean
@@ -700,10 +742,10 @@ unknown_pad:
  *
  * This function is currently not implemented.
  *
- * Returns: %TRUE if the pad is active.
- *
  * MT safe.
  *
+ * Returns: %TRUE if the pad is active.
+ *
  * Since: 0.10.36
  */
 gboolean
@@ -728,10 +770,10 @@ gst_collect_pads2_is_active (GstCollectPads2 * pads, GstPad * pad)
  *
  * This function is currently not implemented.
  *
- * Returns: #GstFlowReturn of the operation.
- *
  * MT safe.
  *
+ * Returns: #GstFlowReturn of the operation.
+ *
  * Since: 0.10.36
  */
 GstFlowReturn
@@ -756,10 +798,10 @@ gst_collect_pads2_collect (GstCollectPads2 * pads)
  *
  * This function is currently not implemented.
  *
- * Returns: #GstFlowReturn of the operation.
- *
  * MT safe.
  *
+ * Returns: #GstFlowReturn of the operation.
+ *
  * Since: 0.10.36
  */
 GstFlowReturn
@@ -819,7 +861,6 @@ gst_collect_pads2_set_flushing_unlocked (GstCollectPads2 * pads,
  *
  * MT safe.
  *
- *
  * Since: 0.10.36
  */
 void
@@ -946,11 +987,11 @@ gst_collect_pads2_stop (GstCollectPads2 * pads)
  * should be called with the @pads STREAM_LOCK held, such as in the callback
  * handler.
  *
+ * MT safe.
+ *
  * Returns: The buffer in @data or NULL if no buffer is queued.
  *  should unref the buffer after usage.
  *
- * MT safe.
- *
  * Since: 0.10.36
  */
 GstBuffer *
@@ -980,11 +1021,11 @@ gst_collect_pads2_peek (GstCollectPads2 * pads, GstCollectData2 * data)
  * should be called with the @pads STREAM_LOCK held, such as in the callback
  * handler.
  *
- * Returns: The buffer in @data or NULL if no buffer was queued.
- *   You should unref the buffer after usage.
- *
  * MT safe.
  *
+ * Returns: (transfer full): The buffer in @data or NULL if no buffer was
+ *   queued. You should unref the buffer after usage.
+ *
  * Since: 0.10.36
  */
 GstBuffer *
@@ -1034,11 +1075,11 @@ gst_collect_pads2_clear (GstCollectPads2 * pads, GstCollectData2 * data)
  * This function should be called with @pads STREAM_LOCK held, such as
  * in the callback.
  *
+ * MT safe.
+ *
  * Returns: The maximum number of bytes queued on all pads. This function
  * returns 0 if a pad has no queued buffer.
  *
- * MT safe.
- *
  * Since: 0.10.36
  */
 /* we might pre-calculate this in some struct field,
@@ -1098,7 +1139,7 @@ not_filled:
  * gst_collect_pads2_read:
  * @pads: the collectspads to query
  * @data: the data to use
- * @bytes: a pointer to a byte array
+ * @bytes: (out) (transfer none) (array length=size): a pointer to a byte array
  * @size: the number of bytes to read
  *
  * Get a pointer in @bytes where @size bytes can be read from the
@@ -1107,12 +1148,12 @@ not_filled:
  * This function should be called with @pads STREAM_LOCK held, such as
  * in the callback.
  *
+ * MT safe.
+ *
  * Returns: The number of bytes available for consumption in the
  * memory pointed to by @bytes. This can be less than @size and
  * is 0 if the pad is end-of-stream.
  *
- * MT safe.
- *
  * Since: 0.10.36
  */
 guint
@@ -1149,11 +1190,11 @@ gst_collect_pads2_read (GstCollectPads2 * pads, GstCollectData2 * data,
  * This function should be called with @pads STREAM_LOCK held, such as
  * in the callback.
  *
+ * MT safe.
+ *
  * Returns: The number of bytes flushed This can be less than @size and
  * is 0 if the pad was end-of-stream.
  *
- * MT safe.
- *
  * Since: 0.10.36
  */
 guint
@@ -1194,13 +1235,13 @@ gst_collect_pads2_flush (GstCollectPads2 * pads, GstCollectData2 * data,
  * This function should be called with @pads STREAM_LOCK held, such as in the
  * callback.
  *
+ * MT safe.
+ *
  * Since: 0.10.36
  *
- * Returns: A sub buffer. The size of the buffer can be less that requested.
+ * Returns: (transfer full): A sub buffer. The size of the buffer can be less that requested.
  * A return of NULL signals that the pad is end-of-stream.
  * Unref the buffer after use.
- *
- * MT safe.
  */
 GstBuffer *
 gst_collect_pads2_read_buffer (GstCollectPads2 * pads, GstCollectData2 * data,
@@ -1234,13 +1275,13 @@ gst_collect_pads2_read_buffer (GstCollectPads2 * pads, GstCollectData2 * data,
  * This function should be called with @pads STREAM_LOCK held, such as in the
  * callback.
  *
+ * MT safe.
+ *
  * Since: 0.10.36
  *
  * Returns: A sub buffer. The size of the buffer can be less that requested.
  * A return of NULL signals that the pad is end-of-stream.
  * Unref the buffer after use.
- *
- * MT safe.
  */
 GstBuffer *
 gst_collect_pads2_take_buffer (GstCollectPads2 * pads, GstCollectData2 * data,
@@ -1287,7 +1328,7 @@ gst_collect_pads2_set_waiting (GstCollectPads2 * pads, GstCollectData2 * data,
   /* Do something only on a change and if not locked */
   if (!GST_COLLECT_PADS2_STATE_IS_SET (data, GST_COLLECT_PADS2_STATE_LOCKED) &&
       (GST_COLLECT_PADS2_STATE_IS_SET (data, GST_COLLECT_PADS2_STATE_WAITING) !=
-          ! !waiting)) {
+          !!waiting)) {
     /* Set waiting state for this pad */
     if (waiting)
       GST_COLLECT_PADS2_STATE_SET (data, GST_COLLECT_PADS2_STATE_WAITING);
@@ -1452,8 +1493,14 @@ gst_collect_pads2_recalculate_waiting (GstCollectPads2 * pads)
     int cmp_res;
 
     /* check if pad has a segment */
-    if (data->segment.format == GST_FORMAT_UNDEFINED)
-      continue;
+    if (data->segment.format == GST_FORMAT_UNDEFINED) {
+      GST_WARNING_OBJECT (pads,
+          "GstCollectPads2 has no time segment, assuming 0 based.");
+      gst_segment_init (&data->segment, GST_FORMAT_TIME);
+      gst_segment_set_newsegment (&data->segment, FALSE, 1.0f,
+          GST_FORMAT_TIME, 0, -1, 0);
+      GST_COLLECT_PADS2_STATE_SET (data, GST_COLLECT_PADS2_STATE_NEW_SEGMENT);
+    }
 
     /* check segment format */
     if (data->segment.format != GST_FORMAT_TIME) {
@@ -1662,8 +1709,8 @@ gst_collect_pads2_event (GstPad * pad, GstEvent * event)
 
   pads = data->collect;
 
-  GST_DEBUG ("Got %s event on pad %s:%s", GST_EVENT_TYPE_NAME (event),
-      GST_DEBUG_PAD_NAME (data->pad));
+  GST_DEBUG_OBJECT (data->pad, "Got %s event on sink pad from %s",
+      GST_EVENT_TYPE_NAME (event), GST_OBJECT_NAME (GST_EVENT_SRC (event)));
 
   GST_OBJECT_LOCK (pads);
   event_func = pads->priv->event_func;
@@ -1677,8 +1724,10 @@ gst_collect_pads2_event (GstPad * pad, GstEvent * event)
       /* forward event to unblock check_collected */
       if (event_func)
         res = event_func (pads, data, event, event_user_data);
-      if (!res)
+      if (!res) {
+        GST_DEBUG_OBJECT (pad, "forwarding flush start");
         res = gst_pad_event_default (pad, event);
+      }
 
       /* now unblock the chain function.
        * no cond per pad, so they all unblock, 
@@ -1765,6 +1814,14 @@ gst_collect_pads2_event (GstPad * pad, GstEvent * event)
           ", stop %" GST_TIME_FORMAT, GST_TIME_ARGS (start),
           GST_TIME_ARGS (stop));
 
+      /* default collection can not handle other segment formats than time */
+      if (buffer_func && format != GST_FORMAT_TIME) {
+        GST_WARNING_OBJECT (pads, "GstCollectPads2 default collecting "
+            "can only handle time segments. Non time segment ignored.");
+        goto newsegment_done;
+      }
+
+      /* accept segment */
       gst_segment_set_newsegment_full (&data->segment, update, rate, arate,
           format, start, stop, time);
 
@@ -1774,13 +1831,6 @@ gst_collect_pads2_event (GstPad * pad, GstEvent * event)
       if (!buffer_func)
         goto newsegment_done;
 
-      /* default collection can not handle other segment formats than time */
-      if (format != GST_FORMAT_TIME) {
-        GST_ERROR_OBJECT (pads, "GstCollectPads2 default collecting "
-            "can only handle time segments.");
-        goto newsegment_done;
-      }
-
       /* If oldest time is not known, or current pad got newsegment;
        * recalculate the state */
       if (!pads->priv->earliest_data || pads->priv->earliest_data == data) {
@@ -1816,8 +1866,10 @@ forward_or_default:
   }
   if (event_func)
     res = event_func (pads, data, event, event_user_data);
-  if (!res)
+  if (!res) {
+    GST_DEBUG_OBJECT (pad, "forwarding %s", GST_EVENT_TYPE_NAME (event));
     res = gst_pad_event_default (pad, event);
+  }
   if (need_unlock)
     GST_COLLECT_PADS2_STREAM_UNLOCK (pads);
   goto done;
diff --git a/libs/gst/base/gstcollectpads2.h b/libs/gst/base/gstcollectpads2.h
index 03414e9..1fb0085 100644
--- a/libs/gst/base/gstcollectpads2.h
+++ b/libs/gst/base/gstcollectpads2.h
@@ -260,7 +260,7 @@ typedef GstFlowReturn (*GstCollectPads2ClipFunction) (GstCollectPads2 *pads, Gst
  *
  * Since: 0.10.36
  */
-#define GST_COLLECT_PADS2_STREAM_LOCK(pads)     (g_static_rec_mutex_lock(GST_COLLECT_PADS2_GET_STREAM_LOCK (pads)))
+#define GST_COLLECT_PADS2_STREAM_LOCK(pads)     g_static_rec_mutex_lock(GST_COLLECT_PADS2_GET_STREAM_LOCK (pads))
 /**
  * GST_COLLECT_PADS2_STREAM_UNLOCK:
  * @pads: a #GstCollectPads2
@@ -269,7 +269,7 @@ typedef GstFlowReturn (*GstCollectPads2ClipFunction) (GstCollectPads2 *pads, Gst
  *
  * Since: 0.10.36
  */
-#define GST_COLLECT_PADS2_STREAM_UNLOCK(pads)   (g_static_rec_mutex_unlock(GST_COLLECT_PADS2_GET_STREAM_LOCK (pads)))
+#define GST_COLLECT_PADS2_STREAM_UNLOCK(pads)   g_static_rec_mutex_unlock(GST_COLLECT_PADS2_GET_STREAM_LOCK (pads))
 
 /**
  * GstCollectPads2:
@@ -352,6 +352,11 @@ GstBuffer*	gst_collect_pads2_take_buffer	(GstCollectPads2 * pads, GstCollectData
 void		gst_collect_pads2_set_waiting	(GstCollectPads2 *pads, GstCollectData2 *data,
 						 gboolean waiting);
 
+/* convenience helper */
+GstFlowReturn	gst_collect_pads2_clip_running_time (GstCollectPads2 * pads,
+						GstCollectData2 * cdata, GstBuffer * buf, GstBuffer ** outbuf,
+                                                gpointer user_data);
+
 
 G_END_DECLS
 
diff --git a/libs/gst/check/Makefile.am b/libs/gst/check/Makefile.am
index 8dcf66d..6115d99 100644
--- a/libs/gst/check/Makefile.am
+++ b/libs/gst/check/Makefile.am
@@ -83,6 +83,7 @@ LIBGSTCHECK_EXPORTED_FUNCS = \
 	gst_check_teardown_pad_by_name \
 	gst_check_teardown_sink_pad \
 	gst_check_teardown_src_pad \
+	gst_consistency_checker_add_pad \
 	gst_consistency_checker_new \
 	gst_consistency_checker_reset \
 	gst_consistency_checker_free
diff --git a/libs/gst/check/gstconsistencychecker.c b/libs/gst/check/gstconsistencychecker.c
index ded047e..242f949 100644
--- a/libs/gst/check/gstconsistencychecker.c
+++ b/libs/gst/check/gstconsistencychecker.c
@@ -3,6 +3,7 @@
  * unit testing helper lib
  *
  * Copyright (C) 2009 Edward Hervey <bilboed@bilboed.com>
+ * Copyright (C) 2012 Stefan Sauer <ensonic@users.sf.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -34,17 +35,29 @@
 
 struct _GstStreamConsistency
 {
-  gboolean flushing;
-  gboolean newsegment;
-  gboolean eos;
-  gulong probeid;
-  GstPad *pad;
+  /* FIXME: do we want to track some states per pad? */
+  volatile gboolean flushing;
+  volatile gboolean newsegment;
+  volatile gboolean eos;
+  volatile gboolean expect_flush;
+  GstObject *parent;
+  GList *pads;
 };
 
+typedef struct _GstStreamConsistencyProbe
+{
+  GstPad *pad;
+  gulong probeid;
+} GstStreamConsistencyProbe;
+
+
 static gboolean
 source_pad_data_cb (GstPad * pad, GstMiniObject * data,
     GstStreamConsistency * consist)
 {
+  GST_DEBUG_OBJECT (pad, "%p: %d %d %d %d", consist, consist->flushing,
+      consist->newsegment, consist->eos, consist->expect_flush);
+
   if (GST_IS_BUFFER (data)) {
     GST_DEBUG_OBJECT (pad, "Buffer %" GST_TIME_FORMAT,
         GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (GST_BUFFER (data))));
@@ -58,6 +71,9 @@ source_pad_data_cb (GstPad * pad, GstMiniObject * data,
     GST_DEBUG_OBJECT (pad, "%s", GST_EVENT_TYPE_NAME (event));
     switch (GST_EVENT_TYPE (event)) {
       case GST_EVENT_FLUSH_START:
+        /* getting two flush_start in a row seems to be okay
+           fail_if (consist->flushing, "Received another FLUSH_START");
+         */
         consist->flushing = TRUE;
         break;
       case GST_EVENT_FLUSH_STOP:
@@ -65,9 +81,11 @@ source_pad_data_cb (GstPad * pad, GstMiniObject * data,
         fail_unless (consist->flushing,
             "Received a FLUSH_STOP without a FLUSH_START");
         fail_if (consist->eos, "Received a FLUSH_STOP after an EOS");
-        consist->flushing = FALSE;
+        consist->flushing = consist->expect_flush = FALSE;
         break;
       case GST_EVENT_NEWSEGMENT:
+        fail_if ((consist->expect_flush && consist->flushing),
+            "Received NEWSEGMENT while in a flushing seek");
         consist->newsegment = TRUE;
         consist->eos = FALSE;
         break;
@@ -93,6 +111,69 @@ source_pad_data_cb (GstPad * pad, GstMiniObject * data,
   return TRUE;
 }
 
+static gboolean
+sink_pad_data_cb (GstPad * pad, GstMiniObject * data,
+    GstStreamConsistency * consist)
+{
+  GST_DEBUG_OBJECT (pad, "%p: %d %d %d %d", consist, consist->flushing,
+      consist->newsegment, consist->eos, consist->expect_flush);
+
+  if (GST_IS_BUFFER (data)) {
+    GST_DEBUG_OBJECT (pad, "Buffer %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (GST_BUFFER (data))));
+    /* If an EOS went through, a buffer would be invalid */
+    fail_if (consist->eos, "Buffer received after EOS");
+    /* Buffers need to be preceded by a newsegment event */
+    fail_unless (consist->newsegment, "Buffer received without newsegment");
+  } else if (GST_IS_EVENT (data)) {
+    GstEvent *event = (GstEvent *) data;
+
+    GST_DEBUG_OBJECT (pad, "%s", GST_EVENT_TYPE_NAME (event));
+    switch (GST_EVENT_TYPE (event)) {
+      case GST_EVENT_SEEK:
+      {
+        GstSeekFlags flags;
+
+        gst_event_parse_seek (event, NULL, NULL, &flags, NULL, NULL, NULL,
+            NULL);
+        consist->expect_flush =
+            ((flags & GST_SEEK_FLAG_FLUSH) == GST_SEEK_FLAG_FLUSH);
+        break;
+      }
+      case GST_EVENT_NEWSEGMENT:
+        fail_if ((consist->expect_flush && consist->flushing),
+            "Received NEWSEGMENT while in a flushing seek");
+        consist->newsegment = TRUE;
+        consist->eos = FALSE;
+        break;
+      default:
+        /* FIXME : Figure out what to do for other events */
+        break;
+    }
+  }
+
+  return TRUE;
+}
+
+static void
+add_pad (GstStreamConsistency * consist, GstPad * pad)
+{
+  GstStreamConsistencyProbe *p;
+  GstPadDirection dir;
+
+  p = g_new0 (GstStreamConsistencyProbe, 1);
+  p->pad = g_object_ref (pad);
+  dir = gst_pad_get_direction (pad);
+  if (dir == GST_PAD_SRC) {
+    p->probeid =
+        gst_pad_add_data_probe (pad, (GCallback) source_pad_data_cb, consist);
+  } else if (dir == GST_PAD_SINK) {
+    p->probeid =
+        gst_pad_add_data_probe (pad, (GCallback) sink_pad_data_cb, consist);
+  }
+  consist->pads = g_list_prepend (consist->pads, p);
+}
+
 /**
  * gst_consistency_checker_new:
  * @pad: The #GstPad on which the dataflow will be checked.
@@ -100,13 +181,10 @@ source_pad_data_cb (GstPad * pad, GstMiniObject * data,
  * Sets up a data probe on the given pad which will raise assertions if the
  * data flow is inconsistent.
  *
- * Currently only works for source pads.
- *
  * Returns: A #GstStreamConsistency structure used to track data flow.
  *
  * Since: 0.10.24
  */
-
 GstStreamConsistency *
 gst_consistency_checker_new (GstPad * pad)
 {
@@ -115,14 +193,38 @@ gst_consistency_checker_new (GstPad * pad)
   g_return_val_if_fail (pad != NULL, NULL);
 
   consist = g_new0 (GstStreamConsistency, 1);
-  consist->pad = g_object_ref (pad);
-  consist->probeid =
-      gst_pad_add_data_probe (pad, (GCallback) source_pad_data_cb, consist);
 
+  if (!consist->pads) {
+    consist->parent = GST_OBJECT_PARENT (pad);
+  }
+  add_pad (consist, pad);
   return consist;
 }
 
 /**
+ * gst_consistency_checker_add_pad:
+ * @consist: The #GstStreamConsistency handle
+ * @pad: The #GstPad on which the dataflow will be checked.
+ *
+ * Sets up a data probe on the given pad which will raise assertions if the
+ * data flow is inconsistent.
+ *
+ * Returns: %TRUE if the pad was added
+ *
+ * Since: 0.10.37
+ */
+gboolean
+gst_consistency_checker_add_pad (GstStreamConsistency * consist, GstPad * pad)
+{
+  g_return_val_if_fail (consist != NULL, FALSE);
+  g_return_val_if_fail (pad != NULL, FALSE);
+  g_return_val_if_fail (GST_OBJECT_PARENT (pad) == consist->parent, FALSE);
+
+  add_pad (consist, pad);
+  return TRUE;
+}
+
+/**
  * gst_consistency_checker_reset:
  * @consist: The #GstStreamConsistency to reset.
  *
@@ -143,7 +245,7 @@ gst_consistency_checker_reset (GstStreamConsistency * consist)
  * gst_consistency_checker_free:
  * @consist: The #GstStreamConsistency to free.
  *
- * Frees the allocated data and probe associated with @consist.
+ * Frees the allocated data and probes associated with @consist.
  *
  * Since: 0.10.24
  */
@@ -151,8 +253,16 @@ gst_consistency_checker_reset (GstStreamConsistency * consist)
 void
 gst_consistency_checker_free (GstStreamConsistency * consist)
 {
-  /* Remove the data probe */
-  gst_pad_remove_data_probe (consist->pad, consist->probeid);
-  g_object_unref (consist->pad);
+  GList *node;
+  GstStreamConsistencyProbe *p;
+
+  /* Remove the data probes */
+  for (node = consist->pads; node; node = g_list_next (node)) {
+    p = (GstStreamConsistencyProbe *) node->data;
+    gst_pad_remove_data_probe (p->pad, p->probeid);
+    g_object_unref (p->pad);
+    g_free (p);
+  }
+  g_list_free (consist->pads);
   g_free (consist);
 }
diff --git a/libs/gst/check/gstconsistencychecker.h b/libs/gst/check/gstconsistencychecker.h
index ec88af7..4cbf3f8 100644
--- a/libs/gst/check/gstconsistencychecker.h
+++ b/libs/gst/check/gstconsistencychecker.h
@@ -37,11 +37,13 @@ G_BEGIN_DECLS
 typedef struct _GstStreamConsistency GstStreamConsistency;
 
 
-GstStreamConsistency * gst_consistency_checker_new   (GstPad * pad);
+GstStreamConsistency * gst_consistency_checker_new     (GstPad * pad);
+gboolean               gst_consistency_checker_add_pad (GstStreamConsistency * consist,
+                                                        GstPad * pad);
 
-void                   gst_consistency_checker_reset (GstStreamConsistency * consist);
+void                   gst_consistency_checker_reset   (GstStreamConsistency * consist);
 
-void                   gst_consistency_checker_free  (GstStreamConsistency * consist);
+void                   gst_consistency_checker_free    (GstStreamConsistency * consist);
 
 G_END_DECLS
 
diff --git a/libs/gst/check/libcheck/check.h.in b/libs/gst/check/libcheck/check.h.in
index 231fdbb..3ed1acd 100644
--- a/libs/gst/check/libcheck/check.h.in
+++ b/libs/gst/check/libcheck/check.h.in
@@ -232,7 +232,7 @@ static void __testname (int _i CK_ATTRIBUTE_UNUSED)\
         "Failure '"#expr"' occured" , ## __VA_ARGS__, NULL)
 
 /* Always fail */
-#define fail(...) _fail_unless(0, __FILE__, __LINE__, "Failed" , ## __VA_ARGS__, NULL)
+#define fail(...) _fail_unless(0, __FILE__, __LINE__, "Failed"  __VA_ARGS__, NULL)
 
 /* Non macro version of #fail_unless, with more complicated interface */
 void CK_EXPORT _fail_unless (int result, const char *file,
diff --git a/libs/gst/controller/gstinterpolationcontrolsource.c b/libs/gst/controller/gstinterpolationcontrolsource.c
index 2bdefeb..1dd0a89 100644
--- a/libs/gst/controller/gstinterpolationcontrolsource.c
+++ b/libs/gst/controller/gstinterpolationcontrolsource.c
@@ -51,8 +51,6 @@ GST_DEBUG_CATEGORY_EXTERN (GST_CAT_DEFAULT);
 G_DEFINE_TYPE (GstInterpolationControlSource, gst_interpolation_control_source,
     GST_TYPE_CONTROL_SOURCE);
 
-static GObjectClass *parent_class = NULL;
-
 /*
  * gst_control_point_free:
  * @prop: the object to free
@@ -672,13 +670,14 @@ gst_interpolation_control_source_finalize (GObject * obj)
   gst_interpolation_control_source_reset (self);
   g_mutex_unlock (self->lock);
   g_mutex_free (self->lock);
-  G_OBJECT_CLASS (parent_class)->finalize (obj);
+  G_OBJECT_CLASS (gst_interpolation_control_source_parent_class)->finalize
+      (obj);
 }
 
 static void
 gst_interpolation_control_source_dispose (GObject * obj)
 {
-  G_OBJECT_CLASS (parent_class)->dispose (obj);
+  G_OBJECT_CLASS (gst_interpolation_control_source_parent_class)->dispose (obj);
 }
 
 static void
@@ -688,7 +687,6 @@ gst_interpolation_control_source_class_init (GstInterpolationControlSourceClass
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
   GstControlSourceClass *csource_class = GST_CONTROL_SOURCE_CLASS (klass);
 
-  parent_class = g_type_class_peek_parent (klass);
   g_type_class_add_private (klass,
       sizeof (GstInterpolationControlSourcePrivate));
 
diff --git a/libs/gst/controller/gstlfocontrolsource.c b/libs/gst/controller/gstlfocontrolsource.c
index 6139687..f462fdd 100644
--- a/libs/gst/controller/gstlfocontrolsource.c
+++ b/libs/gst/controller/gstlfocontrolsource.c
@@ -608,8 +608,6 @@ gst_lfo_waveform_get_type (void)
 G_DEFINE_TYPE (GstLFOControlSource, gst_lfo_control_source,
     GST_TYPE_CONTROL_SOURCE);
 
-static GObjectClass *parent_class = NULL;
-
 static void
 gst_lfo_control_source_reset (GstLFOControlSource * self)
 {
@@ -953,13 +951,13 @@ gst_lfo_control_source_finalize (GObject * obj)
     self->lock = NULL;
   }
 
-  G_OBJECT_CLASS (parent_class)->finalize (obj);
+  G_OBJECT_CLASS (gst_lfo_control_source_parent_class)->finalize (obj);
 }
 
 static void
 gst_lfo_control_source_dispose (GObject * obj)
 {
-  G_OBJECT_CLASS (parent_class)->dispose (obj);
+  G_OBJECT_CLASS (gst_lfo_control_source_parent_class)->dispose (obj);
 }
 
 static void
@@ -1084,7 +1082,6 @@ gst_lfo_control_source_class_init (GstLFOControlSourceClass * klass)
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
   GstControlSourceClass *csource_class = GST_CONTROL_SOURCE_CLASS (klass);
 
-  parent_class = g_type_class_peek_parent (klass);
   g_type_class_add_private (klass, sizeof (GstLFOControlSourcePrivate));
 
   gobject_class->finalize = gst_lfo_control_source_finalize;
diff --git a/plugins/elements/gstfakesink.c b/plugins/elements/gstfakesink.c
index 202d07b..93dbd46 100644
--- a/plugins/elements/gstfakesink.c
+++ b/plugins/elements/gstfakesink.c
@@ -131,6 +131,7 @@ static GstFlowReturn gst_fake_sink_preroll (GstBaseSink * bsink,
 static GstFlowReturn gst_fake_sink_render (GstBaseSink * bsink,
     GstBuffer * buffer);
 static gboolean gst_fake_sink_event (GstBaseSink * bsink, GstEvent * event);
+static gboolean gst_fake_sink_query (GstBaseSink * bsink, GstQuery * query);
 
 static guint gst_fake_sink_signals[LAST_SIGNAL] = { 0 };
 
@@ -266,6 +267,7 @@ gst_fake_sink_class_init (GstFakeSinkClass * klass)
   gstbase_sink_class->event = GST_DEBUG_FUNCPTR (gst_fake_sink_event);
   gstbase_sink_class->preroll = GST_DEBUG_FUNCPTR (gst_fake_sink_preroll);
   gstbase_sink_class->render = GST_DEBUG_FUNCPTR (gst_fake_sink_render);
+  gstbase_sink_class->query = GST_DEBUG_FUNCPTR (gst_fake_sink_query);
 }
 
 static void
@@ -554,6 +556,29 @@ eos:
   }
 }
 
+static gboolean
+gst_fake_sink_query (GstBaseSink * bsink, GstQuery * query)
+{
+  gboolean ret;
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_SEEKING:{
+      GstFormat fmt;
+
+      /* we don't supporting seeking */
+      gst_query_parse_seeking (query, &fmt, NULL, NULL, NULL);
+      gst_query_set_seeking (query, fmt, FALSE, 0, -1);
+      ret = TRUE;
+      break;
+    }
+    default:
+      ret = GST_BASE_SINK_CLASS (parent_class)->query (bsink, query);
+      break;
+  }
+
+  return ret;
+}
+
 static GstStateChangeReturn
 gst_fake_sink_change_state (GstElement * element, GstStateChange transition)
 {
diff --git a/plugins/elements/gstfdsink.c b/plugins/elements/gstfdsink.c
index 6383d2a..7667088 100644
--- a/plugins/elements/gstfdsink.c
+++ b/plugins/elements/gstfdsink.c
@@ -118,7 +118,7 @@ static void gst_fd_sink_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
 static void gst_fd_sink_dispose (GObject * obj);
 
-static gboolean gst_fd_sink_query (GstPad * pad, GstQuery * query);
+static gboolean gst_fd_sink_query (GstBaseSink * bsink, GstQuery * query);
 static GstFlowReturn gst_fd_sink_render (GstBaseSink * sink,
     GstBuffer * buffer);
 static gboolean gst_fd_sink_start (GstBaseSink * basesink);
@@ -161,6 +161,7 @@ gst_fd_sink_class_init (GstFdSinkClass * klass)
   gstbasesink_class->unlock = GST_DEBUG_FUNCPTR (gst_fd_sink_unlock);
   gstbasesink_class->unlock_stop = GST_DEBUG_FUNCPTR (gst_fd_sink_unlock_stop);
   gstbasesink_class->event = GST_DEBUG_FUNCPTR (gst_fd_sink_event);
+  gstbasesink_class->query = GST_DEBUG_FUNCPTR (gst_fd_sink_query);
 
   g_object_class_install_property (gobject_class, ARG_FD,
       g_param_spec_int ("fd", "fd", "An open file descriptor to write to",
@@ -170,11 +171,6 @@ gst_fd_sink_class_init (GstFdSinkClass * klass)
 static void
 gst_fd_sink_init (GstFdSink * fdsink, GstFdSinkClass * klass)
 {
-  GstPad *pad;
-
-  pad = GST_BASE_SINK_PAD (fdsink);
-  gst_pad_set_query_function (pad, GST_DEBUG_FUNCPTR (gst_fd_sink_query));
-
   fdsink->fd = 1;
   fdsink->uri = g_strdup_printf ("fd://%d", fdsink->fd);
   fdsink->bytes_written = 0;
@@ -195,12 +191,12 @@ gst_fd_sink_dispose (GObject * obj)
 }
 
 static gboolean
-gst_fd_sink_query (GstPad * pad, GstQuery * query)
+gst_fd_sink_query (GstBaseSink * bsink, GstQuery * query)
 {
   GstFdSink *fdsink;
   GstFormat format;
 
-  fdsink = GST_FD_SINK (GST_PAD_PARENT (pad));
+  fdsink = GST_FD_SINK (bsink);
 
   switch (GST_QUERY_TYPE (query)) {
     case GST_QUERY_POSITION:
@@ -222,8 +218,18 @@ gst_fd_sink_query (GstPad * pad, GstQuery * query)
       gst_query_set_uri (query, fdsink->uri);
       return TRUE;
 
+    case GST_QUERY_SEEKING:
+      gst_query_parse_seeking (query, &format, NULL, NULL, NULL);
+      if (format == GST_FORMAT_BYTES || format == GST_FORMAT_DEFAULT) {
+        gst_query_set_seeking (query, GST_FORMAT_BYTES, fdsink->seekable, 0,
+            -1);
+      } else {
+        gst_query_set_seeking (query, format, FALSE, 0, -1);
+      }
+      return TRUE;
+
     default:
-      return gst_pad_query_default (pad, query);
+      return GST_BASE_SINK_CLASS (parent_class)->query (bsink, query);
   }
 }
 
@@ -384,6 +390,9 @@ gst_fd_sink_start (GstBaseSink * basesink)
   fdsink->bytes_written = 0;
   fdsink->current_pos = 0;
 
+  fdsink->seekable = gst_fd_sink_do_seek (fdsink, 0);
+  GST_INFO_OBJECT (fdsink, "seeking supported: %d", fdsink->seekable);
+
   return TRUE;
 
   /* ERRORS */
diff --git a/plugins/elements/gstfdsink.h b/plugins/elements/gstfdsink.h
index 90913b4..59393d0 100644
--- a/plugins/elements/gstfdsink.h
+++ b/plugins/elements/gstfdsink.h
@@ -59,6 +59,8 @@ struct _GstFdSink {
   int fd;
   guint64 bytes_written;
   guint64 current_pos;
+
+  gboolean seekable;
 };
 
 struct _GstFdSinkClass {
diff --git a/plugins/elements/gstfilesink.c b/plugins/elements/gstfilesink.c
index 9356c0f..543dbfe 100644
--- a/plugins/elements/gstfilesink.c
+++ b/plugins/elements/gstfilesink.c
@@ -495,6 +495,16 @@ gst_file_sink_query (GstBaseSink * bsink, GstQuery * query)
       res = TRUE;
       break;
 
+    case GST_QUERY_SEEKING:
+      gst_query_parse_seeking (query, &format, NULL, NULL, NULL);
+      if (format == GST_FORMAT_BYTES || format == GST_FORMAT_DEFAULT) {
+        gst_query_set_seeking (query, GST_FORMAT_BYTES, self->seekable, 0, -1);
+      } else {
+        gst_query_set_seeking (query, format, FALSE, 0, -1);
+      }
+      res = TRUE;
+      break;
+
     default:
       res = GST_BASE_SINK_CLASS (parent_class)->query (bsink, query);
       break;
diff --git a/plugins/elements/gstfilesrc.c b/plugins/elements/gstfilesrc.c
index 87402c8..1f3017a 100644
--- a/plugins/elements/gstfilesrc.c
+++ b/plugins/elements/gstfilesrc.c
@@ -332,6 +332,8 @@ gst_file_src_init (GstFileSrc * src, GstFileSrcClass * g_class)
   src->sequential = DEFAULT_SEQUENTIAL;
 
   src->is_regular = FALSE;
+
+  gst_base_src_set_blocksize (GST_BASE_SRC (src), DEFAULT_BLOCKSIZE);
 }
 
 static void
diff --git a/plugins/elements/gstinputselector.c b/plugins/elements/gstinputselector.c
index 4da4735..89cf724 100644
--- a/plugins/elements/gstinputselector.c
+++ b/plugins/elements/gstinputselector.c
@@ -683,9 +683,10 @@ gst_input_selector_wait_running_time (GstInputSelector * sel,
    *   d) the active pad has no running time or the active
    *      pad's running time is before this running time
    *   e) the active pad has a non-time segment
+   *   f) the active pad changed and has not pushed anything
    */
-  while (pad != active_selpad && !sel->flushing && !pad->flushing &&
-      (sel->blocked || active_running_time == -1
+  while (pad != active_selpad && !sel->flushing && !pad->flushing
+      && active_selpad->pushed && (sel->blocked || active_running_time == -1
           || running_time >= active_running_time)) {
     if (!sel->blocked)
       GST_DEBUG_OBJECT (pad,
diff --git a/plugins/elements/gstmultiqueue.c b/plugins/elements/gstmultiqueue.c
index 0054715..11344e5 100644
--- a/plugins/elements/gstmultiqueue.c
+++ b/plugins/elements/gstmultiqueue.c
@@ -140,6 +140,12 @@ struct _GstSingleQueue
 
   /* flowreturn of previous srcpad push */
   GstFlowReturn srcresult;
+  /* If something was actually pushed on
+   * this pad after flushing/pad activation
+   * and the srcresult corresponds to something
+   * real
+   */
+  gboolean pushed;
 
   /* segments */
   GstSegment sink_segment;
@@ -748,27 +754,29 @@ gst_single_queue_flush (GstMultiQueue * mq, GstSingleQueue * sq, gboolean flush)
       sq->id);
 
   if (flush) {
+    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
     sq->srcresult = GST_FLOW_WRONG_STATE;
     gst_data_queue_set_flushing (sq->queue, TRUE);
 
     sq->flushing = TRUE;
+    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
     /* wake up non-linked task */
     GST_LOG_OBJECT (mq, "SingleQueue %d : waking up eventually waiting task",
         sq->id);
-    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
     g_cond_signal (sq->turn);
-    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
     GST_LOG_OBJECT (mq, "SingleQueue %d : pausing task", sq->id);
     result = gst_pad_pause_task (sq->srcpad);
     sq->sink_tainted = sq->src_tainted = TRUE;
   } else {
+    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
     gst_data_queue_flush (sq->queue);
     gst_segment_init (&sq->sink_segment, GST_FORMAT_TIME);
     gst_segment_init (&sq->src_segment, GST_FORMAT_TIME);
     /* All pads start off not-linked for a smooth kick-off */
     sq->srcresult = GST_FLOW_OK;
+    sq->pushed = FALSE;
     sq->cur_time = 0;
     sq->max_size.visible = mq->max_size.visible;
     sq->is_eos = FALSE;
@@ -780,11 +788,10 @@ gst_single_queue_flush (GstMultiQueue * mq, GstSingleQueue * sq, gboolean flush)
     gst_data_queue_set_flushing (sq->queue, FALSE);
 
     /* Reset high time to be recomputed next */
-    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
     mq->high_time = GST_CLOCK_TIME_NONE;
-    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
     sq->flushing = FALSE;
+    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
     GST_LOG_OBJECT (mq, "SingleQueue %d : starting task", sq->id);
     result =
@@ -1186,6 +1193,7 @@ gst_multi_queue_loop (GstPad * pad)
   guint32 newid;
   GstFlowReturn result;
   GstClockTime next_time;
+  gboolean is_buffer;
 
   sq = (GstSingleQueue *) gst_pad_get_element_private (pad);
   mq = sq->mqueue;
@@ -1207,6 +1215,8 @@ gst_multi_queue_loop (GstPad * pad)
   object = gst_multi_queue_item_steal_object (item);
   gst_multi_queue_item_destroy (item);
 
+  is_buffer = GST_IS_BUFFER (object);
+
   /* Get running time of the item. Events will have GST_CLOCK_TIME_NONE */
   next_time = get_running_time (&sq->src_segment, object, TRUE);
 
@@ -1218,14 +1228,13 @@ gst_multi_queue_loop (GstPad * pad)
    * or it's the first loop, or we just passed the previous highid, 
    * we might need to wake some sleeping pad up, so there's extra work 
    * there too */
+  GST_MULTI_QUEUE_MUTEX_LOCK (mq);
   if (sq->srcresult == GST_FLOW_NOT_LINKED
       || (sq->last_oldid == G_MAXUINT32) || (newid != (sq->last_oldid + 1))
       || sq->last_oldid > mq->highid) {
     GST_LOG_OBJECT (mq, "CHECKING sq->srcresult: %s",
         gst_flow_get_name (sq->srcresult));
 
-    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
-
     /* Check again if we're flushing after the lock is taken,
      * the flush flag might have been changed in the meantime */
     if (sq->flushing) {
@@ -1292,9 +1301,8 @@ gst_multi_queue_loop (GstPad * pad)
     /* We're done waiting, we can clear the nextid and nexttime */
     sq->nextid = 0;
     sq->next_time = GST_CLOCK_TIME_NONE;
-
-    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
   }
+  GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
   if (sq->flushing)
     goto out_flushing;
@@ -1303,6 +1311,7 @@ gst_multi_queue_loop (GstPad * pad)
       gst_flow_get_name (sq->srcresult));
 
   /* Update time stats */
+  GST_MULTI_QUEUE_MUTEX_LOCK (mq);
   next_time = get_running_time (&sq->src_segment, object, FALSE);
   if (next_time != GST_CLOCK_TIME_NONE) {
     if (sq->last_time == GST_CLOCK_TIME_NONE || sq->last_time < next_time)
@@ -1313,12 +1322,52 @@ gst_multi_queue_loop (GstPad * pad)
       wake_up_next_non_linked (mq);
     }
   }
+  GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
   /* Try to push out the new object */
   result = gst_single_queue_push_one (mq, sq, object);
-  sq->srcresult = result;
   object = NULL;
 
+  /* Check if we pushed something already and if this is
+   * now a switch from an active to a non-active stream.
+   *
+   * If it is, we reset all the waiting streams, let them
+   * push another buffer to see if they're now active again.
+   * This allows faster switching between streams and prevents
+   * deadlocks if downstream does any waiting too.
+   */
+  GST_MULTI_QUEUE_MUTEX_LOCK (mq);
+  if (sq->pushed && sq->srcresult == GST_FLOW_OK
+      && result == GST_FLOW_NOT_LINKED) {
+    GList *tmp;
+
+    GST_LOG_OBJECT (mq, "SingleQueue %d : Changed from active to non-active",
+        sq->id);
+
+    compute_high_id (mq);
+
+    /* maybe no-one is waiting */
+    if (mq->numwaiting > 0) {
+      /* Else figure out which singlequeue(s) need waking up */
+      for (tmp = mq->queues; tmp; tmp = g_list_next (tmp)) {
+        GstSingleQueue *sq2 = (GstSingleQueue *) tmp->data;
+
+        if (sq2->srcresult == GST_FLOW_NOT_LINKED) {
+          GST_LOG_OBJECT (mq, "Waking up singlequeue %d", sq2->id);
+          sq2->pushed = FALSE;
+          sq2->srcresult = GST_FLOW_OK;
+          g_cond_signal (sq2->turn);
+        }
+      }
+    }
+  }
+
+  if (is_buffer)
+    sq->pushed = TRUE;
+  sq->srcresult = result;
+  sq->last_oldid = newid;
+  GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
+
   if (result != GST_FLOW_OK && result != GST_FLOW_NOT_LINKED
       && result != GST_FLOW_UNEXPECTED)
     goto out_flushing;
@@ -1326,8 +1375,6 @@ gst_multi_queue_loop (GstPad * pad)
   GST_LOG_OBJECT (mq, "AFTER PUSHING sq->srcresult: %s",
       gst_flow_get_name (sq->srcresult));
 
-  sq->last_oldid = newid;
-
   return;
 
 out_flushing:
@@ -1337,6 +1384,7 @@ out_flushing:
 
     /* Need to make sure wake up any sleeping pads when we exit */
     GST_MULTI_QUEUE_MUTEX_LOCK (mq);
+    compute_high_time (mq);
     compute_high_id (mq);
     wake_up_next_non_linked (mq);
     GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
@@ -1421,16 +1469,30 @@ static gboolean
 gst_multi_queue_sink_activate_push (GstPad * pad, gboolean active)
 {
   GstSingleQueue *sq;
+  GstMultiQueue *mq;
 
   sq = (GstSingleQueue *) gst_pad_get_element_private (pad);
+  mq = (GstMultiQueue *) gst_pad_get_parent (pad);
+
+  /* mq is NULL if the pad is activated/deactivated before being
+   * added to the multiqueue */
+  if (mq)
+    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
 
   if (active) {
     /* All pads start off linked until they push one buffer */
     sq->srcresult = GST_FLOW_OK;
+    sq->pushed = FALSE;
   } else {
     sq->srcresult = GST_FLOW_WRONG_STATE;
     gst_data_queue_flush (sq->queue);
   }
+
+  if (mq) {
+    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
+    gst_object_unref (mq);
+  }
+
   return TRUE;
 }
 
@@ -1943,6 +2005,7 @@ gst_single_queue_new (GstMultiQueue * mqueue, gint id)
 
   sq->mqueue = mqueue;
   sq->srcresult = GST_FLOW_WRONG_STATE;
+  sq->pushed = FALSE;
   sq->queue = gst_data_queue_new_full ((GstDataQueueCheckFullFunction)
       single_queue_check_full,
       (GstDataQueueFullCallback) single_queue_overrun_cb,
diff --git a/plugins/elements/gstoutputselector.c b/plugins/elements/gstoutputselector.c
index 41b176c..b3b6c36 100644
--- a/plugins/elements/gstoutputselector.c
+++ b/plugins/elements/gstoutputselector.c
@@ -453,7 +453,8 @@ gst_output_selector_switch (GstOutputSelector * osel)
 
   /* Switch */
   GST_OBJECT_LOCK (GST_OBJECT (osel));
-  GST_INFO ("switching to pad %" GST_PTR_FORMAT, osel->pending_srcpad);
+  GST_INFO_OBJECT (osel, "switching to pad %" GST_PTR_FORMAT,
+      osel->pending_srcpad);
   if (gst_pad_is_linked (osel->pending_srcpad)) {
     osel->active_srcpad = osel->pending_srcpad;
     res = TRUE;
@@ -464,23 +465,25 @@ gst_output_selector_switch (GstOutputSelector * osel)
 
   /* Send NEWSEGMENT event and latest buffer if switching succeeded
    * and we already have a valid segment configured */
-  if (res && osel->segment.format != GST_FORMAT_UNDEFINED) {
-    /* Send NEWSEGMENT to the pad we are going to switch to */
-    seg = &osel->segment;
-
-    /* If resending then mark newsegment start and position accordingly */
-    if (osel->resend_latest && osel->latest_buffer &&
-        GST_BUFFER_TIMESTAMP_IS_VALID (osel->latest_buffer)) {
-      start = position = GST_BUFFER_TIMESTAMP (osel->latest_buffer);
-    } else {
-      start = position = seg->last_stop;
-    }
-    ev = gst_event_new_new_segment (TRUE, seg->rate,
-        seg->format, start, seg->stop, position);
-    if (!gst_pad_push_event (osel->active_srcpad, ev)) {
-      GST_WARNING_OBJECT (osel,
-          "newsegment handling failed in %" GST_PTR_FORMAT,
-          osel->active_srcpad);
+  if (res) {
+    if (osel->segment.format != GST_FORMAT_UNDEFINED) {
+      /* Send NEWSEGMENT to the pad we are going to switch to */
+      seg = &osel->segment;
+
+      /* If resending then mark newsegment start and position accordingly */
+      if (osel->resend_latest && osel->latest_buffer &&
+          GST_BUFFER_TIMESTAMP_IS_VALID (osel->latest_buffer)) {
+        start = position = GST_BUFFER_TIMESTAMP (osel->latest_buffer);
+      } else {
+        start = position = seg->last_stop;
+      }
+      ev = gst_event_new_new_segment (TRUE, seg->rate,
+          seg->format, start, seg->stop, position);
+      if (!gst_pad_push_event (osel->active_srcpad, ev)) {
+        GST_WARNING_OBJECT (osel,
+            "newsegment handling failed in %" GST_PTR_FORMAT,
+            osel->active_srcpad);
+      }
     }
 
     /* Resend latest buffer to newly switched pad */
diff --git a/plugins/elements/gstqueue2.c b/plugins/elements/gstqueue2.c
index 8c4e4cc..ebd2cde 100644
--- a/plugins/elements/gstqueue2.c
+++ b/plugins/elements/gstqueue2.c
@@ -740,11 +740,9 @@ apply_segment (GstQueue2 * queue, GstEvent * event, GstSegment * segment,
       G_GINT64_FORMAT, update, rate, arate, format, start, stop, time);
 
   if (format == GST_FORMAT_BYTES) {
-    if (QUEUE_IS_USING_TEMP_FILE (queue)) {
+    if (!QUEUE_IS_USING_QUEUE (queue) && is_sink) {
       /* start is where we'll be getting from and as such writing next */
       queue->current = add_range (queue, start);
-      /* update the stats for this range */
-      update_cur_level (queue, queue->current);
     }
   }
 
@@ -1087,6 +1085,8 @@ perform_seek_to_offset (GstQueue2 * queue, guint64 offset)
   GstEvent *event;
   gboolean res;
 
+  /* until we receive the FLUSH_STOP from this seek, we skip data */
+  queue->seeking = TRUE;
   GST_QUEUE2_MUTEX_UNLOCK (queue);
 
   GST_DEBUG_OBJECT (queue, "Seeking to %" G_GUINT64_FORMAT, offset);
@@ -1139,20 +1139,27 @@ gst_queue2_have_data (GstQueue2 * queue, guint64 offset, guint length)
           (offset + length) - range->writing_pos);
 
   } else {
-    GST_INFO_OBJECT (queue, "not found in any range");
-    /* we don't have the range, see how far away we are, FIXME, find a good
-     * threshold based on the incoming rate. */
+    GST_INFO_OBJECT (queue, "not found in any range off %" G_GUINT64_FORMAT
+        " len %u", offset, length);
+    /* we don't have the range, see how far away we are */
     if (!queue->is_eos && queue->current) {
+      /* FIXME, find a good threshold based on the incoming rate. */
+      guint64 threshold = 1024 * 512;
+
       if (QUEUE_IS_USING_RING_BUFFER (queue)) {
-        if (offset < queue->current->offset || offset >
-            queue->current->writing_pos + QUEUE_MAX_BYTES (queue) -
-            queue->cur_level.bytes) {
-          perform_seek_to_offset (queue, offset);
-        } else {
+        guint64 distance;
+
+        distance = QUEUE_MAX_BYTES (queue) - queue->cur_level.bytes;
+        /* don't wait for the complete buffer to fill */
+        distance = MIN (distance, threshold);
+
+        if (offset >= queue->current->offset && offset <=
+            queue->current->writing_pos + distance) {
           GST_INFO_OBJECT (queue,
               "requested data is within range, wait for data");
+          return FALSE;
         }
-      } else if (offset < queue->current->writing_pos + 200000) {
+      } else if (offset < queue->current->writing_pos + threshold) {
         update_cur_pos (queue, queue->current, offset + length);
         GST_INFO_OBJECT (queue, "wait for data");
         return FALSE;
@@ -1237,6 +1244,7 @@ gst_queue2_create_read (GstQueue2 * queue, guint64 offset, guint length,
   guint block_length, remaining, read_length;
   gint64 read_return;
   guint64 rb_size;
+  guint64 max_size;
   guint64 rpos;
 
   /* allocate the output buffer of the requested size */
@@ -1248,6 +1256,7 @@ gst_queue2_create_read (GstQueue2 * queue, guint64 offset, guint length,
 
   rpos = offset;
   rb_size = queue->ring_buffer_max_size;
+  max_size = QUEUE_MAX_BYTES (queue);
 
   remaining = length;
   while (remaining > 0) {
@@ -1266,16 +1275,16 @@ gst_queue2_create_read (GstQueue2 * queue, guint64 offset, guint length,
 
         GST_DEBUG_OBJECT (queue,
             "reading %" G_GUINT64_FORMAT ", writing %" G_GUINT64_FORMAT
-            ", level %" G_GUINT64_FORMAT,
-            rpos, queue->current->writing_pos, level);
+            ", level %" G_GUINT64_FORMAT ", max %" G_GUINT64_FORMAT,
+            rpos, queue->current->writing_pos, level, max_size);
 
-        if (level >= rb_size) {
+        if (level >= max_size) {
           /* we don't have the data but if we have a ring buffer that is full, we
            * need to read */
           GST_DEBUG_OBJECT (queue,
-              "ring buffer full, reading ring-buffer-max-size %"
-              G_GUINT64_FORMAT " bytes", rb_size);
-          read_length = rb_size;
+              "ring buffer full, reading QUEUE_MAX_BYTES %"
+              G_GUINT64_FORMAT " bytes", max_size);
+          read_length = max_size;
         } else if (queue->is_eos) {
           /* won't get any more data so read any data we have */
           if (level) {
@@ -1283,6 +1292,8 @@ gst_queue2_create_read (GstQueue2 * queue, guint64 offset, guint length,
                 "EOS hit but read %" G_GUINT64_FORMAT " bytes that we have",
                 level);
             read_length = level;
+            remaining = level;
+            length = level;
           } else {
             GST_DEBUG_OBJECT (queue,
                 "EOS hit and we don't have any requested data");
@@ -1293,15 +1304,12 @@ gst_queue2_create_read (GstQueue2 * queue, guint64 offset, guint length,
       }
 
       if (read_length == 0) {
-        if (QUEUE_IS_USING_RING_BUFFER (queue)
-            && queue->current->max_reading_pos > rpos) {
-          /* protect cached data (data between offset and max_reading_pos)
-           * and update current level */
+        if (QUEUE_IS_USING_RING_BUFFER (queue)) {
           GST_DEBUG_OBJECT (queue,
-              "protecting cached data [%" G_GUINT64_FORMAT "-%" G_GUINT64_FORMAT
-              "]", rpos, queue->current->max_reading_pos);
-          queue->current->max_reading_pos = rpos;
-          update_cur_level (queue, queue->current);
+              "update current position [%" G_GUINT64_FORMAT "-%"
+              G_GUINT64_FORMAT "]", rpos, queue->current->max_reading_pos);
+          update_cur_pos (queue, queue->current, rpos);
+          GST_QUEUE2_SIGNAL_DEL (queue);
         }
         GST_DEBUG_OBJECT (queue, "waiting for add");
         GST_QUEUE2_WAIT_ADD_CHECK (queue, queue->srcresult, out_flushing);
@@ -1613,7 +1621,7 @@ gst_queue2_create_write (GstQueue2 * queue, GstBuffer * buffer)
   data = GST_BUFFER_DATA (buffer);
 
   GST_DEBUG_OBJECT (queue, "Writing %u bytes to %" G_GUINT64_FORMAT, size,
-      GST_BUFFER_OFFSET (buffer));
+      writing_pos);
 
   while (size > 0) {
     guint to_write;
@@ -2128,7 +2136,7 @@ gst_queue2_handle_sink_event (GstPad * pad, GstEvent * event)
     case GST_EVENT_FLUSH_START:
     {
       GST_CAT_LOG_OBJECT (queue_dataflow, queue, "received flush start event");
-      if (QUEUE_IS_USING_QUEUE (queue)) {
+      if (queue->srcpad->mode == GST_ACTIVATE_PUSH) {
         /* forward event */
         gst_pad_push_event (queue->srcpad, event);
 
@@ -2160,7 +2168,7 @@ gst_queue2_handle_sink_event (GstPad * pad, GstEvent * event)
     {
       GST_CAT_LOG_OBJECT (queue_dataflow, queue, "received flush stop event");
 
-      if (QUEUE_IS_USING_QUEUE (queue)) {
+      if (queue->srcpad->mode == GST_ACTIVATE_PUSH) {
         /* forward event */
         gst_pad_push_event (queue->srcpad, event);
 
@@ -2170,6 +2178,7 @@ gst_queue2_handle_sink_event (GstPad * pad, GstEvent * event)
         queue->sinkresult = GST_FLOW_OK;
         queue->is_eos = FALSE;
         queue->unexpected = FALSE;
+        queue->seeking = FALSE;
         /* reset rate counters */
         reset_rate_timer (queue);
         gst_pad_start_task (queue->srcpad, (GstTaskFunction) gst_queue2_loop,
@@ -2181,6 +2190,7 @@ gst_queue2_handle_sink_event (GstPad * pad, GstEvent * event)
         queue->is_eos = FALSE;
         queue->unexpected = FALSE;
         queue->sinkresult = GST_FLOW_OK;
+        queue->seeking = FALSE;
         GST_QUEUE2_MUTEX_UNLOCK (queue);
 
         gst_event_unref (event);
@@ -2296,6 +2306,10 @@ gst_queue2_chain_buffer_or_buffer_list (GstQueue2 * queue,
   if (queue->unexpected)
     goto out_unexpected;
 
+  /* while we didn't receive the newsegment, we're seeking and we skip data */
+  if (queue->seeking)
+    goto out_seeking;
+
   if (!gst_queue2_wait_free_space (queue))
     goto out_flushing;
 
@@ -2325,6 +2339,14 @@ out_eos:
 
     return GST_FLOW_UNEXPECTED;
   }
+out_seeking:
+  {
+    GST_CAT_LOG_OBJECT (queue_dataflow, queue, "exit because we are seeking");
+    GST_QUEUE2_MUTEX_UNLOCK (queue);
+    gst_mini_object_unref (item);
+
+    return GST_FLOW_OK;
+  }
 out_unexpected:
   {
     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
@@ -2618,12 +2640,6 @@ gst_queue2_handle_src_event (GstPad * pad, GstEvent * event)
         /* now unblock the getrange function */
         GST_QUEUE2_MUTEX_LOCK (queue);
         queue->srcresult = GST_FLOW_OK;
-        if (queue->current) {
-          /* forget the highest read offset, we'll calculate a new one when we
-           * get the next getrange request. We need to do this in order to reset
-           * the buffering percentage */
-          queue->current->max_reading_pos = 0;
-        }
         GST_QUEUE2_MUTEX_UNLOCK (queue);
 
         /* when using a temp file, we eat the event */
diff --git a/plugins/elements/gstqueue2.h b/plugins/elements/gstqueue2.h
index 02a38f2..3698344 100644
--- a/plugins/elements/gstqueue2.h
+++ b/plugins/elements/gstqueue2.h
@@ -143,6 +143,7 @@ struct _GstQueue2
    * because we can't save it on the file */
   gboolean segment_event_received;
   GstEvent *starting_segment;
+  gboolean seeking;
 
   guint64 ring_buffer_max_size;
   guint8 * ring_buffer;
diff --git a/plugins/elements/gsttee.c b/plugins/elements/gsttee.c
index 6b875a7..f1ec8a4 100644
--- a/plugins/elements/gsttee.c
+++ b/plugins/elements/gsttee.c
@@ -859,7 +859,7 @@ gst_tee_sink_activate_push (GstPad * pad, gboolean active)
   tee = GST_TEE (GST_OBJECT_PARENT (pad));
 
   GST_OBJECT_LOCK (tee);
-  tee->sink_mode = active && GST_ACTIVATE_PUSH;
+  tee->sink_mode = (active ? GST_ACTIVATE_PUSH : GST_ACTIVATE_NONE);
 
   if (active && !tee->has_chain)
     goto no_chain;
@@ -912,7 +912,7 @@ gst_tee_src_activate_pull (GstPad * pad, gboolean active)
     if (pad == tee->pull_pad)
       tee->pull_pad = NULL;
   }
-  tee->sink_mode = active && GST_ACTIVATE_PULL;
+  tee->sink_mode = (active ? GST_ACTIVATE_PULL : GST_ACTIVATE_NONE);
   GST_OBJECT_UNLOCK (tee);
 
   gst_object_unref (tee);
diff --git a/po/id.po b/po/id.po
index 62267bc..9b88775 100644
--- a/po/id.po
+++ b/po/id.po
@@ -1,13 +1,13 @@
 # Indonesian translations for gstreamer package.
 # This file is put in the public domain.
-# Andhika Padmawan <andhika.padmawan@gmail.com>, 2010-2012.
+# Andhika Padmawan <andhika.padmawan@gmail.com>, 2010.
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: gstreamer 0.10.32.2\n"
+"Project-Id-Version: gstreamer 0.10.29.2\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/\n"
-"POT-Creation-Date: 2012-02-20 21:32+0000\n"
-"PO-Revision-Date: 2012-01-28 11:44+0700\n"
+"POT-Creation-Date: 2011-06-04 13:33+0100\n"
+"PO-Revision-Date: 2010-06-29 21:55+0700\n"
 "Last-Translator: Andhika Padmawan <andhika.padmawan@gmail.com>\n"
 "Language-Team: Indonesian <translation-team-id@lists.sourceforge.net>\n"
 "Language: id\n"
@@ -153,7 +153,7 @@ msgid "Could not configure supporting library."
 msgstr "Tak dapat mengatur pustaka pendukung."
 
 msgid "Encoding error."
-msgstr "Galat penyandian."
+msgstr ""
 
 msgid "GStreamer encountered a general resource error."
 msgstr "GStreamer menghadapi galat umum sumber daya."
@@ -303,11 +303,13 @@ msgstr "tanggal"
 msgid "date the data was created (as a GDate structure)"
 msgstr "tanggal data dibuat (menurut struktur GDate)"
 
+#, fuzzy
 msgid "datetime"
-msgstr "tanggalwaktu"
+msgstr "tanggal"
 
+#, fuzzy
 msgid "date and time the data was created (as a GstDateTime structure)"
-msgstr "tanggal dan waktu data dibuat (menurut struktur GDateTime)"
+msgstr "tanggal data dibuat (menurut struktur GDate)"
 
 msgid "genre"
 msgstr "genre"
@@ -403,11 +405,12 @@ msgstr "uri hak cipta"
 msgid "URI to the copyright notice of the data"
 msgstr "URI ke keterangan hak cipta data"
 
+#, fuzzy
 msgid "encoded by"
-msgstr "disandikan oleh"
+msgstr "penyandi"
 
 msgid "name of the encoding person or organization"
-msgstr "nama penyandian orang atau organisasi"
+msgstr ""
 
 msgid "contact"
 msgstr "kontak"
@@ -650,11 +653,12 @@ msgstr ""
 "lokasi di dalam kota tempat media dihasilkan atau dibuat (misalnya "
 "lingkungan)"
 
+#, fuzzy
 msgid "geo location horizontal error"
-msgstr "galat horizontal lokasi geografis"
+msgstr "nama lokasi geografis"
 
 msgid "expected error of the horizontal positioning measures (in meters)"
-msgstr "galat yang diharapkan dari pengukuran posisi horizontal (dalam meter)"
+msgstr ""
 
 msgid "geo location movement speed"
 msgstr "kecepatan gerak lokasi geografis"
@@ -761,17 +765,19 @@ msgstr "model divais"
 msgid "Model of the device used to create this media"
 msgstr "Model divais yang digunakan untuk membuat media ini"
 
+#, fuzzy
 msgid "application name"
-msgstr "nama aplikasi"
+msgstr "nama lokasi geografis"
 
+#, fuzzy
 msgid "Application used to create the media"
-msgstr "Aplikasi yang digunakan untuk membuat media"
+msgstr "Model divais yang digunakan untuk membuat media ini"
 
 msgid "application data"
-msgstr "data aplikasi"
+msgstr ""
 
 msgid "Arbitrary application data to be serialized into the media"
-msgstr "Data aplikasi wajib yang akan diurutkan dalam media"
+msgstr ""
 
 msgid "image orientation"
 msgstr "orientasi gambar"
@@ -957,13 +963,13 @@ msgid "controllable"
 msgstr "dapat dikendalikan"
 
 msgid "changeable in NULL, READY, PAUSED or PLAYING state"
-msgstr "dapat diubah dalam kondisi NULL, READY, PAUSED atau PLAYING"
+msgstr ""
 
 msgid "changeable only in NULL, READY or PAUSED state"
-msgstr "hanya dapat diubah dalam kondisi NULL, READY, atau PAUSED"
+msgstr ""
 
 msgid "changeable only in NULL or READY state"
-msgstr "hanya dapat diubah dalam kondisi NULL atau READY"
+msgstr ""
 
 msgid "Blacklisted files:"
 msgstr "Berkas yang dilarang:"
@@ -1047,7 +1053,7 @@ msgid "WARNING: element named '%s' not found.\n"
 msgstr "GALAT: elemen yang dinamakan '%s' tak ditemukan.\n"
 
 msgid "Index statistics"
-msgstr "Statistik indeks"
+msgstr ""
 
 #, c-format
 msgid "Got message #%u from element \"%s\" (%s): "
@@ -1159,7 +1165,7 @@ msgid "Force EOS on sources before shutting the pipeline down"
 msgstr "Paksa EOS pada sumber sebelum mematikan pemipaan"
 
 msgid "Gather and print index statistics"
-msgstr "Kumpulkan dan cetak statistik indeks"
+msgstr ""
 
 #, c-format
 msgid "ERROR: pipeline could not be constructed: %s.\n"
diff --git a/scripts/gst-uninstalled b/scripts/gst-uninstalled
index 485a1c1..045c437 100755
--- a/scripts/gst-uninstalled
+++ b/scripts/gst-uninstalled
@@ -59,10 +59,12 @@ $PATH"
 # /some/path: makes the dynamic linker look in . too, so avoid this
 LD_LIBRARY_PATH=$GST_PREFIX/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}
 DYLD_LIBRARY_PATH=$GST_PREFIX/lib${DYLD_LIBRARY_PATH:+:$DYLD_LIBRARY_PATH}
+GI_TYPELIB_PATH=$GST_PREFIX/share/gir-1.0${GI_TYPELIB_PATH:+:$GI_TYPELIB_PATH}
 
 # GStreamer rtsp server library
 LD_LIBRARY_PATH=$GST/gst-rtsp-server/gst/rtsp-server/.libs:$LD_LIBRARY_PATH
 DYLD_LIBRARY_PATH=$GST/gst-rtsp-server/gst/rtsp-server/.libs:$DYLD_LIBRARY_PATH
+GI_TYPELIB_PATH=$GST/gst-rtsp-server/gst/rtsp-server:$GI_TYPELIB_PATH
 
 # GStreamer ffmpeg libraries
 for path in libavformat libavutil libavcodec libpostproc libavdevice
@@ -76,6 +78,7 @@ for path in app audio cdda fft interfaces pbutils netbuffer riff rtp rtsp sdp ta
 do
   LD_LIBRARY_PATH=$GST/gst-plugins-base/gst-libs/gst/$path/.libs:$LD_LIBRARY_PATH
   DYLD_LIBRARY_PATH=$GST/gst-plugins-base/gst-libs/gst/$path/.libs:$DYLD_LIBRARY_PATH
+  GI_TYPELIB_PATH=$GST/gst-plugins-base/gst-libs/gst/$path:$GI_TYPELIB_PATH
 done
 
 # GStreamer core libraries
@@ -83,11 +86,14 @@ for path in base net check controller dataprotocol
 do
   LD_LIBRARY_PATH=$GST/gstreamer/libs/gst/$path/.libs:$LD_LIBRARY_PATH
   DYLD_LIBRARY_PATH=$GST/gstreamer/libs/gst/$path/.libs:$DYLD_LIBRARY_PATH
+  GI_TYPELIB_PATH=$GST/gstreamer/libs/gst/$path:$GI_TYPELIB_PATH
 done
 LD_LIBRARY_PATH=$GST/gstreamer/gst/.libs:$LD_LIBRARY_PATH
 DYLD_LIBRARY_PATH=$GST/gstreamer/gst/.libs:$DYLD_LIBRARY_PATH
+GI_TYPELIB_PATH=$GST/gstreamer/gst:$GI_TYPELIB_PATH
 export LD_LIBRARY_PATH
 export DYLD_LIBRARY_PATH
+export GI_TYPELIB_PATH
   
 export PKG_CONFIG_PATH="\
 $GST_PREFIX/lib/pkgconfig\
diff --git a/tests/benchmarks/gstclockstress.c b/tests/benchmarks/gstclockstress.c
index 60895d9..ed89840 100644
--- a/tests/benchmarks/gstclockstress.c
+++ b/tests/benchmarks/gstclockstress.c
@@ -60,6 +60,11 @@ main (gint argc, gchar * argv[])
 
   num_threads = atoi (argv[1]);
 
+  if (num_threads <= 0 || num_threads > MAX_THREADS) {
+    g_print ("number of threads must be between 0 and %d\n", MAX_THREADS);
+    exit (-2);
+  }
+
   sysclock = gst_system_clock_obtain ();
 
   for (t = 0; t < num_threads; t++) {
diff --git a/tests/check/Makefile.am b/tests/check/Makefile.am
index bf56a90..c91bece 100644
--- a/tests/check/Makefile.am
+++ b/tests/check/Makefile.am
@@ -63,7 +63,7 @@ REGISTRY_CHECKS =				\
 	gst/gstevent				\
 	gst/gstghostpad				\
 	gst/gstindex				\
-	gst/gstinterface				\
+	gst/gstinterface			\
 	gst/gstplugin				\
 	gst/gstpreset				\
 	gst/gstquery				\
@@ -89,6 +89,7 @@ REGISTRY_CHECKS =				\
 	libs/basesink				\
 	libs/controller				\
 	libs/typefindhelper			\
+	pipelines/seek				\
 	pipelines/stress			\
 	pipelines/queue-error
 endif
@@ -117,6 +118,8 @@ check_PROGRAMS =				\
 	gst/gsttag				\
 	gst/gsttagsetter			\
 	gst/gsttask				\
+	gst/gsttoc				\
+	gst/gsttocsetter			\
 	gst/gstvalue				\
 	generic/states				\
 	$(PARSE_CHECKS)				\
diff --git a/tests/check/elements/queue2.c b/tests/check/elements/queue2.c
index f74b3ea..1142002 100644
--- a/tests/check/elements/queue2.c
+++ b/tests/check/elements/queue2.c
@@ -207,6 +207,60 @@ GST_START_TEST (test_simple_create_destroy)
 
 GST_END_TEST;
 
+static gpointer
+push_buffer (GstPad * sinkpad)
+{
+  GstBuffer *buffer;
+
+  buffer = gst_buffer_new_and_alloc (1 * 1024);
+
+  gst_pad_chain (sinkpad, buffer);
+
+  return NULL;
+}
+
+GST_START_TEST (test_filled_read)
+{
+  GstElement *queue2;
+  GstBuffer *buffer;
+  GstPad *sinkpad, *srcpad;
+  GThread *thread;
+
+  queue2 = gst_element_factory_make ("queue2", NULL);
+  sinkpad = gst_element_get_static_pad (queue2, "sink");
+  srcpad = gst_element_get_static_pad (queue2, "src");
+
+  g_object_set (queue2, "ring-buffer-max-size", (guint64) 5 * 1024,
+      "use-buffering", FALSE,
+      "max-size-buffers", (guint) 0, "max-size-time", (guint64) 0,
+      "max-size-bytes", (guint) 4 * 1024, NULL);
+
+  gst_pad_activate_pull (srcpad, TRUE);
+  gst_element_set_state (queue2, GST_STATE_PLAYING);
+
+  /* fill up the buffer */
+  buffer = gst_buffer_new_and_alloc (4 * 1024);
+  fail_unless (gst_pad_chain (sinkpad, buffer) == GST_FLOW_OK);
+
+  thread = g_thread_create ((GThreadFunc) push_buffer, sinkpad, TRUE, NULL);
+
+  fail_unless (gst_pad_get_range (srcpad, 1024, 4 * 1024,
+          &buffer) == GST_FLOW_OK);
+
+  fail_unless (GST_BUFFER_SIZE (buffer) == 4 * 1024);
+
+  gst_element_set_state (queue2, GST_STATE_NULL);
+
+  g_thread_join (thread);
+
+  gst_object_unref (sinkpad);
+  gst_object_unref (srcpad);
+  gst_object_unref (queue2);
+}
+
+GST_END_TEST;
+
+
 static Suite *
 queue2_suite (void)
 {
@@ -219,6 +273,7 @@ queue2_suite (void)
   tcase_add_test (tc_chain, test_simple_pipeline_ringbuffer);
   tcase_add_test (tc_chain, test_simple_shutdown_while_running);
   tcase_add_test (tc_chain, test_simple_shutdown_while_running_ringbuffer);
+  tcase_add_test (tc_chain, test_filled_read);
   return s;
 }
 
diff --git a/tests/check/gst/gstdatetime.c b/tests/check/gst/gstdatetime.c
index ccc692f..10f1c60 100644
--- a/tests/check/gst/gstdatetime.c
+++ b/tests/check/gst/gstdatetime.c
@@ -24,11 +24,13 @@
 #include <time.h>
 #include <gst/check/gstcheck.h>
 
-#define ASSERT_TIME(dt,H,M,S) G_STMT_START { \
-  assert_equals_int ((H), gst_date_time_get_hour ((dt))); \
-  assert_equals_int ((M), gst_date_time_get_minute ((dt))); \
-  assert_equals_int ((S), gst_date_time_get_second ((dt))); \
-} G_STMT_END
+#define assert_almost_equals_int(a, b)                            \
+G_STMT_START {                                                           \
+  int first = a;                                                         \
+  int second = b;                                                        \
+  fail_unless(ABS (first - second) <= 1,                                 \
+    "'" #a "' (%d) is not almost equal to '" #b"' (%d)", first, second); \
+} G_STMT_END;
 
 GST_START_TEST (test_GstDateTime_now)
 {
@@ -49,7 +51,7 @@ GST_START_TEST (test_GstDateTime_now)
   assert_equals_int (gst_date_time_get_day (dt), tm.tm_mday);
   assert_equals_int (gst_date_time_get_hour (dt), tm.tm_hour);
   assert_equals_int (gst_date_time_get_minute (dt), tm.tm_min);
-  assert_equals_int (gst_date_time_get_second (dt), tm.tm_sec);
+  assert_almost_equals_int (gst_date_time_get_second (dt), tm.tm_sec);
   gst_date_time_unref (dt);
 }
 
@@ -177,7 +179,7 @@ GST_START_TEST (test_GstDateTime_get_microsecond)
   g_get_current_time (&tv);
   dt = gst_date_time_new (0, 2010, 7, 15, 11, 12,
       13 + (tv.tv_usec / 1000000.0));
-  assert_equals_int (tv.tv_usec, gst_date_time_get_microsecond (dt));
+  assert_almost_equals_int (tv.tv_usec, gst_date_time_get_microsecond (dt));
   gst_date_time_unref (dt);
 }
 
@@ -252,7 +254,7 @@ GST_START_TEST (test_GstDateTime_utc_now)
   assert_equals_int (tm.tm_mday, gst_date_time_get_day (dt));
   assert_equals_int (tm.tm_hour, gst_date_time_get_hour (dt));
   assert_equals_int (tm.tm_min, gst_date_time_get_minute (dt));
-  assert_equals_int (tm.tm_sec, gst_date_time_get_second (dt));
+  assert_almost_equals_int (tm.tm_sec, gst_date_time_get_second (dt));
   gst_date_time_unref (dt);
 }
 
diff --git a/tests/check/gst/gsttoc.c b/tests/check/gst/gsttoc.c
new file mode 100644
index 0000000..3788b16
--- /dev/null
+++ b/tests/check/gst/gsttoc.c
@@ -0,0 +1,369 @@
+/* GStreamer
+ *
+ * unit test for GstToc
+ *
+ * Copyright (C) 2010, 2012 Alexander Saprykin <xelfium@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*  -------  TOC  -------
+ *           /  \
+ *   edition1    edition2
+ *   |           |
+ *   -chapter1   -chapter3
+ *   -chapter2    |
+ *                -subchapter1
+ */
+
+#include <gst/check/gstcheck.h>
+
+#define ENTRY_ED1       "/edition1"
+#define ENTRY_ED2       "/edition2"
+#define ENTRY_ED3       "test-edition"
+
+#define ENTRY_CH1       "/edition1/chapter1"
+#define ENTRY_CH2       "/edition1/chapter2"
+#define ENTRY_CH3       "/edition2/chapter3"
+#define ENTRY_CH4       "/test-chapter"
+
+#define ENTRY_SUB1      "/edition2/chapter3/subchapter1"
+
+#define ENTRY_TAG       "EntryTag"
+#define TOC_TAG         "TocTag"
+
+#define TEST_UID        "129537542"
+#define INFO_NAME	"gst-toc-check"
+#define INFO_FIELD      "info-test"
+#define INFO_TEXT_EN    "info-text-entry"
+#define INFO_TEXT_TOC   "info-text-toc"
+
+#define CHECK_TOC_ENTRY(entry_c,type_c,uid_c)                            \
+{                                                                        \
+  gchar *tag_c;                                                          \
+  const GValue *val;                                                     \
+  GstStructure *struct_c;                                                \
+                                                                         \
+  fail_unless_equals_string (entry_c->uid, uid_c);                       \
+  fail_unless (entry_c->type == type_c);                                 \
+  fail_unless (entry_c->tags != NULL);                                   \
+  fail_unless (entry_c->pads == NULL);                                   \
+                                                                         \
+  fail_unless (entry_c->info != NULL);                                   \
+  gst_structure_get (entry_c->info, INFO_NAME, GST_TYPE_STRUCTURE,       \
+      &struct_c, NULL);                                                  \
+  fail_unless (struct_c != NULL);                                        \
+  val = gst_structure_get_value (struct_c, INFO_FIELD);                  \
+  fail_unless (val != NULL);                                             \
+  fail_unless_equals_string (g_value_get_string (val), INFO_TEXT_EN);    \
+                                                                         \
+  fail_unless (gst_tag_list_get_string (entry_c->tags,                   \
+      GST_TAG_TITLE, &tag_c));                                           \
+  fail_unless_equals_string (tag_c, ENTRY_TAG);                          \
+  g_free (tag_c);                                                        \
+  gst_structure_free (struct_c);                                         \
+}
+
+#define CHECK_TOC(toc_t)                                                 \
+{                                                                        \
+  GstTocEntry *entry_t, *subentry_t;                                     \
+  gchar *tag_t;                                                          \
+  const GValue *val;                                                     \
+  GstStructure *struct_toc;                                              \
+                                                                         \
+  /* check TOC */                                                        \
+  fail_unless (g_list_length (toc_t->entries) == 2);                     \
+  fail_unless (toc_t->tags != NULL);                                     \
+  fail_unless (gst_tag_list_get_string (toc_t->tags,                     \
+      GST_TAG_TITLE, &tag_t));                                           \
+  fail_unless_equals_string (tag_t, TOC_TAG);                            \
+  g_free (tag_t);                                                        \
+                                                                         \
+  fail_unless (toc_t->info != NULL);                                     \
+  gst_structure_get (toc_t->info, INFO_NAME, GST_TYPE_STRUCTURE,         \
+      &struct_toc, NULL);                                                \
+  fail_unless (struct_toc != NULL);                                      \
+  val = gst_structure_get_value (struct_toc, INFO_FIELD);                \
+  fail_unless (val != NULL);                                             \
+  fail_unless_equals_string (g_value_get_string (val), INFO_TEXT_TOC);   \
+  gst_structure_free (struct_toc);                                       \
+                                                                         \
+  /* check edition1 */                                                   \
+  entry_t = g_list_nth_data (toc_t->entries, 0);                         \
+  fail_if (entry_t == NULL);                                             \
+  fail_unless (g_list_length (entry_t->subentries) == 2);                \
+  CHECK_TOC_ENTRY (entry_t, GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED1);      \
+  /* check chapter1 */                                                   \
+  subentry_t = g_list_nth_data (entry_t->subentries, 0);                 \
+  fail_if (subentry_t == NULL);                                          \
+  fail_unless (g_list_length (subentry_t->subentries) == 0);             \
+  CHECK_TOC_ENTRY (subentry_t, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH1);   \
+  /* check chapter2 */                                                   \
+  subentry_t = g_list_nth_data (entry_t->subentries, 1);                 \
+  fail_if (subentry_t == NULL);                                          \
+  fail_unless (g_list_length (subentry_t->subentries) == 0);             \
+  CHECK_TOC_ENTRY (subentry_t, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH2);   \
+  /* check edition2 */                                                   \
+  entry_t = g_list_nth_data (toc_t->entries, 1);                         \
+  fail_if (entry_t == NULL);                                             \
+  fail_unless (g_list_length (entry_t->subentries) == 1);                \
+  CHECK_TOC_ENTRY (entry_t, GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED2);      \
+  /* check chapter3 */                                                   \
+  subentry_t = g_list_nth_data (entry_t->subentries, 0);                 \
+  fail_if (subentry_t == NULL);                                          \
+  fail_unless (g_list_length (subentry_t->subentries) == 1);             \
+  CHECK_TOC_ENTRY (subentry_t, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH3);   \
+  /* check subchapter1 */                                                \
+  subentry_t = g_list_nth_data (subentry_t->subentries, 0);              \
+  fail_if (subentry_t == NULL);                                          \
+  fail_unless (g_list_length (subentry_t->subentries) == 0);             \
+  CHECK_TOC_ENTRY (subentry_t, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_SUB1);  \
+}
+
+GST_START_TEST (test_serializing)
+{
+  GstStructure *structure;
+  GstToc *toc, *test_toc = NULL;
+  GstTocEntry *ed, *ch, *subch;
+  GstEvent *event;
+  GstMessage *message;
+  GstQuery *query;
+  gboolean updated;
+  gchar *uid;
+  gint64 start = -1, stop = -1;
+
+  toc = gst_toc_new ();
+  fail_if (toc == NULL);
+  gst_tag_list_add (toc->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      TOC_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_TOC,
+      NULL);
+  gst_structure_set (toc->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  /* create edition1 */
+  ed = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED1);
+  fail_if (ed == NULL);
+  gst_tag_list_add (ed->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (ed->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  CHECK_TOC_ENTRY (ed, GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED1);
+
+  /* append chapter1 to edition1 */
+  ch = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH1);
+  fail_if (ch == NULL);
+  gst_tag_list_add (ch->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (ch->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  CHECK_TOC_ENTRY (ch, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH1);
+
+  ed->subentries = g_list_append (ed->subentries, ch);
+  fail_unless (g_list_length (ed->subentries) == 1);
+
+  /* append chapter2 to edition1 */
+  ch = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH2);
+  fail_if (ch == NULL);
+  gst_tag_list_add (ch->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (ch->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  CHECK_TOC_ENTRY (ch, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH2);
+
+  ed->subentries = g_list_append (ed->subentries, ch);
+  fail_unless (g_list_length (ed->subentries) == 2);
+
+  /* append edition1 to the TOC */
+  toc->entries = g_list_append (toc->entries, ed);
+  fail_unless (g_list_length (toc->entries) == 1);
+
+  /* test gst_toc_entry_find() */
+  ed = NULL;
+  ed = gst_toc_find_entry (toc, ENTRY_ED1);
+
+  fail_if (ed == NULL);
+
+  CHECK_TOC_ENTRY (ed, GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED1);
+
+  /* test info GstStructure */
+  gst_toc_entry_set_start_stop (ch, 100, 1000);
+  fail_if (!gst_toc_entry_get_start_stop (ch, &start, &stop));
+  fail_unless (start == 100);
+  fail_unless (stop == 1000);
+
+  /* create edition2 */
+  ed = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED2);
+  fail_if (ed == NULL);
+  gst_tag_list_add (ed->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (ed->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  CHECK_TOC_ENTRY (ed, GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED2);
+
+  /* create chapter3 */
+  ch = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH3);
+  fail_if (ch == NULL);
+  gst_tag_list_add (ch->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (ch->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  CHECK_TOC_ENTRY (ch, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH3);
+
+  /* create subchapter1 */
+  subch = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_SUB1);
+  fail_if (subch == NULL);
+  gst_tag_list_add (subch->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (subch->info, INFO_NAME, GST_TYPE_STRUCTURE, structure,
+      NULL);
+  gst_structure_free (structure);
+
+  CHECK_TOC_ENTRY (subch, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_SUB1);
+
+  /* append subchapter1 to chapter3 */
+  ch->subentries = g_list_append (ch->subentries, subch);
+  fail_unless (g_list_length (ch->subentries) == 1);
+
+  /* append chapter3 to edition2 */
+  ed->subentries = g_list_append (ed->subentries, ch);
+  fail_unless (g_list_length (ed->subentries) == 1);
+
+  /* finally append edition2 to the TOC */
+  toc->entries = g_list_append (toc->entries, ed);
+  fail_unless (g_list_length (toc->entries) == 2);
+
+  /* test gst_toc_copy() */
+  test_toc = gst_toc_copy (toc);
+  fail_if (test_toc == NULL);
+  CHECK_TOC (test_toc);
+  gst_toc_free (test_toc);
+  test_toc = NULL;
+
+  /* check TOC event handling */
+  event = gst_event_new_toc (toc, TRUE);
+  fail_if (event == NULL);
+  fail_if (event->structure == NULL);
+  fail_unless (event->type == GST_EVENT_TOC);
+  ASSERT_MINI_OBJECT_REFCOUNT (GST_MINI_OBJECT (event), "GstEvent", 1);
+
+  gst_event_parse_toc (event, &test_toc, &updated);
+  fail_unless (updated == TRUE);
+  fail_if (test_toc == NULL);
+  CHECK_TOC (test_toc);
+  gst_toc_free (test_toc);
+  gst_event_unref (event);
+  updated = FALSE;
+  test_toc = NULL;
+
+  /* check TOC message handling */
+  message = gst_message_new_toc (NULL, toc, TRUE);
+  fail_if (message == NULL);
+  fail_if (event->structure == NULL);
+  fail_unless (message->type == GST_MESSAGE_TOC);
+  ASSERT_MINI_OBJECT_REFCOUNT (GST_MINI_OBJECT (message), "GstMessage", 1);
+
+  gst_message_parse_toc (message, &test_toc, &updated);
+  fail_unless (updated == TRUE);
+  fail_if (test_toc == NULL);
+  CHECK_TOC (test_toc);
+  gst_toc_free (test_toc);
+  gst_message_unref (message);
+  test_toc = NULL;
+
+  /* check TOC select event handling */
+  event = gst_event_new_toc_select (TEST_UID);
+  fail_if (event == NULL);
+  fail_if (event->structure == NULL);
+  fail_unless (event->type == GST_EVENT_TOC_SELECT);
+  ASSERT_MINI_OBJECT_REFCOUNT (GST_MINI_OBJECT (event), "GstEvent", 1);
+
+  gst_event_parse_toc_select (event, &uid);
+  fail_unless_equals_string (uid, TEST_UID);
+  gst_event_unref (event);
+  g_free (uid);
+
+  /* check TOC query handling */
+  query = gst_query_new_toc ();
+  fail_if (query == NULL);
+  gst_query_set_toc (query, toc, TEST_UID);
+  fail_if (query->structure == NULL);
+  fail_unless (query->type == GST_QUERY_TOC);
+  ASSERT_MINI_OBJECT_REFCOUNT (GST_MINI_OBJECT (query), "GstQuery", 1);
+
+  gst_query_parse_toc (query, &test_toc, &uid);
+  fail_unless_equals_string (uid, TEST_UID);
+  fail_if (test_toc == NULL);
+  CHECK_TOC (test_toc);
+  gst_toc_free (test_toc);
+  gst_query_unref (query);
+  g_free (uid);
+
+  /* that's wrong code, we should fail */
+  ch = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH4);
+  toc->entries = g_list_prepend (toc->entries, ch);
+  ASSERT_CRITICAL (message = gst_message_new_toc (NULL, toc, TRUE));
+
+  /* and yet another one */
+  toc->entries = g_list_remove (toc->entries, ch);
+  gst_toc_entry_free (ch);
+  ed = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED3);
+  ch = (GstTocEntry *) (toc->entries->data);
+  ch->subentries = g_list_prepend (ch->subentries, ed);
+  ASSERT_WARNING (message = gst_message_new_toc (NULL, toc, TRUE));
+
+  gst_toc_free (toc);
+}
+
+GST_END_TEST;
+
+static Suite *
+gst_toc_suite (void)
+{
+  Suite *s = suite_create ("GstToc");
+  TCase *tc_chain = tcase_create ("general");
+
+  suite_add_tcase (s, tc_chain);
+  tcase_add_test (tc_chain, test_serializing);
+
+  return s;
+}
+
+GST_CHECK_MAIN (gst_toc);
diff --git a/tests/check/gst/gsttocsetter.c b/tests/check/gst/gsttocsetter.c
new file mode 100644
index 0000000..eabf41e
--- /dev/null
+++ b/tests/check/gst/gsttocsetter.c
@@ -0,0 +1,431 @@
+/* GStreamer GstTocSetter interface unit tests
+ * Copyright (C) 2010, 2012 Alexander Saprykin <xelfium@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <gst/check/gstcheck.h>
+#include <gst/gst.h>
+#include <string.h>
+
+#define ENTRY_ED1       "/edition1"
+#define ENTRY_ED2       "/edition2"
+#define ENTRY_ED3       "test-edition"
+
+#define ENTRY_CH1       "/edition1/chapter1"
+#define ENTRY_CH2       "/edition1/chapter2"
+#define ENTRY_CH3       "/edition2/chapter3"
+#define ENTRY_CH4       "/test-chapter"
+
+#define ENTRY_SUB1      "/edition2/chapter3/subchapter1"
+
+#define ENTRY_TAG       "EntryTag"
+#define TOC_TAG         "TocTag"
+#define INFO_NAME       "gst-toc-setter-check"
+#define INFO_FIELD      "info-test"
+#define INFO_TEXT_EN    "info-text-entry"
+#define INFO_TEXT_TOC   "info-text-toc"
+
+#define CHECK_TOC_ENTRY(entry_c,type_c,uid_c)                            \
+{                                                                        \
+  gchar *tag_c;                                                          \
+  const GValue *val;                                                     \
+  GstStructure *struct_c;                                                \
+                                                                         \
+  fail_unless_equals_string (entry_c->uid, uid_c);                       \
+  fail_unless (entry_c->type == type_c);                                 \
+  fail_unless (entry_c->tags != NULL);                                   \
+  fail_unless (entry_c->pads == NULL);                                   \
+                                                                         \
+  fail_unless (entry_c->info != NULL);                                   \
+  gst_structure_get (entry_c->info, INFO_NAME, GST_TYPE_STRUCTURE,       \
+      &struct_c, NULL);                                                  \
+  fail_unless (struct_c != NULL);                                        \
+  val = gst_structure_get_value (struct_c, INFO_FIELD);             \
+  fail_unless (val != NULL);                                             \
+  fail_unless_equals_string (g_value_get_string (val), INFO_TEXT_EN);    \
+                                                                         \
+  fail_unless (gst_tag_list_get_string (entry_c->tags,                   \
+               GST_TAG_TITLE, &tag_c));                                  \
+  fail_unless_equals_string (tag_c, ENTRY_TAG);                          \
+  g_free (tag_c);                                                        \
+  gst_structure_free (struct_c);                                         \
+}
+
+#define CHECK_TOC(toc_t)                                                 \
+{                                                                        \
+  GstTocEntry *entry_t, *subentry_t;                                     \
+  gchar *tag_t;                                                          \
+  const GValue *val;                                                     \
+  GstStructure *struct_toc;                                              \
+                                                                         \
+  /* check TOC */                                                        \
+  fail_unless (g_list_length (toc_t->entries) == 2);                     \
+  fail_unless (toc_t->tags != NULL);                                     \
+  fail_unless (gst_tag_list_get_string (toc_t->tags,                     \
+               GST_TAG_TITLE, &tag_t));                                  \
+  fail_unless_equals_string (tag_t, TOC_TAG);                            \
+  g_free (tag_t);                                                        \
+                                                                         \
+  fail_unless (toc_t->info != NULL);                                     \
+  gst_structure_get (toc_t->info, INFO_NAME, GST_TYPE_STRUCTURE,         \
+      &struct_toc, NULL);                                                \
+  fail_unless (struct_toc != NULL);                                      \
+  val = gst_structure_get_value (struct_toc, INFO_FIELD);                \
+  fail_unless (val != NULL);                                             \
+  fail_unless_equals_string (g_value_get_string (val), INFO_TEXT_TOC);   \
+  gst_structure_free (struct_toc);                                       \
+                                                                         \
+  /* check edition1 */                                                   \
+  entry_t = g_list_nth_data (toc_t->entries, 0);                         \
+  fail_if (entry_t == NULL);                                             \
+  fail_unless (g_list_length (entry_t->subentries) == 2);                \
+  CHECK_TOC_ENTRY (entry_t, GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED1);      \
+  /* check chapter1 */                                                   \
+  subentry_t = g_list_nth_data (entry_t->subentries, 0);                 \
+  fail_if (subentry_t == NULL);                                          \
+  fail_unless (g_list_length (subentry_t->subentries) == 0);             \
+  CHECK_TOC_ENTRY (subentry_t, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH1);   \
+  /* check chapter2 */                                                   \
+  subentry_t = g_list_nth_data (entry_t->subentries, 1);                 \
+  fail_if (subentry_t == NULL);                                          \
+  fail_unless (g_list_length (subentry_t->subentries) == 0);             \
+  CHECK_TOC_ENTRY (subentry_t, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH2);   \
+  /* check edition2 */                                                   \
+  entry_t = g_list_nth_data (toc_t->entries, 1);                         \
+  fail_if (entry_t == NULL);                                             \
+  fail_unless (g_list_length (entry_t->subentries) == 1);                \
+  CHECK_TOC_ENTRY (entry_t, GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED2);      \
+  /* check chapter3 */                                                   \
+  subentry_t = g_list_nth_data (entry_t->subentries, 0);                 \
+  fail_if (subentry_t == NULL);                                          \
+  fail_unless (g_list_length (subentry_t->subentries) == 1);             \
+  CHECK_TOC_ENTRY (subentry_t, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH3);   \
+  /* check subchapter1 */                                                \
+  subentry_t = g_list_nth_data (subentry_t->subentries, 0);              \
+  fail_if (subentry_t == NULL);                                          \
+  fail_unless (g_list_length (subentry_t->subentries) == 0);             \
+  CHECK_TOC_ENTRY (subentry_t, GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_SUB1);  \
+}
+
+/* some minimal GstTocSetter object */
+#define GST_TYPE_DUMMY_ENC gst_dummy_enc_get_type()
+
+typedef GstElement GstDummyEnc;
+typedef GstElementClass GstDummyEncClass;
+
+static void gst_dummy_enc_add_interfaces (GType enc_type);
+
+GType gst_dummy_enc_get_type (void);
+GST_BOILERPLATE_FULL (GstDummyEnc, gst_dummy_enc, GstElement,
+    GST_TYPE_ELEMENT, gst_dummy_enc_add_interfaces);
+
+static void
+gst_dummy_enc_add_interfaces (GType enc_type)
+{
+  static const GInterfaceInfo toc_setter_info = { NULL, NULL, NULL };
+
+  g_type_add_interface_static (enc_type, GST_TYPE_TOC_SETTER, &toc_setter_info);
+}
+
+static void
+gst_dummy_enc_base_init (gpointer g_class)
+{
+}
+
+static void
+gst_dummy_enc_class_init (GstDummyEncClass * klass)
+{
+}
+
+static void
+gst_dummy_enc_init (GstDummyEnc * enc, GstDummyEncClass * klass)
+{
+}
+
+static GstToc *
+create_toc (void)
+{
+  GstStructure *structure;
+  GstToc *toc;
+  GstTocEntry *ed, *ch, *subch;
+
+  toc = gst_toc_new ();
+  gst_tag_list_add (toc->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      TOC_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_TOC,
+      NULL);
+  gst_structure_set (toc->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  /* create edition1 */
+  ed = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED1);
+  gst_tag_list_add (ed->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (ed->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  /* append chapter1 to edition1 */
+  ch = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH1);
+  gst_tag_list_add (ch->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (ch->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  ed->subentries = g_list_append (ed->subentries, ch);
+
+  /* append chapter2 to edition1 */
+  ch = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH2);
+  gst_tag_list_add (ch->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (ch->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  ed->subentries = g_list_append (ed->subentries, ch);
+
+  /* append edition1 to the TOC */
+  toc->entries = g_list_append (toc->entries, ed);
+
+  /* create edition2 */
+  ed = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_EDITION, ENTRY_ED2);
+  gst_tag_list_add (ed->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (ed->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  /* create chapter3 */
+  ch = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_CH3);
+  gst_tag_list_add (ch->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (ch->info, INFO_NAME, GST_TYPE_STRUCTURE, structure, NULL);
+  gst_structure_free (structure);
+
+  /* create subchapter1 */
+  subch = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_CHAPTER, ENTRY_SUB1);
+  gst_tag_list_add (subch->tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE,
+      ENTRY_TAG, NULL);
+  structure =
+      gst_structure_new (INFO_NAME, INFO_FIELD, G_TYPE_STRING, INFO_TEXT_EN,
+      NULL);
+  gst_structure_set (subch->info, INFO_NAME, GST_TYPE_STRUCTURE, structure,
+      NULL);
+  gst_structure_free (structure);
+
+  /* append subchapter1 to chapter3 */
+  ch->subentries = g_list_append (ch->subentries, subch);
+
+  /* append chapter3 to edition2 */
+  ed->subentries = g_list_append (ed->subentries, ch);
+
+  /* finally append edition2 to the TOC */
+  toc->entries = g_list_append (toc->entries, ed);
+
+  return toc;
+}
+
+GST_START_TEST (test_set)
+{
+  GstToc *toc;
+  GstTocEntry *entry, *ed;
+  GstTocSetter *setter;
+  GstElement *enc;
+
+  enc = g_object_new (GST_TYPE_DUMMY_ENC, NULL);
+  fail_unless (enc != NULL);
+
+  setter = GST_TOC_SETTER (enc);
+
+  toc = create_toc ();
+  fail_unless (toc != NULL);
+
+  gst_toc_setter_set_toc (setter, toc);
+
+  gst_toc_free (toc);
+  toc = gst_toc_setter_get_toc_copy (setter);
+
+  CHECK_TOC (toc);
+
+  /* test entry adding into the root TOC */
+  entry = g_list_last (toc->entries)->data;
+  toc->entries = g_list_remove (toc->entries, entry);
+
+  gst_toc_setter_set_toc (setter, toc);
+  gst_toc_setter_add_toc_entry (setter, "0", entry);
+
+  gst_toc_free (toc);
+  gst_toc_entry_free (entry);
+  toc = gst_toc_setter_get_toc_copy (setter);
+
+  CHECK_TOC (toc);
+
+  /* test entry adding into the arbitrary entry */
+  entry = gst_toc_find_entry (toc, ENTRY_CH2);
+  fail_if (entry == NULL);
+
+  ed = toc->entries->data;
+  ed->subentries = g_list_remove (ed->subentries, entry);
+
+  gst_toc_setter_add_toc_entry (setter, ed->uid, entry);
+
+  CHECK_TOC (toc);
+
+  gst_toc_free (toc);
+  gst_toc_setter_reset_toc (setter);
+  toc = gst_toc_setter_get_toc_copy (setter);
+
+  fail_unless (toc == NULL);
+
+  g_object_unref (enc);
+}
+
+GST_END_TEST static int spin_and_wait = 1;
+static int threads_running = 0;
+
+#define THREADS_TEST_SECONDS 1.5
+
+static gpointer
+test_threads_thread_func1 (gpointer data)
+{
+  GstToc *toc;
+  GstTocSetter *setter = GST_TOC_SETTER (data);
+  GTimer *timer;
+
+  toc = create_toc ();
+  timer = g_timer_new ();
+
+  g_atomic_int_inc (&threads_running);
+  while (g_atomic_int_get (&spin_and_wait))
+    g_usleep (0);
+
+  GST_INFO ("Go!");
+  g_timer_start (timer);
+
+  while (g_timer_elapsed (timer, NULL) < THREADS_TEST_SECONDS)
+    gst_toc_setter_set_toc (setter, toc);
+
+  gst_toc_free (toc);
+  g_timer_destroy (timer);
+  GST_INFO ("Done");
+
+  return NULL;
+}
+
+static gpointer
+test_threads_thread_func2 (gpointer data)
+{
+  GstToc *toc;
+  GstTocSetter *setter = GST_TOC_SETTER (data);
+  GTimer *timer;
+
+  toc = create_toc ();
+  timer = g_timer_new ();
+
+  g_atomic_int_inc (&threads_running);
+  while (g_atomic_int_get (&spin_and_wait))
+    g_usleep (0);
+
+  GST_INFO ("Go!");
+  g_timer_start (timer);
+
+  while (g_timer_elapsed (timer, NULL) < THREADS_TEST_SECONDS)
+    gst_toc_setter_set_toc (setter, toc);
+
+  gst_toc_free (toc);
+  g_timer_destroy (timer);
+  GST_INFO ("Done");
+
+  return NULL;
+}
+
+static gpointer
+test_threads_thread_func3 (gpointer data)
+{
+  GstTocSetter *setter = GST_TOC_SETTER (data);
+  GTimer *timer;
+
+  timer = g_timer_new ();
+
+  g_atomic_int_inc (&threads_running);
+  while (g_atomic_int_get (&spin_and_wait))
+    g_usleep (0);
+
+  GST_INFO ("Go!");
+  g_timer_start (timer);
+
+  while (g_timer_elapsed (timer, NULL) < THREADS_TEST_SECONDS) {
+    gst_toc_setter_reset_toc (setter);
+  }
+
+  g_timer_destroy (timer);
+  GST_INFO ("Done");
+
+  return NULL;
+}
+
+GST_START_TEST (test_threads)
+{
+  GstTocSetter *setter;
+  GThread *threads[3];
+
+  setter = GST_TOC_SETTER (g_object_new (GST_TYPE_DUMMY_ENC, NULL));
+
+  spin_and_wait = TRUE;
+  threads[0] = g_thread_create (test_threads_thread_func1, setter, TRUE, NULL);
+  threads[1] = g_thread_create (test_threads_thread_func2, setter, TRUE, NULL);
+  threads[2] = g_thread_create (test_threads_thread_func3, setter, TRUE, NULL);
+
+  while (g_atomic_int_get (&threads_running) < 3)
+    g_usleep (10);
+
+  g_atomic_int_set (&spin_and_wait, FALSE);
+
+  g_thread_join (threads[0]);
+  g_thread_join (threads[1]);
+  g_thread_join (threads[2]);
+
+  g_object_unref (G_OBJECT (setter));
+}
+
+GST_END_TEST static Suite *
+gst_toc_setter_suite (void)
+{
+  Suite *s = suite_create ("GstTocSetter");
+  TCase *tc_chain = tcase_create ("general");
+
+  suite_add_tcase (s, tc_chain);
+  tcase_add_test (tc_chain, test_set);
+  tcase_add_test (tc_chain, test_threads);
+
+  return s;
+}
+
+GST_CHECK_MAIN (gst_toc_setter);
diff --git a/tests/check/pipelines/seek.c b/tests/check/pipelines/seek.c
new file mode 100644
index 0000000..84c1161
--- /dev/null
+++ b/tests/check/pipelines/seek.c
@@ -0,0 +1,226 @@
+/* GStreamer simple seek unit test
+ * Copyright (C) 2012 Collabora Ltd.
+ *   Author: Tim-Philipp Müller <tim.muller@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <gst/gst.h>
+#include <gst/base/gstbasesrc.h>
+
+#include <gst/check/gstcheck.h>
+#include <gst/check/gstconsistencychecker.h>
+
+/* ========================================================================
+ *  Dummy source, like a stripped down audio test source
+ * ======================================================================== */
+
+#define SAMPLERATE 44100
+#define CHUNKS_PER_SEC 10
+
+typedef struct
+{
+  GstBaseSrc parent;
+  GstClockTime next_time;
+} TimedTestSrc;
+
+typedef struct
+{
+  GstBaseSrcClass parent_class;
+} TimedTestSrcClass;
+
+static GstStaticPadTemplate timed_test_src_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("timed/audio"));
+
+static GType timed_test_src_get_type (void);
+
+GST_BOILERPLATE (TimedTestSrc, timed_test_src, GstBaseSrc, GST_TYPE_BASE_SRC);
+
+static gboolean timed_test_src_is_seekable (GstBaseSrc * basesrc);
+static gboolean timed_test_src_check_get_range (GstBaseSrc * basesrc);
+static gboolean timed_test_src_do_seek (GstBaseSrc * basesrc,
+    GstSegment * segment);
+static gboolean timed_test_src_start (GstBaseSrc * basesrc);
+static gboolean timed_test_src_stop (GstBaseSrc * basesrc);
+static GstFlowReturn timed_test_src_create (GstBaseSrc * basesrc,
+    guint64 offset, guint length, GstBuffer ** buffer);
+
+static void
+timed_test_src_base_init (gpointer g_class)
+{
+  gst_element_class_add_static_pad_template (GST_ELEMENT_CLASS (g_class),
+      &timed_test_src_src_template);
+}
+
+static void
+timed_test_src_class_init (TimedTestSrcClass * klass)
+{
+  GstBaseSrcClass *gstbasesrc_class = (GstBaseSrcClass *) klass;
+
+  gstbasesrc_class->is_seekable = timed_test_src_is_seekable;
+  gstbasesrc_class->check_get_range = timed_test_src_check_get_range;
+  gstbasesrc_class->do_seek = timed_test_src_do_seek;
+  gstbasesrc_class->start = timed_test_src_start;
+  gstbasesrc_class->stop = timed_test_src_stop;
+  gstbasesrc_class->create = timed_test_src_create;
+}
+
+static void
+timed_test_src_init (TimedTestSrc * src, TimedTestSrcClass * g_class)
+{
+  gst_base_src_set_format (GST_BASE_SRC (src), GST_FORMAT_TIME);
+  gst_base_src_set_live (GST_BASE_SRC (src), FALSE);
+}
+
+static gboolean
+timed_test_src_start (GstBaseSrc * basesrc)
+{
+  TimedTestSrc *src = (TimedTestSrc *) basesrc;
+
+  src->next_time = 0;
+  return TRUE;
+}
+
+static gboolean
+timed_test_src_stop (GstBaseSrc * basesrc)
+{
+  return TRUE;
+}
+
+static gboolean
+timed_test_src_do_seek (GstBaseSrc * basesrc, GstSegment * segment)
+{
+  TimedTestSrc *src = (TimedTestSrc *) basesrc;
+
+  src->next_time = segment->last_stop;
+  return TRUE;
+}
+
+static gboolean
+timed_test_src_is_seekable (GstBaseSrc * basesrc)
+{
+  return TRUE;
+}
+
+static gboolean
+timed_test_src_check_get_range (GstBaseSrc * basesrc)
+{
+  return FALSE;
+}
+
+static GstFlowReturn
+timed_test_src_create (GstBaseSrc * basesrc, guint64 offset, guint length,
+    GstBuffer ** buf)
+{
+  TimedTestSrc *src = (TimedTestSrc *) basesrc;
+
+  *buf = gst_buffer_new_and_alloc (SAMPLERATE / CHUNKS_PER_SEC);
+  GST_BUFFER_TIMESTAMP (*buf) = src->next_time;
+  GST_BUFFER_DURATION (*buf) = GST_SECOND / CHUNKS_PER_SEC;
+  src->next_time += GST_BUFFER_DURATION (*buf);
+  return GST_FLOW_OK;
+}
+
+/* ======================================================================== */
+
+GST_START_TEST (test_seek)
+{
+  GstStreamConsistency *consist;
+  GstMessage *msg;
+  GstElement *bin, *src1, *sink;
+  gboolean res;
+  GstPad *srcpad;
+  GstBus *bus;
+
+  GST_INFO ("preparing test");
+
+  /* build pipeline */
+  bin = gst_pipeline_new ("pipeline");
+  bus = gst_element_get_bus (bin);
+  gst_bus_add_signal_watch_full (bus, G_PRIORITY_HIGH);
+
+  src1 = g_object_new (timed_test_src_get_type (), "name", "testsrc", NULL);
+
+  sink = gst_element_factory_make ("fakesink", "sink");
+  gst_bin_add_many (GST_BIN (bin), src1, sink, NULL);
+
+  res = gst_element_link (src1, sink);
+  fail_unless (res == TRUE, NULL);
+
+  srcpad = gst_element_get_static_pad (src1, "src");
+  consist = gst_consistency_checker_new (srcpad);
+  gst_object_unref (srcpad);
+
+  GST_INFO ("starting test");
+
+  /* prepare playing */
+  res = gst_element_set_state (bin, GST_STATE_PAUSED);
+  fail_unless (res != GST_STATE_CHANGE_FAILURE, NULL);
+
+  /* wait for completion */
+  res =
+      gst_element_get_state (GST_ELEMENT (bin), NULL, NULL,
+      GST_CLOCK_TIME_NONE);
+  fail_unless (res != GST_STATE_CHANGE_FAILURE, NULL);
+
+  res = gst_element_send_event (bin,
+      gst_event_new_seek (1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
+          GST_SEEK_TYPE_SET, (GstClockTime) 0,
+          GST_SEEK_TYPE_SET, (GstClockTime) 2 * GST_SECOND));
+  fail_unless (res == TRUE, NULL);
+
+  GST_INFO ("seeked");
+
+  /* run pipeline */
+  res = gst_element_set_state (bin, GST_STATE_PLAYING);
+  fail_unless (res != GST_STATE_CHANGE_FAILURE, NULL);
+
+  msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE,
+      GST_MESSAGE_EOS | GST_MESSAGE_ERROR);
+  fail_unless_equals_string (GST_MESSAGE_TYPE_NAME (msg), "eos");
+  gst_message_unref (msg);
+
+  res = gst_element_set_state (bin, GST_STATE_NULL);
+  fail_unless (res != GST_STATE_CHANGE_FAILURE, NULL);
+
+  /* cleanup */
+  gst_consistency_checker_free (consist);
+  gst_object_unref (bus);
+  gst_object_unref (bin);
+}
+
+GST_END_TEST;
+
+static Suite *
+pipelines_seek_suite (void)
+{
+  Suite *s = suite_create ("pipelines-seek");
+  TCase *tc_chain = tcase_create ("general");
+
+  suite_add_tcase (s, tc_chain);
+  tcase_add_test (tc_chain, test_seek);
+
+  return s;
+}
+
+GST_CHECK_MAIN (pipelines_seek);
diff --git a/tools/gst-inspect.c b/tools/gst-inspect.c
index d3ce0c8..f8d2f2f 100644
--- a/tools/gst-inspect.c
+++ b/tools/gst-inspect.c
@@ -21,6 +21,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
@@ -1230,7 +1234,7 @@ print_plugin_info (GstPlugin * plugin)
 static void
 print_plugin_features (GstPlugin * plugin)
 {
-  GList *features;
+  GList *features, *features_to_free;
   gint num_features = 0;
   gint num_elements = 0;
   gint num_typefinders = 0;
@@ -1241,6 +1245,7 @@ print_plugin_features (GstPlugin * plugin)
       gst_registry_get_feature_list_by_plugin (gst_registry_get_default (),
       plugin->desc.name);
 
+  features_to_free = features;
   while (features) {
     GstPluginFeature *feature;
 
@@ -1284,6 +1289,7 @@ print_plugin_features (GstPlugin * plugin)
       num_other++;
     }
     num_features++;
+    gst_object_unref (feature);
     features = g_list_next (features);
   }
   n_print ("\n");
@@ -1298,6 +1304,9 @@ print_plugin_features (GstPlugin * plugin)
     n_print ("  +-- %d other objects\n", num_other);
 
   n_print ("\n");
+
+  if (features_to_free)
+    g_list_free (features_to_free);
 }
 
 static int
@@ -1339,6 +1348,7 @@ print_element_info (GstElementFactory * factory, gboolean print_names)
 
   element = gst_element_factory_create (factory, NULL);
   if (!element) {
+    gst_object_unref (factory);
     g_print ("couldn't construct element for some reason\n");
     return -1;
   }
diff --git a/tools/gst-launch.c b/tools/gst-launch.c
index b801d03..09577b1 100644
--- a/tools/gst-launch.c
+++ b/tools/gst-launch.c
@@ -69,6 +69,7 @@ static GstElement *pipeline;
 static EventLoopResult caught_error = ELR_NO_ERROR;
 static gboolean quiet = FALSE;
 static gboolean tags = FALSE;
+static gboolean toc = FALSE;
 static gboolean messages = FALSE;
 static gboolean is_live = FALSE;
 static gboolean waiting_eos = FALSE;
@@ -507,6 +508,36 @@ print_tag (const GstTagList * list, const gchar * tag, gpointer unused)
   }
 }
 
+#define MAX_INDENT 40
+
+static void
+print_toc_entry (gpointer data, gpointer user_data)
+{
+  GstTocEntry *entry = (GstTocEntry *) data;
+  const gchar spc[MAX_INDENT + 1] = "                                        ";
+  const gchar *entry_types[] = { "chapter", "edition" };
+  guint indent = MIN (GPOINTER_TO_UINT (user_data), MAX_INDENT);
+  gint64 start, stop;
+
+  gst_toc_entry_get_start_stop (entry, &start, &stop);
+
+  PRINT ("%s%s:", &spc[MAX_INDENT - indent], entry_types[entry->type]);
+  if (GST_CLOCK_TIME_IS_VALID (start)) {
+    PRINT (" start: %" GST_TIME_FORMAT, GST_TIME_ARGS (start));
+  }
+  if (GST_CLOCK_TIME_IS_VALID (stop)) {
+    PRINT (" stop: %" GST_TIME_FORMAT, GST_TIME_ARGS (stop));
+  }
+  PRINT ("\n");
+  indent += 2;
+
+  /* TODO: print tags */
+
+  /* loop over sub-toc entries */
+  g_list_foreach (entry->subentries, print_toc_entry,
+      GUINT_TO_POINTER (indent));
+}
+
 #ifndef DISABLE_FAULT_HANDLER
 /* we only use sighandler here because the registers are not important */
 static void
@@ -689,7 +720,7 @@ event_loop (GstElement * pipeline, gboolean blocking, GstState target_state)
       }
       case GST_MESSAGE_TAG:
         if (tags) {
-          GstTagList *tags;
+          GstTagList *tag_list;
 
           if (GST_IS_ELEMENT (GST_MESSAGE_SRC (message))) {
             PRINT (_("FOUND TAG      : found by element \"%s\".\n"),
@@ -704,9 +735,31 @@ event_loop (GstElement * pipeline, gboolean blocking, GstState target_state)
             PRINT (_("FOUND TAG\n"));
           }
 
-          gst_message_parse_tag (message, &tags);
-          gst_tag_list_foreach (tags, print_tag, NULL);
-          gst_tag_list_free (tags);
+          gst_message_parse_tag (message, &tag_list);
+          gst_tag_list_foreach (tag_list, print_tag, NULL);
+          gst_tag_list_free (tag_list);
+        }
+        break;
+      case GST_MESSAGE_TOC:
+        if (toc) {
+          GstToc *toc_msg;
+          gboolean updated;
+
+          if (GST_IS_ELEMENT (GST_MESSAGE_SRC (message))) {
+            PRINT (_("FOUND TOC      : found by element \"%s\".\n"),
+                GST_MESSAGE_SRC_NAME (message));
+          } else if (GST_IS_OBJECT (GST_MESSAGE_SRC (message))) {
+            PRINT (_("FOUND TOC      : found by object \"%s\".\n"),
+                GST_MESSAGE_SRC_NAME (message));
+          } else {
+            PRINT (_("FOUND TOC\n"));
+          }
+
+          gst_message_parse_toc (message, &toc_msg, &updated);
+          /* recursively loop over toc entries */
+          g_list_foreach (toc_msg->entries, print_toc_entry,
+              GUINT_TO_POINTER (0));
+          gst_toc_free (toc_msg);
         }
         break;
       case GST_MESSAGE_INFO:{
@@ -929,6 +982,8 @@ main (int argc, char *argv[])
   GOptionEntry options[] = {
     {"tags", 't', 0, G_OPTION_ARG_NONE, &tags,
         N_("Output tags (also known as metadata)"), NULL},
+    {"toc", 'c', 0, G_OPTION_ARG_NONE, &toc,
+        N_("Ouput TOC (chapters and editions)"), NULL},
     {"verbose", 'v', 0, G_OPTION_ARG_NONE, &verbose,
         N_("Output status information and property notifications"), NULL},
     {"quiet", 'q', 0, G_OPTION_ARG_NONE, &quiet,
diff --git a/win32/common/config.h b/win32/common/config.h
index ae83e50..dbc82e4 100644
--- a/win32/common/config.h
+++ b/win32/common/config.h
@@ -59,13 +59,13 @@
 #define GST_MAJORMINOR "0.10"
 
 /* package name in plugins */
-#define GST_PACKAGE_NAME "GStreamer source release"
+#define GST_PACKAGE_NAME "GStreamer git"
 
 /* package origin */
 #define GST_PACKAGE_ORIGIN "Unknown package origin"
 
 /* GStreamer package release date/time for plugins as YYYY-MM-DD */
-#define GST_PACKAGE_RELEASE_DATETIME "2012-02-20"
+#define GST_PACKAGE_RELEASE_DATETIME "2012-02-23T10:04Z"
 
 /* location of the installed gst-plugin-scanner */
 #define GST_PLUGIN_SCANNER_INSTALLED LIBDIR "\\gst-plugin-scanner"
@@ -343,7 +343,7 @@
 #define PACKAGE_NAME "GStreamer"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "GStreamer 0.10.36"
+#define PACKAGE_STRING "GStreamer 0.10.36.1"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "gstreamer"
@@ -352,7 +352,7 @@
 #undef PACKAGE_URL
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "0.10.36"
+#define PACKAGE_VERSION "0.10.36.1"
 
 /* directory where plugins are located */
 #ifdef _DEBUG
@@ -383,7 +383,7 @@
 #undef USE_POISONING
 
 /* Version number of package */
-#define VERSION "0.10.36"
+#define VERSION "0.10.36.1"
 
 /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
    significant byte first (like Motorola and SPARC, unlike Intel). */
diff --git a/win32/common/gstversion.h b/win32/common/gstversion.h
index 86040e6..f1154e2 100644
--- a/win32/common/gstversion.h
+++ b/win32/common/gstversion.h
@@ -64,7 +64,7 @@ G_BEGIN_DECLS
  * The nano version of GStreamer at compile time:
  * Actual releases have 0, GIT versions have 1, prerelease versions have 2-...
  */
-#define GST_VERSION_NANO (0)
+#define GST_VERSION_NANO (1)
 
 /**
  * GST_CHECK_VERSION:
diff --git a/win32/common/libgstbase.def b/win32/common/libgstbase.def
index e68c0e9..806ba6c 100644
--- a/win32/common/libgstbase.def
+++ b/win32/common/libgstbase.def
@@ -210,6 +210,7 @@ EXPORTS
 	gst_collect_pads2_add_pad
 	gst_collect_pads2_add_pad_full
 	gst_collect_pads2_available
+	gst_collect_pads2_clip_running_time
 	gst_collect_pads2_collect
 	gst_collect_pads2_collect_range
 	gst_collect_pads2_flush
diff --git a/win32/common/libgstreamer.def b/win32/common/libgstreamer.def
index 03f4a04..627268c 100644
--- a/win32/common/libgstreamer.def
+++ b/win32/common/libgstreamer.def
@@ -416,6 +416,8 @@ EXPORTS
 	gst_event_new_sink_message
 	gst_event_new_step
 	gst_event_new_tag
+	gst_event_new_toc
+	gst_event_new_toc_select
 	gst_event_parse_buffer_size
 	gst_event_parse_latency
 	gst_event_parse_new_segment
@@ -426,6 +428,8 @@ EXPORTS
 	gst_event_parse_sink_message
 	gst_event_parse_step
 	gst_event_parse_tag
+	gst_event_parse_toc
+	gst_event_parse_toc_select
 	gst_event_set_seqnum
 	gst_event_type_flags_get_type
 	gst_event_type_get_flags
@@ -571,6 +575,7 @@ EXPORTS
 	gst_message_new_structure_change
 	gst_message_new_tag
 	gst_message_new_tag_full
+	gst_message_new_toc
 	gst_message_new_warning
 	gst_message_parse_async_start
 	gst_message_parse_buffering
@@ -595,6 +600,7 @@ EXPORTS
 	gst_message_parse_structure_change
 	gst_message_parse_tag
 	gst_message_parse_tag_full
+	gst_message_parse_toc
 	gst_message_parse_warning
 	gst_message_set_buffering_stats
 	gst_message_set_qos_stats
@@ -878,6 +884,7 @@ EXPORTS
 	gst_query_new_position
 	gst_query_new_seeking
 	gst_query_new_segment
+	gst_query_new_toc
 	gst_query_new_uri
 	gst_query_parse_buffering_percent
 	gst_query_parse_buffering_range
@@ -891,6 +898,7 @@ EXPORTS
 	gst_query_parse_position
 	gst_query_parse_seeking
 	gst_query_parse_segment
+	gst_query_parse_toc
 	gst_query_parse_uri
 	gst_query_set_buffering_percent
 	gst_query_set_buffering_range
@@ -903,6 +911,7 @@ EXPORTS
 	gst_query_set_position
 	gst_query_set_seeking
 	gst_query_set_segment
+	gst_query_set_toc
 	gst_query_set_uri
 	gst_query_type_get_by_nick
 	gst_query_type_get_details
@@ -1134,6 +1143,25 @@ EXPORTS
 	gst_task_start
 	gst_task_state_get_type
 	gst_task_stop
+	gst_toc_copy
+	gst_toc_entry_copy
+	gst_toc_entry_free
+	gst_toc_entry_get_start_stop
+	gst_toc_entry_new
+	gst_toc_entry_new_with_pad
+	gst_toc_entry_set_start_stop
+	gst_toc_entry_type_get_type
+	gst_toc_find_entry
+	gst_toc_free
+	gst_toc_new
+	gst_toc_setter_add_toc_entry
+	gst_toc_setter_get_toc
+	gst_toc_setter_get_toc_copy
+	gst_toc_setter_get_toc_entry
+	gst_toc_setter_get_toc_entry_copy
+	gst_toc_setter_get_type
+	gst_toc_setter_reset_toc
+	gst_toc_setter_set_toc
 	gst_trace_destroy
 	gst_trace_flush
 	gst_trace_new
diff --git a/gst/Makefile.am b/gst/Makefile.am
index 0da40a0..a9852de 100644
--- a/gst/Makefile.am
+++ b/gst/Makefile.am
@@ -99,7 +99,6 @@ libgstreamer_@GST_MAJORMINOR@_la_SOURCES = \
 	gsttask.c		\
 	gsttaskpool.c		\
 	gsttoc.c		\
-	gsttocsetter.c		\
 	$(GST_TRACE_SRC)	\
 	gsttypefind.c		\
 	gsttypefindfactory.c	\

