diff --git a/autogen.sh b/autogen.sh
index c0cd19e..b2e9ee4 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -1,6 +1,12 @@
 #!/bin/sh
 # Run this to generate all the initial makefiles, etc.
 
+test -n "$srcdir" || srcdir=`dirname "$0"`
+test -n "$srcdir" || srcdir=.
+
+olddir=`pwd`
+cd "$srcdir"
+
 DIE=0
 package=gstreamer
 srcfile=gst/gst.c
@@ -29,7 +35,9 @@ then
     ln -s ../../common/hooks/pre-commit.hook .git/hooks/pre-commit
 fi
 
-
+# GNU gettext automake support doesn't get along with git.
+# https://bugzilla.gnome.org/show_bug.cgi?id=661128
+touch -t 200001010000 po/gstreamer-0.10.pot
 
 CONFIGURE_DEF_OPT='--enable-maintainer-mode --enable-failing-tests --enable-poisoning --enable-gtk-doc --enable-docbook'
 
@@ -56,7 +64,7 @@ autoheader_check || DIE=1
 die_check $DIE
 
 # if no arguments specified then this will be printed
-if test -z "$*"; then
+if test -z "$*" && test -z "$NOCONFIGURE"; then
   echo "+ checking for autogen.sh options"
   echo "  This autogen script will automatically run ./configure as:"
   echo "  ./configure $CONFIGURE_DEF_OPT"
@@ -97,13 +105,15 @@ test -n "$NOCONFIGURE" && {
   exit 0
 }
 
+cd "$olddir"
+
 echo "+ running configure ... "
 test ! -z "$CONFIGURE_DEF_OPT" && echo "  ./configure default flags: $CONFIGURE_DEF_OPT"
 test ! -z "$CONFIGURE_EXT_OPT" && echo "  ./configure external flags: $CONFIGURE_EXT_OPT"
 echo
 
-echo ./configure $CONFIGURE_DEF_OPT $CONFIGURE_EXT_OPT
-./configure $CONFIGURE_DEF_OPT $CONFIGURE_EXT_OPT || {
+echo "$srcdir/configure" $CONFIGURE_DEF_OPT $CONFIGURE_EXT_OPT
+"$srcdir/configure" $CONFIGURE_DEF_OPT $CONFIGURE_EXT_OPT || {
         echo "  configure failed"
         exit 1
 }
diff --git a/configure.ac b/configure.ac
index 57c54da..8a67c36 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3,7 +3,7 @@ AC_PREREQ(2.60)
 dnl initialize autoconf
 dnl when going to/from release please set the nano (fourth number) right !
 dnl releases only do Wall, git and prerelease does Werror too
-AC_INIT(GStreamer, 0.10.36,
+AC_INIT(GStreamer, 0.10.36.1,
     http://bugzilla.gnome.org/enter_bug.cgi?product=GStreamer,
     gstreamer)
 AG_GST_INIT
@@ -48,7 +48,7 @@ dnl - interfaces added/removed/changed -> increment CURRENT, REVISION = 0
 dnl - interfaces added -> increment AGE
 dnl - interfaces removed -> AGE = 0
 dnl sets GST_LT_LDFLAGS
-AS_LIBTOOL(GST, 30, 0, 30)
+AS_LIBTOOL(GST, 31, 0, 31)
 
 dnl FIXME: this macro doesn't actually work;
 dnl the generated libtool script has no support for the listed tags.
@@ -646,7 +648,7 @@ if test "x${GST_DISABLE_GST_DEBUG}" = "xyes"; then
 fi
 
 dnl define an ERROR_CFLAGS Makefile variable
-AG_GST_SET_ERROR_CFLAGS($GST_GIT, [-Wmissing-declarations -Wmissing-prototypes -Wredundant-decls -Wundef -Wwrite-strings -Wformat-nonliteral -Wformat-security -Wold-style-definition -Winit-self -Wmissing-include-dirs -Waddress -Waggregate-return -Wno-multichar -Wnested-externs $NO_WARNINGS])
+AG_GST_SET_ERROR_CFLAGS($FATAL_WARNINGS, [-Wmissing-declarations -Wmissing-prototypes -Wredundant-decls -Wundef -Wwrite-strings -Wformat-nonliteral -Wformat-security -Wold-style-definition -Winit-self -Wmissing-include-dirs -Waddress -Waggregate-return -Wno-multichar -Wnested-externs $NO_WARNINGS])
 
 dnl define correct level for debugging messages
 AG_GST_SET_LEVEL_DEFAULT($GST_GIT)
diff --git a/docs/faq/general.xml b/docs/faq/general.xml
index c6ccb6a..e85bec0 100644
--- a/docs/faq/general.xml
+++ b/docs/faq/general.xml
@@ -99,7 +99,7 @@ What are the exact licensing terms for GStreamer and its plugins ?
       <answer>
         <para>
 All of GStreamer, including our own plugin code, is licensed under the 
-<ulink url="http://www.gnu.org/licenses/lgpl.html">GNU LGPL</ulink> license.
+<ulink url="http://www.gnu.org/licenses/lgpl-2.1.html">GNU LGPL 2.1</ulink> license.
 Some of the libraries we use for some of the plugins are however under the 
 GPL, which means that those plugins can not be used by a non-GPL-compatible 
 application. 
diff --git a/docs/gst/gstreamer-sections.txt b/docs/gst/gstreamer-sections.txt
index 5fc6ec6..58be88d 100644
--- a/docs/gst/gstreamer-sections.txt
+++ b/docs/gst/gstreamer-sections.txt
@@ -2329,6 +2329,7 @@ GST_TAG_ALBUM_GAIN
 GST_TAG_ALBUM_PEAK
 GST_TAG_REFERENCE_LEVEL
 GST_TAG_LANGUAGE_CODE
+GST_TAG_LANGUAGE_NAME
 GST_TAG_IMAGE
 GST_TAG_PREVIEW_IMAGE
 GST_TAG_ATTACHMENT
diff --git a/docs/plugins/inspect/plugin-coreelements.xml b/docs/plugins/inspect/plugin-coreelements.xml
index fcd61ff..f67a60b 100644
--- a/docs/plugins/inspect/plugin-coreelements.xml
+++ b/docs/plugins/inspect/plugin-coreelements.xml
@@ -3,10 +3,10 @@
   <description>standard GStreamer elements</description>
   <filename>../../plugins/elements/.libs/libgstcoreelements.so</filename>
   <basename>libgstcoreelements.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gstreamer</source>
-  <package>GStreamer source release</package>
+  <package>GStreamer git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-coreindexers.xml b/docs/plugins/inspect/plugin-coreindexers.xml
index 9c43c63..8356f0c 100644
--- a/docs/plugins/inspect/plugin-coreindexers.xml
+++ b/docs/plugins/inspect/plugin-coreindexers.xml
@@ -3,10 +3,10 @@
   <description>GStreamer core indexers</description>
   <filename>../../plugins/indexers/.libs/libgstcoreindexers.so</filename>
   <basename>libgstcoreindexers.so</basename>
-  <version>0.10.36</version>
+  <version>0.10.36.1</version>
   <license>LGPL</license>
   <source>gstreamer</source>
-  <package>GStreamer source release</package>
+  <package>GStreamer git</package>
   <origin>Unknown package origin</origin>
   <elements>
   </elements>
diff --git a/gst/gst.c b/gst/gst.c
index ff7f250..8e6c542 100644
--- a/gst/gst.c
+++ b/gst/gst.c
@@ -913,7 +913,7 @@ parse_one_option (gint opt, const gchar * arg, GError ** err)
       GstDebugLevel tmp = GST_LEVEL_NONE;
 
       tmp = (GstDebugLevel) strtol (arg, NULL, 0);
-      if (tmp >= 0 && tmp < GST_LEVEL_COUNT) {
+      if (((guint) tmp) < GST_LEVEL_COUNT) {
         gst_debug_set_default_threshold (tmp);
       }
       break;
diff --git a/gst/gst_private.h b/gst/gst_private.h
index 6bd6725..c36a72d 100644
--- a/gst/gst_private.h
+++ b/gst/gst_private.h
@@ -141,7 +141,7 @@ gint priv_gst_date_time_compare (gconstpointer dt1, gconstpointer dt2);
 
 #ifndef GST_DISABLE_REGISTRY
 /* Secret variable to initialise gst without registry cache */
-extern gboolean _gst_disable_registry_cache;
+GST_EXPORT gboolean _gst_disable_registry_cache;
 #endif
 
 /* provide inline gst_g_value_get_foo_unchecked(), used in gststructure.c */
diff --git a/gst/gstconfig.h.in b/gst/gstconfig.h.in
index 4138b18..37db17e 100644
--- a/gst/gstconfig.h.in
+++ b/gst/gstconfig.h.in
@@ -229,7 +229,11 @@
 #endif
 #else /* not _MSC_VER */
 #define GST_PLUGIN_EXPORT
+#if (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#define GST_EXPORT extern __attribute__ ((visibility ("default")))
+#else
 #define GST_EXPORT extern
 #endif
+#endif
 
 #endif /* __GST_CONFIG_H__ */
diff --git a/gst/gstghostpad.c b/gst/gstghostpad.c
index d8fb3ea..284be98 100644
--- a/gst/gstghostpad.c
+++ b/gst/gstghostpad.c
@@ -166,7 +166,7 @@ gst_proxy_pad_query_default (GstPad * pad, GstQuery * query)
 }
 
 /**
- * gst_proyx_pad_iterate_internal_links_default:
+ * gst_proxy_pad_iterate_internal_links_default:
  * @pad: the #GstPad to get the internal links of.
  *
  * Invoke the default iterate internal links function of the proxy pad.
diff --git a/gst/gstpad.c b/gst/gstpad.c
index ef28bf5..f99bd7d 100644
--- a/gst/gstpad.c
+++ b/gst/gstpad.c
@@ -5596,7 +5596,7 @@ gst_pad_start_task (GstPad * pad, GstTaskFunction func, gpointer data)
     task = gst_task_create (func, data);
     gst_task_set_lock (task, GST_PAD_GET_STREAM_LOCK (pad));
     gst_task_set_thread_callbacks (task, &thr_callbacks, pad, NULL);
-    GST_DEBUG_OBJECT (pad, "created task");
+    GST_INFO_OBJECT (pad, "created task %p", task);
     GST_PAD_TASK (pad) = task;
     gst_object_ref (task);
     /* release lock to post the message */
diff --git a/gst/gstpad.h b/gst/gstpad.h
index 8990fdc..ef0c146 100644
--- a/gst/gstpad.h
+++ b/gst/gstpad.h
@@ -828,7 +828,7 @@ struct _GstPadClass {
  *
  * Lock the stream lock of @pad.
  */
-#define GST_PAD_STREAM_LOCK(pad)        (g_static_rec_mutex_lock(GST_PAD_GET_STREAM_LOCK(pad)))
+#define GST_PAD_STREAM_LOCK(pad)        g_static_rec_mutex_lock(GST_PAD_GET_STREAM_LOCK(pad))
 /**
  * GST_PAD_STREAM_LOCK_FULL:
  * @pad: a #GstPad
@@ -836,7 +836,7 @@ struct _GstPadClass {
  *
  * Lock the stream lock of @pad @t times.
  */
-#define GST_PAD_STREAM_LOCK_FULL(pad,t) (g_static_rec_mutex_lock_full(GST_PAD_GET_STREAM_LOCK(pad), t))
+#define GST_PAD_STREAM_LOCK_FULL(pad,t) g_static_rec_mutex_lock_full(GST_PAD_GET_STREAM_LOCK(pad), t)
 /**
  * GST_PAD_STREAM_TRYLOCK:
  * @pad: a #GstPad
@@ -844,14 +844,14 @@ struct _GstPadClass {
  * Try to Lock the stream lock of the pad, return TRUE if the lock could be
  * taken.
  */
-#define GST_PAD_STREAM_TRYLOCK(pad)     (g_static_rec_mutex_trylock(GST_PAD_GET_STREAM_LOCK(pad)))
+#define GST_PAD_STREAM_TRYLOCK(pad)     g_static_rec_mutex_trylock(GST_PAD_GET_STREAM_LOCK(pad))
 /**
  * GST_PAD_STREAM_UNLOCK:
  * @pad: a #GstPad
  *
  * Unlock the stream lock of @pad.
  */
-#define GST_PAD_STREAM_UNLOCK(pad)      (g_static_rec_mutex_unlock(GST_PAD_GET_STREAM_LOCK(pad)))
+#define GST_PAD_STREAM_UNLOCK(pad)      g_static_rec_mutex_unlock(GST_PAD_GET_STREAM_LOCK(pad))
 /**
  * GST_PAD_STREAM_UNLOCK_FULL:
  * @pad: a #GstPad
@@ -859,7 +859,7 @@ struct _GstPadClass {
  * Fully unlock the recursive stream lock of @pad, return the number of times
  * @pad was locked.
  */
-#define GST_PAD_STREAM_UNLOCK_FULL(pad) (g_static_rec_mutex_unlock_full(GST_PAD_GET_STREAM_LOCK(pad)))
+#define GST_PAD_STREAM_UNLOCK_FULL(pad) g_static_rec_mutex_unlock_full(GST_PAD_GET_STREAM_LOCK(pad))
 
 #define GST_PAD_GET_PREROLL_LOCK(pad)   (GST_PAD_CAST(pad)->preroll_lock)
 #define GST_PAD_PREROLL_LOCK(pad)       (g_mutex_lock(GST_PAD_GET_PREROLL_LOCK(pad)))
diff --git a/gst/gstpipeline.c b/gst/gstpipeline.c
index b032c2f..8612ae3 100644
--- a/gst/gstpipeline.c
+++ b/gst/gstpipeline.c
@@ -408,7 +408,9 @@ gst_pipeline_change_state (GstElement * element, GstStateChange transition)
 
       /* running time changed, either with a PAUSED or a flush, we need to check
        * if there is a new clock & update the base time */
-      if (update_clock || last_start_time != start_time) {
+      /* only do this for top-level, however */
+      if (GST_OBJECT_PARENT (element) == NULL &&
+          (update_clock || last_start_time != start_time)) {
         GST_DEBUG_OBJECT (pipeline, "Need to update start_time");
 
         /* when going to PLAYING, select a clock when needed. If we just got
diff --git a/gst/gstplugin.c b/gst/gstplugin.c
index 02e5cc9..693bc0f 100644
--- a/gst/gstplugin.c
+++ b/gst/gstplugin.c
@@ -90,7 +90,7 @@ static char *_gst_plugin_fault_handler_filename = NULL;
  * MIT/X11: http://www.opensource.org/licenses/mit-license.php
  * 3-clause BSD: http://www.opensource.org/licenses/bsd-license.php
  */
-static const gchar *valid_licenses[] = {
+static const gchar *const valid_licenses[] = {
   "LGPL",                       /* GNU Lesser General Public License */
   "GPL",                        /* GNU General Public License */
   "QPL",                        /* Trolltech Qt Public License */
@@ -487,7 +487,7 @@ priv_gst_plugin_loading_get_whitelist_hash (void)
 static gboolean
 gst_plugin_check_license (const gchar * license)
 {
-  const gchar **check_license = valid_licenses;
+  const gchar *const *check_license = valid_licenses;
 
   g_assert (check_license);
 
diff --git a/gst/gstquery.c b/gst/gstquery.c
index 2b1c382..d9c48f8 100644
--- a/gst/gstquery.c
+++ b/gst/gstquery.c
@@ -61,6 +61,11 @@
  * Last reviewed on 2006-02-14 (0.10.4)
  */
 
+
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include "gst_private.h"
 #include "gstinfo.h"
 #include "gstquery.h"
diff --git a/gst/gstregistrybinary.c b/gst/gstregistrybinary.c
index 1a58837..5848066 100644
--- a/gst/gstregistrybinary.c
+++ b/gst/gstregistrybinary.c
@@ -219,10 +219,11 @@ gst_registry_binary_cache_write (BinaryRegistryCache * cache,
 {
   long written;
   if (offset != cache->currentoffset) {
-    if (lseek (cache->cache_fd, offset, SEEK_SET) != 0) {
-      GST_ERROR ("Seeking to new offset failed");
-      return FALSE;
+    if (lseek (cache->cache_fd, offset, SEEK_SET) < 0) {
+      GST_ERROR ("Seeking to new offset failed: %s", g_strerror (errno));
+      return -1;
     }
+    GST_LOG ("Seeked from offset %lu to %lu", offset, cache->currentoffset);
     cache->currentoffset = offset;
   }
 
@@ -245,12 +246,13 @@ gst_registry_binary_cache_finish (BinaryRegistryCache * cache, gboolean success)
   if (close (cache->cache_fd) < 0)
     goto close_failed;
 
-  if (success) {
-    /* Only do the rename if we wrote the entire file successfully */
-    if (g_rename (cache->tmp_location, cache->location) < 0) {
-      GST_ERROR ("g_rename() failed: %s", g_strerror (errno));
-      goto rename_failed;
-    }
+  if (!success)
+    goto fail_after_close;
+
+  /* Only do the rename if we wrote the entire file successfully */
+  if (g_rename (cache->tmp_location, cache->location) < 0) {
+    GST_ERROR ("g_rename() failed: %s", g_strerror (errno));
+    goto rename_failed;
   }
 
   g_free (cache->tmp_location);
diff --git a/gst/gsttaglist.c b/gst/gsttaglist.c
index 282c920..ac88c79 100644
--- a/gst/gsttaglist.c
+++ b/gst/gsttaglist.c
@@ -274,7 +274,11 @@ _gst_tag_initialize (void)
       _("reference level of track and album gain values"), NULL);
   gst_tag_register (GST_TAG_LANGUAGE_CODE, GST_TAG_FLAG_META, G_TYPE_STRING,
       _("language code"),
-      _("language code for this stream, conforming to ISO-639-1"), NULL);
+      _("language code for this stream, conforming to ISO-639-1 or ISO-639-2"),
+      NULL);
+  gst_tag_register (GST_TAG_LANGUAGE_NAME, GST_TAG_FLAG_META, G_TYPE_STRING,
+      _("language name"),
+      _("freeform name of the language this stream is in"), NULL);
   gst_tag_register (GST_TAG_IMAGE, GST_TAG_FLAG_META, GST_TYPE_BUFFER,
       _("image"), _("image related to this stream"), gst_tag_merge_use_first);
   gst_tag_register (GST_TAG_PREVIEW_IMAGE, GST_TAG_FLAG_META, GST_TYPE_BUFFER,
diff --git a/gst/gsttaglist.h b/gst/gsttaglist.h
index 0cec033..96fcdb5 100644
--- a/gst/gsttaglist.h
+++ b/gst/gsttaglist.h
@@ -741,10 +741,25 @@ gboolean     gst_tag_list_get_buffer_index  (const GstTagList * list,
 /**
  * GST_TAG_LANGUAGE_CODE:
  *
- * Language code (ISO-639-1) (string) of the content
+ * ISO-639-2 or ISO-639-1 code for the language the content is in (string)
+ *
+ * There is utility API in libgsttag in gst-plugins-base to obtain a translated
+ * language name from the language code: gst_tag_get_language_name()
  */
 #define GST_TAG_LANGUAGE_CODE          "language-code"
 /**
+ * GST_TAG_LANGUAGE_NAME:
+ *
+ * Name of the language the content is in (string)
+ *
+ * Free-form name of the language the content is in, if a language code
+ * is not available. This tag should not be set in addition to a language
+ * code. It is undefined what language or locale the language name is in.
+ *
+ * Since: 0.10.37
+ */
+#define GST_TAG_LANGUAGE_NAME          "language-name"
+/**
  * GST_TAG_IMAGE:
  *
  * image (buffer) (buffer caps should specify the content type and preferably
diff --git a/gst/gsttask.c b/gst/gsttask.c
index 4aae349..1f72e92 100644
--- a/gst/gsttask.c
+++ b/gst/gsttask.c
@@ -306,7 +306,8 @@ gst_task_func (GstTask * task)
 
         t = g_static_rec_mutex_unlock_full (lock);
         if (t <= 0) {
-          g_warning ("wrong STREAM_LOCK count %d", t);
+          g_warning ("wrong STREAM_LOCK count %d for lock %p on task %p", t,
+              lock, task);
         }
         GST_TASK_SIGNAL (task);
         GST_TASK_WAIT (task);
@@ -443,6 +444,7 @@ gst_task_set_lock (GstTask * task, GStaticRecMutex * mutex)
   GST_OBJECT_LOCK (task);
   if (G_UNLIKELY (task->running))
     goto is_running;
+  GST_INFO ("setting stream lock %p on task %p", mutex, task);
   GST_TASK_GET_LOCK (task) = mutex;
   GST_OBJECT_UNLOCK (task);
 
diff --git a/gst/gstvalue.c b/gst/gstvalue.c
index 4f2b80d..bf9bb13 100644
--- a/gst/gstvalue.c
+++ b/gst/gstvalue.c
@@ -1315,8 +1315,9 @@ gst_value_free_fraction_range (GValue * value)
   GValue *vals = (GValue *) value->data[0].v_pointer;
 
   if (vals != NULL) {
-    g_value_unset (&vals[0]);
-    g_value_unset (&vals[1]);
+    /* we know the two values contain fractions without internal allocs */
+    /* g_value_unset (&vals[0]); */
+    /* g_value_unset (&vals[1]); */
     g_slice_free1 (2 * sizeof (GValue), vals);
     value->data[0].v_pointer = NULL;
   }
@@ -1465,8 +1466,9 @@ gst_value_set_fraction_range_full (GValue * value,
   gst_value_set_fraction (&end, numerator_end, denominator_end);
   gst_value_set_fraction_range (value, &start, &end);
 
-  g_value_unset (&start);
-  g_value_unset (&end);
+  /* we know the two values contain fractions without internal allocs */
+  /* g_value_unset (&start); */
+  /* g_value_unset (&end);   */
 }
 
 /**
diff --git a/gstreamer.doap b/gstreamer.doap
index 63d4fdc..d569497 100644
--- a/gstreamer.doap
+++ b/gstreamer.doap
@@ -40,18 +40,6 @@ hierarchy, and a set of media-agnostic core elements.
 
  <release>
   <Version>
-   <revision>0.10.36</revision>
-   <branch>0.10</branch>
-   <name>Harder</name>
-   <created>2012-02-20</created>
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gstreamer/gstreamer-0.10.36.tar.bz2" />
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gstreamer/gstreamer-0.10.36.tar.gz" />
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gstreamer/gstreamer-0.10.36.tar.xz" />
-  </Version>
- </release>
-
- <release>
-  <Version>
    <revision>0.10.35</revision>
    <branch>0.10</branch>
    <name>Nuclear Fission</name>
diff --git a/libs/gst/base/gstbaseparse.c b/libs/gst/base/gstbaseparse.c
index 1da663c..56a0818 100644
--- a/libs/gst/base/gstbaseparse.c
+++ b/libs/gst/base/gstbaseparse.c
@@ -276,8 +276,6 @@ struct _GstBaseParsePrivate
   guint max_bitrate;
   guint posted_avg_bitrate;
 
-  GList *pending_events;
-
   /* frames/buffers that are queued and ready to go on OK */
   GQueue queued_frames;
 
@@ -316,9 +314,10 @@ struct _GstBaseParsePrivate
   GstClockTime last_ts;
   gint64 last_offset;
 
+  /* Pending serialized events */
+  GList *pending_events;
   /* Newsegment event to be sent after SEEK */
-  GstEvent *pending_segment;
-
+  gboolean pending_segment;
   /* Segment event that closes the running segment prior to SEEK */
   GstEvent *close_segment;
 
@@ -456,6 +455,19 @@ gst_base_parse_clear_queues (GstBaseParse * parse)
   g_list_free (parse->priv->detect_buffers);
   parse->priv->detect_buffers = NULL;
   parse->priv->detect_buffers_size = 0;
+
+  g_queue_foreach (&parse->priv->queued_frames,
+      (GFunc) gst_base_parse_frame_free, NULL);
+  g_queue_clear (&parse->priv->queued_frames);
+
+  gst_buffer_replace (&parse->priv->cache, NULL);
+
+  g_list_foreach (parse->priv->pending_events, (GFunc) gst_event_unref, NULL);
+  g_list_free (parse->priv->pending_events);
+  parse->priv->pending_events = NULL;
+  parse->priv->pending_segment = FALSE;
+
+  gst_event_replace (&parse->priv->close_segment, NULL);
 }
 
 static void
@@ -466,10 +478,6 @@ gst_base_parse_finalize (GObject * object)
 
   g_object_unref (parse->priv->adapter);
 
-  if (parse->priv->pending_segment) {
-    p_ev = &parse->priv->pending_segment;
-    gst_event_replace (p_ev, NULL);
-  }
   if (parse->priv->close_segment) {
     p_ev = &parse->priv->close_segment;
     gst_event_replace (p_ev, NULL);
@@ -484,10 +492,7 @@ gst_base_parse_finalize (GObject * object)
       NULL);
   g_list_free (parse->priv->pending_events);
   parse->priv->pending_events = NULL;
-
-  g_queue_foreach (&parse->priv->queued_frames,
-      (GFunc) gst_base_parse_frame_free, NULL);
-  g_queue_clear (&parse->priv->queued_frames);
+  parse->priv->pending_segment = FALSE;
 
   if (parse->priv->index) {
     gst_object_unref (parse->priv->index);
@@ -757,15 +762,13 @@ gst_base_parse_reset (GstBaseParse * parse)
   parse->priv->last_ts = GST_CLOCK_TIME_NONE;
   parse->priv->last_offset = 0;
 
-  if (parse->priv->pending_segment) {
-    gst_event_unref (parse->priv->pending_segment);
-    parse->priv->pending_segment = NULL;
-  }
-
   g_list_foreach (parse->priv->pending_events, (GFunc) gst_mini_object_unref,
       NULL);
   g_list_free (parse->priv->pending_events);
   parse->priv->pending_events = NULL;
+  parse->priv->pending_segment = FALSE;
+
+  gst_event_replace (&parse->priv->close_segment, NULL);
 
   if (parse->priv->cache) {
     gst_buffer_unref (parse->priv->cache);
@@ -910,9 +913,10 @@ gst_base_parse_sink_event (GstPad * pad, GstEvent * event)
   GST_DEBUG_OBJECT (parse, "handling event %d, %s", GST_EVENT_TYPE (event),
       GST_EVENT_TYPE_NAME (event));
 
-  /* Cache all events except EOS, NEWSEGMENT and FLUSH_STOP if we have a
+  /* Cache all serialized events except EOS, NEWSEGMENT and FLUSH_STOP if we have a
    * pending segment */
-  if (parse->priv->pending_segment && GST_EVENT_TYPE (event) != GST_EVENT_EOS
+  if (parse->priv->pending_segment && GST_EVENT_IS_SERIALIZED (event)
+      && GST_EVENT_TYPE (event) != GST_EVENT_EOS
       && GST_EVENT_TYPE (event) != GST_EVENT_NEWSEGMENT
       && GST_EVENT_TYPE (event) != GST_EVENT_FLUSH_START
       && GST_EVENT_TYPE (event) != GST_EVENT_FLUSH_STOP) {
@@ -925,7 +929,6 @@ gst_base_parse_sink_event (GstPad * pad, GstEvent * event)
         g_list_append (parse->priv->pending_events, event);
     ret = TRUE;
   } else {
-
     if (GST_EVENT_TYPE (event) == GST_EVENT_EOS &&
         parse->priv->framecount < MIN_FRAMES_TO_POST_BITRATE)
       /* We've not posted bitrate tags yet - do so now */
@@ -962,7 +965,6 @@ static gboolean
 gst_base_parse_sink_eventfunc (GstBaseParse * parse, GstEvent * event)
 {
   gboolean handled = FALSE;
-  GstEvent **eventp;
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_NEWSEGMENT:
@@ -1053,9 +1055,9 @@ gst_base_parse_sink_eventfunc (GstBaseParse * parse, GstEvent * event)
       /* save the segment for later, right before we push a new buffer so that
        * the caps are fixed and the next linked element can receive
        * the segment. */
-      eventp = &parse->priv->pending_segment;
-      gst_event_replace (eventp, event);
-      gst_event_unref (event);
+      parse->priv->pending_events =
+          g_list_append (parse->priv->pending_events, event);
+      parse->priv->pending_segment = TRUE;
       handled = TRUE;
 
       /* but finish the current segment */
@@ -1107,10 +1109,16 @@ gst_base_parse_sink_eventfunc (GstBaseParse * parse, GstEvent * event)
         GST_ELEMENT_ERROR (parse, STREAM, WRONG_TYPE,
             ("No valid frames found before end of stream"), (NULL));
       }
-      /* newsegment before eos */
-      if (parse->priv->pending_segment) {
-        gst_pad_push_event (parse->srcpad, parse->priv->pending_segment);
-        parse->priv->pending_segment = NULL;
+      /* newsegment and other serialized events before eos */
+      if (G_UNLIKELY (parse->priv->pending_events)) {
+        GList *l;
+
+        for (l = parse->priv->pending_events; l != NULL; l = l->next) {
+          gst_pad_push_event (parse->srcpad, GST_EVENT (l->data));
+        }
+        g_list_free (parse->priv->pending_events);
+        parse->priv->pending_events = NULL;
+        parse->priv->pending_segment = FALSE;
       }
       break;
 
@@ -1827,27 +1835,36 @@ gst_base_parse_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
   /* should have caps by now */
   g_return_val_if_fail (GST_PAD_CAPS (parse->srcpad), GST_FLOW_ERROR);
 
+  if (G_UNLIKELY (parse->priv->pending_segment)) {
+    /* have caps; check identity */
+    gst_base_parse_check_media (parse);
+  }
+
+  /* and should then also be linked downstream, so safe to send some events */
+  if (G_UNLIKELY (parse->priv->close_segment)) {
+    /* only set up by loop */
+    GST_DEBUG_OBJECT (parse, "loop sending close segment");
+    gst_pad_push_event (parse->srcpad, parse->priv->close_segment);
+    parse->priv->close_segment = NULL;
+  }
+
+  /* Push pending events, including NEWSEGMENT events */
+  if (G_UNLIKELY (parse->priv->pending_events)) {
+    GList *l;
+
+    for (l = parse->priv->pending_events; l != NULL; l = l->next) {
+      gst_pad_push_event (parse->srcpad, GST_EVENT (l->data));
+    }
+    g_list_free (parse->priv->pending_events);
+    parse->priv->pending_events = NULL;
+    parse->priv->pending_segment = FALSE;
+  }
+
   /* segment adjustment magic; only if we are running the whole show */
   if (!parse->priv->passthrough && parse->segment.rate > 0.0 &&
       (parse->priv->pad_mode == GST_ACTIVATE_PULL ||
           parse->priv->upstream_seekable)) {
-    /* segment times are typically estimates,
-     * actual frame data might lead subclass to different timestamps,
-     * so override segment start from what is supplied there */
-    if (G_UNLIKELY (parse->priv->pending_segment && !parse->priv->exact_position
-            && GST_CLOCK_TIME_IS_VALID (last_start))) {
-      gst_event_unref (parse->priv->pending_segment);
-      parse->segment.start =
-          MIN ((guint64) last_start, (guint64) parse->segment.stop);
-      GST_DEBUG_OBJECT (parse,
-          "adjusting pending segment start to %" GST_TIME_FORMAT,
-          GST_TIME_ARGS (parse->segment.start));
-      parse->priv->pending_segment =
-          gst_event_new_new_segment (FALSE, parse->segment.rate,
-          parse->segment.format, parse->segment.start,
-          parse->segment.stop, parse->segment.start);
-    }
-    /* handle gaps, e.g. non-zero start-time, in as much not handled by above */
+    /* handle gaps */
     if (GST_CLOCK_TIME_IS_VALID (parse->segment.last_stop) &&
         GST_CLOCK_TIME_IS_VALID (last_start)) {
       GstClockTimeDiff diff;
@@ -1866,27 +1883,20 @@ gst_base_parse_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
             "Sending updated NEWSEGMENT events", diff,
             GST_TIME_ARGS (parse->segment.last_stop),
             GST_TIME_ARGS (last_start));
-        if (G_UNLIKELY (parse->priv->pending_segment)) {
-          gst_event_unref (parse->priv->pending_segment);
-          parse->segment.start = last_start;
-          parse->priv->pending_segment =
-              gst_event_new_new_segment (FALSE, parse->segment.rate,
-              parse->segment.format, parse->segment.start,
-              parse->segment.stop, parse->segment.start);
-        } else {
-          /* send newsegment events such that the gap is not accounted in
-           * accum time, hence running_time */
-          /* close ahead of gap */
-          gst_pad_push_event (parse->srcpad,
-              gst_event_new_new_segment (TRUE, parse->segment.rate,
-                  parse->segment.format, parse->segment.last_stop,
-                  parse->segment.last_stop, parse->segment.last_stop));
-          /* skip gap */
-          gst_pad_push_event (parse->srcpad,
-              gst_event_new_new_segment (FALSE, parse->segment.rate,
-                  parse->segment.format, last_start,
-                  parse->segment.stop, last_start));
-        }
+
+        /* send newsegment events such that the gap is not accounted in
+         * accum time, hence running_time */
+        /* close ahead of gap */
+        gst_pad_push_event (parse->srcpad,
+            gst_event_new_new_segment (TRUE, parse->segment.rate,
+                parse->segment.format, parse->segment.last_stop,
+                parse->segment.last_stop, parse->segment.last_stop));
+        /* skip gap */
+        gst_pad_push_event (parse->srcpad,
+            gst_event_new_new_segment (FALSE, parse->segment.rate,
+                parse->segment.format, last_start,
+                parse->segment.stop, last_start));
+
         /* align segment view with downstream,
          * prevents double-counting accum when closing segment */
         gst_segment_set_newsegment (&parse->segment, FALSE,
@@ -1897,41 +1907,10 @@ gst_base_parse_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
     }
   }
 
-  /* and should then also be linked downstream, so safe to send some events */
-  if (G_UNLIKELY (parse->priv->close_segment)) {
-    /* only set up by loop */
-    GST_DEBUG_OBJECT (parse, "loop sending close segment");
-    gst_pad_push_event (parse->srcpad, parse->priv->close_segment);
-    parse->priv->close_segment = NULL;
-  }
-  if (G_UNLIKELY (parse->priv->pending_segment)) {
-    GstEvent *pending_segment;
-
-    pending_segment = parse->priv->pending_segment;
-    parse->priv->pending_segment = NULL;
-
-    GST_DEBUG_OBJECT (parse, "%s push pending segment",
-        parse->priv->pad_mode == GST_ACTIVATE_PULL ? "loop" : "chain");
-    gst_pad_push_event (parse->srcpad, pending_segment);
-
-    /* have caps; check identity */
-    gst_base_parse_check_media (parse);
-  }
-
   /* update bitrates and optionally post corresponding tags
    * (following newsegment) */
   gst_base_parse_update_bitrates (parse, frame);
 
-  if (G_UNLIKELY (parse->priv->pending_events)) {
-    GList *l;
-
-    for (l = parse->priv->pending_events; l != NULL; l = l->next) {
-      gst_pad_push_event (parse->srcpad, GST_EVENT (l->data));
-    }
-    g_list_free (parse->priv->pending_events);
-    parse->priv->pending_events = NULL;
-  }
-
   if (klass->pre_push_frame) {
     ret = klass->pre_push_frame (parse, frame);
   } else {
@@ -2487,7 +2466,7 @@ gst_base_parse_chain (GstPad * pad, GstBuffer * buffer)
     ret = gst_base_parse_handle_and_push_frame (parse, bclass, frame);
     GST_PAD_STREAM_UNLOCK (parse->srcpad);
 
-    if (ret != GST_FLOW_OK) {
+    if (ret != GST_FLOW_OK && ret != GST_FLOW_NOT_LINKED) {
       GST_LOG_OBJECT (parse, "push returned %d", ret);
       break;
     }
@@ -2891,11 +2870,18 @@ pause:
       push_eos = TRUE;
     }
     if (push_eos) {
-      /* newsegment before eos */
-      if (parse->priv->pending_segment) {
-        gst_pad_push_event (parse->srcpad, parse->priv->pending_segment);
-        parse->priv->pending_segment = NULL;
+      /* Push pending events, including NEWSEGMENT events */
+      if (G_UNLIKELY (parse->priv->pending_events)) {
+        GList *l;
+
+        for (l = parse->priv->pending_events; l != NULL; l = l->next) {
+          gst_pad_push_event (parse->srcpad, GST_EVENT (l->data));
+        }
+        g_list_free (parse->priv->pending_events);
+        parse->priv->pending_events = NULL;
+        parse->priv->pending_segment = FALSE;
       }
+
       gst_pad_push_event (parse->srcpad, gst_event_new_eos ());
     }
     gst_object_unref (parse);
@@ -2992,9 +2978,15 @@ gst_base_parse_sink_activate_pull (GstPad * sinkpad, gboolean active)
 
   if (result) {
     if (active) {
-      parse->priv->pending_segment = gst_event_new_new_segment (FALSE,
+      GstEvent *event;
+
+      event = gst_event_new_new_segment (FALSE,
           parse->segment.rate, parse->segment.format,
           parse->segment.start, parse->segment.stop, parse->segment.last_stop);
+      parse->priv->pending_events =
+          g_list_append (parse->priv->pending_events, event);
+      parse->priv->pending_segment = TRUE;
+
       result &=
           gst_pad_start_task (sinkpad, (GstTaskFunction) gst_base_parse_loop,
           sinkpad);
@@ -3845,14 +3837,11 @@ gst_base_parse_handle_seek (GstBaseParse * parse, GstEvent * event)
     memcpy (&parse->segment, &seeksegment, sizeof (GstSegment));
 
     /* store the newsegment event so it can be sent from the streaming thread. */
-    if (parse->priv->pending_segment)
-      gst_event_unref (parse->priv->pending_segment);
-
-    /* This will be sent later in _loop() */
-    parse->priv->pending_segment =
+    parse->priv->pending_segment = TRUE;
+    parse->priv->pending_events = g_list_append (parse->priv->pending_events,
         gst_event_new_new_segment (FALSE, parse->segment.rate,
-        parse->segment.format, parse->segment.start,
-        parse->segment.stop, parse->segment.start);
+            parse->segment.format, parse->segment.start,
+            parse->segment.stop, parse->segment.start));
 
     GST_DEBUG_OBJECT (parse, "Created newseg format %d, "
         "start = %" GST_TIME_FORMAT ", stop = %" GST_TIME_FORMAT
@@ -3910,7 +3899,7 @@ gst_base_parse_handle_seek (GstBaseParse * parse, GstEvent * event)
        seek event (in bytes) to upstream. Segment / flush handling happens
        in corresponding src event handlers */
     GST_DEBUG_OBJECT (parse, "seek in PUSH mode");
-    if (seekstop >= 0 && seekpos <= seekpos)
+    if (seekstop >= 0 && seekstop <= seekpos)
       seekstop = seekpos;
     new_event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags,
         GST_SEEK_TYPE_SET, seekpos, stop_type, seekstop);
diff --git a/libs/gst/base/gstbasetransform.c b/libs/gst/base/gstbasetransform.c
index 4408ef2..e1fbaa9 100644
--- a/libs/gst/base/gstbasetransform.c
+++ b/libs/gst/base/gstbasetransform.c
@@ -2220,6 +2220,19 @@ gst_base_transform_sink_event (GstPad * pad, GstEvent * event)
     } else {
       delay = GST_EVENT_IS_SERIALIZED (event) && !caps_set
           && GST_EVENT_TYPE (event) != GST_EVENT_EOS;
+
+      /* do not stall sparse stream update newsegment events */
+      if (delay && (GST_EVENT_TYPE (event) == GST_EVENT_NEWSEGMENT)) {
+        gboolean update;
+
+        gst_event_parse_new_segment_full (event, &update, NULL, NULL, NULL,
+            NULL, NULL, NULL);
+        if (update) {
+          GST_DEBUG_OBJECT (trans, "update segment; triggering delayed events");
+          delay = FALSE;
+          caps_set = TRUE;
+        }
+      }
     }
 
     if (delay) {
@@ -2642,7 +2655,7 @@ gst_base_transform_chain (GstPad * pad, GstBuffer * buffer)
   /* outbuf can be NULL, this means a dropped buffer, if we have a buffer but
    * GST_BASE_TRANSFORM_FLOW_DROPPED we will not push either. */
   if (outbuf != NULL) {
-    if ((ret == GST_FLOW_OK)) {
+    if (ret == GST_FLOW_OK) {
       GstClockTime last_stop_out = GST_CLOCK_TIME_NONE;
 
       /* Remember last stop position */
diff --git a/libs/gst/base/gstcollectpads.c b/libs/gst/base/gstcollectpads.c
index 7fb0bf4..681102f 100644
--- a/libs/gst/base/gstcollectpads.c
+++ b/libs/gst/base/gstcollectpads.c
@@ -806,7 +806,7 @@ gst_collect_pads_pop (GstCollectPads * pads, GstCollectData * data)
 }
 
 /* pop and unref the currently queued buffer, should e called with the LOCK
- * helt. */
+ * held. */
 static void
 gst_collect_pads_clear (GstCollectPads * pads, GstCollectData * data)
 {
diff --git a/libs/gst/base/gstcollectpads2.c b/libs/gst/base/gstcollectpads2.c
index a2fdd6b..466e47d 100644
--- a/libs/gst/base/gstcollectpads2.c
+++ b/libs/gst/base/gstcollectpads2.c
@@ -278,10 +278,10 @@ gst_collect_pads2_finalize (GObject * object)
  *
  * Create a new instance of #GstCollectsPads.
  *
- * Returns: a new #GstCollectPads2, or NULL in case of an error.
- *
  * MT safe.
  *
+ * Returns: (transfer full): a new #GstCollectPads2, or NULL in case of an error.
+ *
  * Since: 0.10.36
  */
 GstCollectPads2 *
@@ -307,7 +307,7 @@ gst_collect_pads2_set_buffer_function_locked (GstCollectPads2 * pads,
  * gst_collect_pads2_set_buffer_function:
  * @pads: the collectpads to use
  * @func: the function to set
- * @user_data: user data passed to the function
+ * @user_data: (closure): user data passed to the function
  *
  * Set the callback function and user data that will be called with
  * the oldest buffer when all pads have been collected.
@@ -332,7 +332,7 @@ gst_collect_pads2_set_buffer_function (GstCollectPads2 * pads,
  * gst_collect_pads2_set_compare_function:
  * @pads: the pads to use
  * @func: the function to set
- * @user_data: user data passed to the function
+ * @user_data: (closure): user data passed to the function
  *
  * Set the timestamp comparison function.
  *
@@ -449,6 +449,48 @@ gst_collect_pads2_set_event_function (GstCollectPads2 * pads,
   GST_OBJECT_UNLOCK (pads);
 }
 
+/**
+* gst_collect_pads2_clip_running_time:
+* @pads: the collectspads to use
+* @cdata: collect data of corresponding pad
+* @buf: buffer being clipped
+* @outbuf: output buffer with running time, or NULL if clipped
+* @user_data: user data (unused)
+*
+* Convenience clipping function that converts incoming buffer's timestamp
+* to running time, or clips the buffer if outside configured segment.
+*
+* Since: 0.10.37
+*/
+GstFlowReturn
+gst_collect_pads2_clip_running_time (GstCollectPads2 * pads,
+    GstCollectData2 * cdata, GstBuffer * buf, GstBuffer ** outbuf,
+    gpointer user_data)
+{
+  GstClockTime time;
+
+  *outbuf = buf;
+  time = GST_BUFFER_TIMESTAMP (buf);
+
+  /* invalid left alone and passed */
+  if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (time))) {
+    time = gst_segment_to_running_time (&cdata->segment, GST_FORMAT_TIME, time);
+    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time))) {
+      GST_DEBUG_OBJECT (cdata->pad, "clipping buffer on pad outside segment");
+      gst_buffer_unref (buf);
+      *outbuf = NULL;
+    } else {
+      GST_LOG_OBJECT (cdata->pad, "buffer ts %" GST_TIME_FORMAT " -> %"
+          GST_TIME_FORMAT " running time",
+          GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)), GST_TIME_ARGS (time));
+      *outbuf = gst_buffer_make_metadata_writable (buf);
+      GST_BUFFER_TIMESTAMP (*outbuf) = time;
+    }
+  }
+
+  return GST_FLOW_OK;
+}
+
  /**
  * gst_collect_pads2_set_clip_function:
  * @pads: the collectspads to use
@@ -474,7 +516,7 @@ gst_collect_pads2_set_clip_function (GstCollectPads2 * pads,
 /**
  * gst_collect_pads2_add_pad:
  * @pads: the collectspads to use
- * @pad: the pad to add
+ * @pad: (transfer none): the pad to add
  * @size: the size of the returned #GstCollectData2 structure
  *
  * Add a pad to the collection of collect pads. The pad has to be
@@ -488,14 +530,14 @@ gst_collect_pads2_set_clip_function (GstCollectPads2 * pads,
  * The pad will be automatically activated in push mode when @pads is
  * started.
  *
- * This function calls gst_collect_pads2_add_pad() passing a value of NULL
+ * This function calls gst_collect_pads2_add_pad_full() passing a value of NULL
  * for destroy_notify and TRUE for locked.
  *
+ * MT safe.
+ *
  * Returns: a new #GstCollectData2 to identify the new pad. Or NULL
  *   if wrong parameters are supplied.
  *
- * MT safe.
- *
  * Since: 0.10.36
  */
 GstCollectData2 *
@@ -507,7 +549,7 @@ gst_collect_pads2_add_pad (GstCollectPads2 * pads, GstPad * pad, guint size)
 /**
  * gst_collect_pads2_add_pad_full:
  * @pads: the collectspads to use
- * @pad: the pad to add
+ * @pad: (transfer none): the pad to add
  * @size: the size of the returned #GstCollectData2 structure
  * @destroy_notify: function to be called before the returned #GstCollectData2
  * structure is freed
@@ -537,12 +579,12 @@ gst_collect_pads2_add_pad (GstCollectPads2 * pads, GstPad * pad, guint size)
  * The pad will be automatically activated in push mode when @pads is
  * started.
  *
+ * MT safe.
+ *
  * Since: 0.10.36
  *
  * Returns: a new #GstCollectData2 to identify the new pad. Or NULL
  *   if wrong parameters are supplied.
- *
- * MT safe.
  */
 GstCollectData2 *
 gst_collect_pads2_add_pad_full (GstCollectPads2 * pads, GstPad * pad,
@@ -605,7 +647,7 @@ find_pad (GstCollectData2 * data, GstPad * pad)
 /**
  * gst_collect_pads2_remove_pad:
  * @pads: the collectspads to use
- * @pad: the pad to remove
+ * @pad: (transfer none): the pad to remove
  *
  * Remove a pad from the collection of collect pads. This function will also
  * free the #GstCollectData2 and all the resources that were allocated with
@@ -613,10 +655,10 @@ find_pad (GstCollectData2 * data, GstPad * pad)
  *
  * The pad will be deactivated automatically when @pads is stopped.
  *
- * Returns: %TRUE if the pad could be removed.
- *
  * MT safe.
  *
+ * Returns: %TRUE if the pad could be removed.
+ *
  * Since: 0.10.36
  */
 gboolean
@@ -700,10 +742,10 @@ unknown_pad:
  *
  * This function is currently not implemented.
  *
- * Returns: %TRUE if the pad is active.
- *
  * MT safe.
  *
+ * Returns: %TRUE if the pad is active.
+ *
  * Since: 0.10.36
  */
 gboolean
@@ -728,10 +770,10 @@ gst_collect_pads2_is_active (GstCollectPads2 * pads, GstPad * pad)
  *
  * This function is currently not implemented.
  *
- * Returns: #GstFlowReturn of the operation.
- *
  * MT safe.
  *
+ * Returns: #GstFlowReturn of the operation.
+ *
  * Since: 0.10.36
  */
 GstFlowReturn
@@ -756,10 +798,10 @@ gst_collect_pads2_collect (GstCollectPads2 * pads)
  *
  * This function is currently not implemented.
  *
- * Returns: #GstFlowReturn of the operation.
- *
  * MT safe.
  *
+ * Returns: #GstFlowReturn of the operation.
+ *
  * Since: 0.10.36
  */
 GstFlowReturn
@@ -819,7 +861,6 @@ gst_collect_pads2_set_flushing_unlocked (GstCollectPads2 * pads,
  *
  * MT safe.
  *
- *
  * Since: 0.10.36
  */
 void
@@ -946,11 +987,11 @@ gst_collect_pads2_stop (GstCollectPads2 * pads)
  * should be called with the @pads STREAM_LOCK held, such as in the callback
  * handler.
  *
+ * MT safe.
+ *
  * Returns: The buffer in @data or NULL if no buffer is queued.
  *  should unref the buffer after usage.
  *
- * MT safe.
- *
  * Since: 0.10.36
  */
 GstBuffer *
@@ -980,11 +1021,11 @@ gst_collect_pads2_peek (GstCollectPads2 * pads, GstCollectData2 * data)
  * should be called with the @pads STREAM_LOCK held, such as in the callback
  * handler.
  *
- * Returns: The buffer in @data or NULL if no buffer was queued.
- *   You should unref the buffer after usage.
- *
  * MT safe.
  *
+ * Returns: (transfer full): The buffer in @data or NULL if no buffer was
+ *   queued. You should unref the buffer after usage.
+ *
  * Since: 0.10.36
  */
 GstBuffer *
@@ -1034,11 +1075,11 @@ gst_collect_pads2_clear (GstCollectPads2 * pads, GstCollectData2 * data)
  * This function should be called with @pads STREAM_LOCK held, such as
  * in the callback.
  *
+ * MT safe.
+ *
  * Returns: The maximum number of bytes queued on all pads. This function
  * returns 0 if a pad has no queued buffer.
  *
- * MT safe.
- *
  * Since: 0.10.36
  */
 /* we might pre-calculate this in some struct field,
@@ -1098,7 +1139,7 @@ not_filled:
  * gst_collect_pads2_read:
  * @pads: the collectspads to query
  * @data: the data to use
- * @bytes: a pointer to a byte array
+ * @bytes: (out) (transfer none) (array length=size): a pointer to a byte array
  * @size: the number of bytes to read
  *
  * Get a pointer in @bytes where @size bytes can be read from the
@@ -1107,12 +1148,12 @@ not_filled:
  * This function should be called with @pads STREAM_LOCK held, such as
  * in the callback.
  *
+ * MT safe.
+ *
  * Returns: The number of bytes available for consumption in the
  * memory pointed to by @bytes. This can be less than @size and
  * is 0 if the pad is end-of-stream.
  *
- * MT safe.
- *
  * Since: 0.10.36
  */
 guint
@@ -1149,11 +1190,11 @@ gst_collect_pads2_read (GstCollectPads2 * pads, GstCollectData2 * data,
  * This function should be called with @pads STREAM_LOCK held, such as
  * in the callback.
  *
+ * MT safe.
+ *
  * Returns: The number of bytes flushed This can be less than @size and
  * is 0 if the pad was end-of-stream.
  *
- * MT safe.
- *
  * Since: 0.10.36
  */
 guint
@@ -1194,13 +1235,13 @@ gst_collect_pads2_flush (GstCollectPads2 * pads, GstCollectData2 * data,
  * This function should be called with @pads STREAM_LOCK held, such as in the
  * callback.
  *
+ * MT safe.
+ *
  * Since: 0.10.36
  *
- * Returns: A sub buffer. The size of the buffer can be less that requested.
+ * Returns: (transfer full): A sub buffer. The size of the buffer can be less that requested.
  * A return of NULL signals that the pad is end-of-stream.
  * Unref the buffer after use.
- *
- * MT safe.
  */
 GstBuffer *
 gst_collect_pads2_read_buffer (GstCollectPads2 * pads, GstCollectData2 * data,
@@ -1234,13 +1275,13 @@ gst_collect_pads2_read_buffer (GstCollectPads2 * pads, GstCollectData2 * data,
  * This function should be called with @pads STREAM_LOCK held, such as in the
  * callback.
  *
+ * MT safe.
+ *
  * Since: 0.10.36
  *
  * Returns: A sub buffer. The size of the buffer can be less that requested.
  * A return of NULL signals that the pad is end-of-stream.
  * Unref the buffer after use.
- *
- * MT safe.
  */
 GstBuffer *
 gst_collect_pads2_take_buffer (GstCollectPads2 * pads, GstCollectData2 * data,
@@ -1287,7 +1328,7 @@ gst_collect_pads2_set_waiting (GstCollectPads2 * pads, GstCollectData2 * data,
   /* Do something only on a change and if not locked */
   if (!GST_COLLECT_PADS2_STATE_IS_SET (data, GST_COLLECT_PADS2_STATE_LOCKED) &&
       (GST_COLLECT_PADS2_STATE_IS_SET (data, GST_COLLECT_PADS2_STATE_WAITING) !=
-          ! !waiting)) {
+          !!waiting)) {
     /* Set waiting state for this pad */
     if (waiting)
       GST_COLLECT_PADS2_STATE_SET (data, GST_COLLECT_PADS2_STATE_WAITING);
@@ -1662,8 +1703,8 @@ gst_collect_pads2_event (GstPad * pad, GstEvent * event)
 
   pads = data->collect;
 
-  GST_DEBUG ("Got %s event on pad %s:%s", GST_EVENT_TYPE_NAME (event),
-      GST_DEBUG_PAD_NAME (data->pad));
+  GST_DEBUG_OBJECT (data->pad, "Got %s event on sink pad from %s",
+      GST_EVENT_TYPE_NAME (event), GST_OBJECT_NAME (GST_EVENT_SRC (event)));
 
   GST_OBJECT_LOCK (pads);
   event_func = pads->priv->event_func;
@@ -1677,8 +1718,10 @@ gst_collect_pads2_event (GstPad * pad, GstEvent * event)
       /* forward event to unblock check_collected */
       if (event_func)
         res = event_func (pads, data, event, event_user_data);
-      if (!res)
+      if (!res) {
+        GST_DEBUG_OBJECT (pad, "forwarding flush start");
         res = gst_pad_event_default (pad, event);
+      }
 
       /* now unblock the chain function.
        * no cond per pad, so they all unblock, 
@@ -1816,8 +1859,10 @@ forward_or_default:
   }
   if (event_func)
     res = event_func (pads, data, event, event_user_data);
-  if (!res)
+  if (!res) {
+    GST_DEBUG_OBJECT (pad, "forwarding %s", GST_EVENT_TYPE_NAME (event));
     res = gst_pad_event_default (pad, event);
+  }
   if (need_unlock)
     GST_COLLECT_PADS2_STREAM_UNLOCK (pads);
   goto done;
diff --git a/libs/gst/base/gstcollectpads2.h b/libs/gst/base/gstcollectpads2.h
index 03414e9..1fb0085 100644
--- a/libs/gst/base/gstcollectpads2.h
+++ b/libs/gst/base/gstcollectpads2.h
@@ -260,7 +260,7 @@ typedef GstFlowReturn (*GstCollectPads2ClipFunction) (GstCollectPads2 *pads, Gst
  *
  * Since: 0.10.36
  */
-#define GST_COLLECT_PADS2_STREAM_LOCK(pads)     (g_static_rec_mutex_lock(GST_COLLECT_PADS2_GET_STREAM_LOCK (pads)))
+#define GST_COLLECT_PADS2_STREAM_LOCK(pads)     g_static_rec_mutex_lock(GST_COLLECT_PADS2_GET_STREAM_LOCK (pads))
 /**
  * GST_COLLECT_PADS2_STREAM_UNLOCK:
  * @pads: a #GstCollectPads2
@@ -269,7 +269,7 @@ typedef GstFlowReturn (*GstCollectPads2ClipFunction) (GstCollectPads2 *pads, Gst
  *
  * Since: 0.10.36
  */
-#define GST_COLLECT_PADS2_STREAM_UNLOCK(pads)   (g_static_rec_mutex_unlock(GST_COLLECT_PADS2_GET_STREAM_LOCK (pads)))
+#define GST_COLLECT_PADS2_STREAM_UNLOCK(pads)   g_static_rec_mutex_unlock(GST_COLLECT_PADS2_GET_STREAM_LOCK (pads))
 
 /**
  * GstCollectPads2:
@@ -352,6 +352,11 @@ GstBuffer*	gst_collect_pads2_take_buffer	(GstCollectPads2 * pads, GstCollectData
 void		gst_collect_pads2_set_waiting	(GstCollectPads2 *pads, GstCollectData2 *data,
 						 gboolean waiting);
 
+/* convenience helper */
+GstFlowReturn	gst_collect_pads2_clip_running_time (GstCollectPads2 * pads,
+						GstCollectData2 * cdata, GstBuffer * buf, GstBuffer ** outbuf,
+                                                gpointer user_data);
+
 
 G_END_DECLS
 
diff --git a/libs/gst/check/Makefile.am b/libs/gst/check/Makefile.am
index 8dcf66d..6115d99 100644
--- a/libs/gst/check/Makefile.am
+++ b/libs/gst/check/Makefile.am
@@ -83,6 +83,7 @@ LIBGSTCHECK_EXPORTED_FUNCS = \
 	gst_check_teardown_pad_by_name \
 	gst_check_teardown_sink_pad \
 	gst_check_teardown_src_pad \
+	gst_consistency_checker_add_pad \
 	gst_consistency_checker_new \
 	gst_consistency_checker_reset \
 	gst_consistency_checker_free
diff --git a/libs/gst/check/gstconsistencychecker.c b/libs/gst/check/gstconsistencychecker.c
index ded047e..242f949 100644
--- a/libs/gst/check/gstconsistencychecker.c
+++ b/libs/gst/check/gstconsistencychecker.c
@@ -3,6 +3,7 @@
  * unit testing helper lib
  *
  * Copyright (C) 2009 Edward Hervey <bilboed@bilboed.com>
+ * Copyright (C) 2012 Stefan Sauer <ensonic@users.sf.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -34,17 +35,29 @@
 
 struct _GstStreamConsistency
 {
-  gboolean flushing;
-  gboolean newsegment;
-  gboolean eos;
-  gulong probeid;
-  GstPad *pad;
+  /* FIXME: do we want to track some states per pad? */
+  volatile gboolean flushing;
+  volatile gboolean newsegment;
+  volatile gboolean eos;
+  volatile gboolean expect_flush;
+  GstObject *parent;
+  GList *pads;
 };
 
+typedef struct _GstStreamConsistencyProbe
+{
+  GstPad *pad;
+  gulong probeid;
+} GstStreamConsistencyProbe;
+
+
 static gboolean
 source_pad_data_cb (GstPad * pad, GstMiniObject * data,
     GstStreamConsistency * consist)
 {
+  GST_DEBUG_OBJECT (pad, "%p: %d %d %d %d", consist, consist->flushing,
+      consist->newsegment, consist->eos, consist->expect_flush);
+
   if (GST_IS_BUFFER (data)) {
     GST_DEBUG_OBJECT (pad, "Buffer %" GST_TIME_FORMAT,
         GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (GST_BUFFER (data))));
@@ -58,6 +71,9 @@ source_pad_data_cb (GstPad * pad, GstMiniObject * data,
     GST_DEBUG_OBJECT (pad, "%s", GST_EVENT_TYPE_NAME (event));
     switch (GST_EVENT_TYPE (event)) {
       case GST_EVENT_FLUSH_START:
+        /* getting two flush_start in a row seems to be okay
+           fail_if (consist->flushing, "Received another FLUSH_START");
+         */
         consist->flushing = TRUE;
         break;
       case GST_EVENT_FLUSH_STOP:
@@ -65,9 +81,11 @@ source_pad_data_cb (GstPad * pad, GstMiniObject * data,
         fail_unless (consist->flushing,
             "Received a FLUSH_STOP without a FLUSH_START");
         fail_if (consist->eos, "Received a FLUSH_STOP after an EOS");
-        consist->flushing = FALSE;
+        consist->flushing = consist->expect_flush = FALSE;
         break;
       case GST_EVENT_NEWSEGMENT:
+        fail_if ((consist->expect_flush && consist->flushing),
+            "Received NEWSEGMENT while in a flushing seek");
         consist->newsegment = TRUE;
         consist->eos = FALSE;
         break;
@@ -93,6 +111,69 @@ source_pad_data_cb (GstPad * pad, GstMiniObject * data,
   return TRUE;
 }
 
+static gboolean
+sink_pad_data_cb (GstPad * pad, GstMiniObject * data,
+    GstStreamConsistency * consist)
+{
+  GST_DEBUG_OBJECT (pad, "%p: %d %d %d %d", consist, consist->flushing,
+      consist->newsegment, consist->eos, consist->expect_flush);
+
+  if (GST_IS_BUFFER (data)) {
+    GST_DEBUG_OBJECT (pad, "Buffer %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (GST_BUFFER (data))));
+    /* If an EOS went through, a buffer would be invalid */
+    fail_if (consist->eos, "Buffer received after EOS");
+    /* Buffers need to be preceded by a newsegment event */
+    fail_unless (consist->newsegment, "Buffer received without newsegment");
+  } else if (GST_IS_EVENT (data)) {
+    GstEvent *event = (GstEvent *) data;
+
+    GST_DEBUG_OBJECT (pad, "%s", GST_EVENT_TYPE_NAME (event));
+    switch (GST_EVENT_TYPE (event)) {
+      case GST_EVENT_SEEK:
+      {
+        GstSeekFlags flags;
+
+        gst_event_parse_seek (event, NULL, NULL, &flags, NULL, NULL, NULL,
+            NULL);
+        consist->expect_flush =
+            ((flags & GST_SEEK_FLAG_FLUSH) == GST_SEEK_FLAG_FLUSH);
+        break;
+      }
+      case GST_EVENT_NEWSEGMENT:
+        fail_if ((consist->expect_flush && consist->flushing),
+            "Received NEWSEGMENT while in a flushing seek");
+        consist->newsegment = TRUE;
+        consist->eos = FALSE;
+        break;
+      default:
+        /* FIXME : Figure out what to do for other events */
+        break;
+    }
+  }
+
+  return TRUE;
+}
+
+static void
+add_pad (GstStreamConsistency * consist, GstPad * pad)
+{
+  GstStreamConsistencyProbe *p;
+  GstPadDirection dir;
+
+  p = g_new0 (GstStreamConsistencyProbe, 1);
+  p->pad = g_object_ref (pad);
+  dir = gst_pad_get_direction (pad);
+  if (dir == GST_PAD_SRC) {
+    p->probeid =
+        gst_pad_add_data_probe (pad, (GCallback) source_pad_data_cb, consist);
+  } else if (dir == GST_PAD_SINK) {
+    p->probeid =
+        gst_pad_add_data_probe (pad, (GCallback) sink_pad_data_cb, consist);
+  }
+  consist->pads = g_list_prepend (consist->pads, p);
+}
+
 /**
  * gst_consistency_checker_new:
  * @pad: The #GstPad on which the dataflow will be checked.
@@ -100,13 +181,10 @@ source_pad_data_cb (GstPad * pad, GstMiniObject * data,
  * Sets up a data probe on the given pad which will raise assertions if the
  * data flow is inconsistent.
  *
- * Currently only works for source pads.
- *
  * Returns: A #GstStreamConsistency structure used to track data flow.
  *
  * Since: 0.10.24
  */
-
 GstStreamConsistency *
 gst_consistency_checker_new (GstPad * pad)
 {
@@ -115,14 +193,38 @@ gst_consistency_checker_new (GstPad * pad)
   g_return_val_if_fail (pad != NULL, NULL);
 
   consist = g_new0 (GstStreamConsistency, 1);
-  consist->pad = g_object_ref (pad);
-  consist->probeid =
-      gst_pad_add_data_probe (pad, (GCallback) source_pad_data_cb, consist);
 
+  if (!consist->pads) {
+    consist->parent = GST_OBJECT_PARENT (pad);
+  }
+  add_pad (consist, pad);
   return consist;
 }
 
 /**
+ * gst_consistency_checker_add_pad:
+ * @consist: The #GstStreamConsistency handle
+ * @pad: The #GstPad on which the dataflow will be checked.
+ *
+ * Sets up a data probe on the given pad which will raise assertions if the
+ * data flow is inconsistent.
+ *
+ * Returns: %TRUE if the pad was added
+ *
+ * Since: 0.10.37
+ */
+gboolean
+gst_consistency_checker_add_pad (GstStreamConsistency * consist, GstPad * pad)
+{
+  g_return_val_if_fail (consist != NULL, FALSE);
+  g_return_val_if_fail (pad != NULL, FALSE);
+  g_return_val_if_fail (GST_OBJECT_PARENT (pad) == consist->parent, FALSE);
+
+  add_pad (consist, pad);
+  return TRUE;
+}
+
+/**
  * gst_consistency_checker_reset:
  * @consist: The #GstStreamConsistency to reset.
  *
@@ -143,7 +245,7 @@ gst_consistency_checker_reset (GstStreamConsistency * consist)
  * gst_consistency_checker_free:
  * @consist: The #GstStreamConsistency to free.
  *
- * Frees the allocated data and probe associated with @consist.
+ * Frees the allocated data and probes associated with @consist.
  *
  * Since: 0.10.24
  */
@@ -151,8 +253,16 @@ gst_consistency_checker_reset (GstStreamConsistency * consist)
 void
 gst_consistency_checker_free (GstStreamConsistency * consist)
 {
-  /* Remove the data probe */
-  gst_pad_remove_data_probe (consist->pad, consist->probeid);
-  g_object_unref (consist->pad);
+  GList *node;
+  GstStreamConsistencyProbe *p;
+
+  /* Remove the data probes */
+  for (node = consist->pads; node; node = g_list_next (node)) {
+    p = (GstStreamConsistencyProbe *) node->data;
+    gst_pad_remove_data_probe (p->pad, p->probeid);
+    g_object_unref (p->pad);
+    g_free (p);
+  }
+  g_list_free (consist->pads);
   g_free (consist);
 }
diff --git a/libs/gst/check/gstconsistencychecker.h b/libs/gst/check/gstconsistencychecker.h
index ec88af7..4cbf3f8 100644
--- a/libs/gst/check/gstconsistencychecker.h
+++ b/libs/gst/check/gstconsistencychecker.h
@@ -37,11 +37,13 @@ G_BEGIN_DECLS
 typedef struct _GstStreamConsistency GstStreamConsistency;
 
 
-GstStreamConsistency * gst_consistency_checker_new   (GstPad * pad);
+GstStreamConsistency * gst_consistency_checker_new     (GstPad * pad);
+gboolean               gst_consistency_checker_add_pad (GstStreamConsistency * consist,
+                                                        GstPad * pad);
 
-void                   gst_consistency_checker_reset (GstStreamConsistency * consist);
+void                   gst_consistency_checker_reset   (GstStreamConsistency * consist);
 
-void                   gst_consistency_checker_free  (GstStreamConsistency * consist);
+void                   gst_consistency_checker_free    (GstStreamConsistency * consist);
 
 G_END_DECLS
 
diff --git a/libs/gst/check/libcheck/check.h.in b/libs/gst/check/libcheck/check.h.in
index 231fdbb..3ed1acd 100644
--- a/libs/gst/check/libcheck/check.h.in
+++ b/libs/gst/check/libcheck/check.h.in
@@ -232,7 +232,7 @@ static void __testname (int _i CK_ATTRIBUTE_UNUSED)\
         "Failure '"#expr"' occured" , ## __VA_ARGS__, NULL)
 
 /* Always fail */
-#define fail(...) _fail_unless(0, __FILE__, __LINE__, "Failed" , ## __VA_ARGS__, NULL)
+#define fail(...) _fail_unless(0, __FILE__, __LINE__, "Failed"  __VA_ARGS__, NULL)
 
 /* Non macro version of #fail_unless, with more complicated interface */
 void CK_EXPORT _fail_unless (int result, const char *file,
diff --git a/libs/gst/controller/gstinterpolationcontrolsource.c b/libs/gst/controller/gstinterpolationcontrolsource.c
index 2bdefeb..1dd0a89 100644
--- a/libs/gst/controller/gstinterpolationcontrolsource.c
+++ b/libs/gst/controller/gstinterpolationcontrolsource.c
@@ -51,8 +51,6 @@ GST_DEBUG_CATEGORY_EXTERN (GST_CAT_DEFAULT);
 G_DEFINE_TYPE (GstInterpolationControlSource, gst_interpolation_control_source,
     GST_TYPE_CONTROL_SOURCE);
 
-static GObjectClass *parent_class = NULL;
-
 /*
  * gst_control_point_free:
  * @prop: the object to free
@@ -672,13 +670,14 @@ gst_interpolation_control_source_finalize (GObject * obj)
   gst_interpolation_control_source_reset (self);
   g_mutex_unlock (self->lock);
   g_mutex_free (self->lock);
-  G_OBJECT_CLASS (parent_class)->finalize (obj);
+  G_OBJECT_CLASS (gst_interpolation_control_source_parent_class)->finalize
+      (obj);
 }
 
 static void
 gst_interpolation_control_source_dispose (GObject * obj)
 {
-  G_OBJECT_CLASS (parent_class)->dispose (obj);
+  G_OBJECT_CLASS (gst_interpolation_control_source_parent_class)->dispose (obj);
 }
 
 static void
@@ -688,7 +687,6 @@ gst_interpolation_control_source_class_init (GstInterpolationControlSourceClass
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
   GstControlSourceClass *csource_class = GST_CONTROL_SOURCE_CLASS (klass);
 
-  parent_class = g_type_class_peek_parent (klass);
   g_type_class_add_private (klass,
       sizeof (GstInterpolationControlSourcePrivate));
 
diff --git a/libs/gst/controller/gstlfocontrolsource.c b/libs/gst/controller/gstlfocontrolsource.c
index 6139687..f462fdd 100644
--- a/libs/gst/controller/gstlfocontrolsource.c
+++ b/libs/gst/controller/gstlfocontrolsource.c
@@ -608,8 +608,6 @@ gst_lfo_waveform_get_type (void)
 G_DEFINE_TYPE (GstLFOControlSource, gst_lfo_control_source,
     GST_TYPE_CONTROL_SOURCE);
 
-static GObjectClass *parent_class = NULL;
-
 static void
 gst_lfo_control_source_reset (GstLFOControlSource * self)
 {
@@ -953,13 +951,13 @@ gst_lfo_control_source_finalize (GObject * obj)
     self->lock = NULL;
   }
 
-  G_OBJECT_CLASS (parent_class)->finalize (obj);
+  G_OBJECT_CLASS (gst_lfo_control_source_parent_class)->finalize (obj);
 }
 
 static void
 gst_lfo_control_source_dispose (GObject * obj)
 {
-  G_OBJECT_CLASS (parent_class)->dispose (obj);
+  G_OBJECT_CLASS (gst_lfo_control_source_parent_class)->dispose (obj);
 }
 
 static void
@@ -1084,7 +1082,6 @@ gst_lfo_control_source_class_init (GstLFOControlSourceClass * klass)
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
   GstControlSourceClass *csource_class = GST_CONTROL_SOURCE_CLASS (klass);
 
-  parent_class = g_type_class_peek_parent (klass);
   g_type_class_add_private (klass, sizeof (GstLFOControlSourcePrivate));
 
   gobject_class->finalize = gst_lfo_control_source_finalize;
diff --git a/plugins/elements/gstfakesink.c b/plugins/elements/gstfakesink.c
index 202d07b..93dbd46 100644
--- a/plugins/elements/gstfakesink.c
+++ b/plugins/elements/gstfakesink.c
@@ -131,6 +131,7 @@ static GstFlowReturn gst_fake_sink_preroll (GstBaseSink * bsink,
 static GstFlowReturn gst_fake_sink_render (GstBaseSink * bsink,
     GstBuffer * buffer);
 static gboolean gst_fake_sink_event (GstBaseSink * bsink, GstEvent * event);
+static gboolean gst_fake_sink_query (GstBaseSink * bsink, GstQuery * query);
 
 static guint gst_fake_sink_signals[LAST_SIGNAL] = { 0 };
 
@@ -266,6 +267,7 @@ gst_fake_sink_class_init (GstFakeSinkClass * klass)
   gstbase_sink_class->event = GST_DEBUG_FUNCPTR (gst_fake_sink_event);
   gstbase_sink_class->preroll = GST_DEBUG_FUNCPTR (gst_fake_sink_preroll);
   gstbase_sink_class->render = GST_DEBUG_FUNCPTR (gst_fake_sink_render);
+  gstbase_sink_class->query = GST_DEBUG_FUNCPTR (gst_fake_sink_query);
 }
 
 static void
@@ -554,6 +556,29 @@ eos:
   }
 }
 
+static gboolean
+gst_fake_sink_query (GstBaseSink * bsink, GstQuery * query)
+{
+  gboolean ret;
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_SEEKING:{
+      GstFormat fmt;
+
+      /* we don't supporting seeking */
+      gst_query_parse_seeking (query, &fmt, NULL, NULL, NULL);
+      gst_query_set_seeking (query, fmt, FALSE, 0, -1);
+      ret = TRUE;
+      break;
+    }
+    default:
+      ret = GST_BASE_SINK_CLASS (parent_class)->query (bsink, query);
+      break;
+  }
+
+  return ret;
+}
+
 static GstStateChangeReturn
 gst_fake_sink_change_state (GstElement * element, GstStateChange transition)
 {
diff --git a/plugins/elements/gstfdsink.c b/plugins/elements/gstfdsink.c
index 6383d2a..7667088 100644
--- a/plugins/elements/gstfdsink.c
+++ b/plugins/elements/gstfdsink.c
@@ -118,7 +118,7 @@ static void gst_fd_sink_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
 static void gst_fd_sink_dispose (GObject * obj);
 
-static gboolean gst_fd_sink_query (GstPad * pad, GstQuery * query);
+static gboolean gst_fd_sink_query (GstBaseSink * bsink, GstQuery * query);
 static GstFlowReturn gst_fd_sink_render (GstBaseSink * sink,
     GstBuffer * buffer);
 static gboolean gst_fd_sink_start (GstBaseSink * basesink);
@@ -161,6 +161,7 @@ gst_fd_sink_class_init (GstFdSinkClass * klass)
   gstbasesink_class->unlock = GST_DEBUG_FUNCPTR (gst_fd_sink_unlock);
   gstbasesink_class->unlock_stop = GST_DEBUG_FUNCPTR (gst_fd_sink_unlock_stop);
   gstbasesink_class->event = GST_DEBUG_FUNCPTR (gst_fd_sink_event);
+  gstbasesink_class->query = GST_DEBUG_FUNCPTR (gst_fd_sink_query);
 
   g_object_class_install_property (gobject_class, ARG_FD,
       g_param_spec_int ("fd", "fd", "An open file descriptor to write to",
@@ -170,11 +171,6 @@ gst_fd_sink_class_init (GstFdSinkClass * klass)
 static void
 gst_fd_sink_init (GstFdSink * fdsink, GstFdSinkClass * klass)
 {
-  GstPad *pad;
-
-  pad = GST_BASE_SINK_PAD (fdsink);
-  gst_pad_set_query_function (pad, GST_DEBUG_FUNCPTR (gst_fd_sink_query));
-
   fdsink->fd = 1;
   fdsink->uri = g_strdup_printf ("fd://%d", fdsink->fd);
   fdsink->bytes_written = 0;
@@ -195,12 +191,12 @@ gst_fd_sink_dispose (GObject * obj)
 }
 
 static gboolean
-gst_fd_sink_query (GstPad * pad, GstQuery * query)
+gst_fd_sink_query (GstBaseSink * bsink, GstQuery * query)
 {
   GstFdSink *fdsink;
   GstFormat format;
 
-  fdsink = GST_FD_SINK (GST_PAD_PARENT (pad));
+  fdsink = GST_FD_SINK (bsink);
 
   switch (GST_QUERY_TYPE (query)) {
     case GST_QUERY_POSITION:
@@ -222,8 +218,18 @@ gst_fd_sink_query (GstPad * pad, GstQuery * query)
       gst_query_set_uri (query, fdsink->uri);
       return TRUE;
 
+    case GST_QUERY_SEEKING:
+      gst_query_parse_seeking (query, &format, NULL, NULL, NULL);
+      if (format == GST_FORMAT_BYTES || format == GST_FORMAT_DEFAULT) {
+        gst_query_set_seeking (query, GST_FORMAT_BYTES, fdsink->seekable, 0,
+            -1);
+      } else {
+        gst_query_set_seeking (query, format, FALSE, 0, -1);
+      }
+      return TRUE;
+
     default:
-      return gst_pad_query_default (pad, query);
+      return GST_BASE_SINK_CLASS (parent_class)->query (bsink, query);
   }
 }
 
@@ -384,6 +390,9 @@ gst_fd_sink_start (GstBaseSink * basesink)
   fdsink->bytes_written = 0;
   fdsink->current_pos = 0;
 
+  fdsink->seekable = gst_fd_sink_do_seek (fdsink, 0);
+  GST_INFO_OBJECT (fdsink, "seeking supported: %d", fdsink->seekable);
+
   return TRUE;
 
   /* ERRORS */
diff --git a/plugins/elements/gstfdsink.h b/plugins/elements/gstfdsink.h
index 90913b4..59393d0 100644
--- a/plugins/elements/gstfdsink.h
+++ b/plugins/elements/gstfdsink.h
@@ -59,6 +59,8 @@ struct _GstFdSink {
   int fd;
   guint64 bytes_written;
   guint64 current_pos;
+
+  gboolean seekable;
 };
 
 struct _GstFdSinkClass {
diff --git a/plugins/elements/gstfilesink.c b/plugins/elements/gstfilesink.c
index 9356c0f..543dbfe 100644
--- a/plugins/elements/gstfilesink.c
+++ b/plugins/elements/gstfilesink.c
@@ -495,6 +495,16 @@ gst_file_sink_query (GstBaseSink * bsink, GstQuery * query)
       res = TRUE;
       break;
 
+    case GST_QUERY_SEEKING:
+      gst_query_parse_seeking (query, &format, NULL, NULL, NULL);
+      if (format == GST_FORMAT_BYTES || format == GST_FORMAT_DEFAULT) {
+        gst_query_set_seeking (query, GST_FORMAT_BYTES, self->seekable, 0, -1);
+      } else {
+        gst_query_set_seeking (query, format, FALSE, 0, -1);
+      }
+      res = TRUE;
+      break;
+
     default:
       res = GST_BASE_SINK_CLASS (parent_class)->query (bsink, query);
       break;
diff --git a/plugins/elements/gstinputselector.c b/plugins/elements/gstinputselector.c
index 4da4735..89cf724 100644
--- a/plugins/elements/gstinputselector.c
+++ b/plugins/elements/gstinputselector.c
@@ -683,9 +683,10 @@ gst_input_selector_wait_running_time (GstInputSelector * sel,
    *   d) the active pad has no running time or the active
    *      pad's running time is before this running time
    *   e) the active pad has a non-time segment
+   *   f) the active pad changed and has not pushed anything
    */
-  while (pad != active_selpad && !sel->flushing && !pad->flushing &&
-      (sel->blocked || active_running_time == -1
+  while (pad != active_selpad && !sel->flushing && !pad->flushing
+      && active_selpad->pushed && (sel->blocked || active_running_time == -1
           || running_time >= active_running_time)) {
     if (!sel->blocked)
       GST_DEBUG_OBJECT (pad,
diff --git a/plugins/elements/gstmultiqueue.c b/plugins/elements/gstmultiqueue.c
index 0054715..9891b93 100644
--- a/plugins/elements/gstmultiqueue.c
+++ b/plugins/elements/gstmultiqueue.c
@@ -140,6 +140,12 @@ struct _GstSingleQueue
 
   /* flowreturn of previous srcpad push */
   GstFlowReturn srcresult;
+  /* If something was actually pushed on
+   * this pad after flushing/pad activation
+   * and the srcresult corresponds to something
+   * real
+   */
+  gboolean pushed;
 
   /* segments */
   GstSegment sink_segment;
@@ -748,27 +754,29 @@ gst_single_queue_flush (GstMultiQueue * mq, GstSingleQueue * sq, gboolean flush)
       sq->id);
 
   if (flush) {
+    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
     sq->srcresult = GST_FLOW_WRONG_STATE;
     gst_data_queue_set_flushing (sq->queue, TRUE);
 
     sq->flushing = TRUE;
+    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
     /* wake up non-linked task */
     GST_LOG_OBJECT (mq, "SingleQueue %d : waking up eventually waiting task",
         sq->id);
-    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
     g_cond_signal (sq->turn);
-    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
     GST_LOG_OBJECT (mq, "SingleQueue %d : pausing task", sq->id);
     result = gst_pad_pause_task (sq->srcpad);
     sq->sink_tainted = sq->src_tainted = TRUE;
   } else {
+    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
     gst_data_queue_flush (sq->queue);
     gst_segment_init (&sq->sink_segment, GST_FORMAT_TIME);
     gst_segment_init (&sq->src_segment, GST_FORMAT_TIME);
     /* All pads start off not-linked for a smooth kick-off */
     sq->srcresult = GST_FLOW_OK;
+    sq->pushed = FALSE;
     sq->cur_time = 0;
     sq->max_size.visible = mq->max_size.visible;
     sq->is_eos = FALSE;
@@ -780,11 +788,10 @@ gst_single_queue_flush (GstMultiQueue * mq, GstSingleQueue * sq, gboolean flush)
     gst_data_queue_set_flushing (sq->queue, FALSE);
 
     /* Reset high time to be recomputed next */
-    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
     mq->high_time = GST_CLOCK_TIME_NONE;
-    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
     sq->flushing = FALSE;
+    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
     GST_LOG_OBJECT (mq, "SingleQueue %d : starting task", sq->id);
     result =
@@ -1218,14 +1225,13 @@ gst_multi_queue_loop (GstPad * pad)
    * or it's the first loop, or we just passed the previous highid, 
    * we might need to wake some sleeping pad up, so there's extra work 
    * there too */
+  GST_MULTI_QUEUE_MUTEX_LOCK (mq);
   if (sq->srcresult == GST_FLOW_NOT_LINKED
       || (sq->last_oldid == G_MAXUINT32) || (newid != (sq->last_oldid + 1))
       || sq->last_oldid > mq->highid) {
     GST_LOG_OBJECT (mq, "CHECKING sq->srcresult: %s",
         gst_flow_get_name (sq->srcresult));
 
-    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
-
     /* Check again if we're flushing after the lock is taken,
      * the flush flag might have been changed in the meantime */
     if (sq->flushing) {
@@ -1292,9 +1298,8 @@ gst_multi_queue_loop (GstPad * pad)
     /* We're done waiting, we can clear the nextid and nexttime */
     sq->nextid = 0;
     sq->next_time = GST_CLOCK_TIME_NONE;
-
-    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
   }
+  GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
   if (sq->flushing)
     goto out_flushing;
@@ -1303,6 +1308,7 @@ gst_multi_queue_loop (GstPad * pad)
       gst_flow_get_name (sq->srcresult));
 
   /* Update time stats */
+  GST_MULTI_QUEUE_MUTEX_LOCK (mq);
   next_time = get_running_time (&sq->src_segment, object, FALSE);
   if (next_time != GST_CLOCK_TIME_NONE) {
     if (sq->last_time == GST_CLOCK_TIME_NONE || sq->last_time < next_time)
@@ -1313,10 +1319,51 @@ gst_multi_queue_loop (GstPad * pad)
       wake_up_next_non_linked (mq);
     }
   }
+  GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
 
   /* Try to push out the new object */
   result = gst_single_queue_push_one (mq, sq, object);
+
+  /* Check if we pushed something already and if this is
+   * now a switch from an active to a non-active stream.
+   *
+   * If it is, we reset all the waiting streams, let them
+   * push another buffer to see if they're now active again.
+   * This allows faster switching between streams and prevents
+   * deadlocks if downstream does any waiting too.
+   */
+  GST_MULTI_QUEUE_MUTEX_LOCK (mq);
+  if (sq->pushed && sq->srcresult == GST_FLOW_OK
+      && result == GST_FLOW_NOT_LINKED) {
+    GList *tmp;
+
+    GST_LOG_OBJECT (mq, "SingleQueue %d : Changed from active to non-active",
+        sq->id);
+
+    compute_high_id (mq);
+
+    /* maybe no-one is waiting */
+    if (mq->numwaiting > 0) {
+      /* Else figure out which singlequeue(s) need waking up */
+      for (tmp = mq->queues; tmp; tmp = g_list_next (tmp)) {
+        GstSingleQueue *sq2 = (GstSingleQueue *) tmp->data;
+
+        if (sq2->srcresult == GST_FLOW_NOT_LINKED) {
+          GST_LOG_OBJECT (mq, "Waking up singlequeue %d", sq2->id);
+          sq2->pushed = FALSE;
+          sq2->srcresult = GST_FLOW_OK;
+          g_cond_signal (sq2->turn);
+        }
+      }
+    }
+  }
+
+  if (GST_IS_BUFFER (object))
+    sq->pushed = TRUE;
   sq->srcresult = result;
+  sq->last_oldid = newid;
+  GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
+
   object = NULL;
 
   if (result != GST_FLOW_OK && result != GST_FLOW_NOT_LINKED
@@ -1326,8 +1373,6 @@ gst_multi_queue_loop (GstPad * pad)
   GST_LOG_OBJECT (mq, "AFTER PUSHING sq->srcresult: %s",
       gst_flow_get_name (sq->srcresult));
 
-  sq->last_oldid = newid;
-
   return;
 
 out_flushing:
@@ -1337,6 +1382,7 @@ out_flushing:
 
     /* Need to make sure wake up any sleeping pads when we exit */
     GST_MULTI_QUEUE_MUTEX_LOCK (mq);
+    compute_high_time (mq);
     compute_high_id (mq);
     wake_up_next_non_linked (mq);
     GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
@@ -1421,16 +1467,30 @@ static gboolean
 gst_multi_queue_sink_activate_push (GstPad * pad, gboolean active)
 {
   GstSingleQueue *sq;
+  GstMultiQueue *mq;
 
   sq = (GstSingleQueue *) gst_pad_get_element_private (pad);
+  mq = (GstMultiQueue *) gst_pad_get_parent (pad);
+
+  /* mq is NULL if the pad is activated/deactivated before being
+   * added to the multiqueue */
+  if (mq)
+    GST_MULTI_QUEUE_MUTEX_LOCK (mq);
 
   if (active) {
     /* All pads start off linked until they push one buffer */
     sq->srcresult = GST_FLOW_OK;
+    sq->pushed = FALSE;
   } else {
     sq->srcresult = GST_FLOW_WRONG_STATE;
     gst_data_queue_flush (sq->queue);
   }
+
+  if (mq) {
+    GST_MULTI_QUEUE_MUTEX_UNLOCK (mq);
+    gst_object_unref (mq);
+  }
+
   return TRUE;
 }
 
@@ -1943,6 +2003,7 @@ gst_single_queue_new (GstMultiQueue * mqueue, gint id)
 
   sq->mqueue = mqueue;
   sq->srcresult = GST_FLOW_WRONG_STATE;
+  sq->pushed = FALSE;
   sq->queue = gst_data_queue_new_full ((GstDataQueueCheckFullFunction)
       single_queue_check_full,
       (GstDataQueueFullCallback) single_queue_overrun_cb,
diff --git a/plugins/elements/gstoutputselector.c b/plugins/elements/gstoutputselector.c
index 41b176c..b3b6c36 100644
--- a/plugins/elements/gstoutputselector.c
+++ b/plugins/elements/gstoutputselector.c
@@ -453,7 +453,8 @@ gst_output_selector_switch (GstOutputSelector * osel)
 
   /* Switch */
   GST_OBJECT_LOCK (GST_OBJECT (osel));
-  GST_INFO ("switching to pad %" GST_PTR_FORMAT, osel->pending_srcpad);
+  GST_INFO_OBJECT (osel, "switching to pad %" GST_PTR_FORMAT,
+      osel->pending_srcpad);
   if (gst_pad_is_linked (osel->pending_srcpad)) {
     osel->active_srcpad = osel->pending_srcpad;
     res = TRUE;
@@ -464,23 +465,25 @@ gst_output_selector_switch (GstOutputSelector * osel)
 
   /* Send NEWSEGMENT event and latest buffer if switching succeeded
    * and we already have a valid segment configured */
-  if (res && osel->segment.format != GST_FORMAT_UNDEFINED) {
-    /* Send NEWSEGMENT to the pad we are going to switch to */
-    seg = &osel->segment;
-
-    /* If resending then mark newsegment start and position accordingly */
-    if (osel->resend_latest && osel->latest_buffer &&
-        GST_BUFFER_TIMESTAMP_IS_VALID (osel->latest_buffer)) {
-      start = position = GST_BUFFER_TIMESTAMP (osel->latest_buffer);
-    } else {
-      start = position = seg->last_stop;
-    }
-    ev = gst_event_new_new_segment (TRUE, seg->rate,
-        seg->format, start, seg->stop, position);
-    if (!gst_pad_push_event (osel->active_srcpad, ev)) {
-      GST_WARNING_OBJECT (osel,
-          "newsegment handling failed in %" GST_PTR_FORMAT,
-          osel->active_srcpad);
+  if (res) {
+    if (osel->segment.format != GST_FORMAT_UNDEFINED) {
+      /* Send NEWSEGMENT to the pad we are going to switch to */
+      seg = &osel->segment;
+
+      /* If resending then mark newsegment start and position accordingly */
+      if (osel->resend_latest && osel->latest_buffer &&
+          GST_BUFFER_TIMESTAMP_IS_VALID (osel->latest_buffer)) {
+        start = position = GST_BUFFER_TIMESTAMP (osel->latest_buffer);
+      } else {
+        start = position = seg->last_stop;
+      }
+      ev = gst_event_new_new_segment (TRUE, seg->rate,
+          seg->format, start, seg->stop, position);
+      if (!gst_pad_push_event (osel->active_srcpad, ev)) {
+        GST_WARNING_OBJECT (osel,
+            "newsegment handling failed in %" GST_PTR_FORMAT,
+            osel->active_srcpad);
+      }
     }
 
     /* Resend latest buffer to newly switched pad */
diff --git a/plugins/elements/gsttee.c b/plugins/elements/gsttee.c
index 6b875a7..f1ec8a4 100644
--- a/plugins/elements/gsttee.c
+++ b/plugins/elements/gsttee.c
@@ -859,7 +859,7 @@ gst_tee_sink_activate_push (GstPad * pad, gboolean active)
   tee = GST_TEE (GST_OBJECT_PARENT (pad));
 
   GST_OBJECT_LOCK (tee);
-  tee->sink_mode = active && GST_ACTIVATE_PUSH;
+  tee->sink_mode = (active ? GST_ACTIVATE_PUSH : GST_ACTIVATE_NONE);
 
   if (active && !tee->has_chain)
     goto no_chain;
@@ -912,7 +912,7 @@ gst_tee_src_activate_pull (GstPad * pad, gboolean active)
     if (pad == tee->pull_pad)
       tee->pull_pad = NULL;
   }
-  tee->sink_mode = active && GST_ACTIVATE_PULL;
+  tee->sink_mode = (active ? GST_ACTIVATE_PULL : GST_ACTIVATE_NONE);
   GST_OBJECT_UNLOCK (tee);
 
   gst_object_unref (tee);
diff --git a/po/id.po b/po/id.po
index 62267bc..9b88775 100644
--- a/po/id.po
+++ b/po/id.po
@@ -1,13 +1,13 @@
 # Indonesian translations for gstreamer package.
 # This file is put in the public domain.
-# Andhika Padmawan <andhika.padmawan@gmail.com>, 2010-2012.
+# Andhika Padmawan <andhika.padmawan@gmail.com>, 2010.
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: gstreamer 0.10.32.2\n"
+"Project-Id-Version: gstreamer 0.10.29.2\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/\n"
-"POT-Creation-Date: 2012-02-20 21:32+0000\n"
-"PO-Revision-Date: 2012-01-28 11:44+0700\n"
+"POT-Creation-Date: 2011-06-04 13:33+0100\n"
+"PO-Revision-Date: 2010-06-29 21:55+0700\n"
 "Last-Translator: Andhika Padmawan <andhika.padmawan@gmail.com>\n"
 "Language-Team: Indonesian <translation-team-id@lists.sourceforge.net>\n"
 "Language: id\n"
@@ -153,7 +153,7 @@ msgid "Could not configure supporting library."
 msgstr "Tak dapat mengatur pustaka pendukung."
 
 msgid "Encoding error."
-msgstr "Galat penyandian."
+msgstr ""
 
 msgid "GStreamer encountered a general resource error."
 msgstr "GStreamer menghadapi galat umum sumber daya."
@@ -303,11 +303,13 @@ msgstr "tanggal"
 msgid "date the data was created (as a GDate structure)"
 msgstr "tanggal data dibuat (menurut struktur GDate)"
 
+#, fuzzy
 msgid "datetime"
-msgstr "tanggalwaktu"
+msgstr "tanggal"
 
+#, fuzzy
 msgid "date and time the data was created (as a GstDateTime structure)"
-msgstr "tanggal dan waktu data dibuat (menurut struktur GDateTime)"
+msgstr "tanggal data dibuat (menurut struktur GDate)"
 
 msgid "genre"
 msgstr "genre"
@@ -403,11 +405,12 @@ msgstr "uri hak cipta"
 msgid "URI to the copyright notice of the data"
 msgstr "URI ke keterangan hak cipta data"
 
+#, fuzzy
 msgid "encoded by"
-msgstr "disandikan oleh"
+msgstr "penyandi"
 
 msgid "name of the encoding person or organization"
-msgstr "nama penyandian orang atau organisasi"
+msgstr ""
 
 msgid "contact"
 msgstr "kontak"
@@ -650,11 +653,12 @@ msgstr ""
 "lokasi di dalam kota tempat media dihasilkan atau dibuat (misalnya "
 "lingkungan)"
 
+#, fuzzy
 msgid "geo location horizontal error"
-msgstr "galat horizontal lokasi geografis"
+msgstr "nama lokasi geografis"
 
 msgid "expected error of the horizontal positioning measures (in meters)"
-msgstr "galat yang diharapkan dari pengukuran posisi horizontal (dalam meter)"
+msgstr ""
 
 msgid "geo location movement speed"
 msgstr "kecepatan gerak lokasi geografis"
@@ -761,17 +765,19 @@ msgstr "model divais"
 msgid "Model of the device used to create this media"
 msgstr "Model divais yang digunakan untuk membuat media ini"
 
+#, fuzzy
 msgid "application name"
-msgstr "nama aplikasi"
+msgstr "nama lokasi geografis"
 
+#, fuzzy
 msgid "Application used to create the media"
-msgstr "Aplikasi yang digunakan untuk membuat media"
+msgstr "Model divais yang digunakan untuk membuat media ini"
 
 msgid "application data"
-msgstr "data aplikasi"
+msgstr ""
 
 msgid "Arbitrary application data to be serialized into the media"
-msgstr "Data aplikasi wajib yang akan diurutkan dalam media"
+msgstr ""
 
 msgid "image orientation"
 msgstr "orientasi gambar"
@@ -957,13 +963,13 @@ msgid "controllable"
 msgstr "dapat dikendalikan"
 
 msgid "changeable in NULL, READY, PAUSED or PLAYING state"
-msgstr "dapat diubah dalam kondisi NULL, READY, PAUSED atau PLAYING"
+msgstr ""
 
 msgid "changeable only in NULL, READY or PAUSED state"
-msgstr "hanya dapat diubah dalam kondisi NULL, READY, atau PAUSED"
+msgstr ""
 
 msgid "changeable only in NULL or READY state"
-msgstr "hanya dapat diubah dalam kondisi NULL atau READY"
+msgstr ""
 
 msgid "Blacklisted files:"
 msgstr "Berkas yang dilarang:"
@@ -1047,7 +1053,7 @@ msgid "WARNING: element named '%s' not found.\n"
 msgstr "GALAT: elemen yang dinamakan '%s' tak ditemukan.\n"
 
 msgid "Index statistics"
-msgstr "Statistik indeks"
+msgstr ""
 
 #, c-format
 msgid "Got message #%u from element \"%s\" (%s): "
@@ -1159,7 +1165,7 @@ msgid "Force EOS on sources before shutting the pipeline down"
 msgstr "Paksa EOS pada sumber sebelum mematikan pemipaan"
 
 msgid "Gather and print index statistics"
-msgstr "Kumpulkan dan cetak statistik indeks"
+msgstr ""
 
 #, c-format
 msgid "ERROR: pipeline could not be constructed: %s.\n"
diff --git a/scripts/gst-uninstalled b/scripts/gst-uninstalled
index 485a1c1..045c437 100755
--- a/scripts/gst-uninstalled
+++ b/scripts/gst-uninstalled
@@ -59,10 +59,12 @@ $PATH"
 # /some/path: makes the dynamic linker look in . too, so avoid this
 LD_LIBRARY_PATH=$GST_PREFIX/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}
 DYLD_LIBRARY_PATH=$GST_PREFIX/lib${DYLD_LIBRARY_PATH:+:$DYLD_LIBRARY_PATH}
+GI_TYPELIB_PATH=$GST_PREFIX/share/gir-1.0${GI_TYPELIB_PATH:+:$GI_TYPELIB_PATH}
 
 # GStreamer rtsp server library
 LD_LIBRARY_PATH=$GST/gst-rtsp-server/gst/rtsp-server/.libs:$LD_LIBRARY_PATH
 DYLD_LIBRARY_PATH=$GST/gst-rtsp-server/gst/rtsp-server/.libs:$DYLD_LIBRARY_PATH
+GI_TYPELIB_PATH=$GST/gst-rtsp-server/gst/rtsp-server:$GI_TYPELIB_PATH
 
 # GStreamer ffmpeg libraries
 for path in libavformat libavutil libavcodec libpostproc libavdevice
@@ -76,6 +78,7 @@ for path in app audio cdda fft interfaces pbutils netbuffer riff rtp rtsp sdp ta
 do
   LD_LIBRARY_PATH=$GST/gst-plugins-base/gst-libs/gst/$path/.libs:$LD_LIBRARY_PATH
   DYLD_LIBRARY_PATH=$GST/gst-plugins-base/gst-libs/gst/$path/.libs:$DYLD_LIBRARY_PATH
+  GI_TYPELIB_PATH=$GST/gst-plugins-base/gst-libs/gst/$path:$GI_TYPELIB_PATH
 done
 
 # GStreamer core libraries
@@ -83,11 +86,14 @@ for path in base net check controller dataprotocol
 do
   LD_LIBRARY_PATH=$GST/gstreamer/libs/gst/$path/.libs:$LD_LIBRARY_PATH
   DYLD_LIBRARY_PATH=$GST/gstreamer/libs/gst/$path/.libs:$DYLD_LIBRARY_PATH
+  GI_TYPELIB_PATH=$GST/gstreamer/libs/gst/$path:$GI_TYPELIB_PATH
 done
 LD_LIBRARY_PATH=$GST/gstreamer/gst/.libs:$LD_LIBRARY_PATH
 DYLD_LIBRARY_PATH=$GST/gstreamer/gst/.libs:$DYLD_LIBRARY_PATH
+GI_TYPELIB_PATH=$GST/gstreamer/gst:$GI_TYPELIB_PATH
 export LD_LIBRARY_PATH
 export DYLD_LIBRARY_PATH
+export GI_TYPELIB_PATH
   
 export PKG_CONFIG_PATH="\
 $GST_PREFIX/lib/pkgconfig\
diff --git a/tests/benchmarks/gstclockstress.c b/tests/benchmarks/gstclockstress.c
index 60895d9..ed89840 100644
--- a/tests/benchmarks/gstclockstress.c
+++ b/tests/benchmarks/gstclockstress.c
@@ -60,6 +60,11 @@ main (gint argc, gchar * argv[])
 
   num_threads = atoi (argv[1]);
 
+  if (num_threads <= 0 || num_threads > MAX_THREADS) {
+    g_print ("number of threads must be between 0 and %d\n", MAX_THREADS);
+    exit (-2);
+  }
+
   sysclock = gst_system_clock_obtain ();
 
   for (t = 0; t < num_threads; t++) {
diff --git a/tests/check/Makefile.am b/tests/check/Makefile.am
index bf56a90..c2eadcf 100644
--- a/tests/check/Makefile.am
+++ b/tests/check/Makefile.am
@@ -89,6 +89,7 @@ REGISTRY_CHECKS =				\
 	libs/basesink				\
 	libs/controller				\
 	libs/typefindhelper			\
+	pipelines/seek				\
 	pipelines/stress			\
 	pipelines/queue-error
 endif
diff --git a/tests/check/pipelines/seek.c b/tests/check/pipelines/seek.c
new file mode 100644
index 0000000..84c1161
--- /dev/null
+++ b/tests/check/pipelines/seek.c
@@ -0,0 +1,226 @@
+/* GStreamer simple seek unit test
+ * Copyright (C) 2012 Collabora Ltd.
+ *   Author: Tim-Philipp Mller <tim.muller@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <gst/gst.h>
+#include <gst/base/gstbasesrc.h>
+
+#include <gst/check/gstcheck.h>
+#include <gst/check/gstconsistencychecker.h>
+
+/* ========================================================================
+ *  Dummy source, like a stripped down audio test source
+ * ======================================================================== */
+
+#define SAMPLERATE 44100
+#define CHUNKS_PER_SEC 10
+
+typedef struct
+{
+  GstBaseSrc parent;
+  GstClockTime next_time;
+} TimedTestSrc;
+
+typedef struct
+{
+  GstBaseSrcClass parent_class;
+} TimedTestSrcClass;
+
+static GstStaticPadTemplate timed_test_src_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("timed/audio"));
+
+static GType timed_test_src_get_type (void);
+
+GST_BOILERPLATE (TimedTestSrc, timed_test_src, GstBaseSrc, GST_TYPE_BASE_SRC);
+
+static gboolean timed_test_src_is_seekable (GstBaseSrc * basesrc);
+static gboolean timed_test_src_check_get_range (GstBaseSrc * basesrc);
+static gboolean timed_test_src_do_seek (GstBaseSrc * basesrc,
+    GstSegment * segment);
+static gboolean timed_test_src_start (GstBaseSrc * basesrc);
+static gboolean timed_test_src_stop (GstBaseSrc * basesrc);
+static GstFlowReturn timed_test_src_create (GstBaseSrc * basesrc,
+    guint64 offset, guint length, GstBuffer ** buffer);
+
+static void
+timed_test_src_base_init (gpointer g_class)
+{
+  gst_element_class_add_static_pad_template (GST_ELEMENT_CLASS (g_class),
+      &timed_test_src_src_template);
+}
+
+static void
+timed_test_src_class_init (TimedTestSrcClass * klass)
+{
+  GstBaseSrcClass *gstbasesrc_class = (GstBaseSrcClass *) klass;
+
+  gstbasesrc_class->is_seekable = timed_test_src_is_seekable;
+  gstbasesrc_class->check_get_range = timed_test_src_check_get_range;
+  gstbasesrc_class->do_seek = timed_test_src_do_seek;
+  gstbasesrc_class->start = timed_test_src_start;
+  gstbasesrc_class->stop = timed_test_src_stop;
+  gstbasesrc_class->create = timed_test_src_create;
+}
+
+static void
+timed_test_src_init (TimedTestSrc * src, TimedTestSrcClass * g_class)
+{
+  gst_base_src_set_format (GST_BASE_SRC (src), GST_FORMAT_TIME);
+  gst_base_src_set_live (GST_BASE_SRC (src), FALSE);
+}
+
+static gboolean
+timed_test_src_start (GstBaseSrc * basesrc)
+{
+  TimedTestSrc *src = (TimedTestSrc *) basesrc;
+
+  src->next_time = 0;
+  return TRUE;
+}
+
+static gboolean
+timed_test_src_stop (GstBaseSrc * basesrc)
+{
+  return TRUE;
+}
+
+static gboolean
+timed_test_src_do_seek (GstBaseSrc * basesrc, GstSegment * segment)
+{
+  TimedTestSrc *src = (TimedTestSrc *) basesrc;
+
+  src->next_time = segment->last_stop;
+  return TRUE;
+}
+
+static gboolean
+timed_test_src_is_seekable (GstBaseSrc * basesrc)
+{
+  return TRUE;
+}
+
+static gboolean
+timed_test_src_check_get_range (GstBaseSrc * basesrc)
+{
+  return FALSE;
+}
+
+static GstFlowReturn
+timed_test_src_create (GstBaseSrc * basesrc, guint64 offset, guint length,
+    GstBuffer ** buf)
+{
+  TimedTestSrc *src = (TimedTestSrc *) basesrc;
+
+  *buf = gst_buffer_new_and_alloc (SAMPLERATE / CHUNKS_PER_SEC);
+  GST_BUFFER_TIMESTAMP (*buf) = src->next_time;
+  GST_BUFFER_DURATION (*buf) = GST_SECOND / CHUNKS_PER_SEC;
+  src->next_time += GST_BUFFER_DURATION (*buf);
+  return GST_FLOW_OK;
+}
+
+/* ======================================================================== */
+
+GST_START_TEST (test_seek)
+{
+  GstStreamConsistency *consist;
+  GstMessage *msg;
+  GstElement *bin, *src1, *sink;
+  gboolean res;
+  GstPad *srcpad;
+  GstBus *bus;
+
+  GST_INFO ("preparing test");
+
+  /* build pipeline */
+  bin = gst_pipeline_new ("pipeline");
+  bus = gst_element_get_bus (bin);
+  gst_bus_add_signal_watch_full (bus, G_PRIORITY_HIGH);
+
+  src1 = g_object_new (timed_test_src_get_type (), "name", "testsrc", NULL);
+
+  sink = gst_element_factory_make ("fakesink", "sink");
+  gst_bin_add_many (GST_BIN (bin), src1, sink, NULL);
+
+  res = gst_element_link (src1, sink);
+  fail_unless (res == TRUE, NULL);
+
+  srcpad = gst_element_get_static_pad (src1, "src");
+  consist = gst_consistency_checker_new (srcpad);
+  gst_object_unref (srcpad);
+
+  GST_INFO ("starting test");
+
+  /* prepare playing */
+  res = gst_element_set_state (bin, GST_STATE_PAUSED);
+  fail_unless (res != GST_STATE_CHANGE_FAILURE, NULL);
+
+  /* wait for completion */
+  res =
+      gst_element_get_state (GST_ELEMENT (bin), NULL, NULL,
+      GST_CLOCK_TIME_NONE);
+  fail_unless (res != GST_STATE_CHANGE_FAILURE, NULL);
+
+  res = gst_element_send_event (bin,
+      gst_event_new_seek (1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
+          GST_SEEK_TYPE_SET, (GstClockTime) 0,
+          GST_SEEK_TYPE_SET, (GstClockTime) 2 * GST_SECOND));
+  fail_unless (res == TRUE, NULL);
+
+  GST_INFO ("seeked");
+
+  /* run pipeline */
+  res = gst_element_set_state (bin, GST_STATE_PLAYING);
+  fail_unless (res != GST_STATE_CHANGE_FAILURE, NULL);
+
+  msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE,
+      GST_MESSAGE_EOS | GST_MESSAGE_ERROR);
+  fail_unless_equals_string (GST_MESSAGE_TYPE_NAME (msg), "eos");
+  gst_message_unref (msg);
+
+  res = gst_element_set_state (bin, GST_STATE_NULL);
+  fail_unless (res != GST_STATE_CHANGE_FAILURE, NULL);
+
+  /* cleanup */
+  gst_consistency_checker_free (consist);
+  gst_object_unref (bus);
+  gst_object_unref (bin);
+}
+
+GST_END_TEST;
+
+static Suite *
+pipelines_seek_suite (void)
+{
+  Suite *s = suite_create ("pipelines-seek");
+  TCase *tc_chain = tcase_create ("general");
+
+  suite_add_tcase (s, tc_chain);
+  tcase_add_test (tc_chain, test_seek);
+
+  return s;
+}
+
+GST_CHECK_MAIN (pipelines_seek);
diff --git a/tools/gst-inspect.c b/tools/gst-inspect.c
index d3ce0c8..f8d2f2f 100644
--- a/tools/gst-inspect.c
+++ b/tools/gst-inspect.c
@@ -21,6 +21,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
@@ -1230,7 +1234,7 @@ print_plugin_info (GstPlugin * plugin)
 static void
 print_plugin_features (GstPlugin * plugin)
 {
-  GList *features;
+  GList *features, *features_to_free;
   gint num_features = 0;
   gint num_elements = 0;
   gint num_typefinders = 0;
@@ -1241,6 +1245,7 @@ print_plugin_features (GstPlugin * plugin)
       gst_registry_get_feature_list_by_plugin (gst_registry_get_default (),
       plugin->desc.name);
 
+  features_to_free = features;
   while (features) {
     GstPluginFeature *feature;
 
@@ -1284,6 +1289,7 @@ print_plugin_features (GstPlugin * plugin)
       num_other++;
     }
     num_features++;
+    gst_object_unref (feature);
     features = g_list_next (features);
   }
   n_print ("\n");
@@ -1298,6 +1304,9 @@ print_plugin_features (GstPlugin * plugin)
     n_print ("  +-- %d other objects\n", num_other);
 
   n_print ("\n");
+
+  if (features_to_free)
+    g_list_free (features_to_free);
 }
 
 static int
@@ -1339,6 +1348,7 @@ print_element_info (GstElementFactory * factory, gboolean print_names)
 
   element = gst_element_factory_create (factory, NULL);
   if (!element) {
+    gst_object_unref (factory);
     g_print ("couldn't construct element for some reason\n");
     return -1;
   }
diff --git a/tools/gst-launch.c b/tools/gst-launch.c
index b801d03..f3f2d07 100644
--- a/tools/gst-launch.c
+++ b/tools/gst-launch.c
@@ -689,7 +689,7 @@ event_loop (GstElement * pipeline, gboolean blocking, GstState target_state)
       }
       case GST_MESSAGE_TAG:
         if (tags) {
-          GstTagList *tags;
+          GstTagList *tag_list;
 
           if (GST_IS_ELEMENT (GST_MESSAGE_SRC (message))) {
             PRINT (_("FOUND TAG      : found by element \"%s\".\n"),
@@ -704,9 +704,9 @@ event_loop (GstElement * pipeline, gboolean blocking, GstState target_state)
             PRINT (_("FOUND TAG\n"));
           }
 
-          gst_message_parse_tag (message, &tags);
-          gst_tag_list_foreach (tags, print_tag, NULL);
-          gst_tag_list_free (tags);
+          gst_message_parse_tag (message, &tag_list);
+          gst_tag_list_foreach (tag_list, print_tag, NULL);
+          gst_tag_list_free (tag_list);
         }
         break;
       case GST_MESSAGE_INFO:{
diff --git a/win32/common/config.h b/win32/common/config.h
index ae83e50..dbc82e4 100644
--- a/win32/common/config.h
+++ b/win32/common/config.h
@@ -59,13 +59,13 @@
 #define GST_MAJORMINOR "0.10"
 
 /* package name in plugins */
-#define GST_PACKAGE_NAME "GStreamer source release"
+#define GST_PACKAGE_NAME "GStreamer git"
 
 /* package origin */
 #define GST_PACKAGE_ORIGIN "Unknown package origin"
 
 /* GStreamer package release date/time for plugins as YYYY-MM-DD */
-#define GST_PACKAGE_RELEASE_DATETIME "2012-02-20"
+#define GST_PACKAGE_RELEASE_DATETIME "2012-02-23T10:04Z"
 
 /* location of the installed gst-plugin-scanner */
 #define GST_PLUGIN_SCANNER_INSTALLED LIBDIR "\\gst-plugin-scanner"
@@ -343,7 +343,7 @@
 #define PACKAGE_NAME "GStreamer"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "GStreamer 0.10.36"
+#define PACKAGE_STRING "GStreamer 0.10.36.1"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "gstreamer"
@@ -352,7 +352,7 @@
 #undef PACKAGE_URL
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "0.10.36"
+#define PACKAGE_VERSION "0.10.36.1"
 
 /* directory where plugins are located */
 #ifdef _DEBUG
@@ -383,7 +383,7 @@
 #undef USE_POISONING
 
 /* Version number of package */
-#define VERSION "0.10.36"
+#define VERSION "0.10.36.1"
 
 /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
    significant byte first (like Motorola and SPARC, unlike Intel). */
diff --git a/win32/common/gstversion.h b/win32/common/gstversion.h
index 86040e6..f1154e2 100644
--- a/win32/common/gstversion.h
+++ b/win32/common/gstversion.h
@@ -64,7 +64,7 @@ G_BEGIN_DECLS
  * The nano version of GStreamer at compile time:
  * Actual releases have 0, GIT versions have 1, prerelease versions have 2-...
  */
-#define GST_VERSION_NANO (0)
+#define GST_VERSION_NANO (1)
 
 /**
  * GST_CHECK_VERSION:
diff --git a/win32/common/libgstbase.def b/win32/common/libgstbase.def
index e68c0e9..806ba6c 100644
--- a/win32/common/libgstbase.def
+++ b/win32/common/libgstbase.def
@@ -210,6 +210,7 @@ EXPORTS
 	gst_collect_pads2_add_pad
 	gst_collect_pads2_add_pad_full
 	gst_collect_pads2_available
+	gst_collect_pads2_clip_running_time
 	gst_collect_pads2_collect
 	gst_collect_pads2_collect_range
 	gst_collect_pads2_flush
