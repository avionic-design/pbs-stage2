diff --git a/autogen.sh b/autogen.sh
index 1fcf9f2..645b2ae 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -29,6 +29,9 @@ then
     ln -s ../../common/hooks/pre-commit.hook .git/hooks/pre-commit
 fi
 
+# GNU gettext automake support doesn't get along with git.
+# https://bugzilla.gnome.org/show_bug.cgi?id=661128
+touch -t 200001010000 po/gst-plugins-good-0.10.pot
 
 CONFIGURE_DEF_OPT='--enable-maintainer-mode --enable-gtk-doc'
 
diff --git a/configure.ac b/configure.ac
index 8a43fda..fddc97d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -5,7 +5,7 @@ dnl please read gstreamer/docs/random/autotools before changing this file
 dnl initialize autoconf
 dnl releases only do -Wall, git and prerelease does -Werror too
 dnl use a three digit version number for releases, and four for git/pre
-AC_INIT(GStreamer Good Plug-ins, 0.10.31,
+AC_INIT(GStreamer Good Plug-ins, 0.10.31.1,
     http://bugzilla.gnome.org/enter_bug.cgi?product=GStreamer,
     gst-plugins-good)
 
@@ -55,7 +55,7 @@ AM_PROG_LIBTOOL
 
 dnl *** required versions of GStreamer stuff ***
 GST_REQ=0.10.36
-GSTPB_REQ=0.10.36
+GSTPB_REQ=0.10.36.1
 
 dnl *** autotools stuff ****
 
@@ -298,7 +300,7 @@ AG_GST_SET_PACKAGE_RELEASE_DATETIME_WITH_NANO([$PACKAGE_VERSION_NANO],
 dnl define an ERROR_CFLAGS Makefile variable
 dnl -Wundef: too many broken headers
 if test "x$HAVE_OSX_VIDEO" != "xyes"; then
-  AG_GST_SET_ERROR_CFLAGS($GST_GIT, [
+  AG_GST_SET_ERROR_CFLAGS($FATAL_WARNINGS, [
         -Wmissing-declarations -Wmissing-prototypes -Wredundant-decls
         -Wwrite-strings -Wold-style-definition -Waggregate-return
         -Winit-self -Wmissing-include-dirs -Waddress -Wno-multichar
@@ -307,7 +309,7 @@ else
   dnl work-around for us passing GST_CFLAGS to the ObjC-compiler, which
   dnl doesn't understand all warning flags that the C compiler knows about
   dnl (e.g. -Waddress) or causes problems with some flags (-Waggregate-return)
-  AG_GST_SET_ERROR_CFLAGS($GST_GIT, [
+  AG_GST_SET_ERROR_CFLAGS($FATAL_WARNINGS, [
         -Wmissing-declarations -Wmissing-prototypes -Wredundant-decls
         -Wwrite-strings -Wold-style-definition
         -Winit-self -Wmissing-include-dirs -Wno-multichar
@@ -315,7 +317,7 @@ else
 fi
 
 dnl define an ERROR_CXXFLAGS Makefile variable
-AG_GST_SET_ERROR_CXXFLAGS($GST_GIT, [
+AG_GST_SET_ERROR_CXXFLAGS($FATAL_WARNINGS, [
         -Wmissing-declarations -Wredundant-decls
         -Wwrite-strings
         -Winit-self -Wmissing-include-dirs -Waddress -Wno-multichar ])
@@ -414,18 +416,14 @@ AG_GST_CHECK_FEATURE(DIRECTSOUND, [DirectSound plug-in], directsoundsink, [
   LDFLAGS="$LDFLAGS $DIRECTSOUND_LDFLAGS"
   LIBS="$LIBS -ldsound -ldxerr9 -luser32"
   AC_MSG_CHECKING(for DirectSound LDFLAGS)
-  AC_LINK_IFELSE([
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[
 #include <windows.h>
 #include <dxerr9.h>
 #include <dsound.h>
-
-int main ()
-{
+]], [[
   DXGetErrorString9 (0);
   DirectSoundCreate(NULL, NULL, NULL);
-
-  return 0;
-}
+]])
 ],
     [HAVE_DIRECTSOUND="yes"],
     [HAVE_DIRECTSOUND="no"])
@@ -444,6 +442,12 @@ int main ()
   AC_SUBST(HAVE_DIRECTSOUND)
 ])
 
+dnl *** Win32 WaveOut ***
+translit(dnm, m, l) AM_CONDITIONAL(USE_WAVEFORM, true)
+AG_GST_CHECK_FEATURE(WAVEFORM, [Win32 WaveForm], waveformsink, [
+  AC_CHECK_HEADER(mmsystem.h, HAVE_WAVEFORM="yes", HAVE_WAVEFORM="no", [#include <windows.h>])
+])
+
 dnl *** OSS audio *** (Linux, *BSD)
 translit(dnm, m, l) AM_CONDITIONAL(USE_OSS, true)
 AG_GST_CHECK_FEATURE(OSS, [OSS audio], ossaudio, [
@@ -1046,6 +1050,7 @@ AM_CONDITIONAL(USE_SOUP, false)
 AM_CONDITIONAL(USE_SPEEX, false)
 AM_CONDITIONAL(USE_SUNAUDIO, false)
 AM_CONDITIONAL(USE_TAGLIB, false)
+AM_CONDITIONAL(USE_WAVEFORM, false)
 AM_CONDITIONAL(USE_WAVPACK, false)
 AM_CONDITIONAL(USE_X, false)
 AM_CONDITIONAL(USE_XSHM, false)
diff --git a/docs/plugins/Makefile.am b/docs/plugins/Makefile.am
index 1fc2e07..dc0a0fc 100644
--- a/docs/plugins/Makefile.am
+++ b/docs/plugins/Makefile.am
@@ -69,6 +69,7 @@ EXTRA_HFILES = \
 	$(top_srcdir)/ext/gconf/gstgconfaudiosink.h \
 	$(top_srcdir)/ext/gconf/gstgconfvideosrc.h \
 	$(top_srcdir)/ext/gconf/gstgconfvideosink.h \
+	$(top_srcdir)/ext/gdk_pixbuf/gstgdkpixbufoverlay.h \
 	$(top_srcdir)/ext/gdk_pixbuf/gstgdkpixbufsink.h \
 	$(top_srcdir)/ext/hal/gsthalaudiosink.h \
 	$(top_srcdir)/ext/hal/gsthalaudiosrc.h \
diff --git a/docs/plugins/gst-plugins-good-plugins-docs.sgml b/docs/plugins/gst-plugins-good-plugins-docs.sgml
index 9f65e21..2c7d08b 100644
--- a/docs/plugins/gst-plugins-good-plugins-docs.sgml
+++ b/docs/plugins/gst-plugins-good-plugins-docs.sgml
@@ -85,6 +85,7 @@
     <xi:include href="xml/element-gconfaudiosink.xml" />
     <xi:include href="xml/element-gconfvideosrc.xml" />
     <xi:include href="xml/element-gconfvideosink.xml" />
+    <xi:include href="xml/element-gdkpixbufoverlay.xml" />
     <xi:include href="xml/element-gdkpixbufsink.xml" />
     <xi:include href="xml/element-goom.xml" />
     <xi:include href="xml/element-goom2k1.xml" />
diff --git a/docs/plugins/gst-plugins-good-plugins-sections.txt b/docs/plugins/gst-plugins-good-plugins-sections.txt
index 0f03971..e5f4c38 100644
--- a/docs/plugins/gst-plugins-good-plugins-sections.txt
+++ b/docs/plugins/gst-plugins-good-plugins-sections.txt
@@ -984,6 +984,20 @@ gst_gconf_video_sink_get_type
 </SECTION>
 
 <SECTION>
+<FILE>element-gdkpixbufoverlay</FILE>
+<TITLE>gdkpixbufoverlay</TITLE>
+GstGdkPixbufOverlay
+<SUBSECTION Standard>
+GstGdkPixbufOverlayClass
+GST_TYPE_GDK_PIXBUF_OVERLAY
+GST_GDK_PIXBUF_OVERLAY
+GST_GDK_PIXBUF_OVERLAY_CLASS
+GST_IS_GDK_PIXBUF_OVERLAY
+GST_IS_GDK_PIXBUF_OVERLAY_CLASS
+gst_gdk_pixbuf_overlay_get_type
+</SECTION>
+
+<SECTION>
 <FILE>element-gdkpixbufsink</FILE>
 <TITLE>gdkpixbufsink</TITLE>
 GstGdkPixbufSink
diff --git a/docs/plugins/gst-plugins-good-plugins.args b/docs/plugins/gst-plugins-good-plugins.args
index 625e93e..65153bc 100644
--- a/docs/plugins/gst-plugins-good-plugins.args
+++ b/docs/plugins/gst-plugins-good-plugins.args
@@ -839,6 +839,16 @@
 </ARG>
 
 <ARG>
+<NAME>GstRTSPSrc::do-rtsp-keep-alive</NAME>
+<TYPE>gboolean</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Do RTSP Keep Alive</NICK>
+<BLURB>Send RTSP keep alive packets, disable for old incompatible server.</BLURB>
+<DEFAULT>TRUE</DEFAULT>
+</ARG>
+
+<ARG>
 <NAME>GstRTPDec::skip</NAME>
 <TYPE>gint</TYPE>
 <RANGE></RANGE>
@@ -1895,7 +1905,7 @@
 <FLAGS>rwx</FLAGS>
 <NICK>Seekpoints</NICK>
 <BLURB>Add SEEKTABLE metadata (if > 0, number of entries, if < 0, interval in sec).</BLURB>
-<DEFAULT>0</DEFAULT>
+<DEFAULT>-10</DEFAULT>
 </ARG>
 
 <ARG>
@@ -21389,6 +21399,16 @@
 </ARG>
 
 <ARG>
+<NAME>GstJackAudioSrc::transport</NAME>
+<TYPE>GstJackTransport</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Transport mode</NICK>
+<BLURB>Jack transport behaviour of the client.</BLURB>
+<DEFAULT></DEFAULT>
+</ARG>
+
+<ARG>
 <NAME>GstJackAudioSink::client</NAME>
 <TYPE>JackClient*</TYPE>
 <RANGE></RANGE>
@@ -21429,6 +21449,16 @@
 </ARG>
 
 <ARG>
+<NAME>GstJackAudioSink::transport</NAME>
+<TYPE>GstJackTransport</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Transport mode</NICK>
+<BLURB>Jack transport behaviour of the client.</BLURB>
+<DEFAULT></DEFAULT>
+</ARG>
+
+<ARG>
 <NAME>GstFlacParse::check-frame-checksums</NAME>
 <TYPE>gboolean</TYPE>
 <RANGE></RANGE>
@@ -22418,3 +22448,83 @@
 <DEFAULT>""</DEFAULT>
 </ARG>
 
+<ARG>
+<NAME>GstWavParse::ignore-length</NAME>
+<TYPE>gboolean</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Ignore length</NICK>
+<BLURB>Ignore length from the Wave header.</BLURB>
+<DEFAULT>FALSE</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstGdkPixbufOverlay::location</NAME>
+<TYPE>gchar*</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>location</NICK>
+<BLURB>Location of image file to overlay.</BLURB>
+<DEFAULT>NULL</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstGdkPixbufOverlay::offset-x</NAME>
+<TYPE>gint</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>X Offset</NICK>
+<BLURB>Horizontal offset of overlay image in pixels from top-left corner of video image.</BLURB>
+<DEFAULT>0</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstGdkPixbufOverlay::offset-y</NAME>
+<TYPE>gint</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Y Offset</NICK>
+<BLURB>Vertical offset of overlay image in pixels from top-left corner of video image.</BLURB>
+<DEFAULT>0</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstGdkPixbufOverlay::overlay-height</NAME>
+<TYPE>gint</TYPE>
+<RANGE>>= 0</RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Overlay Height</NICK>
+<BLURB>Height of overlay image in pixels (0 = same as overlay image).</BLURB>
+<DEFAULT>0</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstGdkPixbufOverlay::overlay-width</NAME>
+<TYPE>gint</TYPE>
+<RANGE>>= 0</RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Overlay Width</NICK>
+<BLURB>Width of overlay image in pixels (0 = same as overlay image).</BLURB>
+<DEFAULT>0</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstGdkPixbufOverlay::relative-x</NAME>
+<TYPE>gdouble</TYPE>
+<RANGE>[0,1]</RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Relative X Offset</NICK>
+<BLURB>Horizontal offset of overlay image in fractions of video image width, from top-left corner of video image.</BLURB>
+<DEFAULT>0</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstGdkPixbufOverlay::relative-y</NAME>
+<TYPE>gdouble</TYPE>
+<RANGE>[0,1]</RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Relative Y Offset</NICK>
+<BLURB>Vertical offset of overlay image in fractions of video image height, from top-left corner of video image.</BLURB>
+<DEFAULT>0</DEFAULT>
+</ARG>
+
diff --git a/docs/plugins/gst-plugins-good-plugins.hierarchy b/docs/plugins/gst-plugins-good-plugins.hierarchy
index 3288bab..9b66640 100644
--- a/docs/plugins/gst-plugins-good-plugins.hierarchy
+++ b/docs/plugins/gst-plugins-good-plugins.hierarchy
@@ -4,8 +4,6 @@ GObject
   GstCmmlTagHead
   GstCmmlTagStream
   GstColorBalanceChannel
-  GstMixerTrack
-    GstMixerOptions
   GstObject
     GstBus
     GstClock
@@ -19,9 +17,11 @@ GObject
       GstAuParse
       GstAudioDecoder
         GstSpeexDec
+        GstWavpackDec
       GstAudioEncoder
         GstFlacEnc
         GstSpeexEnc
+        GstWavpackEnc
       GstAviDemux
       GstAviMux
       GstAviSubtitle
@@ -32,6 +32,7 @@ GObject
         GstDcaParse
         GstFlacParse
         GstMpegAudioParse
+        GstWavpackParse2
       GstBaseRTPDepayload
         GstRTPBVDepay
         GstRTPDVDepay
@@ -180,6 +181,7 @@ GObject
           GstDiceTV
           GstEdgeTV
           GstGamma
+          GstGdkPixbufOverlay
           GstNavigationtest
           GstOpTV
           GstQuarkTV
@@ -271,7 +273,7 @@ GObject
       GstTagDemux
         GstApeDemux
         GstID3Demux
-      GstTagLibMux
+      GstTagMux
         GstApev2Mux
         GstId3v2Mux
       GstV4l2Radio
@@ -279,8 +281,6 @@ GObject
       GstVideoMixer2
       GstWavEnc
       GstWavParse
-      GstWavpackDec
-      GstWavpackEnc
       GstWavpackParse
       GstY4mEncode
     GstPad
diff --git a/docs/plugins/gst-plugins-good-plugins.interfaces b/docs/plugins/gst-plugins-good-plugins.interfaces
index b356c99..7345113 100644
--- a/docs/plugins/gst-plugins-good-plugins.interfaces
+++ b/docs/plugins/gst-plugins-good-plugins.interfaces
@@ -56,6 +56,7 @@ GstSpeexEnc GstTagSetter GstPreset
 GstSwitchSink GstChildProxy
 GstSwitchSrc GstChildProxy
 GstTagLibMux GstTagSetter
+GstTagMux GstTagSetter
 GstUDPSink GstURIHandler
 GstUDPSrc GstURIHandler
 GstV4l2Radio GstURIHandler GstImplementsInterface GstTuner GstPropertyProbe
diff --git a/docs/plugins/inspect/plugin-1394.xml b/docs/plugins/inspect/plugin-1394.xml
index 74e4398..9a300f4 100644
--- a/docs/plugins/inspect/plugin-1394.xml
+++ b/docs/plugins/inspect/plugin-1394.xml
@@ -3,10 +3,10 @@
   <description>Source for video data via IEEE1394 interface</description>
   <filename>../../ext/raw1394/.libs/libgst1394.so</filename>
   <basename>libgst1394.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-aasink.xml b/docs/plugins/inspect/plugin-aasink.xml
index 41b7484..b15835a 100644
--- a/docs/plugins/inspect/plugin-aasink.xml
+++ b/docs/plugins/inspect/plugin-aasink.xml
@@ -3,10 +3,10 @@
   <description>ASCII Art video sink</description>
   <filename>../../ext/aalib/.libs/libgstaasink.so</filename>
   <basename>libgstaasink.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-alaw.xml b/docs/plugins/inspect/plugin-alaw.xml
index 4dd3192..cd4c42b 100644
--- a/docs/plugins/inspect/plugin-alaw.xml
+++ b/docs/plugins/inspect/plugin-alaw.xml
@@ -3,10 +3,10 @@
   <description>ALaw audio conversion routines</description>
   <filename>../../gst/law/.libs/libgstalaw.so</filename>
   <basename>libgstalaw.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-alpha.xml b/docs/plugins/inspect/plugin-alpha.xml
index d9c91f0..2b0b75f 100644
--- a/docs/plugins/inspect/plugin-alpha.xml
+++ b/docs/plugins/inspect/plugin-alpha.xml
@@ -3,10 +3,10 @@
   <description>adds an alpha channel to video - constant or via chroma-keying</description>
   <filename>../../gst/alpha/.libs/libgstalpha.so</filename>
   <basename>libgstalpha.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-alphacolor.xml b/docs/plugins/inspect/plugin-alphacolor.xml
index d488936..7009cb9 100644
--- a/docs/plugins/inspect/plugin-alphacolor.xml
+++ b/docs/plugins/inspect/plugin-alphacolor.xml
@@ -3,10 +3,10 @@
   <description>RGBA from/to AYUV colorspace conversion preserving the alpha channel</description>
   <filename>../../gst/alpha/.libs/libgstalphacolor.so</filename>
   <basename>libgstalphacolor.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-annodex.xml b/docs/plugins/inspect/plugin-annodex.xml
index 5cf2db6..00ba705 100644
--- a/docs/plugins/inspect/plugin-annodex.xml
+++ b/docs/plugins/inspect/plugin-annodex.xml
@@ -3,10 +3,10 @@
   <description>annodex stream manipulation (info about annodex: http://www.annodex.net)</description>
   <filename>../../ext/annodex/.libs/libgstannodex.so</filename>
   <basename>libgstannodex.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-apetag.xml b/docs/plugins/inspect/plugin-apetag.xml
index d57533d..e5a5612 100644
--- a/docs/plugins/inspect/plugin-apetag.xml
+++ b/docs/plugins/inspect/plugin-apetag.xml
@@ -3,10 +3,10 @@
   <description>APEv1/2 tag reader</description>
   <filename>../../gst/apetag/.libs/libgstapetag.so</filename>
   <basename>libgstapetag.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-audiofx.xml b/docs/plugins/inspect/plugin-audiofx.xml
index 98462d7..1ededda 100644
--- a/docs/plugins/inspect/plugin-audiofx.xml
+++ b/docs/plugins/inspect/plugin-audiofx.xml
@@ -3,10 +3,10 @@
   <description>Audio effects plugin</description>
   <filename>../../gst/audiofx/.libs/libgstaudiofx.so</filename>
   <basename>libgstaudiofx.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-audioparsers.xml b/docs/plugins/inspect/plugin-audioparsers.xml
index 5579512..764ebfa 100644
--- a/docs/plugins/inspect/plugin-audioparsers.xml
+++ b/docs/plugins/inspect/plugin-audioparsers.xml
@@ -3,10 +3,10 @@
   <description>Parsers for various audio formats</description>
   <filename>../../gst/audioparsers/.libs/libgstaudioparsers.so</filename>
   <basename>libgstaudioparsers.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -26,7 +26,7 @@
           <name>src</name>
           <direction>source</direction>
           <presence>always</presence>
-          <details>audio/mpeg, framed=(boolean)true, mpegversion=(int){ 2, 4 }, stream-format=(string){ raw, adts, adif }</details>
+          <details>audio/mpeg, framed=(boolean)true, mpegversion=(int){ 2, 4 }, stream-format=(string){ raw, adts, adif, loas }</details>
         </caps>
       </pads>
     </element>
@@ -135,5 +135,26 @@
         </caps>
       </pads>
     </element>
+    <element>
+      <name>wavpackparse2</name>
+      <longname>Wavpack audio stream parser</longname>
+      <class>Codec/Parser/Audio</class>
+      <description>Wavpack parser</description>
+      <author>Mark Nauwelaerts &lt;mark.nauwelaerts@collabora.co.uk&gt;</author>
+      <pads>
+        <caps>
+          <name>sink</name>
+          <direction>sink</direction>
+          <presence>always</presence>
+          <details>audio/x-wavpack</details>
+        </caps>
+        <caps>
+          <name>src</name>
+          <direction>source</direction>
+          <presence>always</presence>
+          <details>audio/x-wavpack, width=(int)[ 1, 32 ], channels=(int)[ 1, 8 ], rate=(int)[ 6000, 192000 ], framed=(boolean)true; audio/x-wavpack-correction, framed=(boolean)true</details>
+        </caps>
+      </pads>
+    </element>
   </elements>
 </plugin>
\ No newline at end of file
diff --git a/docs/plugins/inspect/plugin-auparse.xml b/docs/plugins/inspect/plugin-auparse.xml
index 606d88c..b36ed3e 100644
--- a/docs/plugins/inspect/plugin-auparse.xml
+++ b/docs/plugins/inspect/plugin-auparse.xml
@@ -3,10 +3,10 @@
   <description>parses au streams</description>
   <filename>../../gst/auparse/.libs/libgstauparse.so</filename>
   <basename>libgstauparse.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-autodetect.xml b/docs/plugins/inspect/plugin-autodetect.xml
index bda0f2e..ed769cf 100644
--- a/docs/plugins/inspect/plugin-autodetect.xml
+++ b/docs/plugins/inspect/plugin-autodetect.xml
@@ -3,10 +3,10 @@
   <description>Plugin contains auto-detection plugins for video/audio in- and outputs</description>
   <filename>../../gst/autodetect/.libs/libgstautodetect.so</filename>
   <basename>libgstautodetect.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-avi.xml b/docs/plugins/inspect/plugin-avi.xml
index 14128ab..ca77692 100644
--- a/docs/plugins/inspect/plugin-avi.xml
+++ b/docs/plugins/inspect/plugin-avi.xml
@@ -3,10 +3,10 @@
   <description>AVI stream handling</description>
   <filename>../../gst/avi/.libs/libgstavi.so</filename>
   <basename>libgstavi.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -38,7 +38,7 @@
           <name>video_%02d</name>
           <direction>source</direction>
           <presence>sometimes</presence>
-          <details>video/x-3ivx, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-asus, asusversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-asus, asusversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-cirrus-logic-accupak, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-camstudio, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-compressed-yuv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-rgb, bpp=(int){ 8, 24, 32 }, depth=(int){ 8, 24 }, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-truemotion, trueversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dv, systemstream=(boolean)false, dvversion=(int)25, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dv, systemstream=(boolean)false, dvversion=(int)50, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, mpegversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-flash-video, flvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6-flash, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)lucent, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-huffyuv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-intel-h263, variant=(string)intel, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)I420, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)lead, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)lead, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)microsoft, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, mpegversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; image/jpeg, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)42, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)43, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, systemstream=(boolean)false, mpegversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, systemstream=(boolean)false, mpegversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)41, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-mszh, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; image/png, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-rle, layout=(string)microsoft, depth=(int)[ 1, 64 ], framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/sp5x, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-truemotion, trueversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-camtasia, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ultimotion, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)UYVY, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ati-vcr, vcrversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ati-vcr, vcrversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)vdolive, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)vivo, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vmnc, version=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)videosoft, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-xvid, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-xan, wcversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YUY2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YVU9, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-zlib, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-cinepak, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msvideocodec, msvideoversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)xirlink, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dirac, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ffv, ffvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-kmvc, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6-flash, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp7, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp8, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-mimic, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-apple-video, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-theora, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-fraps, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-aasc, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YV12, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-loco, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-zmbv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dv, systemstream=(boolean)true; video/x-avi-unknown</details>
+          <details>video/x-3ivx, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-asus, asusversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-asus, asusversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-cirrus-logic-accupak, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-camstudio, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-compressed-yuv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-rgb, bpp=(int){ 8, 24, 32 }, depth=(int){ 8, 24 }, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-truemotion, trueversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dv, systemstream=(boolean)false, dvversion=(int)25, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dv, systemstream=(boolean)false, dvversion=(int)50, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-divx, divxversion=(int)5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, mpegversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-flash-video, flvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6-flash, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)lucent, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-huffyuv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-intel-h263, variant=(string)intel, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)I420, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)lead, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)lead, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)microsoft, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, mpegversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; image/jpeg, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)42, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)43, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, systemstream=(boolean)false, mpegversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/mpeg, systemstream=(boolean)false, mpegversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msmpeg, msmpegversion=(int)41, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-mszh, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; image/png, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-rle, layout=(string)microsoft, depth=(int)[ 1, 64 ], framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-indeo, indeoversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/sp5x, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-truemotion, trueversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-camtasia, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ultimotion, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)UYVY, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ati-vcr, vcrversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ati-vcr, vcrversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)vdolive, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)vivo, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vmnc, version=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)videosoft, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-wmv, wmvversion=(int)3, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-xvid, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-xan, wcversion=(int)4, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YUY2, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YVU9, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-zlib, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-cinepak, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h264, variant=(string)itu, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-msvideocodec, msvideoversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-h263, variant=(string)xirlink, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dirac, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-ffv, ffvversion=(int)1, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-kmvc, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp5, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp6-flash, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp7, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-vp8, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-mimic, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-apple-video, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-theora, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-fraps, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-aasc, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)YV12, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-loco, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-zmbv, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-yuv, format=(fourcc)v210, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-raw-rgb, endianness=(int)4321, depth=(int)30, bpp=(int)32, red_mask=(int)1072693248, green_mask=(int)1047552, blue_mask=(int)1023, framerate=(fraction)[ 0/1, 2147483647/1 ], width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ]; video/x-dv, systemstream=(boolean)true; video/x-avi-unknown</details>
         </caps>
       </pads>
     </element>
@@ -53,7 +53,7 @@
           <name>audio_%d</name>
           <direction>sink</direction>
           <presence>request</presence>
-          <details>audio/x-raw-int, endianness=(int)1234, signed=(boolean){ true, false }, width=(int){ 8, 16 }, depth=(int){ 8, 16 }, rate=(int)[ 1000, 96000 ], channels=(int)[ 1, 2 ]; audio/mpeg, mpegversion=(int)1, layer=(int)[ 1, 3 ], rate=(int)[ 1000, 96000 ], channels=(int)[ 1, 2 ]; audio/mpeg, mpegversion=(int)4, stream-format=(string)raw, rate=(int)[ 1000, 96000 ], channels=(int)[ 1, 2 ]; audio/x-ac3, rate=(int)[ 1000, 96000 ], channels=(int)[ 1, 2 ]; audio/x-alaw, rate=(int)[ 1000, 48000 ], channels=(int)[ 1, 2 ]; audio/x-mulaw, rate=(int)[ 1000, 48000 ], channels=(int)[ 1, 2 ]; audio/x-wma, rate=(int)[ 1000, 96000 ], channels=(int)[ 1, 2 ], wmaversion=(int)[ 1, 2 ]</details>
+          <details>audio/x-raw-int, endianness=(int)1234, signed=(boolean){ true, false }, width=(int){ 8, 16 }, depth=(int){ 8, 16 }, rate=(int)[ 1000, 96000 ], channels=(int)[ 1, 2 ]; audio/mpeg, mpegversion=(int)1, layer=(int)[ 1, 3 ], rate=(int)[ 1000, 96000 ], channels=(int)[ 1, 2 ]; audio/mpeg, mpegversion=(int)4, stream-format=(string)raw, rate=(int)[ 1000, 96000 ], channels=(int)[ 1, 2 ]; audio/x-ac3, rate=(int)[ 1000, 96000 ], channels=(int)[ 1, 6 ]; audio/x-alaw, rate=(int)[ 1000, 48000 ], channels=(int)[ 1, 2 ]; audio/x-mulaw, rate=(int)[ 1000, 48000 ], channels=(int)[ 1, 2 ]; audio/x-wma, rate=(int)[ 1000, 96000 ], channels=(int)[ 1, 2 ], wmaversion=(int)[ 1, 2 ]</details>
         </caps>
         <caps>
           <name>video_%d</name>
diff --git a/docs/plugins/inspect/plugin-cacasink.xml b/docs/plugins/inspect/plugin-cacasink.xml
index 389f32a..eb94ba0 100644
--- a/docs/plugins/inspect/plugin-cacasink.xml
+++ b/docs/plugins/inspect/plugin-cacasink.xml
@@ -3,10 +3,10 @@
   <description>Colored ASCII Art video sink</description>
   <filename>../../ext/libcaca/.libs/libgstcacasink.so</filename>
   <basename>libgstcacasink.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-cairo.xml b/docs/plugins/inspect/plugin-cairo.xml
index 1cbb913..7ef711a 100644
--- a/docs/plugins/inspect/plugin-cairo.xml
+++ b/docs/plugins/inspect/plugin-cairo.xml
@@ -3,10 +3,10 @@
   <description>Cairo-based elements</description>
   <filename>../../ext/cairo/.libs/libgstcairo.so</filename>
   <basename>libgstcairo.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-cutter.xml b/docs/plugins/inspect/plugin-cutter.xml
index 1a3dd78..6d10c0c 100644
--- a/docs/plugins/inspect/plugin-cutter.xml
+++ b/docs/plugins/inspect/plugin-cutter.xml
@@ -3,10 +3,10 @@
   <description>Audio Cutter to split audio into non-silent bits</description>
   <filename>../../gst/cutter/.libs/libgstcutter.so</filename>
   <basename>libgstcutter.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-debug.xml b/docs/plugins/inspect/plugin-debug.xml
index dedcb7e..42690e6 100644
--- a/docs/plugins/inspect/plugin-debug.xml
+++ b/docs/plugins/inspect/plugin-debug.xml
@@ -3,10 +3,10 @@
   <description>elements for testing and debugging</description>
   <filename>../../gst/debugutils/.libs/libgstdebug.so</filename>
   <basename>libgstdebug.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-deinterlace.xml b/docs/plugins/inspect/plugin-deinterlace.xml
index da67e47..ac76c14 100644
--- a/docs/plugins/inspect/plugin-deinterlace.xml
+++ b/docs/plugins/inspect/plugin-deinterlace.xml
@@ -3,10 +3,10 @@
   <description>Deinterlacer</description>
   <filename>../../gst/deinterlace/.libs/libgstdeinterlace.so</filename>
   <basename>libgstdeinterlace.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-dv.xml b/docs/plugins/inspect/plugin-dv.xml
index 27be1a9..530ed69 100644
--- a/docs/plugins/inspect/plugin-dv.xml
+++ b/docs/plugins/inspect/plugin-dv.xml
@@ -3,10 +3,10 @@
   <description>DV demuxer and decoder based on libdv (libdv.sf.net)</description>
   <filename>../../ext/dv/.libs/libgstdv.so</filename>
   <basename>libgstdv.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-efence.xml b/docs/plugins/inspect/plugin-efence.xml
index dae0fda..ecf3b31 100644
--- a/docs/plugins/inspect/plugin-efence.xml
+++ b/docs/plugins/inspect/plugin-efence.xml
@@ -3,10 +3,10 @@
   <description>This element converts a stream of normal GStreamer buffers into a stream of buffers that are allocated in such a way that out-of-bounds access to data in the buffer is more likely to cause segmentation faults.  This allocation method is very similar to the debugging tool &quot;Electric Fence&quot;.</description>
   <filename>../../gst/debugutils/.libs/libgstefence.so</filename>
   <basename>libgstefence.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-effectv.xml b/docs/plugins/inspect/plugin-effectv.xml
index 60ea0d8..4e83773 100644
--- a/docs/plugins/inspect/plugin-effectv.xml
+++ b/docs/plugins/inspect/plugin-effectv.xml
@@ -3,10 +3,10 @@
   <description>effect plugins from the effectv project</description>
   <filename>../../gst/effectv/.libs/libgsteffectv.so</filename>
   <basename>libgsteffectv.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-equalizer.xml b/docs/plugins/inspect/plugin-equalizer.xml
index fc9588c..2eab977 100644
--- a/docs/plugins/inspect/plugin-equalizer.xml
+++ b/docs/plugins/inspect/plugin-equalizer.xml
@@ -3,10 +3,10 @@
   <description>GStreamer audio equalizers</description>
   <filename>../../gst/equalizer/.libs/libgstequalizer.so</filename>
   <basename>libgstequalizer.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-esdsink.xml b/docs/plugins/inspect/plugin-esdsink.xml
index 85ec8dc..52d7cc1 100644
--- a/docs/plugins/inspect/plugin-esdsink.xml
+++ b/docs/plugins/inspect/plugin-esdsink.xml
@@ -3,10 +3,10 @@
   <description>ESD Element Plugins</description>
   <filename>../../ext/esd/.libs/libgstesd.so</filename>
   <basename>libgstesd.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-flac.xml b/docs/plugins/inspect/plugin-flac.xml
index 763eb6e..58278c1 100644
--- a/docs/plugins/inspect/plugin-flac.xml
+++ b/docs/plugins/inspect/plugin-flac.xml
@@ -3,10 +3,10 @@
   <description>The FLAC Lossless compressor Codec</description>
   <filename>../../ext/flac/.libs/libgstflac.so</filename>
   <basename>libgstflac.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-flv.xml b/docs/plugins/inspect/plugin-flv.xml
index 8ac1fe8..fe41fd2 100644
--- a/docs/plugins/inspect/plugin-flv.xml
+++ b/docs/plugins/inspect/plugin-flv.xml
@@ -3,10 +3,10 @@
   <description>FLV muxing and demuxing plugin</description>
   <filename>../../gst/flv/.libs/libgstflv.so</filename>
   <basename>libgstflv.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-flxdec.xml b/docs/plugins/inspect/plugin-flxdec.xml
index f7049cd..6e33406 100644
--- a/docs/plugins/inspect/plugin-flxdec.xml
+++ b/docs/plugins/inspect/plugin-flxdec.xml
@@ -3,10 +3,10 @@
   <description>FLC/FLI/FLX video decoder</description>
   <filename>../../gst/flx/.libs/libgstflxdec.so</filename>
   <basename>libgstflxdec.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-gconfelements.xml b/docs/plugins/inspect/plugin-gconfelements.xml
index e451ebc..66a8943 100644
--- a/docs/plugins/inspect/plugin-gconfelements.xml
+++ b/docs/plugins/inspect/plugin-gconfelements.xml
@@ -3,10 +3,10 @@
   <description>elements wrapping the GStreamer/GConf audio/video output settings</description>
   <filename>../../ext/gconf/.libs/libgstgconfelements.so</filename>
   <basename>libgstgconfelements.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-gdkpixbuf.xml b/docs/plugins/inspect/plugin-gdkpixbuf.xml
index 23e32c3..d8f54a1 100644
--- a/docs/plugins/inspect/plugin-gdkpixbuf.xml
+++ b/docs/plugins/inspect/plugin-gdkpixbuf.xml
@@ -3,10 +3,10 @@
   <description>GdkPixbuf-based image decoder, scaler and sink</description>
   <filename>../../ext/gdk_pixbuf/.libs/libgstgdkpixbuf.so</filename>
   <basename>libgstgdkpixbuf.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -31,6 +31,27 @@
       </pads>
     </element>
     <element>
+      <name>gdkpixbufoverlay</name>
+      <longname>GdkPixbuf Overlay</longname>
+      <class>Filter/Effect/Video</class>
+      <description>Overlay an image onto a video stream</description>
+      <author>Tim-Philipp Müller &lt;tim centricular net&gt;</author>
+      <pads>
+        <caps>
+          <name>sink</name>
+          <direction>sink</direction>
+          <presence>always</presence>
+          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, alpha_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, alpha_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, alpha_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc){ I420, YV12, AYUV, YUY2, UYVY, v308, v210, v216, Y41B, Y42B, Y444, Y800, Y16 , NV12, NV21, UYVP, A420, YUV9, IYU1 }, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
+        </caps>
+        <caps>
+          <name>src</name>
+          <direction>source</direction>
+          <presence>always</presence>
+          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, alpha_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, alpha_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)255, green_mask=(int)65280, blue_mask=(int)16711680, alpha_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc){ I420, YV12, AYUV, YUY2, UYVY, v308, v210, v216, Y41B, Y42B, Y444, Y800, Y16 , NV12, NV21, UYVP, A420, YUV9, IYU1 }, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
+        </caps>
+      </pads>
+    </element>
+    <element>
       <name>gdkpixbufscale</name>
       <longname>GdkPixbuf image scaler</longname>
       <class>Filter/Effect/Video</class>
diff --git a/docs/plugins/inspect/plugin-goom.xml b/docs/plugins/inspect/plugin-goom.xml
index 7d4ad4b..fa59308 100644
--- a/docs/plugins/inspect/plugin-goom.xml
+++ b/docs/plugins/inspect/plugin-goom.xml
@@ -3,10 +3,10 @@
   <description>GOOM visualization filter</description>
   <filename>../../gst/goom/.libs/libgstgoom.so</filename>
   <basename>libgstgoom.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-goom2k1.xml b/docs/plugins/inspect/plugin-goom2k1.xml
index 4f57b00..04befbe 100644
--- a/docs/plugins/inspect/plugin-goom2k1.xml
+++ b/docs/plugins/inspect/plugin-goom2k1.xml
@@ -3,10 +3,10 @@
   <description>GOOM 2k1 visualization filter</description>
   <filename>../../gst/goom2k1/.libs/libgstgoom2k1.so</filename>
   <basename>libgstgoom2k1.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-gstrtpmanager.xml b/docs/plugins/inspect/plugin-gstrtpmanager.xml
index 1d4ecab..c0e12d3 100644
--- a/docs/plugins/inspect/plugin-gstrtpmanager.xml
+++ b/docs/plugins/inspect/plugin-gstrtpmanager.xml
@@ -3,10 +3,10 @@
   <description>RTP session management plugin library</description>
   <filename>../../gst/rtpmanager/.libs/libgstrtpmanager.so</filename>
   <basename>libgstrtpmanager.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-halelements.xml b/docs/plugins/inspect/plugin-halelements.xml
index 70e9892..e0ce5db 100644
--- a/docs/plugins/inspect/plugin-halelements.xml
+++ b/docs/plugins/inspect/plugin-halelements.xml
@@ -3,10 +3,10 @@
   <description>elements wrapping the GStreamer/HAL audio input/output devices</description>
   <filename>../../ext/hal/.libs/libgsthalelements.so</filename>
   <basename>libgsthalelements.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-icydemux.xml b/docs/plugins/inspect/plugin-icydemux.xml
index 612b740..f8fe0d3 100644
--- a/docs/plugins/inspect/plugin-icydemux.xml
+++ b/docs/plugins/inspect/plugin-icydemux.xml
@@ -3,10 +3,10 @@
   <description>Demux ICY tags from a stream</description>
   <filename>../../gst/icydemux/.libs/libgsticydemux.so</filename>
   <basename>libgsticydemux.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-id3demux.xml b/docs/plugins/inspect/plugin-id3demux.xml
index 78d85c6..414ccc6 100644
--- a/docs/plugins/inspect/plugin-id3demux.xml
+++ b/docs/plugins/inspect/plugin-id3demux.xml
@@ -3,10 +3,10 @@
   <description>Demux ID3v1 and ID3v2 tags from a file</description>
   <filename>../../gst/id3demux/.libs/libgstid3demux.so</filename>
   <basename>libgstid3demux.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-imagefreeze.xml b/docs/plugins/inspect/plugin-imagefreeze.xml
index d63157f..2d54160 100644
--- a/docs/plugins/inspect/plugin-imagefreeze.xml
+++ b/docs/plugins/inspect/plugin-imagefreeze.xml
@@ -3,10 +3,10 @@
   <description>Still frame stream generator</description>
   <filename>../../gst/imagefreeze/.libs/libgstimagefreeze.so</filename>
   <basename>libgstimagefreeze.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-interleave.xml b/docs/plugins/inspect/plugin-interleave.xml
index cacd3bc..b1c80e5 100644
--- a/docs/plugins/inspect/plugin-interleave.xml
+++ b/docs/plugins/inspect/plugin-interleave.xml
@@ -3,10 +3,10 @@
   <description>Audio interleaver/deinterleaver</description>
   <filename>../../gst/interleave/.libs/libgstinterleave.so</filename>
   <basename>libgstinterleave.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-isomp4.xml b/docs/plugins/inspect/plugin-isomp4.xml
index f71d1f9..1cbde32 100644
--- a/docs/plugins/inspect/plugin-isomp4.xml
+++ b/docs/plugins/inspect/plugin-isomp4.xml
@@ -3,10 +3,10 @@
   <description>ISO base media file format support (mp4, 3gpp, qt, mj2)</description>
   <filename>../../gst/isomp4/.libs/libgstisomp4.so</filename>
   <basename>libgstisomp4.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-jack.xml b/docs/plugins/inspect/plugin-jack.xml
index c297205..891333f 100644
--- a/docs/plugins/inspect/plugin-jack.xml
+++ b/docs/plugins/inspect/plugin-jack.xml
@@ -3,10 +3,10 @@
   <description>JACK audio elements</description>
   <filename>../../ext/jack/.libs/libgstjack.so</filename>
   <basename>libgstjack.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-jpeg.xml b/docs/plugins/inspect/plugin-jpeg.xml
index a742e2d..b2266b3 100644
--- a/docs/plugins/inspect/plugin-jpeg.xml
+++ b/docs/plugins/inspect/plugin-jpeg.xml
@@ -3,10 +3,10 @@
   <description>JPeg plugin library</description>
   <filename>../../ext/jpeg/.libs/libgstjpeg.so</filename>
   <basename>libgstjpeg.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-level.xml b/docs/plugins/inspect/plugin-level.xml
index a7a2a30..3b3e700 100644
--- a/docs/plugins/inspect/plugin-level.xml
+++ b/docs/plugins/inspect/plugin-level.xml
@@ -3,10 +3,10 @@
   <description>Audio level plugin</description>
   <filename>../../gst/level/.libs/libgstlevel.so</filename>
   <basename>libgstlevel.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-matroska.xml b/docs/plugins/inspect/plugin-matroska.xml
index 749a802..aed890c 100644
--- a/docs/plugins/inspect/plugin-matroska.xml
+++ b/docs/plugins/inspect/plugin-matroska.xml
@@ -3,10 +3,10 @@
   <description>Matroska and WebM stream handling</description>
   <filename>../../gst/matroska/.libs/libgstmatroska.so</filename>
   <basename>libgstmatroska.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -59,7 +59,7 @@
           <name>subtitle_%d</name>
           <direction>sink</direction>
           <presence>request</presence>
-          <details>subtitle/x-kate</details>
+          <details>subtitle/x-kate; text/plain; application/x-ssa; application/x-ass; application/x-usf; video/x-dvd-subpicture; application/x-subtitle-unknown</details>
         </caps>
         <caps>
           <name>video_%d</name>
diff --git a/docs/plugins/inspect/plugin-mulaw.xml b/docs/plugins/inspect/plugin-mulaw.xml
index 9329eaf..14d06f4 100644
--- a/docs/plugins/inspect/plugin-mulaw.xml
+++ b/docs/plugins/inspect/plugin-mulaw.xml
@@ -3,10 +3,10 @@
   <description>MuLaw audio conversion routines</description>
   <filename>../../gst/law/.libs/libgstmulaw.so</filename>
   <basename>libgstmulaw.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-multifile.xml b/docs/plugins/inspect/plugin-multifile.xml
index 669bed4..e467370 100644
--- a/docs/plugins/inspect/plugin-multifile.xml
+++ b/docs/plugins/inspect/plugin-multifile.xml
@@ -3,10 +3,10 @@
   <description>Reads/Writes buffers from/to sequentially named files</description>
   <filename>../../gst/multifile/.libs/libgstmultifile.so</filename>
   <basename>libgstmultifile.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-multipart.xml b/docs/plugins/inspect/plugin-multipart.xml
index ccbdb8e..03e3752 100644
--- a/docs/plugins/inspect/plugin-multipart.xml
+++ b/docs/plugins/inspect/plugin-multipart.xml
@@ -3,10 +3,10 @@
   <description>multipart stream manipulation</description>
   <filename>../../gst/multipart/.libs/libgstmultipart.so</filename>
   <basename>libgstmultipart.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-navigationtest.xml b/docs/plugins/inspect/plugin-navigationtest.xml
index d65edab..7ee88d4 100644
--- a/docs/plugins/inspect/plugin-navigationtest.xml
+++ b/docs/plugins/inspect/plugin-navigationtest.xml
@@ -3,10 +3,10 @@
   <description>Template for a video filter</description>
   <filename>../../gst/debugutils/.libs/libgstnavigationtest.so</filename>
   <basename>libgstnavigationtest.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-oss4.xml b/docs/plugins/inspect/plugin-oss4.xml
index f6f6384..18a7c89 100644
--- a/docs/plugins/inspect/plugin-oss4.xml
+++ b/docs/plugins/inspect/plugin-oss4.xml
@@ -3,10 +3,10 @@
   <description>Open Sound System (OSS) version 4 support for GStreamer</description>
   <filename>../../sys/oss4/.libs/libgstoss4audio.so</filename>
   <basename>libgstoss4audio.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-ossaudio.xml b/docs/plugins/inspect/plugin-ossaudio.xml
index e05e651..693eded 100644
--- a/docs/plugins/inspect/plugin-ossaudio.xml
+++ b/docs/plugins/inspect/plugin-ossaudio.xml
@@ -3,10 +3,10 @@
   <description>OSS (Open Sound System) support for GStreamer</description>
   <filename>../../sys/oss/.libs/libgstossaudio.so</filename>
   <basename>libgstossaudio.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-png.xml b/docs/plugins/inspect/plugin-png.xml
index 2209b12..704817d 100644
--- a/docs/plugins/inspect/plugin-png.xml
+++ b/docs/plugins/inspect/plugin-png.xml
@@ -3,10 +3,10 @@
   <description>PNG plugin library</description>
   <filename>../../ext/libpng/.libs/libgstpng.so</filename>
   <basename>libgstpng.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -26,7 +26,7 @@
           <name>src</name>
           <direction>source</direction>
           <presence>always</presence>
-          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, alpha_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)64, depth=(int)64, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
+          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, alpha_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)64, depth=(int)64, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)8, depth=(int)8, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)16, depth=(int)16, endianness=(int)4321, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
         </caps>
       </pads>
     </element>
@@ -41,7 +41,7 @@
           <name>sink</name>
           <direction>sink</direction>
           <presence>always</presence>
-          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, alpha_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)8, depth=(int)8, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
+          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)-16777216, green_mask=(int)16711680, blue_mask=(int)65280, alpha_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)24, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)8, depth=(int)8, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-gray, bpp=(int)16, depth=(int)16, endianness=(int)4321, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
         </caps>
         <caps>
           <name>src</name>
diff --git a/docs/plugins/inspect/plugin-pulseaudio.xml b/docs/plugins/inspect/plugin-pulseaudio.xml
index 8d51d9f..628120d 100644
--- a/docs/plugins/inspect/plugin-pulseaudio.xml
+++ b/docs/plugins/inspect/plugin-pulseaudio.xml
@@ -3,10 +3,10 @@
   <description>PulseAudio plugin library</description>
   <filename>../../ext/pulse/.libs/libgstpulse.so</filename>
   <basename>libgstpulse.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-replaygain.xml b/docs/plugins/inspect/plugin-replaygain.xml
index 240e806..1dd437b 100644
--- a/docs/plugins/inspect/plugin-replaygain.xml
+++ b/docs/plugins/inspect/plugin-replaygain.xml
@@ -3,10 +3,10 @@
   <description>ReplayGain volume normalization</description>
   <filename>../../gst/replaygain/.libs/libgstreplaygain.so</filename>
   <basename>libgstreplaygain.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-rtp.xml b/docs/plugins/inspect/plugin-rtp.xml
index 1277495..d90871a 100644
--- a/docs/plugins/inspect/plugin-rtp.xml
+++ b/docs/plugins/inspect/plugin-rtp.xml
@@ -3,10 +3,10 @@
   <description>Real-time protocol plugins</description>
   <filename>../../gst/rtp/.libs/libgstrtp.so</filename>
   <basename>libgstrtp.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -668,7 +668,7 @@
           <name>src</name>
           <direction>source</direction>
           <presence>always</presence>
-          <details>video/x-h264</details>
+          <details>video/x-h264, stream-format=(string)avc, alignment=(string)au; video/x-h264, stream-format=(string)byte-stream, alignment=(string){ nal, au }</details>
         </caps>
       </pads>
     </element>
@@ -683,7 +683,7 @@
           <name>sink</name>
           <direction>sink</direction>
           <presence>always</presence>
-          <details>video/x-h264</details>
+          <details>video/x-h264, stream-format=(string)byte-stream, alignment=(string){ nal, au }; video/x-h264, stream-format=(string)avc, alignment=(string)au</details>
         </caps>
         <caps>
           <name>src</name>
diff --git a/docs/plugins/inspect/plugin-rtsp.xml b/docs/plugins/inspect/plugin-rtsp.xml
index da53f3e..94785e5 100644
--- a/docs/plugins/inspect/plugin-rtsp.xml
+++ b/docs/plugins/inspect/plugin-rtsp.xml
@@ -3,10 +3,10 @@
   <description>transfer data via RTSP</description>
   <filename>../../gst/rtsp/.libs/libgstrtsp.so</filename>
   <basename>libgstrtsp.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-shapewipe.xml b/docs/plugins/inspect/plugin-shapewipe.xml
index 4ddc5c7..193d703 100644
--- a/docs/plugins/inspect/plugin-shapewipe.xml
+++ b/docs/plugins/inspect/plugin-shapewipe.xml
@@ -3,10 +3,10 @@
   <description>Shape Wipe transition filter</description>
   <filename>../../gst/shapewipe/.libs/libgstshapewipe.so</filename>
   <basename>libgstshapewipe.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-shout2send.xml b/docs/plugins/inspect/plugin-shout2send.xml
index 24eb4a7..9f8c7ec 100644
--- a/docs/plugins/inspect/plugin-shout2send.xml
+++ b/docs/plugins/inspect/plugin-shout2send.xml
@@ -3,7 +3,7 @@
   <description>Sends data to an icecast server using libshout2</description>
   <filename>../../ext/shout2/.libs/libgstshout2.so</filename>
   <basename>libgstshout2.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
   <package>libshout2</package>
diff --git a/docs/plugins/inspect/plugin-smpte.xml b/docs/plugins/inspect/plugin-smpte.xml
index 7283bc7..d9818ea 100644
--- a/docs/plugins/inspect/plugin-smpte.xml
+++ b/docs/plugins/inspect/plugin-smpte.xml
@@ -3,10 +3,10 @@
   <description>Apply the standard SMPTE transitions on video images</description>
   <filename>../../gst/smpte/.libs/libgstsmpte.so</filename>
   <basename>libgstsmpte.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-soup.xml b/docs/plugins/inspect/plugin-soup.xml
index f3707ba..5e6622d 100644
--- a/docs/plugins/inspect/plugin-soup.xml
+++ b/docs/plugins/inspect/plugin-soup.xml
@@ -3,10 +3,10 @@
   <description>libsoup HTTP client src/sink</description>
   <filename>../../ext/soup/.libs/libgstsouphttpsrc.so</filename>
   <basename>libgstsouphttpsrc.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-spectrum.xml b/docs/plugins/inspect/plugin-spectrum.xml
index ac9f023..7c66e45 100644
--- a/docs/plugins/inspect/plugin-spectrum.xml
+++ b/docs/plugins/inspect/plugin-spectrum.xml
@@ -3,10 +3,10 @@
   <description>Run an FFT on the audio signal, output spectrum data</description>
   <filename>../../gst/spectrum/.libs/libgstspectrum.so</filename>
   <basename>libgstspectrum.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-speex.xml b/docs/plugins/inspect/plugin-speex.xml
index fdcc94b..bea4630 100644
--- a/docs/plugins/inspect/plugin-speex.xml
+++ b/docs/plugins/inspect/plugin-speex.xml
@@ -3,10 +3,10 @@
   <description>Speex plugin library</description>
   <filename>../../ext/speex/.libs/libgstspeex.so</filename>
   <basename>libgstspeex.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-taglib.xml b/docs/plugins/inspect/plugin-taglib.xml
index d7d404f..7638b10 100644
--- a/docs/plugins/inspect/plugin-taglib.xml
+++ b/docs/plugins/inspect/plugin-taglib.xml
@@ -3,10 +3,10 @@
   <description>Tag writing plug-in based on taglib</description>
   <filename>../../ext/taglib/.libs/libgsttaglib.so</filename>
   <basename>libgsttaglib.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-udp.xml b/docs/plugins/inspect/plugin-udp.xml
index 2cca70b..128697d 100644
--- a/docs/plugins/inspect/plugin-udp.xml
+++ b/docs/plugins/inspect/plugin-udp.xml
@@ -3,10 +3,10 @@
   <description>transfer data via UDP</description>
   <filename>../../gst/udp/.libs/libgstudp.so</filename>
   <basename>libgstudp.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-video4linux2.xml b/docs/plugins/inspect/plugin-video4linux2.xml
index 5ed6afa..aca1e5f 100644
--- a/docs/plugins/inspect/plugin-video4linux2.xml
+++ b/docs/plugins/inspect/plugin-video4linux2.xml
@@ -3,10 +3,10 @@
   <description>elements for Video 4 Linux</description>
   <filename>../../sys/v4l2/.libs/libgstvideo4linux2.so</filename>
   <basename>libgstvideo4linux2.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-videobox.xml b/docs/plugins/inspect/plugin-videobox.xml
index 37956b0..2c87de0 100644
--- a/docs/plugins/inspect/plugin-videobox.xml
+++ b/docs/plugins/inspect/plugin-videobox.xml
@@ -3,10 +3,10 @@
   <description>resizes a video by adding borders or cropping</description>
   <filename>../../gst/videobox/.libs/libgstvideobox.so</filename>
   <basename>libgstvideobox.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-videocrop.xml b/docs/plugins/inspect/plugin-videocrop.xml
index 795baff..1e0be6b 100644
--- a/docs/plugins/inspect/plugin-videocrop.xml
+++ b/docs/plugins/inspect/plugin-videocrop.xml
@@ -3,10 +3,10 @@
   <description>Crops video into a user-defined region</description>
   <filename>../../gst/videocrop/.libs/libgstvideocrop.so</filename>
   <basename>libgstvideocrop.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-videofilter.xml b/docs/plugins/inspect/plugin-videofilter.xml
index 967f386..58483fb 100644
--- a/docs/plugins/inspect/plugin-videofilter.xml
+++ b/docs/plugins/inspect/plugin-videofilter.xml
@@ -3,10 +3,10 @@
   <description>Video filters plugin</description>
   <filename>../../gst/videofilter/.libs/libgstvideofilter.so</filename>
   <basename>libgstvideofilter.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-videomixer.xml b/docs/plugins/inspect/plugin-videomixer.xml
index 664e5b7..3fda471 100644
--- a/docs/plugins/inspect/plugin-videomixer.xml
+++ b/docs/plugins/inspect/plugin-videomixer.xml
@@ -3,10 +3,10 @@
   <description>Video mixer</description>
   <filename>../../gst/videomixer/.libs/libgstvideomixer.so</filename>
   <basename>libgstvideomixer.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-wavenc.xml b/docs/plugins/inspect/plugin-wavenc.xml
index f384207..5cf8ebc 100644
--- a/docs/plugins/inspect/plugin-wavenc.xml
+++ b/docs/plugins/inspect/plugin-wavenc.xml
@@ -3,10 +3,10 @@
   <description>Encode raw audio into WAV</description>
   <filename>../../gst/wavenc/.libs/libgstwavenc.so</filename>
   <basename>libgstwavenc.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-wavpack.xml b/docs/plugins/inspect/plugin-wavpack.xml
index 79e820d..0d01ce7 100644
--- a/docs/plugins/inspect/plugin-wavpack.xml
+++ b/docs/plugins/inspect/plugin-wavpack.xml
@@ -3,10 +3,10 @@
   <description>Wavpack lossless/lossy audio format handling</description>
   <filename>../../ext/wavpack/.libs/libgstwavpack.so</filename>
   <basename>libgstwavpack.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -26,7 +26,7 @@
           <name>src</name>
           <direction>source</direction>
           <presence>always</presence>
-          <details>audio/x-raw-int, width=(int)32, depth=(int)[ 1, 32 ], channels=(int)[ 1, 8 ], rate=(int)[ 6000, 192000 ], endianness=(int)1234, signed=(boolean)true</details>
+          <details>audio/x-raw-int, width=(int)8, depth=(int)8, channels=(int)[ 1, 8 ], rate=(int)[ 6000, 192000 ], endianness=(int)1234, signed=(boolean)true; audio/x-raw-int, width=(int)16, depth=(int)16, channels=(int)[ 1, 8 ], rate=(int)[ 6000, 192000 ], endianness=(int)1234, signed=(boolean)true; audio/x-raw-int, width=(int)32, depth=(int)32, channels=(int)[ 1, 8 ], rate=(int)[ 6000, 192000 ], endianness=(int)1234, signed=(boolean)true</details>
         </caps>
       </pads>
     </element>
@@ -41,13 +41,13 @@
           <name>sink</name>
           <direction>sink</direction>
           <presence>always</presence>
-          <details>audio/x-raw-int, width=(int)32, depth=(int)[ 1, 32 ], endianness=(int)1234, channels=(int)[ 1, 8 ], rate=(int)[ 6000, 192000 ], signed=(boolean)true</details>
+          <details>audio/x-raw-int, width=(int)32, depth=(int){ 24, 32 }, endianness=(int)1234, channels=(int)[ 1, 8 ], rate=(int)[ 6000, 192000 ], signed=(boolean)true</details>
         </caps>
         <caps>
           <name>src</name>
           <direction>source</direction>
           <presence>always</presence>
-          <details>audio/x-wavpack, width=(int)[ 1, 32 ], channels=(int)[ 1, 2 ], rate=(int)[ 6000, 192000 ], framed=(boolean)true</details>
+          <details>audio/x-wavpack, width=(int)[ 1, 32 ], channels=(int)[ 1, 8 ], rate=(int)[ 6000, 192000 ], framed=(boolean)true</details>
         </caps>
         <caps>
           <name>wvcsrc</name>
diff --git a/docs/plugins/inspect/plugin-wavparse.xml b/docs/plugins/inspect/plugin-wavparse.xml
index 56039a1..7f8ef48 100644
--- a/docs/plugins/inspect/plugin-wavparse.xml
+++ b/docs/plugins/inspect/plugin-wavparse.xml
@@ -3,10 +3,10 @@
   <description>Parse a .wav file into raw audio</description>
   <filename>../../gst/wavparse/.libs/libgstwavparse.so</filename>
   <basename>libgstwavparse.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-ximagesrc.xml b/docs/plugins/inspect/plugin-ximagesrc.xml
index 4463b48..9ce8fd0 100644
--- a/docs/plugins/inspect/plugin-ximagesrc.xml
+++ b/docs/plugins/inspect/plugin-ximagesrc.xml
@@ -3,10 +3,10 @@
   <description>X11 video input plugin using standard Xlib calls</description>
   <filename>../../sys/ximage/.libs/libgstximagesrc.so</filename>
   <basename>libgstximagesrc.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-y4menc.xml b/docs/plugins/inspect/plugin-y4menc.xml
index dc2b7d9..b454642 100644
--- a/docs/plugins/inspect/plugin-y4menc.xml
+++ b/docs/plugins/inspect/plugin-y4menc.xml
@@ -3,10 +3,10 @@
   <description>Encodes a YUV frame into the yuv4mpeg format (mjpegtools)</description>
   <filename>../../gst/y4m/.libs/libgsty4menc.so</filename>
   <basename>libgsty4menc.so</basename>
-  <version>0.10.31</version>
+  <version>0.10.31.1</version>
   <license>LGPL</license>
   <source>gst-plugins-good</source>
-  <package>GStreamer Good Plug-ins source release</package>
+  <package>GStreamer Good Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/ext/annodex/gstannodex.c b/ext/annodex/gstannodex.c
index 05e10c8..72ea88d 100644
--- a/ext/annodex/gstannodex.c
+++ b/ext/annodex/gstannodex.c
@@ -21,6 +21,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/ext/annodex/gstcmmlparser.c b/ext/annodex/gstcmmlparser.c
index 0e2f7cd..b76cf4a 100644
--- a/ext/annodex/gstcmmlparser.c
+++ b/ext/annodex/gstcmmlparser.c
@@ -21,6 +21,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 #include <stdarg.h>
 #include <gst/gst.h>
diff --git a/ext/annodex/gstcmmltag.c b/ext/annodex/gstcmmltag.c
index 2cf5d5f..8b2a189 100644
--- a/ext/annodex/gstcmmltag.c
+++ b/ext/annodex/gstcmmltag.c
@@ -21,6 +21,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/ext/cairo/gsttextoverlay.c b/ext/cairo/gsttextoverlay.c
index 8cb39cc..f8da308 100644
--- a/ext/cairo/gsttextoverlay.c
+++ b/ext/cairo/gsttextoverlay.c
@@ -106,7 +106,7 @@ static gboolean gst_text_overlay_setcaps (GstPad * pad, GstCaps * caps);
 static GstPadLinkReturn gst_text_overlay_text_pad_linked (GstPad * pad,
     GstPad * peer);
 static void gst_text_overlay_text_pad_unlinked (GstPad * pad);
-static GstFlowReturn gst_text_overlay_collected (GstCollectPads * pads,
+static GstFlowReturn gst_text_overlay_collected (GstCollectPads2 * pads,
     gpointer data);
 static void gst_text_overlay_finalize (GObject * object);
 static void gst_text_overlay_font_init (GstCairoTextOverlay * overlay);
@@ -215,7 +215,7 @@ gst_text_overlay_finalize (GObject * object)
 {
   GstCairoTextOverlay *overlay = GST_CAIRO_TEXT_OVERLAY (object);
 
-  gst_collect_pads_stop (overlay->collect);
+  gst_collect_pads2_stop (overlay->collect);
   gst_object_unref (overlay->collect);
 
   g_free (overlay->text_fill_image);
@@ -279,16 +279,16 @@ gst_text_overlay_init (GstCairoTextOverlay * overlay,
   overlay->fps_n = 0;
   overlay->fps_d = 1;
 
-  overlay->collect = gst_collect_pads_new ();
+  overlay->collect = gst_collect_pads2_new ();
 
-  gst_collect_pads_set_function (overlay->collect,
+  gst_collect_pads2_set_function (overlay->collect,
       GST_DEBUG_FUNCPTR (gst_text_overlay_collected), overlay);
 
-  overlay->video_collect_data = gst_collect_pads_add_pad (overlay->collect,
-      overlay->video_sinkpad, sizeof (GstCollectData));
+  overlay->video_collect_data = gst_collect_pads2_add_pad (overlay->collect,
+      overlay->video_sinkpad, sizeof (GstCollectData2));
 
   /* FIXME: hacked way to override/extend the event function of
-   * GstCollectPads; because it sets its own event function giving the
+   * GstCollectPads2; because it sets its own event function giving the
    * element no access to events. Nicked from avimux. */
   overlay->collect_event =
       (GstPadEventFunction) GST_PAD_EVENTFUNC (overlay->video_sinkpad);
@@ -640,8 +640,8 @@ gst_text_overlay_text_pad_linked (GstPad * pad, GstPad * peer)
   GST_DEBUG_OBJECT (overlay, "Text pad linked");
 
   if (overlay->text_collect_data == NULL) {
-    overlay->text_collect_data = gst_collect_pads_add_pad (overlay->collect,
-        overlay->text_sinkpad, sizeof (GstCollectData));
+    overlay->text_collect_data = gst_collect_pads2_add_pad (overlay->collect,
+        overlay->text_sinkpad, sizeof (GstCollectData2));
   }
 
   overlay->need_render = TRUE;
@@ -660,7 +660,7 @@ gst_text_overlay_text_pad_unlinked (GstPad * pad)
   GST_DEBUG_OBJECT (overlay, "Text pad unlinked");
 
   if (overlay->text_collect_data) {
-    gst_collect_pads_remove_pad (overlay->collect, overlay->text_sinkpad);
+    gst_collect_pads2_remove_pad (overlay->collect, overlay->text_sinkpad);
     overlay->text_collect_data = NULL;
   }
 
@@ -807,7 +807,7 @@ gst_text_overlay_pop_video (GstCairoTextOverlay * overlay)
 {
   GstBuffer *buf;
 
-  buf = gst_collect_pads_pop (overlay->collect, overlay->video_collect_data);
+  buf = gst_collect_pads2_pop (overlay->collect, overlay->video_collect_data);
   g_return_if_fail (buf != NULL);
   gst_buffer_unref (buf);
 }
@@ -818,7 +818,7 @@ gst_text_overlay_pop_text (GstCairoTextOverlay * overlay)
   GstBuffer *buf;
 
   if (overlay->text_collect_data) {
-    buf = gst_collect_pads_pop (overlay->collect, overlay->text_collect_data);
+    buf = gst_collect_pads2_pop (overlay->collect, overlay->text_collect_data);
     g_return_if_fail (buf != NULL);
     gst_buffer_unref (buf);
   }
@@ -828,7 +828,7 @@ gst_text_overlay_pop_text (GstCairoTextOverlay * overlay)
 
 /* This function is called when there is data on all pads */
 static GstFlowReturn
-gst_text_overlay_collected (GstCollectPads * pads, gpointer data)
+gst_text_overlay_collected (GstCollectPads2 * pads, gpointer data)
 {
   GstCairoTextOverlay *overlay;
   GstFlowReturn ret = GST_FLOW_OK;
@@ -842,14 +842,14 @@ gst_text_overlay_collected (GstCollectPads * pads, gpointer data)
 
   GST_DEBUG ("Collecting");
 
-  video_frame = gst_collect_pads_peek (overlay->collect,
+  video_frame = gst_collect_pads2_peek (overlay->collect,
       overlay->video_collect_data);
 
   /* send EOS if video stream EOSed regardless of text stream */
   if (video_frame == NULL) {
     GST_DEBUG ("Video stream at EOS");
     if (overlay->text_collect_data) {
-      text_buf = gst_collect_pads_pop (overlay->collect,
+      text_buf = gst_collect_pads2_pop (overlay->collect,
           overlay->text_collect_data);
     }
     gst_pad_push_event (overlay->srcpad, gst_event_new_eos ());
@@ -892,7 +892,7 @@ gst_text_overlay_collected (GstCollectPads * pads, gpointer data)
     goto done;
   }
 
-  text_buf = gst_collect_pads_peek (overlay->collect,
+  text_buf = gst_collect_pads2_peek (overlay->collect,
       overlay->text_collect_data);
 
   /* just push the video frame if the text stream has EOSed */
@@ -1004,7 +1004,7 @@ gst_text_overlay_video_event (GstPad * pad, GstEvent * event)
     gst_pad_push_event (overlay->srcpad, event);
   }
 
-  /* now GstCollectPads can take care of the rest, e.g. EOS */
+  /* now GstCollectPads2 can take care of the rest, e.g. EOS */
   ret = overlay->collect_event (pad, event);
   gst_object_unref (overlay);
   return ret;
@@ -1018,12 +1018,12 @@ gst_text_overlay_change_state (GstElement * element, GstStateChange transition)
 
   switch (transition) {
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (overlay->collect);
+      gst_collect_pads2_start (overlay->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
       /* need to unblock the collectpads before calling the
        * parent change_state so that streaming can finish */
-      gst_collect_pads_stop (overlay->collect);
+      gst_collect_pads2_stop (overlay->collect);
       break;
     default:
       break;
diff --git a/ext/cairo/gsttextoverlay.h b/ext/cairo/gsttextoverlay.h
index dbb2154..1f98d3d 100644
--- a/ext/cairo/gsttextoverlay.h
+++ b/ext/cairo/gsttextoverlay.h
@@ -3,7 +3,7 @@
 #define __GST_CAIRO_TEXT_OVERLAY_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 G_BEGIN_DECLS
 
@@ -45,9 +45,9 @@ struct _GstCairoTextOverlay {
     GstPad               *text_sinkpad;
     GstPad               *srcpad;
 
-    GstCollectPads       *collect;
-    GstCollectData       *video_collect_data;
-    GstCollectData       *text_collect_data;
+    GstCollectPads2      *collect;
+    GstCollectData2      *video_collect_data;
+    GstCollectData2      *text_collect_data;
     GstPadEventFunction   collect_event;
 
     gint                  width;
diff --git a/ext/flac/gstflacdec.c b/ext/flac/gstflacdec.c
index 10f8916..19a866c 100644
--- a/ext/flac/gstflacdec.c
+++ b/ext/flac/gstflacdec.c
@@ -542,6 +542,26 @@ gst_flac_dec_scan_for_last_block (GstFlacDec * flacdec, gint64 * samples)
   }
 }
 
+static gboolean
+gst_flac_dec_handle_decoder_error (GstFlacDec * dec, gboolean msg)
+{
+  gboolean ret;
+
+  dec->error_count++;
+  if (dec->error_count > 10) {
+    if (msg)
+      GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL), (NULL));
+    dec->last_flow = GST_FLOW_ERROR;
+    ret = TRUE;
+  } else {
+    GST_DEBUG_OBJECT (dec, "ignoring error for now at count %d",
+        dec->error_count);
+    ret = FALSE;
+  }
+
+  return ret;
+}
+
 static void
 gst_flac_extract_picture_buffer (GstFlacDec * dec,
     const FLAC__StreamMetadata * metadata)
@@ -672,8 +692,8 @@ gst_flac_dec_error_cb (const FLAC__StreamDecoder * d,
       break;
   }
 
-  GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL), ("%s (%d)", error, status));
-  dec->last_flow = GST_FLOW_ERROR;
+  if (gst_flac_dec_handle_decoder_error (dec, FALSE))
+    GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL), ("%s (%d)", error, status));
 }
 
 static FLAC__StreamDecoderSeekStatus
@@ -1023,6 +1043,9 @@ gst_flac_dec_write (GstFlacDec * flacdec, const FLAC__Frame * frame,
     g_assert_not_reached ();
   }
 
+  if (flacdec->error_count)
+    flacdec->error_count--;
+
   if (!flacdec->seeking) {
     GST_DEBUG_OBJECT (flacdec, "pushing %d samples at offset %" G_GINT64_FORMAT
         " (%" GST_TIME_FORMAT " + %" GST_TIME_FORMAT ")",
@@ -1503,6 +1526,15 @@ gst_flac_dec_chain (GstPad * pad, GstBuffer * buf)
     if (!FLAC__stream_decoder_process_single (dec->decoder)) {
       GST_DEBUG_OBJECT (dec, "process_single failed");
     }
+
+    if (FLAC__stream_decoder_get_state (dec->decoder) ==
+        FLAC__STREAM_DECODER_ABORTED) {
+      GST_WARNING_OBJECT (dec, "Read callback caused internal abort");
+      /* allow recovery */
+      gst_adapter_clear (dec->adapter);
+      FLAC__stream_decoder_flush (dec->decoder);
+      gst_flac_dec_handle_decoder_error (dec, TRUE);
+    }
   } else {
     GST_DEBUG_OBJECT (dec, "don't have all headers yet");
   }
@@ -2154,6 +2186,7 @@ gst_flac_dec_change_state (GstElement * element, GstStateChange transition)
       flacdec->width = 0;
       flacdec->sample_rate = 0;
       gst_segment_init (&flacdec->segment, GST_FORMAT_DEFAULT);
+      flacdec->error_count = 0;
       break;
     default:
       break;
diff --git a/ext/flac/gstflacdec.h b/ext/flac/gstflacdec.h
index 835bdbd..f3882a2 100644
--- a/ext/flac/gstflacdec.h
+++ b/ext/flac/gstflacdec.h
@@ -88,6 +88,8 @@ struct _GstFlacDec {
   guint16        max_blocksize;
 
   gint64         cur_granulepos; /* only used in framed mode (flac-in-ogg) */
+
+  gint           error_count;
 };
 
 struct _GstFlacDecClass {
diff --git a/ext/flac/gstflacenc.c b/ext/flac/gstflacenc.c
index 6a7e1c0..b4de217 100644
--- a/ext/flac/gstflacenc.c
+++ b/ext/flac/gstflacenc.c
@@ -225,7 +225,7 @@ static const GstFlacEncParams flacenc_params[] = {
 
 #define DEFAULT_QUALITY 5
 #define DEFAULT_PADDING 0
-#define DEFAULT_SEEKPOINTS 0
+#define DEFAULT_SEEKPOINTS -10
 
 #define GST_TYPE_FLAC_ENC_QUALITY (gst_flac_enc_quality_get_type ())
 static GType
@@ -814,7 +814,6 @@ gst_flac_enc_set_format (GstAudioEncoder * enc, GstAudioInfo * info)
 encoder_already_initialized:
   {
     g_warning ("flac already initialized -- fixme allow this");
-    gst_object_unref (flacenc);
     return FALSE;
   }
 setting_src_caps_failed:
@@ -822,14 +821,12 @@ setting_src_caps_failed:
     GST_DEBUG_OBJECT (flacenc,
         "Couldn't set caps on source pad: %" GST_PTR_FORMAT, caps);
     gst_caps_unref (caps);
-    gst_object_unref (flacenc);
     return FALSE;
   }
 failed_to_initialize:
   {
     GST_ELEMENT_ERROR (flacenc, LIBRARY, INIT, (NULL),
         ("could not initialize encoder (wrong parameters?)"));
-    gst_object_unref (flacenc);
     return FALSE;
   }
 }
diff --git a/ext/gdk_pixbuf/Makefile.am b/ext/gdk_pixbuf/Makefile.am
index cf5265c..abd7d0b 100644
--- a/ext/gdk_pixbuf/Makefile.am
+++ b/ext/gdk_pixbuf/Makefile.am
@@ -1,12 +1,15 @@
 plugin_LTLIBRARIES = libgstgdkpixbuf.la
 
-libgstgdkpixbuf_la_SOURCES = gstgdkpixbuf.c gstgdkpixbufsink.c pixbufscale.c
+libgstgdkpixbuf_la_SOURCES = gstgdkpixbuf.c gstgdkpixbufsink.c pixbufscale.c \
+	gstgdkpixbufoverlay.c
 libgstgdkpixbuf_la_CFLAGS = \
 	$(GST_PLUGINS_BASE_CFLAGS) \
+	$(GST_CONTROLLER_CFLAGS) \
 	$(GST_BASE_CFLAGS) \
 	$(GST_CFLAGS) $(GDK_PIXBUF_CFLAGS)
 libgstgdkpixbuf_la_LIBADD = \
 	$(GST_PLUGINS_BASE_LIBS) -lgstvideo-$(GST_MAJORMINOR) \
+	$(GST_CONTROLLER_LIBS) \
 	$(GST_BASE_LIBS) \
 	$(GST_LIBS) $(GDK_PIXBUF_LIBS)
 libgstgdkpixbuf_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
@@ -14,6 +17,7 @@ libgstgdkpixbuf_la_LIBTOOLFLAGS = --tag=disable-static
 
 noinst_HEADERS = \
 	gstgdkpixbuf.h \
+	gstgdkpixbufoverlay.c \
 	gstgdkpixbufsink.h \
 	pixbufscale.h \
 	gstgdkanimation.h
diff --git a/ext/gdk_pixbuf/gstgdkpixbuf.c b/ext/gdk_pixbuf/gstgdkpixbuf.c
index 0a09400..5ed7a86 100644
--- a/ext/gdk_pixbuf/gstgdkpixbuf.c
+++ b/ext/gdk_pixbuf/gstgdkpixbuf.c
@@ -23,10 +23,12 @@
 #endif
 #include <gst/gst.h>
 #include <gst/video/video.h>
+#include <gst/controller/gstcontroller.h>
 #include <gdk-pixbuf/gdk-pixbuf.h>
 #include <string.h>
 
 #include "gstgdkpixbuf.h"
+#include "gstgdkpixbufoverlay.h"
 #include "gstgdkpixbufsink.h"
 #include "pixbufscale.h"
 
@@ -537,6 +539,10 @@ plugin_init (GstPlugin * plugin)
       gst_gdk_pixbuf_type_find, NULL, GST_CAPS_ANY, NULL);
 #endif
 
+  if (!gst_element_register (plugin, "gdkpixbufoverlay", GST_RANK_NONE,
+          GST_TYPE_GDK_PIXBUF_OVERLAY))
+    return FALSE;
+
   if (!gst_element_register (plugin, "gdkpixbufsink", GST_RANK_NONE,
           GST_TYPE_GDK_PIXBUF_SINK))
     return FALSE;
@@ -544,6 +550,8 @@ plugin_init (GstPlugin * plugin)
   if (!pixbufscale_init (plugin))
     return FALSE;
 
+  gst_controller_init (NULL, NULL);
+
   /* plugin initialisation succeeded */
   return TRUE;
 }
diff --git a/ext/gdk_pixbuf/gstgdkpixbufoverlay.c b/ext/gdk_pixbuf/gstgdkpixbufoverlay.c
new file mode 100644
index 0000000..59ef712
--- /dev/null
+++ b/ext/gdk_pixbuf/gstgdkpixbufoverlay.c
@@ -0,0 +1,533 @@
+/* GStreamer GdkPixbuf overlay
+ * Copyright (C) 2012 Tim-Philipp Müller <tim centricular net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
+ * Boston, MA 02110-1335, USA.
+ */
+
+/**
+ * SECTION:element-gdkpixbufoverlay
+ * @see_also:
+ *
+ * The gdkpixbufoverlay element overlays an image loaded from file onto
+ * a video stream.
+ *
+ * Changing the positioning or overlay width and height properties at runtime
+ * is supported, but it might be prudent to to protect the property setting
+ * code with GST_BASE_TRANSFORM_LOCK and GST_BASE_TRANSFORM_UNLOCK, as
+ * g_object_set() is not atomic for multiple properties passed in one go.
+ *
+ * Changing the image at runtime is currently not supported.
+ *
+ * Negative offsets are also not yet supported.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch -v videotestsrc ! gdkpixbufoverlay location=image.png ! autovideosink
+ * ]|
+ * Overlays the image in image.png onto the test video picture produced by
+ * videotestsrc.
+ * </refsect2>
+ *
+ * Since: 0.10.33
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/controller/gstcontroller.h>
+
+#include "gstgdkpixbufoverlay.h"
+
+GST_DEBUG_CATEGORY_STATIC (gdkpixbufoverlay_debug);
+#define GST_CAT_DEFAULT gdkpixbufoverlay_debug
+
+static void gst_gdk_pixbuf_overlay_set_property (GObject * object,
+    guint property_id, const GValue * value, GParamSpec * pspec);
+static void gst_gdk_pixbuf_overlay_get_property (GObject * object,
+    guint property_id, GValue * value, GParamSpec * pspec);
+static void gst_gdk_pixbuf_overlay_finalize (GObject * object);
+
+static gboolean gst_gdk_pixbuf_overlay_start (GstBaseTransform * trans);
+static gboolean gst_gdk_pixbuf_overlay_stop (GstBaseTransform * trans);
+static GstFlowReturn
+gst_gdk_pixbuf_overlay_transform_ip (GstBaseTransform * trans, GstBuffer * buf);
+static void gst_gdk_pixbuf_overlay_before_transform (GstBaseTransform * trans,
+    GstBuffer * outbuf);
+static gboolean
+gst_gdk_pixbuf_overlay_set_caps (GstBaseTransform * trans, GstCaps * incaps,
+    GstCaps * outcaps);
+
+enum
+{
+  PROP_0,
+  PROP_LOCATION,
+  PROP_OFFSET_X,
+  PROP_OFFSET_Y,
+  PROP_RELATIVE_X,
+  PROP_RELATIVE_Y,
+  PROP_OVERLAY_WIDTH,
+  PROP_OVERLAY_HEIGHT,
+  PROP_ALPHA
+};
+
+#define VIDEO_CAPS \
+    GST_VIDEO_CAPS_BGRx ";" \
+    GST_VIDEO_CAPS_RGB ";" \
+    GST_VIDEO_CAPS_BGR ";" \
+    GST_VIDEO_CAPS_RGBx ";" \
+    GST_VIDEO_CAPS_xRGB ";" \
+    GST_VIDEO_CAPS_xBGR ";" \
+    GST_VIDEO_CAPS_RGBA ";" \
+    GST_VIDEO_CAPS_BGRA ";" \
+    GST_VIDEO_CAPS_ARGB ";" \
+    GST_VIDEO_CAPS_ABGR ";" \
+    GST_VIDEO_CAPS_YUV ("{I420, YV12, AYUV, YUY2, UYVY, v308, v210," \
+        " v216, Y41B, Y42B, Y444, Y800, Y16, NV12, NV21, UYVP, A420," \
+        " YUV9, IYU1}")
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (VIDEO_CAPS)
+    );
+
+static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (VIDEO_CAPS)
+    );
+
+GST_BOILERPLATE (GstGdkPixbufOverlay, gst_gdk_pixbuf_overlay,
+    GstVideoFilter, GST_TYPE_VIDEO_FILTER);
+
+static void
+gst_gdk_pixbuf_overlay_base_init (gpointer g_class)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
+  gst_element_class_add_static_pad_template (element_class, &src_template);
+
+  gst_element_class_set_details_simple (element_class,
+      "GdkPixbuf Overlay", "Filter/Effect/Video",
+      "Overlay an image onto a video stream",
+      "Tim-Philipp Müller <tim centricular net>");
+}
+
+static void
+gst_gdk_pixbuf_overlay_class_init (GstGdkPixbufOverlayClass * klass)
+{
+  GstBaseTransformClass *basetrans_class = GST_BASE_TRANSFORM_CLASS (klass);
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  gobject_class->set_property = gst_gdk_pixbuf_overlay_set_property;
+  gobject_class->get_property = gst_gdk_pixbuf_overlay_get_property;
+  gobject_class->finalize = gst_gdk_pixbuf_overlay_finalize;
+
+  basetrans_class->start = GST_DEBUG_FUNCPTR (gst_gdk_pixbuf_overlay_start);
+  basetrans_class->stop = GST_DEBUG_FUNCPTR (gst_gdk_pixbuf_overlay_stop);
+  basetrans_class->set_caps =
+      GST_DEBUG_FUNCPTR (gst_gdk_pixbuf_overlay_set_caps);
+  basetrans_class->transform_ip =
+      GST_DEBUG_FUNCPTR (gst_gdk_pixbuf_overlay_transform_ip);
+  basetrans_class->before_transform =
+      GST_DEBUG_FUNCPTR (gst_gdk_pixbuf_overlay_before_transform);
+
+  g_object_class_install_property (gobject_class, PROP_LOCATION,
+      g_param_spec_string ("location", "location",
+          "Location of image file to overlay", NULL,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_OFFSET_X,
+      g_param_spec_int ("offset-x", "X Offset",
+          "Horizontal offset of overlay image in pixels from top-left corner "
+          "of video image", G_MININT, G_MAXINT, 0,
+          GST_PARAM_CONTROLLABLE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_READWRITE
+          | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_OFFSET_Y,
+      g_param_spec_int ("offset-y", "Y Offset",
+          "Vertical offset of overlay image in pixels from top-left corner "
+          "of video image", G_MININT, G_MAXINT, 0,
+          GST_PARAM_CONTROLLABLE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_READWRITE
+          | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_RELATIVE_X,
+      g_param_spec_double ("relative-x", "Relative X Offset",
+          "Horizontal offset of overlay image in fractions of video image "
+          "width, from top-left corner of video image", 0.0, 1.0, 0.0,
+          GST_PARAM_CONTROLLABLE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_READWRITE
+          | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_RELATIVE_Y,
+      g_param_spec_double ("relative-y", "Relative Y Offset",
+          "Vertical offset of overlay image in fractions of video image "
+          "height, from top-left corner of video image", 0.0, 1.0, 0.0,
+          GST_PARAM_CONTROLLABLE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_READWRITE
+          | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_OVERLAY_WIDTH,
+      g_param_spec_int ("overlay-width", "Overlay Width",
+          "Width of overlay image in pixels (0 = same as overlay image)", 0,
+          G_MAXINT, 0,
+          GST_PARAM_CONTROLLABLE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_READWRITE
+          | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_OVERLAY_HEIGHT,
+      g_param_spec_int ("overlay-height", "Overlay Height",
+          "Height of overlay image in pixels (0 = same as overlay image)", 0,
+          G_MAXINT, 0,
+          GST_PARAM_CONTROLLABLE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_READWRITE
+          | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_ALPHA,
+      g_param_spec_double ("alpha", "Alpha", "Global alpha of overlay image",
+          0.0, 1.0, 1.0, GST_PARAM_CONTROLLABLE | GST_PARAM_MUTABLE_PLAYING
+          | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  GST_DEBUG_CATEGORY_INIT (gdkpixbufoverlay_debug, "gdkpixbufoverlay", 0,
+      "debug category for gdkpixbufoverlay element");
+}
+
+static void
+gst_gdk_pixbuf_overlay_init (GstGdkPixbufOverlay * overlay,
+    GstGdkPixbufOverlayClass * overlay_class)
+{
+  overlay->offset_x = 0;
+  overlay->offset_y = 0;
+
+  overlay->relative_x = 0.0;
+  overlay->relative_y = 0.0;
+
+  overlay->overlay_width = 0;
+  overlay->overlay_height = 0;
+
+  overlay->alpha = 1.0;
+}
+
+void
+gst_gdk_pixbuf_overlay_set_property (GObject * object, guint property_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstGdkPixbufOverlay *overlay = GST_GDK_PIXBUF_OVERLAY (object);
+
+  GST_OBJECT_LOCK (overlay);
+
+  switch (property_id) {
+    case PROP_LOCATION:
+      g_free (overlay->location);
+      overlay->location = g_value_dup_string (value);
+      break;
+    case PROP_OFFSET_X:
+      overlay->offset_x = g_value_get_int (value);
+      overlay->update_composition = TRUE;
+      break;
+    case PROP_OFFSET_Y:
+      overlay->offset_y = g_value_get_int (value);
+      overlay->update_composition = TRUE;
+      break;
+    case PROP_RELATIVE_X:
+      overlay->relative_x = g_value_get_double (value);
+      overlay->update_composition = TRUE;
+      break;
+    case PROP_RELATIVE_Y:
+      overlay->relative_y = g_value_get_double (value);
+      overlay->update_composition = TRUE;
+      break;
+    case PROP_OVERLAY_WIDTH:
+      overlay->overlay_width = g_value_get_int (value);
+      overlay->update_composition = TRUE;
+      break;
+    case PROP_OVERLAY_HEIGHT:
+      overlay->overlay_height = g_value_get_int (value);
+      overlay->update_composition = TRUE;
+      break;
+    case PROP_ALPHA:
+      overlay->alpha = g_value_get_double (value);
+      overlay->update_composition = TRUE;
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+
+  GST_OBJECT_UNLOCK (overlay);
+}
+
+void
+gst_gdk_pixbuf_overlay_get_property (GObject * object, guint property_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstGdkPixbufOverlay *overlay = GST_GDK_PIXBUF_OVERLAY (object);
+
+  GST_OBJECT_LOCK (overlay);
+
+  switch (property_id) {
+    case PROP_LOCATION:
+      g_value_set_string (value, overlay->location);
+      break;
+    case PROP_OFFSET_X:
+      g_value_set_int (value, overlay->offset_x);
+      break;
+    case PROP_OFFSET_Y:
+      g_value_set_int (value, overlay->offset_y);
+      break;
+    case PROP_RELATIVE_X:
+      g_value_set_double (value, overlay->relative_x);
+      break;
+    case PROP_RELATIVE_Y:
+      g_value_set_double (value, overlay->relative_y);
+      break;
+    case PROP_OVERLAY_WIDTH:
+      g_value_set_int (value, overlay->overlay_width);
+      break;
+    case PROP_OVERLAY_HEIGHT:
+      g_value_set_int (value, overlay->overlay_height);
+      break;
+    case PROP_ALPHA:
+      g_value_set_double (value, overlay->alpha);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+
+  GST_OBJECT_UNLOCK (overlay);
+}
+
+void
+gst_gdk_pixbuf_overlay_finalize (GObject * object)
+{
+  GstGdkPixbufOverlay *overlay = GST_GDK_PIXBUF_OVERLAY (object);
+
+  g_free (overlay->location);
+  overlay->location = NULL;
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_gdk_pixbuf_overlay_load_image (GstGdkPixbufOverlay * overlay, GError ** err)
+{
+  GdkPixbuf *pixbuf;
+  guint8 *pixels, *p;
+  gint width, height, stride, w, h;
+
+  pixbuf = gdk_pixbuf_new_from_file (overlay->location, err);
+
+  if (pixbuf == NULL)
+    return FALSE;
+
+  if (!gdk_pixbuf_get_has_alpha (pixbuf)) {
+    GdkPixbuf *alpha_pixbuf;
+
+    /* FIXME: we could do this much more efficiently ourselves below, but
+     * we're lazy for now */
+    /* FIXME: perhaps expose substitute_color via properties */
+    alpha_pixbuf = gdk_pixbuf_add_alpha (pixbuf, FALSE, 0, 0, 0);
+    g_object_unref (pixbuf);
+    pixbuf = alpha_pixbuf;
+  }
+
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+  stride = gdk_pixbuf_get_rowstride (pixbuf);
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+  /* the memory layout in GdkPixbuf is R-G-B-A, we want:
+   *  - B-G-R-A on little-endian platforms
+   *  - A-R-G-B on big-endian platforms
+   */
+  for (h = 0; h < height; ++h) {
+    p = pixels + (h * stride);
+    for (w = 0; w < width; ++w) {
+      guint8 tmp;
+
+      /* R-G-B-A ==> B-G-R-A */
+      tmp = p[0];
+      p[0] = p[2];
+      p[2] = tmp;
+
+      if (G_BYTE_ORDER == G_BIG_ENDIAN) {
+        /* B-G-R-A ==> A-R-G-B */
+        /* we can probably assume sane alignment */
+        *((guint32 *) p) = GUINT32_SWAP_LE_BE (*((guint32 *) p));
+      }
+
+      p += 4;
+    }
+  }
+
+  overlay->pixels = gst_buffer_new ();
+  GST_BUFFER_DATA (overlay->pixels) = pixels;
+  /* assume we have row padding even for the last row */
+  GST_BUFFER_SIZE (overlay->pixels) = height * stride;
+  /* transfer ownership of pixbuf to buffer */
+  GST_BUFFER_MALLOCDATA (overlay->pixels) = (guint8 *) pixbuf;
+  GST_BUFFER_FREE_FUNC (overlay->pixels) = (GFreeFunc) g_object_unref;
+
+  overlay->pixels_width = width;
+  overlay->pixels_height = height;
+  overlay->pixels_stride = stride;
+
+  overlay->update_composition = TRUE;
+
+  GST_INFO_OBJECT (overlay, "Loaded image, %d x %d", width, height);
+  return TRUE;
+}
+
+static gboolean
+gst_gdk_pixbuf_overlay_start (GstBaseTransform * trans)
+{
+  GstGdkPixbufOverlay *overlay = GST_GDK_PIXBUF_OVERLAY (trans);
+  GError *err = NULL;
+
+  if (overlay->location != NULL) {
+    if (!gst_gdk_pixbuf_overlay_load_image (overlay, &err))
+      goto error_loading_image;
+
+    gst_base_transform_set_passthrough (trans, FALSE);
+  } else {
+    GST_WARNING_OBJECT (overlay, "no image location set, doing nothing");
+    gst_base_transform_set_passthrough (trans, TRUE);
+  }
+
+  return TRUE;
+
+/* ERRORS */
+error_loading_image:
+  {
+    GST_ELEMENT_ERROR (overlay, RESOURCE, OPEN_READ,
+        ("Could not load overlay image."), ("%s", err->message));
+    g_error_free (err);
+    return FALSE;
+  }
+}
+
+static gboolean
+gst_gdk_pixbuf_overlay_stop (GstBaseTransform * trans)
+{
+  GstGdkPixbufOverlay *overlay = GST_GDK_PIXBUF_OVERLAY (trans);
+
+  if (overlay->comp) {
+    gst_video_overlay_composition_unref (overlay->comp);
+    overlay->comp = NULL;
+  }
+
+  gst_buffer_replace (&overlay->pixels, NULL);
+
+  return TRUE;
+}
+
+static gboolean
+gst_gdk_pixbuf_overlay_set_caps (GstBaseTransform * trans, GstCaps * incaps,
+    GstCaps * outcaps)
+{
+  GstGdkPixbufOverlay *overlay = GST_GDK_PIXBUF_OVERLAY (trans);
+  GstVideoFormat video_format;
+  int w, h;
+
+  if (!gst_video_format_parse_caps (incaps, &video_format, &w, &h))
+    return FALSE;
+
+  overlay->format = video_format;
+  overlay->width = w;
+  overlay->height = h;
+  return TRUE;
+}
+
+static void
+gst_gdk_pixbuf_overlay_update_composition (GstGdkPixbufOverlay * overlay)
+{
+  GstVideoOverlayComposition *comp;
+  GstVideoOverlayRectangle *rect;
+  gint x, y, width, height;
+
+  if (overlay->comp) {
+    gst_video_overlay_composition_unref (overlay->comp);
+    overlay->comp = NULL;
+  }
+
+  if (overlay->alpha == 0.0)
+    return;
+
+  x = overlay->offset_x + (overlay->relative_x * overlay->pixels_width);
+  y = overlay->offset_y + (overlay->relative_y * overlay->pixels_height);
+
+  /* FIXME: this should work, but seems to crash */
+  if (x < 0)
+    x = 0;
+  if (y < 0)
+    y = 0;
+
+  width = overlay->overlay_width;
+  if (width == 0)
+    width = overlay->pixels_width;
+
+  height = overlay->overlay_height;
+  if (height == 0)
+    height = overlay->pixels_height;
+
+  GST_DEBUG_OBJECT (overlay, "overlay image dimensions: %d x %d, alpha=%.2f",
+      overlay->pixels_width, overlay->pixels_height, overlay->alpha);
+  GST_DEBUG_OBJECT (overlay, "properties: x,y: %d,%d (%g%%,%g%%) - WxH: %dx%d",
+      overlay->offset_x, overlay->offset_y,
+      overlay->relative_x * 100.0, overlay->relative_y * 100.0,
+      overlay->overlay_height, overlay->overlay_width);
+  GST_DEBUG_OBJECT (overlay, "overlay rendered: %d x %d @ %d,%d (onto %d x %d)",
+      width, height, x, y, overlay->width, overlay->height);
+
+  rect = gst_video_overlay_rectangle_new_argb (overlay->pixels,
+      overlay->pixels_width, overlay->pixels_height, overlay->pixels_stride,
+      x, y, width, height, GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
+
+  if (overlay->alpha != 1.0)
+    gst_video_overlay_rectangle_set_global_alpha (rect, overlay->alpha);
+
+  comp = gst_video_overlay_composition_new (rect);
+  gst_video_overlay_rectangle_unref (rect);
+
+  overlay->comp = comp;
+}
+
+static void
+gst_gdk_pixbuf_overlay_before_transform (GstBaseTransform * trans,
+    GstBuffer * outbuf)
+{
+  GstClockTime stream_time;
+
+  stream_time = gst_segment_to_stream_time (&trans->segment, GST_FORMAT_TIME,
+      GST_BUFFER_TIMESTAMP (outbuf));
+
+  if (GST_CLOCK_TIME_IS_VALID (stream_time))
+    gst_object_sync_values (G_OBJECT (trans), stream_time);
+}
+
+static GstFlowReturn
+gst_gdk_pixbuf_overlay_transform_ip (GstBaseTransform * trans, GstBuffer * buf)
+{
+  GstGdkPixbufOverlay *overlay = GST_GDK_PIXBUF_OVERLAY (trans);
+
+  GST_OBJECT_LOCK (overlay);
+
+  if (G_UNLIKELY (overlay->update_composition)) {
+    gst_gdk_pixbuf_overlay_update_composition (overlay);
+    overlay->update_composition = FALSE;
+  }
+
+  GST_OBJECT_UNLOCK (overlay);
+
+  if (overlay->comp != NULL)
+    gst_video_overlay_composition_blend (overlay->comp, buf);
+
+  return GST_FLOW_OK;
+}
diff --git a/ext/gdk_pixbuf/gstgdkpixbufoverlay.h b/ext/gdk_pixbuf/gstgdkpixbufoverlay.h
new file mode 100644
index 0000000..f815e31
--- /dev/null
+++ b/ext/gdk_pixbuf/gstgdkpixbufoverlay.h
@@ -0,0 +1,89 @@
+/* GStreamer GdkPixbuf overlay
+ * Copyright (C) 2012 Tim-Philipp Müller <tim centricular net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_GDK_PIXBUF_OVERLAY_H_
+#define _GST_GDK_PIXBUF_OVERLAY_H_
+
+#include <gst/video/video.h>
+#include <gst/video/gstvideofilter.h>
+#include <gst/video/video-overlay-composition.h>
+
+#include <gdk-pixbuf/gdk-pixbuf.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_GDK_PIXBUF_OVERLAY   (gst_gdk_pixbuf_overlay_get_type())
+#define GST_GDK_PIXBUF_OVERLAY(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GDK_PIXBUF_OVERLAY,GstGdkPixbufOverlay))
+#define GST_GDK_PIXBUF_OVERLAY_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GDK_PIXBUF_OVERLAY,GstGdkPixbufOverlayClass))
+#define GST_IS_GDK_PIXBUF_OVERLAY(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GDK_PIXBUF_OVERLAY))
+#define GST_IS_GDK_PIXBUF_OVERLAY_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GDK_PIXBUF_OVERLAY))
+
+typedef struct _GstGdkPixbufOverlay GstGdkPixbufOverlay;
+typedef struct _GstGdkPixbufOverlayClass GstGdkPixbufOverlayClass;
+
+/**
+ * GstGdkPixbufOverlay:
+ *
+ * The opaque element instance structure.
+ */
+struct _GstGdkPixbufOverlay
+{
+  GstVideoFilter               videofilter;
+
+  /* negotiated format */
+  GstVideoFormat               format;
+  gint                         width;
+  gint                         height;
+
+  /* properties */
+  gchar                      * location;
+
+  gint                         offset_x;
+  gint                         offset_y;
+
+  gdouble                      relative_x;
+  gdouble                      relative_y;
+
+  gint                         overlay_width;
+  gint                         overlay_height;
+
+  gdouble                      alpha;
+
+  /* the loaded image */
+  GstBuffer                  * pixels;
+  guint                        pixels_width;
+  guint                        pixels_height;
+  guint                        pixels_stride;
+
+  GstVideoOverlayComposition * comp;
+
+  /* render position or dimension has changed */
+  gboolean                     update_composition;
+};
+
+struct _GstGdkPixbufOverlayClass
+{
+  GstVideoFilterClass  videofilter_class;
+};
+
+GType gst_gdk_pixbuf_overlay_get_type (void);
+
+G_END_DECLS
+
+#endif
diff --git a/ext/jack/gstjack.c b/ext/jack/gstjack.c
index 8180afb..680a12d 100644
--- a/ext/jack/gstjack.c
+++ b/ext/jack/gstjack.c
@@ -46,6 +46,25 @@ gst_jack_connect_get_type (void)
   return (GType) jack_connect_type;
 }
 
+GType
+gst_jack_transport_get_type (void)
+{
+  static volatile gsize type = 0;
+
+  if (g_once_init_enter (&type)) {
+    static const GFlagsValue flag_values[] = {
+      {GST_JACK_TRANSPORT_MASTER,
+          "Start and stop transport with state changes", "master"},
+      {GST_JACK_TRANSPORT_SLAVE,
+          "Follow transport state changes", "slave"},
+      {0, NULL, NULL},
+    };
+    GType tmp = g_flags_register_static ("GstJackTransport", flag_values);
+    g_once_init_leave (&type, tmp);
+  }
+  return (GType) type;
+}
+
 
 static gpointer
 gst_jack_client_copy (gpointer jclient)
diff --git a/ext/jack/gstjack.h b/ext/jack/gstjack.h
index d923866..50033d9 100644
--- a/ext/jack/gstjack.h
+++ b/ext/jack/gstjack.h
@@ -37,19 +37,35 @@
  *
  * Specify how the output ports will be connected.
  */
-
 typedef enum {
   GST_JACK_CONNECT_NONE,
   GST_JACK_CONNECT_AUTO,
   GST_JACK_CONNECT_AUTO_FORCED
 } GstJackConnect;
 
+/**
+ * GstJackTransport:
+ * @GST_JACK_TRANSPORT_AUTONOMOUS: no transport support
+ * @GST_JACK_TRANSPORT_MASTER: start and stop transport with state-changes
+ * @GST_JACK_TRANSPORT_SLAVE: follow transport state changes
+ *
+ * The jack transport state allow to sync multiple clients. This enum defines a
+ * client behaviour regarding to the transport mechanism.
+ */
+typedef enum {
+  GST_JACK_TRANSPORT_AUTONOMOUS = 0,
+  GST_JACK_TRANSPORT_MASTER = (1 << 0),
+  GST_JACK_TRANSPORT_SLAVE = (1 << 1),
+} GstJackTransport;
+
 typedef jack_default_audio_sample_t sample_t;
 
-#define GST_TYPE_JACK_CONNECT (gst_jack_connect_get_type())
-#define GST_TYPE_JACK_CLIENT  (gst_jack_client_get_type ())
+#define GST_TYPE_JACK_CONNECT   (gst_jack_connect_get_type ())
+#define GST_TYPE_JACK_TRANSPORT (gst_jack_transport_get_type ())
+#define GST_TYPE_JACK_CLIENT    (gst_jack_client_get_type ())
 
 GType gst_jack_client_get_type(void);
 GType gst_jack_connect_get_type(void);
+GType gst_jack_transport_get_type(void);
 
 #endif  // _GST_JACK_H_
diff --git a/ext/jack/gstjackaudioclient.c b/ext/jack/gstjackaudioclient.c
index 2bb3555..8680cda 100644
--- a/ext/jack/gstjackaudioclient.c
+++ b/ext/jack/gstjackaudioclient.c
@@ -22,6 +22,7 @@
 #include <string.h>
 
 #include "gstjackaudioclient.h"
+#include "gstjack.h"
 
 #include <gst/glib-compat-private.h>
 
@@ -55,6 +56,10 @@ typedef struct
   gint n_clients;
   GList *src_clients;
   GList *sink_clients;
+
+  /* transport state handling */
+  gint cur_ts;
+  GstState transport_state;
 } GstJackAudioConnection;
 
 /* an object sharing a jack_client_t connection. */
@@ -66,27 +71,65 @@ struct _GstJackAudioClient
   gboolean active;
   gboolean deactivate;
 
-  void (*shutdown) (void *arg);
+  JackShutdownCallback shutdown;
   JackProcessCallback process;
   JackBufferSizeCallback buffer_size;
   JackSampleRateCallback sample_rate;
   gpointer user_data;
 };
 
-typedef jack_default_audio_sample_t sample_t;
-
 typedef struct
 {
   jack_nframes_t nframes;
   gpointer user_data;
 } JackCB;
 
+static gboolean
+jack_handle_transport_change (GstJackAudioClient * client, GstState state)
+{
+  GstObject *obj = GST_OBJECT_PARENT (client->user_data);
+  guint mode;
+
+  g_object_get (obj, "transport", &mode, NULL);
+  if ((mode & GST_JACK_TRANSPORT_SLAVE) && (GST_STATE (obj) != state)) {
+    GST_INFO_OBJECT (obj, "requesting state change: %s",
+        gst_element_state_get_name (state));
+    gst_element_post_message (GST_ELEMENT (obj),
+        gst_message_new_request_state (obj, state));
+    return TRUE;
+  }
+  return FALSE;
+}
+
 static int
 jack_process_cb (jack_nframes_t nframes, void *arg)
 {
   GstJackAudioConnection *conn = (GstJackAudioConnection *) arg;
   GList *walk;
   int res = 0;
+  jack_transport_state_t ts = jack_transport_query (conn->client, NULL);
+
+  if (ts != conn->cur_ts) {
+    conn->cur_ts = ts;
+    switch (ts) {
+      case JackTransportStopped:
+        GST_DEBUG ("transport state is 'stopped'");
+        conn->transport_state = GST_STATE_PAUSED;
+        break;
+      case JackTransportStarting:
+        GST_DEBUG ("transport state is 'starting'");
+        conn->transport_state = GST_STATE_READY;
+        break;
+      case JackTransportRolling:
+        GST_DEBUG ("transport state is 'rolling'");
+        conn->transport_state = GST_STATE_PLAYING;
+        break;
+      default:
+        break;
+    }
+    GST_DEBUG ("num of clients: src=%d, sink=%d",
+        g_list_length (conn->src_clients), g_list_length (conn->sink_clients));
+  }
 
   g_mutex_lock (conn->lock);
   /* call sources first, then sinks. Sources will either push data into the
@@ -116,8 +159,28 @@ jack_process_cb (jack_nframes_t nframes, void *arg)
       }
     }
   }
-  g_mutex_unlock (conn->lock);
 
+  /* handle transport state requisition, do sinks first, stop after the first
+   * element that handled it */
+  if (conn->transport_state != GST_STATE_VOID_PENDING) {
+    for (walk = conn->sink_clients; walk; walk = g_list_next (walk)) {
+      if (jack_handle_transport_change ((GstJackAudioClient *) walk->data,
+              conn->transport_state)) {
+        conn->transport_state = GST_STATE_VOID_PENDING;
+        break;
+      }
+    }
+  }
+  if (conn->transport_state != GST_STATE_VOID_PENDING) {
+    for (walk = conn->src_clients; walk; walk = g_list_next (walk)) {
+      if (jack_handle_transport_change ((GstJackAudioClient *) walk->data,
+              conn->transport_state)) {
+        conn->transport_state = GST_STATE_VOID_PENDING;
+        break;
+      }
+    }
+  }
+  g_mutex_unlock (conn->lock);
   return res;
 }
 
@@ -224,6 +287,8 @@ gst_jack_audio_make_connection (const gchar * id, const gchar * server,
   conn->n_clients = 0;
   conn->src_clients = NULL;
   conn->sink_clients = NULL;
+  conn->cur_ts = -1;
+  conn->transport_state = GST_STATE_VOID_PENDING;
 
   /* set our callbacks  */
   jack_set_process_callback (jclient, jack_process_cb, conn);
@@ -233,6 +298,7 @@ gst_jack_audio_make_connection (const gchar * id, const gchar * server,
   jack_on_shutdown (jclient, jack_shutdown_cb, conn);
 
   /* all callbacks are set, activate the client */
+  GST_INFO ("activate jack_client %p", jclient);
   if ((res = jack_activate (jclient)))
     goto could_not_activate;
 
@@ -327,6 +393,7 @@ gst_jack_audio_unref_connection (GstJackAudioConnection * conn)
      *      waiting for the JACK thread, and can thus cause deadlock in 
      *      jack_process_cb()
      */
+    GST_INFO ("deactivate jack_client %p", conn->client);
     if ((res = jack_deactivate (conn->client))) {
       /* we only warn, this means the server is probably shut down and the client
        * is gone anyway. */
@@ -525,3 +592,22 @@ gst_jack_audio_client_set_active (GstJackAudioClient * client, gboolean active)
 
   return 0;
 }
+
+/**
+ * gst_jack_audio_client_get_transport_state:
+ * @client: a #GstJackAudioClient
+ *
+ * Check the current transport state. The client can use this to request a state
+ * change from the application.
+ *
+ * Returns: the state, %GST_STATE_VOID_PENDING for no change in the transport
+ * state
+ */
+GstState
+gst_jack_audio_client_get_transport_state (GstJackAudioClient * client)
+{
+  GstState state = client->conn->transport_state;
+
+  client->conn->transport_state = GST_STATE_VOID_PENDING;
+  return state;
+}
diff --git a/ext/jack/gstjackaudioclient.h b/ext/jack/gstjackaudioclient.h
index 5fb7e35..f2669c9 100644
--- a/ext/jack/gstjackaudioclient.h
+++ b/ext/jack/gstjackaudioclient.h
@@ -54,6 +54,8 @@ jack_client_t *       gst_jack_audio_client_get_client     (GstJackAudioClient *
 
 gboolean              gst_jack_audio_client_set_active     (GstJackAudioClient *client, gboolean active);
 
+GstState              gst_jack_audio_client_get_transport_state (GstJackAudioClient *client);
+
 G_END_DECLS
 
 #endif /* __GST_JACK_AUDIO_CLIENT_H__ */
diff --git a/ext/jack/gstjackaudiosink.c b/ext/jack/gstjackaudiosink.c
index 078ca24..527a864 100644
--- a/ext/jack/gstjackaudiosink.c
+++ b/ext/jack/gstjackaudiosink.c
@@ -560,6 +560,13 @@ gst_jack_ring_buffer_start (GstRingBuffer * buf)
 
   GST_DEBUG_OBJECT (sink, "start");
 
+  if (sink->transport & GST_JACK_TRANSPORT_MASTER) {
+    jack_client_t *client;
+
+    client = gst_jack_audio_client_get_client (sink->client);
+    jack_transport_start (client);
+  }
+
   return TRUE;
 }
 
@@ -572,6 +579,13 @@ gst_jack_ring_buffer_pause (GstRingBuffer * buf)
 
   GST_DEBUG_OBJECT (sink, "pause");
 
+  if (sink->transport & GST_JACK_TRANSPORT_MASTER) {
+    jack_client_t *client;
+
+    client = gst_jack_audio_client_get_client (sink->client);
+    jack_transport_stop (client);
+  }
+
   return TRUE;
 }
 
@@ -584,6 +598,13 @@ gst_jack_ring_buffer_stop (GstRingBuffer * buf)
 
   GST_DEBUG_OBJECT (sink, "stop");
 
+  if (sink->transport & GST_JACK_TRANSPORT_MASTER) {
+    jack_client_t *client;
+
+    client = gst_jack_audio_client_get_client (sink->client);
+    jack_transport_stop (client);
+  }
+
   return TRUE;
 }
 
@@ -650,7 +671,8 @@ enum
 
 #define DEFAULT_PROP_CONNECT 		GST_JACK_CONNECT_AUTO
 #define DEFAULT_PROP_SERVER 		NULL
-#define DEFAULT_PROP_CLIENT_NAME 	NULL
+#define DEFAULT_PROP_CLIENT_NAME	NULL
+#define DEFAULT_PROP_TRANSPORT	GST_JACK_TRANSPORT_AUTONOMOUS
 
 enum
 {
@@ -659,6 +681,7 @@ enum
   PROP_SERVER,
   PROP_CLIENT,
   PROP_CLIENT_NAME,
+  PROP_TRANSPORT,
   PROP_LAST
 };
 
@@ -736,6 +759,19 @@ gst_jack_audio_sink_class_init (GstJackAudioSinkClass * klass)
           GST_PARAM_MUTABLE_READY | G_PARAM_READWRITE |
           G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstJackAudioSink:transport
+   *
+   * The jack transport behaviour for the client.
+   *
+   * Since: 0.10.31
+   */
+  g_object_class_install_property (gobject_class, PROP_TRANSPORT,
+      g_param_spec_flags ("transport", "Transport mode",
+          "Jack transport behaviour of the client",
+          GST_TYPE_JACK_TRANSPORT, DEFAULT_PROP_TRANSPORT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   gstbasesink_class->get_caps = GST_DEBUG_FUNCPTR (gst_jack_audio_sink_getcaps);
 
   gstbaseaudiosink_class->create_ringbuffer =
@@ -757,8 +793,9 @@ gst_jack_audio_sink_init (GstJackAudioSink * sink,
   sink->jclient = NULL;
   sink->ports = NULL;
   sink->port_count = 0;
-  sink->client_name = g_strdup (DEFAULT_PROP_CLIENT_NAME);
   sink->buffers = NULL;
+  sink->client_name = g_strdup (DEFAULT_PROP_CLIENT_NAME);
+  sink->transport = DEFAULT_PROP_TRANSPORT;
 }
 
 static void
@@ -802,6 +839,9 @@ gst_jack_audio_sink_set_property (GObject * object, guint prop_id,
         sink->jclient = g_value_get_boxed (value);
       }
       break;
+    case PROP_TRANSPORT:
+      sink->transport = g_value_get_flags (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -829,6 +869,9 @@ gst_jack_audio_sink_get_property (GObject * object, guint prop_id,
     case PROP_CLIENT:
       g_value_set_boxed (value, sink->jclient);
       break;
+    case PROP_TRANSPORT:
+      g_value_set_flags (value, sink->transport);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
diff --git a/ext/jack/gstjackaudiosink.h b/ext/jack/gstjackaudiosink.h
index db5fc28..fbb660d 100644
--- a/ext/jack/gstjackaudiosink.h
+++ b/ext/jack/gstjackaudiosink.h
@@ -59,6 +59,7 @@ struct _GstJackAudioSink {
   gchar           *server;
   jack_client_t   *jclient;
   gchar           *client_name;
+  guint            transport;
 
   /* our client */
   GstJackAudioClient *client;
diff --git a/ext/jack/gstjackaudiosrc.c b/ext/jack/gstjackaudiosrc.c
index 3c37970..2063875 100644
--- a/ext/jack/gstjackaudiosrc.c
+++ b/ext/jack/gstjackaudiosrc.c
@@ -572,6 +572,13 @@ gst_jack_ring_buffer_start (GstRingBuffer * buf)
 
   GST_DEBUG_OBJECT (src, "start");
 
+  if (src->transport & GST_JACK_TRANSPORT_MASTER) {
+    jack_client_t *client;
+
+    client = gst_jack_audio_client_get_client (src->client);
+    jack_transport_start (client);
+  }
+
   return TRUE;
 }
 
@@ -584,6 +591,13 @@ gst_jack_ring_buffer_pause (GstRingBuffer * buf)
 
   GST_DEBUG_OBJECT (src, "pause");
 
+  if (src->transport & GST_JACK_TRANSPORT_MASTER) {
+    jack_client_t *client;
+
+    client = gst_jack_audio_client_get_client (src->client);
+    jack_transport_stop (client);
+  }
+
   return TRUE;
 }
 
@@ -596,6 +610,13 @@ gst_jack_ring_buffer_stop (GstRingBuffer * buf)
 
   GST_DEBUG_OBJECT (src, "stop");
 
+  if (src->transport & GST_JACK_TRANSPORT_MASTER) {
+    jack_client_t *client;
+
+    client = gst_jack_audio_client_get_client (src->client);
+    jack_transport_stop (client);
+  }
+
   return TRUE;
 }
 
@@ -654,6 +675,7 @@ enum
 #define DEFAULT_PROP_CONNECT 		GST_JACK_CONNECT_AUTO
 #define DEFAULT_PROP_SERVER 		NULL
 #define DEFAULT_PROP_CLIENT_NAME	NULL
+#define DEFAULT_PROP_TRANSPORT	GST_JACK_TRANSPORT_AUTONOMOUS
 
 enum
 {
@@ -662,6 +684,7 @@ enum
   PROP_SERVER,
   PROP_CLIENT,
   PROP_CLIENT_NAME,
+  PROP_TRANSPORT,
   PROP_LAST
 };
 
@@ -756,6 +779,19 @@ gst_jack_audio_src_class_init (GstJackAudioSrcClass * klass)
           GST_PARAM_MUTABLE_READY | G_PARAM_READWRITE |
           G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstJackAudioSink:transport
+   *
+   * The jack transport behaviour for the client.
+   *
+   * Since: 0.10.31
+   */
+  g_object_class_install_property (gobject_class, PROP_TRANSPORT,
+      g_param_spec_flags ("transport", "Transport mode",
+          "Jack transport behaviour of the client",
+          GST_TYPE_JACK_TRANSPORT, DEFAULT_PROP_TRANSPORT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   gstbasesrc_class->get_caps = GST_DEBUG_FUNCPTR (gst_jack_audio_src_getcaps);
   gstbaseaudiosrc_class->create_ringbuffer =
       GST_DEBUG_FUNCPTR (gst_jack_audio_src_create_ringbuffer);
@@ -767,11 +803,6 @@ gst_jack_audio_src_class_init (GstJackAudioSrcClass * klass)
   gst_jack_audio_client_init ();
 }
 
-/* initialize the new element
- * instantiate pads and add them to element
- * set pad calback functions
- * initialize instance structure
- */
 static void
 gst_jack_audio_src_init (GstJackAudioSrc * src, GstJackAudioSrcClass * gclass)
 {
@@ -783,6 +814,7 @@ gst_jack_audio_src_init (GstJackAudioSrc * src, GstJackAudioSrcClass * gclass)
   src->port_count = 0;
   src->buffers = NULL;
   src->client_name = g_strdup (DEFAULT_PROP_CLIENT_NAME);
+  src->transport = DEFAULT_PROP_TRANSPORT;
 }
 
 static void
@@ -824,6 +856,9 @@ gst_jack_audio_src_set_property (GObject * object, guint prop_id,
         src->jclient = g_value_get_boxed (value);
       }
       break;
+    case PROP_TRANSPORT:
+      src->transport = g_value_get_flags (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -849,6 +884,9 @@ gst_jack_audio_src_get_property (GObject * object, guint prop_id,
     case PROP_CLIENT:
       g_value_set_boxed (value, src->jclient);
       break;
+    case PROP_TRANSPORT:
+      g_value_set_flags (value, src->transport);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
diff --git a/ext/jack/gstjackaudiosrc.h b/ext/jack/gstjackaudiosrc.h
index b69a4d6..c63f40c 100644
--- a/ext/jack/gstjackaudiosrc.h
+++ b/ext/jack/gstjackaudiosrc.h
@@ -72,10 +72,11 @@ struct _GstJackAudioSrc
     GstCaps         *caps;
 
     /* properties */
-    GstJackConnect connect;
+    GstJackConnect   connect;
     gchar           *server;
     jack_client_t   *jclient;
     gchar           *client_name;
+    guint            transport;
 
     /* our client */
     GstJackAudioClient *client;
diff --git a/ext/libpng/gstpngdec.c b/ext/libpng/gstpngdec.c
index 4a2b547..e10bdb7 100644
--- a/ext/libpng/gstpngdec.c
+++ b/ext/libpng/gstpngdec.c
@@ -87,7 +87,8 @@ static GstStaticPadTemplate gst_pngdec_src_pad_template =
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS (GST_VIDEO_CAPS_RGBA ";" GST_VIDEO_CAPS_RGB ";"
-        GST_VIDEO_CAPS_ARGB_64)
+        GST_VIDEO_CAPS_ARGB_64 ";"
+        GST_VIDEO_CAPS_GRAY8 ";" GST_VIDEO_CAPS_GRAY16 ("BIG_ENDIAN"))
     );
 
 static GstStaticPadTemplate gst_pngdec_sink_pad_template =
@@ -371,15 +372,15 @@ gst_pngdec_caps_create_and_set (GstPngDec * pngdec)
 
   /* Get bits per channel */
   bpc = png_get_bit_depth (pngdec->png, pngdec->info);
-  if (bpc > 8) {
-    /* Add alpha channel if 16-bit depth */
-    png_set_add_alpha (pngdec->png, 0xffff, PNG_FILLER_BEFORE);
-    png_set_swap (pngdec->png);
-  }
 
   /* Get Color type */
   color_type = png_get_color_type (pngdec->png, pngdec->info);
 
+  /* Add alpha channel if 16-bit depth, but not for GRAY images */
+  if ((bpc > 8) && (color_type != PNG_COLOR_TYPE_GRAY)) {
+    png_set_add_alpha (pngdec->png, 0xffff, PNG_FILLER_BEFORE);
+    png_set_swap (pngdec->png);
+  }
 #if 0
   /* We used to have this HACK to reverse the outgoing bytes, but the problem
    * that originally required the hack seems to have been in ffmpegcolorspace's
@@ -389,11 +390,16 @@ gst_pngdec_caps_create_and_set (GstPngDec * pngdec)
     png_set_bgr (pngdec->png);
 #endif
 
-  /* Gray scale converted to RGB and upscaled to 8 bits */
+  /* Gray scale with alpha channel converted to RGB */
+  if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
+    GST_LOG_OBJECT (pngdec,
+        "converting grayscale png with alpha channel to RGB");
+    png_set_gray_to_rgb (pngdec->png);
+  }
+
+  /* Gray scale converted to upscaled to 8 bits */
   if ((color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||
       (color_type == PNG_COLOR_TYPE_GRAY)) {
-    GST_LOG_OBJECT (pngdec, "converting grayscale png to RGB");
-    png_set_gray_to_rgb (pngdec->png);
     if (bpc < 8) {              /* Convert to 8 bits */
       GST_LOG_OBJECT (pngdec, "converting grayscale image to 8 bits");
 #if PNG_LIBPNG_VER < 10400
@@ -430,9 +436,15 @@ gst_pngdec_caps_create_and_set (GstPngDec * pngdec)
       pngdec->bpp = 3 * bpc;
       break;
     case PNG_COLOR_TYPE_RGB_ALPHA:
-      GST_LOG_OBJECT (pngdec, "we have an alpha channel, depth is 32 bits");
+      GST_LOG_OBJECT (pngdec,
+          "we have an alpha channel, depth is 32 or 64 bits");
       pngdec->bpp = 4 * bpc;
       break;
+    case PNG_COLOR_TYPE_GRAY:
+      GST_LOG_OBJECT (pngdec,
+          "We have an gray image, depth is 8 or 16 (be) bits");
+      pngdec->bpp = bpc;
+      break;
     default:
       GST_ELEMENT_ERROR (pngdec, STREAM, NOT_IMPLEMENTED, (NULL),
           ("pngdec does not support this color type"));
@@ -440,11 +452,28 @@ gst_pngdec_caps_create_and_set (GstPngDec * pngdec)
       goto beach;
   }
 
-  caps = gst_caps_new_simple ("video/x-raw-rgb",
-      "width", G_TYPE_INT, pngdec->width,
-      "height", G_TYPE_INT, pngdec->height,
-      "bpp", G_TYPE_INT, pngdec->bpp,
-      "framerate", GST_TYPE_FRACTION, pngdec->fps_n, pngdec->fps_d, NULL);
+  if (pngdec->color_type == PNG_COLOR_TYPE_GRAY) {
+    if (pngdec->bpp < 16) {
+      caps = gst_caps_new_simple ("video/x-raw-gray",
+          "width", G_TYPE_INT, pngdec->width,
+          "height", G_TYPE_INT, pngdec->height,
+          "bpp", G_TYPE_INT, pngdec->bpp,
+          "framerate", GST_TYPE_FRACTION, pngdec->fps_n, pngdec->fps_d, NULL);
+    } else {
+      caps = gst_caps_new_simple ("video/x-raw-gray",
+          "width", G_TYPE_INT, pngdec->width,
+          "height", G_TYPE_INT, pngdec->height,
+          "bpp", G_TYPE_INT, pngdec->bpp,
+          "endianness", G_TYPE_INT, G_BIG_ENDIAN,
+          "framerate", GST_TYPE_FRACTION, pngdec->fps_n, pngdec->fps_d, NULL);
+    }
+  } else {
+    caps = gst_caps_new_simple ("video/x-raw-rgb",
+        "width", G_TYPE_INT, pngdec->width,
+        "height", G_TYPE_INT, pngdec->height,
+        "bpp", G_TYPE_INT, pngdec->bpp,
+        "framerate", GST_TYPE_FRACTION, pngdec->fps_n, pngdec->fps_d, NULL);
+  }
 
   templ = gst_static_pad_template_get (&gst_pngdec_src_pad_template);
 
diff --git a/ext/libpng/gstpngenc.c b/ext/libpng/gstpngenc.c
index 30986cd..b30d04f 100644
--- a/ext/libpng/gstpngenc.c
+++ b/ext/libpng/gstpngenc.c
@@ -66,7 +66,7 @@ static GstStaticPadTemplate pngenc_sink_template =
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS (GST_VIDEO_CAPS_RGBA ";" GST_VIDEO_CAPS_RGB ";"
-        GST_VIDEO_CAPS_GRAY8)
+        GST_VIDEO_CAPS_GRAY8 ";" GST_VIDEO_CAPS_GRAY16 ("BIG_ENDIAN"))
     );
 
 /* static GstElementClass *parent_class = NULL; */
@@ -167,6 +167,7 @@ gst_pngenc_setcaps (GstPad * pad, GstCaps * caps)
       pngenc->png_color_type = PNG_COLOR_TYPE_RGB;
       break;
     case GST_VIDEO_FORMAT_GRAY8:
+    case GST_VIDEO_FORMAT_GRAY16_BE:
       pngenc->png_color_type = PNG_COLOR_TYPE_GRAY;
       break;
     default:
@@ -174,6 +175,15 @@ gst_pngenc_setcaps (GstPad * pad, GstCaps * caps)
       goto done;
   }
 
+  switch (format) {
+    case GST_VIDEO_FORMAT_GRAY16_BE:
+      pngenc->depth = 16;
+      break;
+    default:                   /* GST_VIDEO_FORMAT_RGB and GST_VIDEO_FORMAT_GRAY8 */
+      pngenc->depth = 8;
+      break;
+  }
+
   if (G_UNLIKELY (pngenc->width < 16 || pngenc->width > 1000000 ||
           pngenc->height < 16 || pngenc->height > 1000000)) {
     ret = FALSE;
@@ -321,7 +331,7 @@ gst_pngenc_chain (GstPad * pad, GstBuffer * buf)
       pngenc->png_info_ptr,
       pngenc->width,
       pngenc->height,
-      8,
+      pngenc->depth,
       pngenc->png_color_type,
       PNG_INTERLACE_NONE,
       PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
diff --git a/ext/libpng/gstpngenc.h b/ext/libpng/gstpngenc.h
index 792a7c9..1c521ca 100644
--- a/ext/libpng/gstpngenc.h
+++ b/ext/libpng/gstpngenc.h
@@ -50,6 +50,7 @@ struct _GstPngEnc
   png_infop png_info_ptr;
 
   gint png_color_type;
+  gint depth;
   gint width;
   gint height;
   gint stride;
diff --git a/ext/pulse/pulseaudiosink.c b/ext/pulse/pulseaudiosink.c
index cd9f7d9..22b439b 100644
--- a/ext/pulse/pulseaudiosink.c
+++ b/ext/pulse/pulseaudiosink.c
@@ -279,7 +279,9 @@ param_spec_copy (GParamSpec * spec)
 
   g_warning ("Unknown param type %ld for '%s'",
       (long) G_PARAM_SPEC_TYPE (spec), name);
-  g_assert_not_reached ();
+
+  /* Make compiler happy */
+  return NULL;
 }
 
 static void
diff --git a/ext/pulse/pulseprobe.c b/ext/pulse/pulseprobe.c
index 6ebbfb2..8024b5f 100644
--- a/ext/pulse/pulseprobe.c
+++ b/ext/pulse/pulseprobe.c
@@ -21,6 +21,10 @@
  *  USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/ext/speex/gstspeexdec.c b/ext/speex/gstspeexdec.c
index e1d80b6..5abce70 100644
--- a/ext/speex/gstspeexdec.c
+++ b/ext/speex/gstspeexdec.c
@@ -309,8 +309,9 @@ gst_speex_dec_parse_comments (GstSpeexDec * dec, GstBuffer * buf)
 
   GST_INFO_OBJECT (dec, "tags: %" GST_PTR_FORMAT, list);
 
-  gst_element_found_tags_for_pad (GST_ELEMENT (dec),
-      GST_AUDIO_DECODER_SRC_PAD (dec), list);
+  gst_audio_decoder_merge_tags (GST_AUDIO_DECODER (dec), list,
+      GST_TAG_MERGE_REPLACE);
+  gst_tag_list_free (list);
 
   g_free (encoder);
   g_free (ver);
diff --git a/ext/taglib/Makefile.am b/ext/taglib/Makefile.am
index 75459c5..3b2e94c 100644
--- a/ext/taglib/Makefile.am
+++ b/ext/taglib/Makefile.am
@@ -1,6 +1,6 @@
 plugin_LTLIBRARIES = libgsttaglib.la
 
-libgsttaglib_la_SOURCES = gsttaglibmux.c gstid3v2mux.cc gstapev2mux.cc
+libgsttaglib_la_SOURCES = gsttaglibplugin.c gstid3v2mux.cc gstapev2mux.cc
 libgsttaglib_la_CFLAGS = \
 	$(GST_PLUGINS_BASE_CFLAGS) \
 	$(GST_CFLAGS) \
@@ -16,4 +16,4 @@ libgsttaglib_la_LIBADD = \
 libgsttaglib_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgsttaglib_la_LIBTOOLFLAGS = --tag=disable-static
 
-noinst_HEADERS = gsttaglibmux.h gstid3v2mux.h gstapev2mux.h
+noinst_HEADERS = gstid3v2mux.h gstapev2mux.h
diff --git a/ext/taglib/gstapev2mux.cc b/ext/taglib/gstapev2mux.cc
index c99a31f..8863652 100644
--- a/ext/taglib/gstapev2mux.cc
+++ b/ext/taglib/gstapev2mux.cc
@@ -64,17 +64,25 @@ static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("application/x-apetag"));
 
-GST_BOILERPLATE (GstApev2Mux, gst_apev2_mux, GstTagLibMux,
-    GST_TYPE_TAG_LIB_MUX);
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("ANY"));
+
+GST_BOILERPLATE (GstApev2Mux, gst_apev2_mux, GstTagMux,
+    GST_TYPE_TAG_MUX);
 
-static GstBuffer *gst_apev2_mux_render_tag (GstTagLibMux * mux,
-    GstTagList * taglist);
+static GstBuffer *gst_apev2_mux_render_tag (GstTagMux * mux,
+    const GstTagList * taglist);
+static GstBuffer *gst_apev2_mux_render_end_tag (GstTagMux * mux,
+    const GstTagList * taglist);
 
 static void
 gst_apev2_mux_base_init (gpointer g_class)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
 
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
   gst_element_class_add_static_pad_template (element_class, &src_template);
 
   gst_element_class_set_details_simple (element_class,
@@ -89,8 +97,10 @@ gst_apev2_mux_base_init (gpointer g_class)
 static void
 gst_apev2_mux_class_init (GstApev2MuxClass * klass)
 {
-  GST_TAG_LIB_MUX_CLASS (klass)->render_tag =
+  GST_TAG_MUX_CLASS (klass)->render_start_tag =
       GST_DEBUG_FUNCPTR (gst_apev2_mux_render_tag);
+  GST_TAG_MUX_CLASS (klass)->render_end_tag =
+      GST_DEBUG_FUNCPTR (gst_apev2_mux_render_end_tag);
 }
 
 static void
@@ -339,11 +349,12 @@ add_one_tag (const GstTagList * list, const gchar * tag, gpointer user_data)
 }
 
 static GstBuffer *
-gst_apev2_mux_render_tag (GstTagLibMux * mux, GstTagList * taglist)
+gst_apev2_mux_render_tag (GstTagMux * mux, const GstTagList * taglist)
 {
   APE::Tag apev2tag;
   ByteVector rendered_tag;
   GstBuffer *buf;
+  GstCaps *caps;
   guint tag_size;
 
   /* Render the tag */
@@ -357,17 +368,16 @@ gst_apev2_mux_render_tag (GstTagLibMux * mux, GstTagList * taglist)
   /* Create buffer with tag */
   buf = gst_buffer_new_and_alloc (tag_size);
   memcpy (GST_BUFFER_DATA (buf), rendered_tag.data (), tag_size);
-  gst_buffer_set_caps (buf, GST_PAD_CAPS (mux->srcpad));
+
+  caps = gst_static_pad_template_get_caps (&src_template);
+  gst_buffer_set_caps (buf, caps);
+  gst_caps_unref (caps);
 
   return buf;
 }
 
-gboolean
-gst_apev2_mux_plugin_init (GstPlugin * plugin)
+static GstBuffer *
+gst_apev2_mux_render_end_tag (GstTagMux * mux, const GstTagList * taglist)
 {
-  if (!gst_element_register (plugin, "apev2mux", GST_RANK_NONE,
-          GST_TYPE_APEV2_MUX))
-    return FALSE;
-
-  return TRUE;
+  return NULL;
 }
diff --git a/ext/taglib/gstapev2mux.h b/ext/taglib/gstapev2mux.h
index 8dd9333..9539a6a 100644
--- a/ext/taglib/gstapev2mux.h
+++ b/ext/taglib/gstapev2mux.h
@@ -22,7 +22,7 @@
 #ifndef GST_APEV2_MUX_H
 #define GST_APEV2_MUX_H
 
-#include "gsttaglibmux.h"
+#include <gst/tag/gsttagmux.h>
 
 G_BEGIN_DECLS
 
@@ -30,11 +30,11 @@ typedef struct _GstApev2Mux GstApev2Mux;
 typedef struct _GstApev2MuxClass GstApev2MuxClass;
 
 struct _GstApev2Mux {
-  GstTagLibMux  taglibmux;
+  GstTagMux  tagmux;
 };
 
 struct _GstApev2MuxClass {
-  GstTagLibMuxClass  taglibmux_class;
+  GstTagMuxClass  tagmux_class;
 };
 
 #define GST_TYPE_APEV2_MUX \
diff --git a/ext/taglib/gstid3v2mux.cc b/ext/taglib/gstid3v2mux.cc
index 2b5042e..cd61e91 100644
--- a/ext/taglib/gstid3v2mux.cc
+++ b/ext/taglib/gstid3v2mux.cc
@@ -72,18 +72,24 @@ static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("application/x-id3"));
 
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("ANY"));
 
-GST_BOILERPLATE (GstId3v2Mux, gst_id3v2_mux, GstTagLibMux,
-    GST_TYPE_TAG_LIB_MUX);
+GST_BOILERPLATE (GstId3v2Mux, gst_id3v2_mux, GstTagMux, GST_TYPE_TAG_MUX);
 
-static GstBuffer *gst_id3v2_mux_render_tag (GstTagLibMux * mux,
-    GstTagList * taglist);
+static GstBuffer *gst_id3v2_mux_render_tag (GstTagMux * mux,
+    const GstTagList * taglist);
+static GstBuffer *gst_id3v2_mux_render_end_tag (GstTagMux * mux,
+    const GstTagList * taglist);
 
 static void
 gst_id3v2_mux_base_init (gpointer g_class)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
 
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
   gst_element_class_add_static_pad_template (element_class, &src_template);
 
   gst_element_class_set_details_simple (element_class,
@@ -98,8 +104,10 @@ gst_id3v2_mux_base_init (gpointer g_class)
 static void
 gst_id3v2_mux_class_init (GstId3v2MuxClass * klass)
 {
-  GST_TAG_LIB_MUX_CLASS (klass)->render_tag =
+  GST_TAG_MUX_CLASS (klass)->render_start_tag =
       GST_DEBUG_FUNCPTR (gst_id3v2_mux_render_tag);
+  GST_TAG_MUX_CLASS (klass)->render_end_tag =
+      GST_DEBUG_FUNCPTR (gst_id3v2_mux_render_end_tag);
 }
 
 static void
@@ -723,11 +731,12 @@ foreach_add_tag (const GstTagList * list, const gchar * tag, gpointer userdata)
 }
 
 static GstBuffer *
-gst_id3v2_mux_render_tag (GstTagLibMux * mux, GstTagList * taglist)
+gst_id3v2_mux_render_tag (GstTagMux * mux, const GstTagList * taglist)
 {
   ID3v2::Tag id3v2tag;
   ByteVector rendered_tag;
   GstBuffer *buf;
+  GstCaps *caps;
   guint tag_size;
 
   /* write all strings as UTF-8 by default */
@@ -757,19 +766,16 @@ gst_id3v2_mux_render_tag (GstTagLibMux * mux, GstTagList * taglist)
   /* Create buffer with tag */
   buf = gst_buffer_new_and_alloc (tag_size);
   memcpy (GST_BUFFER_DATA (buf), rendered_tag.data (), tag_size);
-  gst_buffer_set_caps (buf, GST_PAD_CAPS (mux->srcpad));
+
+  caps = gst_static_pad_template_get_caps (&src_template);
+  gst_buffer_set_caps (buf, caps);
+  gst_caps_unref (caps);
 
   return buf;
 }
 
-gboolean
-gst_id3v2_mux_plugin_init (GstPlugin * plugin)
+static GstBuffer *
+gst_id3v2_mux_render_end_tag (GstTagMux * mux, const GstTagList * taglist)
 {
-  if (!gst_element_register (plugin, "id3v2mux", GST_RANK_NONE,
-          GST_TYPE_ID3V2_MUX))
-    return FALSE;
-
-  gst_tag_register_musicbrainz_tags ();
-
-  return TRUE;
+  return NULL;
 }
diff --git a/ext/taglib/gstid3v2mux.h b/ext/taglib/gstid3v2mux.h
index 9d47d30..1a66b95 100644
--- a/ext/taglib/gstid3v2mux.h
+++ b/ext/taglib/gstid3v2mux.h
@@ -21,7 +21,7 @@
 #ifndef GST_ID3V2_MUX_H
 #define GST_ID3V2_MUX_H
 
-#include "gsttaglibmux.h"
+#include <gst/tag/gsttagmux.h>
 
 G_BEGIN_DECLS
 
@@ -29,11 +29,11 @@ typedef struct _GstId3v2Mux GstId3v2Mux;
 typedef struct _GstId3v2MuxClass GstId3v2MuxClass;
 
 struct _GstId3v2Mux {
-  GstTagLibMux  taglibmux;
+  GstTagMux  tagmux;
 };
 
 struct _GstId3v2MuxClass {
-  GstTagLibMuxClass  taglibmux_class;
+  GstTagMuxClass  tagmux_class;
 };
 
 #define GST_TYPE_ID3V2_MUX \
diff --git a/ext/taglib/gsttaglibmux.c b/ext/taglib/gsttaglibmux.c
deleted file mode 100644
index 094bec1..0000000
--- a/ext/taglib/gsttaglibmux.c
+++ /dev/null
@@ -1,402 +0,0 @@
-/* GStreamer taglib-based muxer base class
- * Copyright (C) 2006 Christophe Fergeau  <teuf@gnome.org>
- * Copyright (C) 2006 Tim-Philipp Müller <tim centricular net>
- * Copyright (C) 2006 Sebastian Dröge <slomo@circular-chaos.org>
-
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <string.h>
-#include <gst/gsttagsetter.h>
-#include <gst/tag/tag.h>
-
-#include "gsttaglibmux.h"
-
-GST_DEBUG_CATEGORY_STATIC (gst_tag_lib_mux_debug);
-#define GST_CAT_DEFAULT gst_tag_lib_mux_debug
-
-static GstStaticPadTemplate gst_tag_lib_mux_sink_template =
-GST_STATIC_PAD_TEMPLATE ("sink",
-    GST_PAD_SINK,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("ANY"));
-
-static void
-gst_tag_lib_mux_iface_init (GType taglib_type)
-{
-  static const GInterfaceInfo tag_setter_info = {
-    NULL,
-    NULL,
-    NULL
-  };
-
-  g_type_add_interface_static (taglib_type, GST_TYPE_TAG_SETTER,
-      &tag_setter_info);
-}
-
-GST_BOILERPLATE_FULL (GstTagLibMux, gst_tag_lib_mux,
-    GstElement, GST_TYPE_ELEMENT, gst_tag_lib_mux_iface_init);
-
-
-static GstStateChangeReturn
-gst_tag_lib_mux_change_state (GstElement * element, GstStateChange transition);
-static GstFlowReturn gst_tag_lib_mux_chain (GstPad * pad, GstBuffer * buffer);
-static gboolean gst_tag_lib_mux_sink_event (GstPad * pad, GstEvent * event);
-
-static void
-gst_tag_lib_mux_finalize (GObject * obj)
-{
-  GstTagLibMux *mux = GST_TAG_LIB_MUX (obj);
-
-  if (mux->newsegment_ev) {
-    gst_event_unref (mux->newsegment_ev);
-    mux->newsegment_ev = NULL;
-  }
-
-  if (mux->event_tags) {
-    gst_tag_list_free (mux->event_tags);
-    mux->event_tags = NULL;
-  }
-
-  G_OBJECT_CLASS (parent_class)->finalize (obj);
-}
-
-static void
-gst_tag_lib_mux_base_init (gpointer g_class)
-{
-  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
-
-  gst_element_class_add_static_pad_template (element_class,
-      &gst_tag_lib_mux_sink_template);
-
-  GST_DEBUG_CATEGORY_INIT (gst_tag_lib_mux_debug, "taglibmux", 0,
-      "taglib-based muxer");
-}
-
-static void
-gst_tag_lib_mux_class_init (GstTagLibMuxClass * klass)
-{
-  GObjectClass *gobject_class;
-  GstElementClass *gstelement_class;
-
-  gobject_class = (GObjectClass *) klass;
-  gstelement_class = (GstElementClass *) klass;
-
-  gobject_class->finalize = gst_tag_lib_mux_finalize;
-  gstelement_class->change_state =
-      GST_DEBUG_FUNCPTR (gst_tag_lib_mux_change_state);
-}
-
-static void
-gst_tag_lib_mux_init (GstTagLibMux * mux, GstTagLibMuxClass * mux_class)
-{
-  GstElementClass *element_klass = GST_ELEMENT_CLASS (mux_class);
-  GstPadTemplate *tmpl;
-
-  /* pad through which data comes in to the element */
-  mux->sinkpad =
-      gst_pad_new_from_static_template (&gst_tag_lib_mux_sink_template, "sink");
-  gst_pad_set_chain_function (mux->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_tag_lib_mux_chain));
-  gst_pad_set_event_function (mux->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_tag_lib_mux_sink_event));
-  gst_element_add_pad (GST_ELEMENT (mux), mux->sinkpad);
-
-  /* pad through which data goes out of the element */
-  tmpl = gst_element_class_get_pad_template (element_klass, "src");
-  if (tmpl) {
-    mux->srcpad = gst_pad_new_from_template (tmpl, "src");
-    gst_pad_use_fixed_caps (mux->srcpad);
-    gst_pad_set_caps (mux->srcpad, gst_pad_template_get_caps (tmpl));
-    gst_element_add_pad (GST_ELEMENT (mux), mux->srcpad);
-  }
-
-  mux->render_tag = TRUE;
-}
-
-static GstBuffer *
-gst_tag_lib_mux_render_tag (GstTagLibMux * mux)
-{
-  GstTagLibMuxClass *klass;
-  GstTagMergeMode merge_mode;
-  GstTagSetter *tagsetter;
-  GstBuffer *buffer;
-  const GstTagList *tagsetter_tags;
-  GstTagList *taglist;
-  GstEvent *event;
-
-  tagsetter = GST_TAG_SETTER (mux);
-
-  tagsetter_tags = gst_tag_setter_get_tag_list (tagsetter);
-  merge_mode = gst_tag_setter_get_tag_merge_mode (tagsetter);
-
-  GST_LOG_OBJECT (mux, "merging tags, merge mode = %d", merge_mode);
-  GST_LOG_OBJECT (mux, "event tags: %" GST_PTR_FORMAT, mux->event_tags);
-  GST_LOG_OBJECT (mux, "set   tags: %" GST_PTR_FORMAT, tagsetter_tags);
-
-  taglist = gst_tag_list_merge (tagsetter_tags, mux->event_tags, merge_mode);
-
-  GST_LOG_OBJECT (mux, "final tags: %" GST_PTR_FORMAT, taglist);
-
-  klass = GST_TAG_LIB_MUX_CLASS (G_OBJECT_GET_CLASS (mux));
-
-  if (klass->render_tag == NULL)
-    goto no_vfunc;
-
-  buffer = klass->render_tag (mux, taglist);
-
-  if (buffer == NULL)
-    goto render_error;
-
-  mux->tag_size = GST_BUFFER_SIZE (buffer);
-  GST_LOG_OBJECT (mux, "tag size = %" G_GSIZE_FORMAT " bytes", mux->tag_size);
-
-  /* Send newsegment event from byte position 0, so the tag really gets
-   * written to the start of the file, independent of the upstream segment */
-  gst_pad_push_event (mux->srcpad,
-      gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_BYTES, 0, -1, 0));
-
-  /* Send an event about the new tags to downstream elements */
-  /* gst_event_new_tag takes ownership of the list, so no need to unref it */
-  event = gst_event_new_tag (taglist);
-  gst_pad_push_event (mux->srcpad, event);
-
-  GST_BUFFER_OFFSET (buffer) = 0;
-
-  return buffer;
-
-no_vfunc:
-  {
-    GST_ERROR_OBJECT (mux, "Subclass does not implement render_tag vfunc!");
-    gst_tag_list_free (taglist);
-    return NULL;
-  }
-
-render_error:
-  {
-    GST_ERROR_OBJECT (mux, "Failed to render tag");
-    gst_tag_list_free (taglist);
-    return NULL;
-  }
-}
-
-static GstEvent *
-gst_tag_lib_mux_adjust_event_offsets (GstTagLibMux * mux,
-    const GstEvent * newsegment_event)
-{
-  GstFormat format;
-  gint64 start, stop, cur;
-
-  gst_event_parse_new_segment ((GstEvent *) newsegment_event, NULL, NULL,
-      &format, &start, &stop, &cur);
-
-  g_assert (format == GST_FORMAT_BYTES);
-
-  if (start != -1)
-    start += mux->tag_size;
-  if (stop != -1)
-    stop += mux->tag_size;
-  if (cur != -1)
-    cur += mux->tag_size;
-
-  GST_DEBUG_OBJECT (mux, "adjusting newsegment event offsets to start=%"
-      G_GINT64_FORMAT ", stop=%" G_GINT64_FORMAT ", cur=%" G_GINT64_FORMAT
-      " (delta = +%" G_GSIZE_FORMAT ")", start, stop, cur, mux->tag_size);
-
-  return gst_event_new_new_segment (TRUE, 1.0, format, start, stop, cur);
-}
-
-static GstFlowReturn
-gst_tag_lib_mux_chain (GstPad * pad, GstBuffer * buffer)
-{
-  GstTagLibMux *mux = GST_TAG_LIB_MUX (GST_OBJECT_PARENT (pad));
-
-  if (mux->render_tag) {
-    GstFlowReturn ret;
-    GstBuffer *tag_buffer;
-
-    GST_INFO_OBJECT (mux, "Adding tags to stream");
-    tag_buffer = gst_tag_lib_mux_render_tag (mux);
-    if (tag_buffer == NULL)
-      goto no_tag_buffer;
-    ret = gst_pad_push (mux->srcpad, tag_buffer);
-    if (ret != GST_FLOW_OK) {
-      GST_DEBUG_OBJECT (mux, "flow: %s", gst_flow_get_name (ret));
-      gst_buffer_unref (buffer);
-      return ret;
-    }
-
-    /* Now send the cached newsegment event that we got from upstream */
-    if (mux->newsegment_ev) {
-      GST_DEBUG_OBJECT (mux, "sending cached newsegment event");
-      gst_pad_push_event (mux->srcpad,
-          gst_tag_lib_mux_adjust_event_offsets (mux, mux->newsegment_ev));
-      gst_event_unref (mux->newsegment_ev);
-      mux->newsegment_ev = NULL;
-    } else {
-      /* upstream sent no newsegment event or only one in a non-BYTE format */
-    }
-
-    mux->render_tag = FALSE;
-  }
-
-  buffer = gst_buffer_make_metadata_writable (buffer);
-
-  if (GST_BUFFER_OFFSET (buffer) != GST_BUFFER_OFFSET_NONE) {
-    GST_LOG_OBJECT (mux, "Adjusting buffer offset from %" G_GINT64_FORMAT
-        " to %" G_GINT64_FORMAT, GST_BUFFER_OFFSET (buffer),
-        GST_BUFFER_OFFSET (buffer) + mux->tag_size);
-    GST_BUFFER_OFFSET (buffer) += mux->tag_size;
-  }
-
-  gst_buffer_set_caps (buffer, GST_PAD_CAPS (mux->srcpad));
-  return gst_pad_push (mux->srcpad, buffer);
-
-/* ERRORS */
-no_tag_buffer:
-  {
-    GST_ELEMENT_ERROR (mux, LIBRARY, ENCODE, (NULL), (NULL));
-    return GST_FLOW_ERROR;
-  }
-}
-
-static gboolean
-gst_tag_lib_mux_sink_event (GstPad * pad, GstEvent * event)
-{
-  GstTagLibMux *mux;
-  gboolean result;
-
-  mux = GST_TAG_LIB_MUX (gst_pad_get_parent (pad));
-  result = FALSE;
-
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_TAG:{
-      GstTagList *tags;
-
-      gst_event_parse_tag (event, &tags);
-
-      GST_INFO_OBJECT (mux, "Got tag event: %" GST_PTR_FORMAT, tags);
-
-      if (mux->event_tags != NULL) {
-        gst_tag_list_insert (mux->event_tags, tags, GST_TAG_MERGE_REPLACE);
-      } else {
-        mux->event_tags = gst_tag_list_copy (tags);
-      }
-
-      GST_INFO_OBJECT (mux, "Event tags are now: %" GST_PTR_FORMAT,
-          mux->event_tags);
-
-      /* just drop the event, we'll push a new tag event in render_tag */
-      gst_event_unref (event);
-      result = TRUE;
-      break;
-    }
-    case GST_EVENT_NEWSEGMENT:{
-      GstFormat fmt;
-
-      gst_event_parse_new_segment (event, NULL, NULL, &fmt, NULL, NULL, NULL);
-
-      if (fmt != GST_FORMAT_BYTES) {
-        GST_WARNING_OBJECT (mux, "dropping newsegment event in %s format",
-            gst_format_get_name (fmt));
-        gst_event_unref (event);
-        break;
-      }
-
-      if (mux->render_tag) {
-        /* we have not rendered the tag yet, which means that we don't know
-         * how large it is going to be yet, so we can't adjust the offsets
-         * here at this point and need to cache the newsegment event for now
-         * (also, there could be tag events coming after this newsegment event
-         *  and before the first buffer). */
-        if (mux->newsegment_ev) {
-          GST_WARNING_OBJECT (mux, "discarding old cached newsegment event");
-          gst_event_unref (mux->newsegment_ev);
-        }
-
-        GST_LOG_OBJECT (mux, "caching newsegment event for later");
-        mux->newsegment_ev = event;
-      } else {
-        GST_DEBUG_OBJECT (mux, "got newsegment event, adjusting offsets");
-        gst_pad_push_event (mux->srcpad,
-            gst_tag_lib_mux_adjust_event_offsets (mux, event));
-        gst_event_unref (event);
-      }
-      event = NULL;
-      result = TRUE;
-      break;
-    }
-    default:
-      result = gst_pad_event_default (pad, event);
-      break;
-  }
-
-  gst_object_unref (mux);
-
-  return result;
-}
-
-
-static GstStateChangeReturn
-gst_tag_lib_mux_change_state (GstElement * element, GstStateChange transition)
-{
-  GstTagLibMux *mux;
-  GstStateChangeReturn result;
-
-  mux = GST_TAG_LIB_MUX (element);
-
-  result = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
-  if (result != GST_STATE_CHANGE_SUCCESS) {
-    return result;
-  }
-
-  switch (transition) {
-    case GST_STATE_CHANGE_PAUSED_TO_READY:{
-      if (mux->newsegment_ev) {
-        gst_event_unref (mux->newsegment_ev);
-        mux->newsegment_ev = NULL;
-      }
-      if (mux->event_tags) {
-        gst_tag_list_free (mux->event_tags);
-        mux->event_tags = NULL;
-      }
-      mux->tag_size = 0;
-      mux->render_tag = TRUE;
-      break;
-    }
-    default:
-      break;
-  }
-
-  return result;
-}
-
-static gboolean
-plugin_init (GstPlugin * plugin)
-{
-  return (gst_id3v2_mux_plugin_init (plugin)
-      && gst_apev2_mux_plugin_init (plugin));
-}
-
-GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
-    GST_VERSION_MINOR,
-    "taglib",
-    "Tag writing plug-in based on taglib",
-    plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
diff --git a/ext/taglib/gsttaglibmux.h b/ext/taglib/gsttaglibmux.h
deleted file mode 100644
index d26ff30..0000000
--- a/ext/taglib/gsttaglibmux.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/* GStreamer taglib-based muxer base class
- * Copyright (C) 2006 Christophe Fergeau  <teuf@gnome.org>
- * Copyright (C) 2006 Tim-Philipp Müller <tim centricular net>
-
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GST_TAG_LIB_MUX_H
-#define GST_TAG_LIB_MUX_H
-
-#include <gst/gst.h>
-
-G_BEGIN_DECLS
-
-typedef struct _GstTagLibMux GstTagLibMux;
-typedef struct _GstTagLibMuxClass GstTagLibMuxClass;
-
-/* Definition of structure storing data for this element. */
-struct _GstTagLibMux {
-  GstElement    element;
-
-  GstPad       *srcpad;
-  GstPad       *sinkpad;
-  GstTagList   *event_tags; /* tags received from upstream elements */
-  gsize         tag_size;
-  gboolean      render_tag;
-
-  GstEvent     *newsegment_ev; /* cached newsegment event from upstream */
-};
-
-/* Standard definition defining a class for this element. */
-struct _GstTagLibMuxClass {
-  GstElementClass parent_class;
-
-  /* vfuncs */
-  GstBuffer  * (*render_tag) (GstTagLibMux * mux, GstTagList * tag_list);
-};
-
-/* Standard macros for defining types for this element.  */
-#define GST_TYPE_TAG_LIB_MUX \
-  (gst_tag_lib_mux_get_type())
-#define GST_TAG_LIB_MUX(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TAG_LIB_MUX,GstTagLibMux))
-#define GST_TAG_LIB_MUX_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TAG_LIB_MUX,GstTagLibMuxClass))
-#define GST_IS_TAG_LIB_MUX(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TAG_LIB_MUX))
-#define GST_IS_TAG_LIB_MUX_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TAG_LIB_MUX))
-
-/* Standard function returning type information. */
-GType gst_tag_lib_mux_get_type (void);
-gboolean gst_apev2_mux_plugin_init (GstPlugin * plugin);
-gboolean gst_id3v2_mux_plugin_init (GstPlugin * plugin);
-
-G_END_DECLS
-
-#endif
diff --git a/ext/taglib/gsttaglibplugin.c b/ext/taglib/gsttaglibplugin.c
new file mode 100644
index 0000000..67ac332
--- /dev/null
+++ b/ext/taglib/gsttaglibplugin.c
@@ -0,0 +1,49 @@
+/* GStreamer taglib-based muxer base class
+ * Copyright (C) 2006 Christophe Fergeau  <teuf@gnome.org>
+ * Copyright (C) 2006 Tim-Philipp Müller <tim centricular net>
+ * Copyright (C) 2006 Sebastian Dröge <slomo@circular-chaos.org>
+
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gstapev2mux.h"
+#include "gstid3v2mux.h"
+
+#include <gst/tag/tag.h>
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  if (!gst_element_register (plugin, "id3v2mux", GST_RANK_NONE,
+          GST_TYPE_ID3V2_MUX) ||
+      !gst_element_register (plugin, "apev2mux", GST_RANK_NONE,
+          GST_TYPE_APEV2_MUX))
+    return FALSE;
+
+  gst_tag_register_musicbrainz_tags ();
+
+  return TRUE;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "taglib",
+    "Tag writing plug-in based on taglib",
+    plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
diff --git a/ext/wavpack/gstwavpackdec.c b/ext/wavpack/gstwavpackdec.c
index 4ba242d..05caa08 100644
--- a/ext/wavpack/gstwavpackdec.c
+++ b/ext/wavpack/gstwavpackdec.c
@@ -55,8 +55,6 @@
 #include "gstwavpackstreamreader.h"
 
 
-#define WAVPACK_DEC_MAX_ERRORS 16
-
 GST_DEBUG_CATEGORY_STATIC (gst_wavpack_dec_debug);
 #define GST_CAT_DEFAULT gst_wavpack_dec_debug
 
@@ -73,22 +71,34 @@ static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("audio/x-raw-int, "
-        "width = (int) 32, "
-        "depth = (int) [ 1, 32 ], "
+        "width = (int) 8, depth = (int) 8, "
+        "channels = (int) [ 1, 8 ], "
+        "rate = (int) [ 6000, 192000 ], "
+        "endianness = (int) BYTE_ORDER, " "signed = (boolean) true; "
+        "audio/x-raw-int, "
+        "width = (int) 16, depth = (int) 16, "
         "channels = (int) [ 1, 8 ], "
         "rate = (int) [ 6000, 192000 ], "
-        "endianness = (int) BYTE_ORDER, " "signed = (boolean) true")
+        "endianness = (int) BYTE_ORDER, " "signed = (boolean) true; "
+        "audio/x-raw-int, "
+        "width = (int) 32, depth = (int) 32, "
+        "channels = (int) [ 1, 8 ], "
+        "rate = (int) [ 6000, 192000 ], "
+        "endianness = (int) BYTE_ORDER, " "signed = (boolean) true; ")
     );
 
-static GstFlowReturn gst_wavpack_dec_chain (GstPad * pad, GstBuffer * buffer);
-static gboolean gst_wavpack_dec_sink_set_caps (GstPad * pad, GstCaps * caps);
-static gboolean gst_wavpack_dec_sink_event (GstPad * pad, GstEvent * event);
+static gboolean gst_wavpack_dec_start (GstAudioDecoder * dec);
+static gboolean gst_wavpack_dec_stop (GstAudioDecoder * dec);
+static gboolean gst_wavpack_dec_set_format (GstAudioDecoder * dec,
+    GstCaps * caps);
+static GstFlowReturn gst_wavpack_dec_handle_frame (GstAudioDecoder * dec,
+    GstBuffer * buffer);
+
 static void gst_wavpack_dec_finalize (GObject * object);
-static GstStateChangeReturn gst_wavpack_dec_change_state (GstElement * element,
-    GstStateChange transition);
 static void gst_wavpack_dec_post_tags (GstWavpackDec * dec);
 
-GST_BOILERPLATE (GstWavpackDec, gst_wavpack_dec, GstElement, GST_TYPE_ELEMENT);
+GST_BOILERPLATE (GstWavpackDec, gst_wavpack_dec, GstAudioDecoder,
+    GST_TYPE_AUDIO_DECODER);
 
 static void
 gst_wavpack_dec_base_init (gpointer klass)
@@ -108,11 +118,14 @@ static void
 gst_wavpack_dec_class_init (GstWavpackDecClass * klass)
 {
   GObjectClass *gobject_class = (GObjectClass *) klass;
-  GstElementClass *gstelement_class = (GstElementClass *) klass;
+  GstAudioDecoderClass *base_class = (GstAudioDecoderClass *) (klass);
 
-  gstelement_class->change_state =
-      GST_DEBUG_FUNCPTR (gst_wavpack_dec_change_state);
   gobject_class->finalize = gst_wavpack_dec_finalize;
+
+  base_class->start = GST_DEBUG_FUNCPTR (gst_wavpack_dec_start);
+  base_class->stop = GST_DEBUG_FUNCPTR (gst_wavpack_dec_stop);
+  base_class->set_format = GST_DEBUG_FUNCPTR (gst_wavpack_dec_set_format);
+  base_class->handle_frame = GST_DEBUG_FUNCPTR (gst_wavpack_dec_handle_frame);
 }
 
 static void
@@ -121,33 +134,15 @@ gst_wavpack_dec_reset (GstWavpackDec * dec)
   dec->wv_id.buffer = NULL;
   dec->wv_id.position = dec->wv_id.length = 0;
 
-  dec->error_count = 0;
-
   dec->channels = 0;
   dec->channel_mask = 0;
   dec->sample_rate = 0;
   dec->depth = 0;
-
-  gst_segment_init (&dec->segment, GST_FORMAT_TIME);
-  dec->next_block_index = 0;
 }
 
 static void
 gst_wavpack_dec_init (GstWavpackDec * dec, GstWavpackDecClass * gklass)
 {
-  dec->sinkpad = gst_pad_new_from_static_template (&sink_factory, "sink");
-  gst_pad_set_chain_function (dec->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_wavpack_dec_chain));
-  gst_pad_set_setcaps_function (dec->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_wavpack_dec_sink_set_caps));
-  gst_pad_set_event_function (dec->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_wavpack_dec_sink_event));
-  gst_element_add_pad (GST_ELEMENT (dec), dec->sinkpad);
-
-  dec->srcpad = gst_pad_new_from_static_template (&src_factory, "src");
-  gst_pad_use_fixed_caps (dec->srcpad);
-  gst_element_add_pad (GST_ELEMENT (dec), dec->srcpad);
-
   dec->context = NULL;
   dec->stream_reader = gst_wavpack_stream_reader_new ();
 
@@ -166,26 +161,81 @@ gst_wavpack_dec_finalize (GObject * object)
 }
 
 static gboolean
-gst_wavpack_dec_sink_set_caps (GstPad * pad, GstCaps * caps)
+gst_wavpack_dec_start (GstAudioDecoder * dec)
 {
-  GstWavpackDec *dec = GST_WAVPACK_DEC (gst_pad_get_parent (pad));
+  GST_DEBUG_OBJECT (dec, "start");
+
+  /* never mind a few errors */
+  gst_audio_decoder_set_max_errors (dec, 16);
+  /* don't bother us with flushing */
+  gst_audio_decoder_set_drainable (dec, FALSE);
+  /* aim for some perfect timestamping */
+  gst_audio_decoder_set_tolerance (dec, 10 * GST_MSECOND);
+
+  return TRUE;
+}
+
+static gboolean
+gst_wavpack_dec_stop (GstAudioDecoder * dec)
+{
+  GstWavpackDec *wpdec = GST_WAVPACK_DEC (dec);
+
+  GST_DEBUG_OBJECT (dec, "stop");
+
+  if (wpdec->context) {
+    WavpackCloseFile (wpdec->context);
+    wpdec->context = NULL;
+  }
+
+  gst_wavpack_dec_reset (wpdec);
+
+  return TRUE;
+}
+
+static void
+gst_wavpack_dec_negotiate (GstWavpackDec * dec)
+{
+  GstCaps *caps;
+
+  /* arrange for 1, 2 or 4-byte width == depth output */
+  if (dec->depth == 24)
+    dec->width = 32;
+  else
+    dec->width = dec->depth;
+
+  caps = gst_caps_new_simple ("audio/x-raw-int",
+      "rate", G_TYPE_INT, dec->sample_rate,
+      "channels", G_TYPE_INT, dec->channels,
+      "depth", G_TYPE_INT, dec->width,
+      "width", G_TYPE_INT, dec->width,
+      "endianness", G_TYPE_INT, G_BYTE_ORDER,
+      "signed", G_TYPE_BOOLEAN, TRUE, NULL);
+
+  /* Only set the channel layout for more than two channels
+   * otherwise things break unfortunately */
+  if (dec->channel_mask != 0 && dec->channels > 2)
+    if (!gst_wavpack_set_channel_layout (caps, dec->channel_mask))
+      GST_WARNING_OBJECT (dec, "Failed to set channel layout");
+
+  GST_DEBUG_OBJECT (dec, "setting caps %" GST_PTR_FORMAT, caps);
+
+  /* should always succeed */
+  gst_pad_set_caps (GST_AUDIO_DECODER_SRC_PAD (dec), caps);
+  gst_caps_unref (caps);
+}
+
+static gboolean
+gst_wavpack_dec_set_format (GstAudioDecoder * bdec, GstCaps * caps)
+{
+  GstWavpackDec *dec = GST_WAVPACK_DEC (bdec);
   GstStructure *structure = gst_caps_get_structure (caps, 0);
 
   /* Check if we can set the caps here already */
   if (gst_structure_get_int (structure, "channels", &dec->channels) &&
       gst_structure_get_int (structure, "rate", &dec->sample_rate) &&
       gst_structure_get_int (structure, "width", &dec->depth)) {
-    GstCaps *caps;
     GstAudioChannelPosition *pos;
 
-    caps = gst_caps_new_simple ("audio/x-raw-int",
-        "rate", G_TYPE_INT, dec->sample_rate,
-        "channels", G_TYPE_INT, dec->channels,
-        "depth", G_TYPE_INT, dec->depth,
-        "width", G_TYPE_INT, 32,
-        "endianness", G_TYPE_INT, G_BYTE_ORDER,
-        "signed", G_TYPE_BOOLEAN, TRUE, NULL);
-
     /* If we already have the channel layout set from upstream
      * take this */
     if (gst_structure_has_field (structure, "channel-positions")) {
@@ -202,19 +252,13 @@ gst_wavpack_dec_sink_set_caps (GstPad * pad, GstCaps * caps)
         g_free (pos);
     }
 
-    GST_DEBUG_OBJECT (dec, "setting caps %" GST_PTR_FORMAT, caps);
-
-    /* should always succeed */
-    gst_pad_set_caps (dec->srcpad, caps);
-    gst_caps_unref (caps);
+    gst_wavpack_dec_negotiate (dec);
 
     /* send GST_TAG_AUDIO_CODEC and GST_TAG_BITRATE tags before something
      * is decoded or after the format has changed */
     gst_wavpack_dec_post_tags (dec);
   }
 
-  gst_object_unref (dec);
-
   return TRUE;
 }
 
@@ -225,28 +269,26 @@ gst_wavpack_dec_post_tags (GstWavpackDec * dec)
   GstFormat format_time = GST_FORMAT_TIME, format_bytes = GST_FORMAT_BYTES;
   gint64 duration, size;
 
-  list = gst_tag_list_new ();
-
-  gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
-      GST_TAG_AUDIO_CODEC, "Wavpack", NULL);
-
   /* try to estimate the average bitrate */
-  if (gst_pad_query_peer_duration (dec->sinkpad, &format_bytes, &size) &&
-      gst_pad_query_peer_duration (dec->sinkpad, &format_time, &duration) &&
-      size > 0 && duration > 0) {
+  if (gst_pad_query_peer_duration (GST_AUDIO_DECODER_SINK_PAD (dec),
+          &format_bytes, &size) &&
+      gst_pad_query_peer_duration (GST_AUDIO_DECODER_SINK_PAD (dec),
+          &format_time, &duration) && size > 0 && duration > 0) {
     guint64 bitrate;
 
+    list = gst_tag_list_new ();
+
     bitrate = gst_util_uint64_scale (size, 8 * GST_SECOND, duration);
     gst_tag_list_add (list, GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE,
         (guint) bitrate, NULL);
-  }
 
-  gst_element_post_message (GST_ELEMENT (dec),
-      gst_message_new_tag (GST_OBJECT (dec), list));
+    gst_element_post_message (GST_ELEMENT (dec),
+        gst_message_new_tag (GST_OBJECT (dec), list));
+  }
 }
 
 static GstFlowReturn
-gst_wavpack_dec_chain (GstPad * pad, GstBuffer * buf)
+gst_wavpack_dec_handle_frame (GstAudioDecoder * bdec, GstBuffer * buf)
 {
   GstWavpackDec *dec;
   GstBuffer *outbuf = NULL;
@@ -254,8 +296,13 @@ gst_wavpack_dec_chain (GstPad * pad, GstBuffer * buf)
   WavpackHeader wph;
   int32_t decoded, unpacked_size;
   gboolean format_changed;
+  gint width, depth, i, max;
+  gint32 *dec_data = NULL;
+  guint8 *out_data;
 
-  dec = GST_WAVPACK_DEC (GST_PAD_PARENT (pad));
+  dec = GST_WAVPACK_DEC (bdec);
+
+  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);
 
   /* check input, we only accept framed input with complete chunks */
   if (GST_BUFFER_SIZE (buf) < sizeof (WavpackHeader))
@@ -283,46 +330,31 @@ gst_wavpack_dec_chain (GstPad * pad, GstBuffer * buf)
     dec->context = WavpackOpenFileInputEx (dec->stream_reader,
         &dec->wv_id, NULL, error_msg, OPEN_STREAMING, 0);
 
+    /* expect this to work */
     if (!dec->context) {
-      GST_WARNING ("Couldn't decode buffer: %s", error_msg);
-      dec->error_count++;
-      if (dec->error_count <= WAVPACK_DEC_MAX_ERRORS) {
-        goto out;               /* just return OK for now */
-      } else {
-        goto decode_error;
-      }
+      GST_WARNING_OBJECT (dec, "Couldn't decode buffer: %s", error_msg);
+      goto context_failed;
     }
   }
 
   g_assert (dec->context != NULL);
 
-  dec->error_count = 0;
-
   format_changed =
       (dec->sample_rate != WavpackGetSampleRate (dec->context)) ||
       (dec->channels != WavpackGetNumChannels (dec->context)) ||
-      (dec->depth != WavpackGetBitsPerSample (dec->context)) ||
+      (dec->depth != WavpackGetBytesPerSample (dec->context) * 8) ||
 #ifdef WAVPACK_OLD_API
       (dec->channel_mask != dec->context->config.channel_mask);
 #else
       (dec->channel_mask != WavpackGetChannelMask (dec->context));
 #endif
 
-  if (!GST_PAD_CAPS (dec->srcpad) || format_changed) {
-    GstCaps *caps;
+  if (!GST_PAD_CAPS (GST_AUDIO_DECODER_SRC_PAD (dec)) || format_changed) {
     gint channel_mask;
 
     dec->sample_rate = WavpackGetSampleRate (dec->context);
     dec->channels = WavpackGetNumChannels (dec->context);
-    dec->depth = WavpackGetBitsPerSample (dec->context);
-
-    caps = gst_caps_new_simple ("audio/x-raw-int",
-        "rate", G_TYPE_INT, dec->sample_rate,
-        "channels", G_TYPE_INT, dec->channels,
-        "depth", G_TYPE_INT, dec->depth,
-        "width", G_TYPE_INT, 32,
-        "endianness", G_TYPE_INT, G_BYTE_ORDER,
-        "signed", G_TYPE_BOOLEAN, TRUE, NULL);
+    dec->depth = WavpackGetBytesPerSample (dec->context) * 8;
 
 #ifdef WAVPACK_OLD_API
     channel_mask = dec->context->config.channel_mask;
@@ -334,17 +366,7 @@ gst_wavpack_dec_chain (GstPad * pad, GstBuffer * buf)
 
     dec->channel_mask = channel_mask;
 
-    /* Only set the channel layout for more than two channels
-     * otherwise things break unfortunately */
-    if (channel_mask != 0 && dec->channels > 2)
-      if (!gst_wavpack_set_channel_layout (caps, channel_mask))
-        GST_WARNING_OBJECT (dec, "Failed to set channel layout");
-
-    GST_DEBUG_OBJECT (dec, "setting caps %" GST_PTR_FORMAT, caps);
-
-    /* should always succeed */
-    gst_pad_set_caps (dec->srcpad, caps);
-    gst_caps_unref (caps);
+    gst_wavpack_dec_negotiate (dec);
 
     /* send GST_TAG_AUDIO_CODEC and GST_TAG_BITRATE tags before something
      * is decoded or after the format has changed */
@@ -352,59 +374,82 @@ gst_wavpack_dec_chain (GstPad * pad, GstBuffer * buf)
   }
 
   /* alloc output buffer */
-  unpacked_size = 4 * wph.block_samples * dec->channels;
-  ret = gst_pad_alloc_buffer (dec->srcpad, GST_BUFFER_OFFSET (buf),
-      unpacked_size, GST_PAD_CAPS (dec->srcpad), &outbuf);
+  unpacked_size = (dec->width / 8) * wph.block_samples * dec->channels;
+  ret = gst_pad_alloc_buffer (GST_AUDIO_DECODER_SRC_PAD (dec),
+      GST_BUFFER_OFFSET (buf), unpacked_size,
+      GST_PAD_CAPS (GST_AUDIO_DECODER_SRC_PAD (dec)), &outbuf);
 
   if (ret != GST_FLOW_OK)
     goto out;
 
-  gst_buffer_copy_metadata (outbuf, buf, GST_BUFFER_COPY_TIMESTAMPS);
-
-  /* If we got a DISCONT buffer forward the flag. Nothing else
-   * has to be done as libwavpack doesn't store state between
-   * Wavpack blocks */
-  if (GST_BUFFER_IS_DISCONT (buf) || dec->next_block_index != wph.block_index)
-    GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DISCONT);
-
-  dec->next_block_index = wph.block_index + wph.block_samples;
+  dec_data = g_malloc (4 * wph.block_samples * dec->channels);
+  out_data = GST_BUFFER_DATA (outbuf);
 
   /* decode */
-  decoded = WavpackUnpackSamples (dec->context,
-      (int32_t *) GST_BUFFER_DATA (outbuf), wph.block_samples);
+  decoded = WavpackUnpackSamples (dec->context, dec_data, wph.block_samples);
   if (decoded != wph.block_samples)
     goto decode_error;
 
-  if ((outbuf = gst_audio_buffer_clip (outbuf, &dec->segment,
-              dec->sample_rate, 4 * dec->channels))) {
-    GST_LOG_OBJECT (dec, "pushing buffer with time %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (outbuf)));
-    ret = gst_pad_push (dec->srcpad, outbuf);
+  width = dec->width;
+  depth = dec->depth;
+  max = dec->channels * wph.block_samples;
+  if (width == 8) {
+    gint8 *outbuffer = (gint8 *) out_data;
+
+    for (i = 0; i < max; i++) {
+      *outbuffer++ = (gint8) (dec_data[i]);
+    }
+  } else if (width == 16) {
+    gint16 *outbuffer = (gint16 *) out_data;
+
+    for (i = 0; i < max; i++) {
+      *outbuffer++ = (gint16) (dec_data[i]);
+    }
+  } else if (dec->width == 32) {
+    gint32 *outbuffer = (gint32 *) out_data;
+
+    if (width != depth) {
+      for (i = 0; i < max; i++) {
+        *outbuffer++ = (gint32) (dec_data[i] << (width - depth));
+      }
+    } else {
+      for (i = 0; i < max; i++) {
+        *outbuffer++ = (gint32) dec_data[i];
+      }
+    }
+  } else {
+    g_assert_not_reached ();
   }
 
+  g_free (dec_data);
+
+  ret = gst_audio_decoder_finish_frame (bdec, outbuf, 1);
+
 out:
 
   if (G_UNLIKELY (ret != GST_FLOW_OK)) {
     GST_DEBUG_OBJECT (dec, "flow: %s", gst_flow_get_name (ret));
   }
 
-  gst_buffer_unref (buf);
-
   return ret;
 
 /* ERRORS */
 input_not_framed:
   {
     GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL), ("Expected framed input"));
-    gst_buffer_unref (buf);
     return GST_FLOW_ERROR;
   }
 invalid_header:
   {
     GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL), ("Invalid wavpack header"));
-    gst_buffer_unref (buf);
     return GST_FLOW_ERROR;
   }
+context_failed:
+  {
+    GST_AUDIO_DECODER_ERROR (bdec, 1, LIBRARY, INIT, (NULL),
+        ("error creating Wavpack context"), ret);
+    goto out;
+  }
 decode_error:
   {
     const gchar *reason = "unknown";
@@ -418,86 +463,15 @@ decode_error:
     } else {
       reason = "couldn't create decoder context";
     }
-    GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL),
-        ("Failed to decode wavpack stream: %s", reason));
+    GST_AUDIO_DECODER_ERROR (bdec, 1, STREAM, DECODE, (NULL),
+        ("decoding error: %s", reason), ret);
+    g_free (dec_data);
     if (outbuf)
       gst_buffer_unref (outbuf);
-    gst_buffer_unref (buf);
-    return GST_FLOW_ERROR;
-  }
-}
-
-static gboolean
-gst_wavpack_dec_sink_event (GstPad * pad, GstEvent * event)
-{
-  GstWavpackDec *dec = GST_WAVPACK_DEC (gst_pad_get_parent (pad));
-
-  GST_LOG_OBJECT (dec, "Received %s event", GST_EVENT_TYPE_NAME (event));
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_NEWSEGMENT:{
-      GstFormat fmt;
-      gboolean is_update;
-      gint64 start, end, base;
-      gdouble rate;
-
-      gst_event_parse_new_segment (event, &is_update, &rate, &fmt, &start,
-          &end, &base);
-      if (fmt == GST_FORMAT_TIME) {
-        GST_DEBUG ("Got NEWSEGMENT event in GST_FORMAT_TIME, passing on (%"
-            GST_TIME_FORMAT " - %" GST_TIME_FORMAT ")", GST_TIME_ARGS (start),
-            GST_TIME_ARGS (end));
-        gst_segment_set_newsegment (&dec->segment, is_update, rate, fmt,
-            start, end, base);
-      } else {
-        gst_segment_init (&dec->segment, GST_FORMAT_TIME);
-      }
-      break;
-    }
-    default:
-      break;
-  }
-
-  gst_object_unref (dec);
-  return gst_pad_event_default (pad, event);
-}
-
-static GstStateChangeReturn
-gst_wavpack_dec_change_state (GstElement * element, GstStateChange transition)
-{
-  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
-  GstWavpackDec *dec = GST_WAVPACK_DEC (element);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_NULL_TO_READY:
-      break;
-    case GST_STATE_CHANGE_READY_TO_PAUSED:
-      break;
-    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
-      break;
-    default:
-      break;
-  }
-
-  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
-      break;
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
-      if (dec->context) {
-        WavpackCloseFile (dec->context);
-        dec->context = NULL;
-      }
-
-      gst_wavpack_dec_reset (dec);
-      break;
-    case GST_STATE_CHANGE_READY_TO_NULL:
-      break;
-    default:
-      break;
+    if (ret == GST_FLOW_OK)
+      gst_audio_decoder_finish_frame (bdec, NULL, 1);
+    return ret;
   }
-
-  return ret;
 }
 
 gboolean
diff --git a/ext/wavpack/gstwavpackdec.h b/ext/wavpack/gstwavpackdec.h
index eb6e4c3..68e8e33 100644
--- a/ext/wavpack/gstwavpackdec.h
+++ b/ext/wavpack/gstwavpackdec.h
@@ -24,6 +24,7 @@
 #define __GST_WAVPACK_DEC_H__
 
 #include <gst/gst.h>
+#include <gst/audio/gstaudiodecoder.h>
 
 #include <wavpack/wavpack.h>
 
@@ -45,31 +46,25 @@ typedef struct _GstWavpackDecClass GstWavpackDecClass;
 
 struct _GstWavpackDec
 {
-  GstElement element;
+  GstAudioDecoder element;
 
   /*< private > */
-  GstPad *sinkpad;
-  GstPad *srcpad;
 
   WavpackContext *context;
   WavpackStreamReader *stream_reader;
 
   read_id wv_id;
 
-  GstSegment segment;           /* used for clipping, TIME format */
-  guint32 next_block_index;
-
   gint sample_rate;
   gint depth;
+  gint width;
   gint channels;
   gint channel_mask;
-
-  gint error_count;
 };
 
 struct _GstWavpackDecClass
 {
-  GstElementClass parent;
+  GstAudioDecoderClass parent;
 };
 
 GType gst_wavpack_dec_get_type (void);
diff --git a/ext/wavpack/gstwavpackenc.c b/ext/wavpack/gstwavpackenc.c
index a22dd23..5094769 100644
--- a/ext/wavpack/gstwavpackenc.c
+++ b/ext/wavpack/gstwavpackenc.c
@@ -55,12 +55,18 @@
 #include "gstwavpackenc.h"
 #include "gstwavpackcommon.h"
 
-static GstFlowReturn gst_wavpack_enc_chain (GstPad * pad, GstBuffer * buffer);
-static gboolean gst_wavpack_enc_sink_set_caps (GstPad * pad, GstCaps * caps);
+static gboolean gst_wavpack_enc_start (GstAudioEncoder * enc);
+static gboolean gst_wavpack_enc_stop (GstAudioEncoder * enc);
+static gboolean gst_wavpack_enc_set_format (GstAudioEncoder * enc,
+    GstAudioInfo * info);
+static GstFlowReturn gst_wavpack_enc_handle_frame (GstAudioEncoder * enc,
+    GstBuffer * in_buf);
+static gboolean gst_wavpack_enc_sink_event (GstAudioEncoder * enc,
+    GstEvent * event);
+
 static int gst_wavpack_enc_push_block (void *id, void *data, int32_t count);
-static gboolean gst_wavpack_enc_sink_event (GstPad * pad, GstEvent * event);
-static GstStateChangeReturn gst_wavpack_enc_change_state (GstElement * element,
-    GstStateChange transition);
+static GstFlowReturn gst_wavpack_enc_drain (GstWavpackEnc * enc);
+
 static void gst_wavpack_enc_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec);
 static void gst_wavpack_enc_get_property (GObject * object, guint prop_id,
@@ -86,7 +92,7 @@ static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("audio/x-raw-int, "
         "width = (int) 32, "
-        "depth = (int) [ 1, 32], "
+        "depth = (int) { 24, 32 }, "
         "endianness = (int) BYTE_ORDER, "
         "channels = (int) [ 1, 8 ], "
         "rate = (int) [ 6000, 192000 ]," "signed = (boolean) TRUE")
@@ -97,7 +103,7 @@ static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("audio/x-wavpack, "
         "width = (int) [ 1, 32 ], "
-        "channels = (int) [ 1, 2 ], "
+        "channels = (int) [ 1, 8 ], "
         "rate = (int) [ 6000, 192000 ], " "framed = (boolean) TRUE")
     );
 
@@ -196,21 +202,8 @@ gst_wavpack_enc_joint_stereo_mode_get_type (void)
   return qtype;
 }
 
-static void
-_do_init (GType object_type)
-{
-  const GInterfaceInfo preset_interface_info = {
-    NULL,                       /* interface_init */
-    NULL,                       /* interface_finalize */
-    NULL                        /* interface_data */
-  };
-
-  g_type_add_interface_static (object_type, GST_TYPE_PRESET,
-      &preset_interface_info);
-}
-
-GST_BOILERPLATE_FULL (GstWavpackEnc, gst_wavpack_enc, GstElement,
-    GST_TYPE_ELEMENT, _do_init);
+GST_BOILERPLATE (GstWavpackEnc, gst_wavpack_enc, GstAudioEncoder,
+    GST_TYPE_AUDIO_ENCODER);
 
 static void
 gst_wavpack_enc_base_init (gpointer klass)
@@ -220,8 +213,7 @@ gst_wavpack_enc_base_init (gpointer klass)
   /* add pad templates */
   gst_element_class_add_static_pad_template (element_class, &sink_factory);
   gst_element_class_add_static_pad_template (element_class, &src_factory);
-  gst_element_class_add_static_pad_template (element_class,
-      &wvcsrc_factory);
+  gst_element_class_add_static_pad_template (element_class, &wvcsrc_factory);
 
   /* set element details */
   gst_element_class_set_details_simple (element_class, "Wavpack audio encoder",
@@ -230,23 +222,24 @@ gst_wavpack_enc_base_init (gpointer klass)
       "Sebastian Dröge <slomo@circular-chaos.org>");
 }
 
-
 static void
 gst_wavpack_enc_class_init (GstWavpackEncClass * klass)
 {
   GObjectClass *gobject_class = (GObjectClass *) klass;
-  GstElementClass *gstelement_class = (GstElementClass *) klass;
+  GstAudioEncoderClass *base_class = (GstAudioEncoderClass *) (klass);
 
   parent_class = g_type_class_peek_parent (klass);
 
-  /* set state change handler */
-  gstelement_class->change_state =
-      GST_DEBUG_FUNCPTR (gst_wavpack_enc_change_state);
-
   /* set property handlers */
   gobject_class->set_property = gst_wavpack_enc_set_property;
   gobject_class->get_property = gst_wavpack_enc_get_property;
 
+  base_class->start = GST_DEBUG_FUNCPTR (gst_wavpack_enc_start);
+  base_class->stop = GST_DEBUG_FUNCPTR (gst_wavpack_enc_stop);
+  base_class->set_format = GST_DEBUG_FUNCPTR (gst_wavpack_enc_set_format);
+  base_class->handle_frame = GST_DEBUG_FUNCPTR (gst_wavpack_enc_handle_frame);
+  base_class->event = GST_DEBUG_FUNCPTR (gst_wavpack_enc_sink_event);
+
   /* install all properties */
   g_object_class_install_property (gobject_class, ARG_MODE,
       g_param_spec_enum ("mode", "Encoding mode",
@@ -304,6 +297,9 @@ gst_wavpack_enc_reset (GstWavpackEnc * enc)
     g_checksum_free (enc->md5_context);
     enc->md5_context = NULL;
   }
+  if (enc->pending_segment)
+    gst_event_unref (enc->pending_segment);
+  enc->pending_segment = NULL;
 
   if (enc->pending_buffer) {
     gst_buffer_unref (enc->pending_buffer);
@@ -330,18 +326,7 @@ gst_wavpack_enc_reset (GstWavpackEnc * enc)
 static void
 gst_wavpack_enc_init (GstWavpackEnc * enc, GstWavpackEncClass * gclass)
 {
-  enc->sinkpad = gst_pad_new_from_static_template (&sink_factory, "sink");
-  gst_pad_set_setcaps_function (enc->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_wavpack_enc_sink_set_caps));
-  gst_pad_set_chain_function (enc->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_wavpack_enc_chain));
-  gst_pad_set_event_function (enc->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_wavpack_enc_sink_event));
-  gst_element_add_pad (GST_ELEMENT (enc), enc->sinkpad);
-
-  /* setup src pad */
-  enc->srcpad = gst_pad_new_from_static_template (&src_factory, "src");
-  gst_element_add_pad (GST_ELEMENT (enc), enc->srcpad);
+  GstAudioEncoder *benc = GST_AUDIO_ENCODER (enc);
 
   /* initialize object attributes */
   enc->wp_config = NULL;
@@ -365,37 +350,51 @@ gst_wavpack_enc_init (GstWavpackEnc * enc, GstWavpackEncClass * gclass)
   enc->md5 = FALSE;
   enc->extra_processing = 0;
   enc->joint_stereo_mode = GST_WAVPACK_JS_MODE_AUTO;
+
+  /* require perfect ts */
+  gst_audio_encoder_set_perfect_timestamp (benc, TRUE);
+}
+
+
+static gboolean
+gst_wavpack_enc_start (GstAudioEncoder * enc)
+{
+  GST_DEBUG_OBJECT (enc, "start");
+
+  return TRUE;
+}
+
+static gboolean
+gst_wavpack_enc_stop (GstAudioEncoder * enc)
+{
+  GstWavpackEnc *wpenc = GST_WAVPACK_ENC (enc);
+
+  GST_DEBUG_OBJECT (enc, "stop");
+  gst_wavpack_enc_reset (wpenc);
+
+  return TRUE;
 }
 
 static gboolean
-gst_wavpack_enc_sink_set_caps (GstPad * pad, GstCaps * caps)
+gst_wavpack_enc_set_format (GstAudioEncoder * benc, GstAudioInfo * info)
 {
-  GstWavpackEnc *enc = GST_WAVPACK_ENC (gst_pad_get_parent (pad));
-  GstStructure *structure = gst_caps_get_structure (caps, 0);
+  GstWavpackEnc *enc = GST_WAVPACK_ENC (benc);
   GstAudioChannelPosition *pos;
+  GstCaps *caps;
 
-  if (!gst_structure_get_int (structure, "channels", &enc->channels) ||
-      !gst_structure_get_int (structure, "rate", &enc->samplerate) ||
-      !gst_structure_get_int (structure, "depth", &enc->depth)) {
-    GST_ELEMENT_ERROR (enc, LIBRARY, INIT, (NULL),
-        ("got invalid caps: %" GST_PTR_FORMAT, caps));
-    gst_object_unref (enc);
-    return FALSE;
-  }
+  /* we may be configured again, but that change should have cleanup context */
+  g_assert (enc->wp_context == NULL);
 
-  pos = gst_audio_get_channel_positions (structure);
-  /* If one channel is NONE they'll be all undefined */
-  if (pos != NULL && pos[0] == GST_AUDIO_CHANNEL_POSITION_NONE) {
-    g_free (pos);
-    pos = NULL;
-  }
+  enc->channels = GST_AUDIO_INFO_CHANNELS (info);
+  enc->depth = GST_AUDIO_INFO_DEPTH (info);
+  enc->samplerate = GST_AUDIO_INFO_RATE (info);
 
-  if (pos == NULL) {
-    GST_ELEMENT_ERROR (enc, STREAM, FORMAT, (NULL),
-        ("input has no valid channel layout"));
+  pos = info->position;
+  g_assert (pos);
 
-    gst_object_unref (enc);
-    return FALSE;
+  /* If one channel is NONE they'll be all undefined */
+  if (pos != NULL && pos[0] == GST_AUDIO_CHANNEL_POSITION_NONE) {
+    goto invalid_channels;
   }
 
   enc->channel_mask =
@@ -403,7 +402,6 @@ gst_wavpack_enc_sink_set_caps (GstPad * pad, GstCaps * caps)
   enc->need_channel_remap =
       gst_wavpack_set_channel_mapping (pos, enc->channels,
       enc->channel_mapping);
-  g_free (pos);
 
   /* set fixed src pad caps now that we know what we will get */
   caps = gst_caps_new_simple ("audio/x-wavpack",
@@ -414,18 +412,28 @@ gst_wavpack_enc_sink_set_caps (GstPad * pad, GstCaps * caps)
   if (!gst_wavpack_set_channel_layout (caps, enc->channel_mask))
     GST_WARNING_OBJECT (enc, "setting channel layout failed");
 
-  if (!gst_pad_set_caps (enc->srcpad, caps)) {
-    GST_ELEMENT_ERROR (enc, LIBRARY, INIT, (NULL),
-        ("setting caps failed: %" GST_PTR_FORMAT, caps));
-    gst_caps_unref (caps);
-    gst_object_unref (enc);
-    return FALSE;
-  }
-  gst_pad_use_fixed_caps (enc->srcpad);
+  if (!gst_pad_set_caps (GST_AUDIO_ENCODER_SRC_PAD (enc), caps))
+    goto setting_src_caps_failed;
 
   gst_caps_unref (caps);
-  gst_object_unref (enc);
+
+  /* no special feedback to base class; should provide all available samples */
+
   return TRUE;
+
+  /* ERRORS */
+setting_src_caps_failed:
+  {
+    GST_DEBUG_OBJECT (enc,
+        "Couldn't set caps on source pad: %" GST_PTR_FORMAT, caps);
+    gst_caps_unref (caps);
+    return FALSE;
+  }
+invalid_channels:
+  {
+    GST_DEBUG_OBJECT (enc, "input has invalid channel layout");
+    return FALSE;
+  }
 }
 
 static void
@@ -547,21 +555,14 @@ gst_wavpack_enc_push_block (void *id, void *data, int32_t count)
   GstBuffer *buffer;
   GstPad *pad;
   guchar *block = (guchar *) data;
+  gint samples = 0;
 
-  pad = (wid->correction) ? enc->wvcsrcpad : enc->srcpad;
+  pad = (wid->correction) ? enc->wvcsrcpad : GST_AUDIO_ENCODER_SRC_PAD (enc);
   flow =
       (wid->correction) ? &enc->wvcsrcpad_last_return : &enc->
       srcpad_last_return;
 
-  *flow = gst_pad_alloc_buffer_and_set_caps (pad, GST_BUFFER_OFFSET_NONE,
-      count, GST_PAD_CAPS (pad), &buffer);
-
-  if (*flow != GST_FLOW_OK) {
-    GST_WARNING_OBJECT (enc, "flow on %s:%s = %s",
-        GST_DEBUG_PAD_NAME (pad), gst_flow_get_name (*flow));
-    return FALSE;
-  }
-
+  buffer = gst_buffer_new_and_alloc (count);
   g_memmove (GST_BUFFER_DATA (buffer), block, count);
 
   if (count > sizeof (WavpackHeader) && memcmp (block, "wvpk", 4) == 0) {
@@ -597,12 +598,14 @@ gst_wavpack_enc_push_block (void *id, void *data, int32_t count)
       enc->pending_buffer = NULL;
       enc->pending_offset = 0;
 
-      /* if it's the first wavpack block, send a NEW_SEGMENT event */
-      if (wph.block_index == 0) {
-        gst_pad_push_event (pad,
-            gst_event_new_new_segment (FALSE,
-                1.0, GST_FORMAT_TIME, 0, GST_BUFFER_OFFSET_NONE, 0));
+      /* only send segment on correction pad,
+       * regular pad is handled normally by baseclass */
+      if (wid->correction && enc->pending_segment) {
+        gst_pad_push_event (pad, enc->pending_segment);
+        enc->pending_segment = NULL;
+      }
 
+      if (wph.block_index == 0) {
         /* save header for later reference, so we can re-send it later on
          * EOS with fixed up values for total sample count etc. */
         if (enc->first_block == NULL && !wid->correction) {
@@ -612,29 +615,30 @@ gst_wavpack_enc_push_block (void *id, void *data, int32_t count)
         }
       }
     }
+    samples = wph.block_samples;
 
-    /* set buffer timestamp, duration, offset, offset_end from
-     * the wavpack header */
-    GST_BUFFER_TIMESTAMP (buffer) = enc->timestamp_offset +
-        gst_util_uint64_scale_int (GST_SECOND, wph.block_index,
-        enc->samplerate);
-    GST_BUFFER_DURATION (buffer) =
-        gst_util_uint64_scale_int (GST_SECOND, wph.block_samples,
-        enc->samplerate);
+    /* decorate buffer */
+    /* NOTE: this will get overwritten by baseclass, but stay for those
+     * that are pushed directly
+     * FIXME: add setting to baseclass to avoid overwriting it ?? */
     GST_BUFFER_OFFSET (buffer) = wph.block_index;
     GST_BUFFER_OFFSET_END (buffer) = wph.block_index + wph.block_samples;
   } else {
     /* if it's something else set no timestamp and duration on the buffer */
     GST_DEBUG_OBJECT (enc, "got %d bytes of unknown data", count);
-
-    GST_BUFFER_TIMESTAMP (buffer) = GST_CLOCK_TIME_NONE;
-    GST_BUFFER_DURATION (buffer) = GST_CLOCK_TIME_NONE;
   }
 
-  /* push the buffer and forward errors */
-  GST_DEBUG_OBJECT (enc, "pushing buffer with %d bytes",
-      GST_BUFFER_SIZE (buffer));
-  *flow = gst_pad_push (pad, buffer);
+  if (wid->correction || wid->passthrough) {
+    /* push the buffer and forward errors */
+    GST_DEBUG_OBJECT (enc, "pushing buffer with %d bytes",
+        GST_BUFFER_SIZE (buffer));
+    *flow = gst_pad_push (pad, buffer);
+  } else {
+    GST_DEBUG_OBJECT (enc, "handing frame of %d bytes",
+        GST_BUFFER_SIZE (buffer));
+    *flow = gst_audio_encoder_finish_frame (GST_AUDIO_ENCODER (enc), buffer,
+        samples);
+  }
 
   if (*flow != GST_FLOW_OK) {
     GST_WARNING_OBJECT (enc, "flow on %s:%s = %s",
@@ -664,18 +668,25 @@ gst_wavpack_enc_fix_channel_order (GstWavpackEnc * enc, gint32 * data,
 }
 
 static GstFlowReturn
-gst_wavpack_enc_chain (GstPad * pad, GstBuffer * buf)
+gst_wavpack_enc_handle_frame (GstAudioEncoder * benc, GstBuffer * buf)
 {
-  GstWavpackEnc *enc = GST_WAVPACK_ENC (gst_pad_get_parent (pad));
-  uint32_t sample_count = GST_BUFFER_SIZE (buf) / 4;
+  GstWavpackEnc *enc = GST_WAVPACK_ENC (benc);
+  uint32_t sample_count;
   GstFlowReturn ret;
 
+  /* base class ensures configuration */
+  g_return_val_if_fail (enc->depth != 0, GST_FLOW_NOT_NEGOTIATED);
+
   /* reset the last returns to GST_FLOW_OK. This is only set to something else
    * while WavpackPackSamples() or more specific gst_wavpack_enc_push_block()
    * so not valid anymore */
   enc->srcpad_last_return = enc->wvcsrcpad_last_return = GST_FLOW_OK;
 
-  GST_DEBUG ("got %u raw samples", sample_count);
+  if (G_UNLIKELY (!buf))
+    return gst_wavpack_enc_drain (enc);
+
+  sample_count = GST_BUFFER_SIZE (buf) / 4;
+  GST_DEBUG_OBJECT (enc, "got %u raw samples", sample_count);
 
   /* check if we already have a valid WavpackContext, otherwise make one */
   if (!enc->wp_context) {
@@ -683,13 +694,8 @@ gst_wavpack_enc_chain (GstPad * pad, GstBuffer * buf)
     enc->wp_context =
         WavpackOpenFileOutput (gst_wavpack_enc_push_block, &enc->wv_id,
         (enc->correction_mode > 0) ? &enc->wvc_id : NULL);
-    if (!enc->wp_context) {
-      GST_ELEMENT_ERROR (enc, LIBRARY, INIT, (NULL),
-          ("error creating Wavpack context"));
-      gst_object_unref (enc);
-      gst_buffer_unref (buf);
-      return GST_FLOW_ERROR;
-    }
+    if (!enc->wp_context)
+      goto context_failed;
 
     /* set the WavpackConfig according to our parameters */
     gst_wavpack_enc_set_wp_config (enc);
@@ -699,76 +705,12 @@ gst_wavpack_enc_chain (GstPad * pad, GstBuffer * buf)
     if (!WavpackSetConfiguration (enc->wp_context,
             enc->wp_config, (uint32_t) (-1))
         || !WavpackPackInit (enc->wp_context)) {
-      GST_ELEMENT_ERROR (enc, LIBRARY, SETTINGS, (NULL),
-          ("error setting up wavpack encoding context"));
       WavpackCloseFile (enc->wp_context);
-      gst_object_unref (enc);
-      gst_buffer_unref (buf);
-      return GST_FLOW_ERROR;
-    }
-    GST_DEBUG ("setup of encoding context successfull");
-  }
-
-  /* Save the timestamp of the first buffer. This will be later
-   * used as offset for all following buffers */
-  if (enc->timestamp_offset == GST_CLOCK_TIME_NONE) {
-    if (GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
-      enc->timestamp_offset = GST_BUFFER_TIMESTAMP (buf);
-      enc->next_ts = GST_BUFFER_TIMESTAMP (buf);
-    } else {
-      enc->timestamp_offset = 0;
-      enc->next_ts = 0;
-    }
-  }
-
-  /* Check if we have a continous stream, if not drop some samples or the buffer or
-   * insert some silence samples */
-  if (enc->next_ts != GST_CLOCK_TIME_NONE &&
-      GST_BUFFER_TIMESTAMP (buf) < enc->next_ts) {
-    guint64 diff = enc->next_ts - GST_BUFFER_TIMESTAMP (buf);
-    guint64 diff_bytes;
-
-    GST_WARNING_OBJECT (enc, "Buffer is older than previous "
-        "timestamp + duration (%" GST_TIME_FORMAT "< %" GST_TIME_FORMAT
-        "), cannot handle. Clipping buffer.",
-        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
-        GST_TIME_ARGS (enc->next_ts));
-
-    diff_bytes =
-        GST_CLOCK_TIME_TO_FRAMES (diff, enc->samplerate) * enc->channels * 2;
-    if (diff_bytes >= GST_BUFFER_SIZE (buf)) {
-      gst_buffer_unref (buf);
-      return GST_FLOW_OK;
-    }
-    buf = gst_buffer_make_metadata_writable (buf);
-    GST_BUFFER_DATA (buf) += diff_bytes;
-    GST_BUFFER_SIZE (buf) -= diff_bytes;
-
-    GST_BUFFER_TIMESTAMP (buf) += diff;
-    if (GST_BUFFER_DURATION_IS_VALID (buf))
-      GST_BUFFER_DURATION (buf) -= diff;
-  }
-
-  /* Allow a diff of at most 5 ms */
-  if (enc->next_ts != GST_CLOCK_TIME_NONE
-      && GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
-    if (GST_BUFFER_TIMESTAMP (buf) != enc->next_ts &&
-        GST_BUFFER_TIMESTAMP (buf) - enc->next_ts > 5 * GST_MSECOND) {
-      GST_WARNING_OBJECT (enc,
-          "Discontinuity detected: %" G_GUINT64_FORMAT " > %" G_GUINT64_FORMAT,
-          GST_BUFFER_TIMESTAMP (buf) - enc->next_ts, 5 * GST_MSECOND);
-
-      WavpackFlushSamples (enc->wp_context);
-      enc->timestamp_offset += (GST_BUFFER_TIMESTAMP (buf) - enc->next_ts);
+      goto config_failed;
     }
+    GST_DEBUG_OBJECT (enc, "setup of encoding context successfull");
   }
 
-  if (GST_BUFFER_TIMESTAMP_IS_VALID (buf)
-      && GST_BUFFER_DURATION_IS_VALID (buf))
-    enc->next_ts = GST_BUFFER_TIMESTAMP (buf) + GST_BUFFER_DURATION (buf);
-  else
-    enc->next_ts = GST_CLOCK_TIME_NONE;
-
   if (enc->need_channel_remap) {
     buf = gst_buffer_make_writable (buf);
     gst_wavpack_enc_fix_channel_order (enc, (gint32 *) GST_BUFFER_DATA (buf),
@@ -785,7 +727,7 @@ gst_wavpack_enc_chain (GstPad * pad, GstBuffer * buf)
   /* encode and handle return values from encoding */
   if (WavpackPackSamples (enc->wp_context, (int32_t *) GST_BUFFER_DATA (buf),
           sample_count / enc->channels)) {
-    GST_DEBUG ("encoding samples successful");
+    GST_DEBUG_OBJECT (enc, "encoding samples successful");
     ret = GST_FLOW_OK;
   } else {
     if ((enc->srcpad_last_return == GST_FLOW_RESEND) ||
@@ -801,15 +743,35 @@ gst_wavpack_enc_chain (GstPad * pad, GstBuffer * buf)
         (enc->wvcsrcpad_last_return == GST_FLOW_WRONG_STATE)) {
       ret = GST_FLOW_WRONG_STATE;
     } else {
-      GST_ELEMENT_ERROR (enc, LIBRARY, ENCODE, (NULL),
-          ("encoding samples failed"));
-      ret = GST_FLOW_ERROR;
+      goto encoding_failed;
     }
   }
 
-  gst_buffer_unref (buf);
-  gst_object_unref (enc);
+exit:
   return ret;
+
+  /* ERRORS */
+encoding_failed:
+  {
+    GST_ELEMENT_ERROR (enc, LIBRARY, ENCODE, (NULL),
+        ("encoding samples failed"));
+    ret = GST_FLOW_ERROR;
+    goto exit;
+  }
+config_failed:
+  {
+    GST_ELEMENT_ERROR (enc, LIBRARY, SETTINGS, (NULL),
+        ("error setting up wavpack encoding context"));
+    ret = GST_FLOW_ERROR;
+    goto exit;
+  }
+context_failed:
+  {
+    GST_ELEMENT_ERROR (enc, LIBRARY, INIT, (NULL),
+        ("error creating Wavpack context"));
+    ret = GST_FLOW_ERROR;
+    goto exit;
+  }
 }
 
 static void
@@ -826,7 +788,7 @@ gst_wavpack_enc_rewrite_first_block (GstWavpackEnc * enc)
   WavpackUpdateNumSamples (enc->wp_context, enc->first_block);
 
   /* try to seek to the beginning of the output */
-  ret = gst_pad_push_event (enc->srcpad, event);
+  ret = gst_pad_push_event (GST_AUDIO_ENCODER_SRC_PAD (enc), event);
   if (ret) {
     /* try to rewrite the first block */
     GST_DEBUG_OBJECT (enc, "rewriting first block ...");
@@ -834,111 +796,84 @@ gst_wavpack_enc_rewrite_first_block (GstWavpackEnc * enc)
     ret = gst_wavpack_enc_push_block (&enc->wv_id,
         enc->first_block, enc->first_block_size);
     enc->wv_id.passthrough = FALSE;
+    g_free (enc->first_block);
+    enc->first_block = NULL;
   } else {
     GST_WARNING_OBJECT (enc, "rewriting of first block failed. "
         "Seeking to first block failed!");
   }
 }
 
-static gboolean
-gst_wavpack_enc_sink_event (GstPad * pad, GstEvent * event)
+static GstFlowReturn
+gst_wavpack_enc_drain (GstWavpackEnc * enc)
 {
-  GstWavpackEnc *enc = GST_WAVPACK_ENC (gst_pad_get_parent (pad));
-  gboolean ret = TRUE;
+  if (!enc->wp_context)
+    return GST_FLOW_OK;
 
-  GST_DEBUG ("Received %s event on sinkpad", GST_EVENT_TYPE_NAME (event));
+  GST_DEBUG_OBJECT (enc, "draining");
 
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_EOS:
-      /* Encode all remaining samples and flush them to the src pads */
-      WavpackFlushSamples (enc->wp_context);
-
-      /* Drop all remaining data, this is no complete block otherwise
-       * it would've been pushed already */
-      if (enc->pending_buffer) {
-        gst_buffer_unref (enc->pending_buffer);
-        enc->pending_buffer = NULL;
-        enc->pending_offset = 0;
-      }
+  /* Encode all remaining samples and flush them to the src pads */
+  WavpackFlushSamples (enc->wp_context);
 
-      /* write the MD5 sum if we have to write one */
-      if ((enc->md5) && (enc->md5_context)) {
-        guint8 md5_digest[16];
-        gsize digest_len = sizeof (md5_digest);
+  /* Drop all remaining data, this is no complete block otherwise
+   * it would've been pushed already */
+  if (enc->pending_buffer) {
+    gst_buffer_unref (enc->pending_buffer);
+    enc->pending_buffer = NULL;
+    enc->pending_offset = 0;
+  }
 
-        g_checksum_get_digest (enc->md5_context, md5_digest, &digest_len);
-        if (digest_len == sizeof (md5_digest))
-          WavpackStoreMD5Sum (enc->wp_context, md5_digest);
-        else
-          GST_WARNING_OBJECT (enc, "Calculating MD5 digest failed");
-      }
+  /* write the MD5 sum if we have to write one */
+  if ((enc->md5) && (enc->md5_context)) {
+    guint8 md5_digest[16];
+    gsize digest_len = sizeof (md5_digest);
 
-      /* Try to rewrite the first frame with the correct sample number */
-      if (enc->first_block)
-        gst_wavpack_enc_rewrite_first_block (enc);
+    g_checksum_get_digest (enc->md5_context, md5_digest, &digest_len);
+    if (digest_len == sizeof (md5_digest)) {
+      WavpackStoreMD5Sum (enc->wp_context, md5_digest);
+      WavpackFlushSamples (enc->wp_context);
+    } else
+      GST_WARNING_OBJECT (enc, "Calculating MD5 digest failed");
+  }
 
-      /* close the context if not already happened */
-      if (enc->wp_context) {
-        WavpackCloseFile (enc->wp_context);
-        enc->wp_context = NULL;
-      }
+  /* Try to rewrite the first frame with the correct sample number */
+  if (enc->first_block)
+    gst_wavpack_enc_rewrite_first_block (enc);
 
-      ret = gst_pad_event_default (pad, event);
-      break;
-    case GST_EVENT_NEWSEGMENT:
-      if (enc->wp_context) {
-        GST_WARNING_OBJECT (enc, "got NEWSEGMENT after encoding "
-            "already started");
-      }
-      /* drop NEWSEGMENT events, we create our own when pushing
-       * the first buffer to the pads */
-      gst_event_unref (event);
-      ret = TRUE;
-      break;
-    default:
-      ret = gst_pad_event_default (pad, event);
-      break;
+  /* close the context if not already happened */
+  if (enc->wp_context) {
+    WavpackCloseFile (enc->wp_context);
+    enc->wp_context = NULL;
   }
 
-  gst_object_unref (enc);
-  return ret;
+  return GST_FLOW_OK;
 }
 
-static GstStateChangeReturn
-gst_wavpack_enc_change_state (GstElement * element, GstStateChange transition)
+static gboolean
+gst_wavpack_enc_sink_event (GstAudioEncoder * benc, GstEvent * event)
 {
-  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
-  GstWavpackEnc *enc = GST_WAVPACK_ENC (element);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_NULL_TO_READY:
-      /* set the last returned GstFlowReturns of the two pads to GST_FLOW_OK
-       * as they're only set to something else in WavpackPackSamples() or more
-       * specific gst_wavpack_enc_push_block() and nothing happened there yet */
-      enc->srcpad_last_return = enc->wvcsrcpad_last_return = GST_FLOW_OK;
-      break;
-    case GST_STATE_CHANGE_READY_TO_PAUSED:
-      break;
-    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
-    default:
-      break;
-  }
+  GstWavpackEnc *enc = GST_WAVPACK_ENC (benc);
 
-  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+  GST_DEBUG_OBJECT (enc, "Received %s event on sinkpad",
+      GST_EVENT_TYPE_NAME (event));
 
-  switch (transition) {
-    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
-      break;
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_wavpack_enc_reset (enc);
-      break;
-    case GST_STATE_CHANGE_READY_TO_NULL:
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_NEWSEGMENT:
+      if (enc->wp_context) {
+        GST_WARNING_OBJECT (enc, "got NEWSEGMENT after encoding "
+            "already started");
+      }
+      /* peek and hold NEWSEGMENT events for sending on correction pad */
+      if (enc->pending_segment)
+        gst_event_unref (enc->pending_segment);
+      enc->pending_segment = gst_event_ref (event);
       break;
     default:
       break;
   }
 
-  return ret;
+  /* baseclass handles rest */
+  return FALSE;
 }
 
 static void
diff --git a/ext/wavpack/gstwavpackenc.h b/ext/wavpack/gstwavpackenc.h
index d2df844..aab4296 100644
--- a/ext/wavpack/gstwavpackenc.h
+++ b/ext/wavpack/gstwavpackenc.h
@@ -23,6 +23,7 @@
 #define __GST_WAVPACK_ENC_H__
 
 #include <gst/gst.h>
+#include <gst/audio/gstaudioencoder.h>
 
 #include <wavpack/wavpack.h>
 
@@ -50,10 +51,9 @@ typedef struct
 
 struct _GstWavpackEnc
 {
-  GstElement element;
+  GstAudioEncoder element;
 
   /*< private > */
-  GstPad *sinkpad, *srcpad;
   GstPad *wvcsrcpad;
 
   GstFlowReturn srcpad_last_return;
@@ -86,6 +86,7 @@ struct _GstWavpackEnc
 
   GstBuffer *pending_buffer;
   gint32 pending_offset;
+  GstEvent *pending_segment;
 
   GstClockTime timestamp_offset;
   GstClockTime next_ts;
@@ -93,7 +94,7 @@ struct _GstWavpackEnc
 
 struct _GstWavpackEncClass
 {
-  GstElementClass parent;
+  GstAudioEncoderClass parent;
 };
 
 GType gst_wavpack_enc_get_type (void);
diff --git a/ext/wavpack/gstwavpackparse.c b/ext/wavpack/gstwavpackparse.c
index e1ff785..e3625c5 100644
--- a/ext/wavpack/gstwavpackparse.c
+++ b/ext/wavpack/gstwavpackparse.c
@@ -121,8 +121,7 @@ gst_wavpack_parse_base_init (gpointer klass)
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 
   gst_element_class_add_static_pad_template (element_class, &src_factory);
-  gst_element_class_add_static_pad_template (element_class,
-      &wvc_src_factory);
+  gst_element_class_add_static_pad_template (element_class, &wvc_src_factory);
   gst_element_class_add_static_pad_template (element_class, &sink_factory);
 
   gst_element_class_set_details_simple (element_class, "Wavpack parser",
@@ -144,7 +143,6 @@ static void
 gst_wavpack_parse_class_init (GstWavpackParseClass * klass)
 {
   GObjectClass *gobject_class;
-
   GstElementClass *gstelement_class;
 
   gobject_class = (GObjectClass *) klass;
@@ -168,7 +166,6 @@ gst_wavpack_parse_index_get_entry_from_sample (GstWavpackParse * wvparse,
     gint64 sample_offset)
 {
   gint i;
-
   GSList *node;
 
   if (wvparse->entries == NULL)
@@ -289,9 +286,7 @@ static gboolean
 gst_wavpack_parse_src_query (GstPad * pad, GstQuery * query)
 {
   GstWavpackParse *parse = GST_WAVPACK_PARSE (gst_pad_get_parent (pad));
-
   GstFormat format;
-
   gboolean ret = FALSE;
 
   switch (GST_QUERY_TYPE (query)) {
@@ -411,9 +406,7 @@ gst_wavpack_parse_scan_to_find_sample (GstWavpackParse * parse,
     gint64 sample, gint64 * byte_offset, gint64 * start_sample)
 {
   GstWavpackParseIndexEntry *entry;
-
   GstFlowReturn ret;
-
   gint64 off = 0;
 
   /* first, check if we have to scan at all */
@@ -441,7 +434,6 @@ gst_wavpack_parse_scan_to_find_sample (GstWavpackParse * parse,
   /* now scan forward until we find the chunk we're looking for or hit EOS */
   do {
     WavpackHeader header;
-
     GstBuffer *buf;
 
     buf = gst_wavpack_parse_pull_buffer (parse, off, sizeof (WavpackHeader),
@@ -481,13 +473,9 @@ gst_wavpack_parse_send_newsegment (GstWavpackParse * wvparse, gboolean update)
   GstSegment *s = &wvparse->segment;
 
   gboolean ret;
-
   gint64 stop_time = -1;
-
   gint64 start_time = 0;
-
   gint64 cur_pos_time;
-
   gint64 diff;
 
   /* segment is in DEFAULT format, but we want to send a TIME newsegment */
@@ -524,31 +512,18 @@ gst_wavpack_parse_handle_seek_event (GstWavpackParse * wvparse,
     GstEvent * event)
 {
   GstSeekFlags seek_flags;
-
   GstSeekType start_type;
-
   GstSeekType stop_type;
-
   GstSegment segment;
-
   GstFormat format;
-
   gboolean only_update;
-
   gboolean flush, ret;
-
   gdouble speed;
-
   gint64 stop;
-
   gint64 start;                 /* sample we want to seek to                  */
-
   gint64 byte_offset;           /* byte offset the chunk we seek to starts at */
-
   gint64 chunk_start;           /* first sample in chunk we seek to           */
-
   guint rate;
-
   gint64 last_stop;
 
   if (wvparse->adapter) {
@@ -674,7 +649,6 @@ static gboolean
 gst_wavpack_parse_sink_event (GstPad * pad, GstEvent * event)
 {
   GstWavpackParse *parse;
-
   gboolean ret = TRUE;
 
   parse = GST_WAVPACK_PARSE (gst_pad_get_parent (pad));
@@ -733,7 +707,6 @@ static gboolean
 gst_wavpack_parse_src_event (GstPad * pad, GstEvent * event)
 {
   GstWavpackParse *parse;
-
   gboolean ret;
 
   parse = GST_WAVPACK_PARSE (gst_pad_get_parent (pad));
@@ -755,7 +728,6 @@ static void
 gst_wavpack_parse_init (GstWavpackParse * parse, GstWavpackParseClass * gclass)
 {
   GstElementClass *klass = GST_ELEMENT_GET_CLASS (parse);
-
   GstPadTemplate *tmpl;
 
   tmpl = gst_element_class_get_pad_template (klass, "sink");
@@ -780,7 +752,6 @@ static gint64
 gst_wavpack_parse_get_upstream_length (GstWavpackParse * parse)
 {
   gint64 length = -1;
-
   GstFormat format = GST_FORMAT_BYTES;
 
   if (!gst_pad_query_peer_duration (parse->sinkpad, &format, &length)) {
@@ -796,7 +767,6 @@ gst_wavpack_parse_pull_buffer (GstWavpackParse * wvparse, gint64 offset,
     guint size, GstFlowReturn * flow)
 {
   GstFlowReturn flow_ret;
-
   GstBuffer *buf = NULL;
 
   if (offset + size > wvparse->upstream_length) {
@@ -837,9 +807,7 @@ gst_wavpack_parse_create_src_pad (GstWavpackParse * wvparse, GstBuffer * buf,
     WavpackHeader * header)
 {
   GstWavpackMetadata meta;
-
   GstCaps *caps = NULL;
-
   guchar *bufptr;
 
   g_assert (wvparse->srcpad == NULL);
@@ -954,8 +922,8 @@ gst_wavpack_parse_push_buffer (GstWavpackParse * wvparse, GstBuffer * buf,
     WavpackHeader * header)
 {
   GstFlowReturn ret;
-  wvparse->current_offset += header->ckSize + 8;
 
+  wvparse->current_offset += header->ckSize + 8;
   wvparse->segment.last_stop = header->block_index;
 
   if (wvparse->need_newsegment) {
@@ -1021,8 +989,7 @@ gst_wavpack_parse_push_buffer (GstWavpackParse * wvparse, GstBuffer * buf,
 static guint8 *
 gst_wavpack_parse_find_marker (guint8 * buf, guint size)
 {
-  int i;
-
+  gint i;
   guint8 *ret = NULL;
 
   if (G_UNLIKELY (size < 4))
@@ -1041,7 +1008,6 @@ static GstFlowReturn
 gst_wavpack_parse_resync_loop (GstWavpackParse * parse, WavpackHeader * header)
 {
   GstFlowReturn flow_ret = GST_FLOW_UNEXPECTED;
-
   GstBuffer *buf = NULL;
 
   /* loop until we have a frame header or reach the end of the stream */
@@ -1108,7 +1074,6 @@ static void
 gst_wavpack_parse_loop (GstElement * element)
 {
   GstWavpackParse *parse = GST_WAVPACK_PARSE (element);
-
   GstFlowReturn flow_ret;
   WavpackHeader header = { {0,}, 0, };
   GstBuffer *buf = NULL;
@@ -1183,7 +1148,6 @@ static gboolean
 gst_wavpack_parse_resync_adapter (GstAdapter * adapter)
 {
   const guint8 *buf, *marker;
-
   guint avail = gst_adapter_available (adapter);
 
   if (avail < 4)
@@ -1215,11 +1179,8 @@ static GstFlowReturn
 gst_wavpack_parse_chain (GstPad * pad, GstBuffer * buf)
 {
   GstWavpackParse *wvparse = GST_WAVPACK_PARSE (GST_PAD_PARENT (pad));
-
   GstFlowReturn ret = GST_FLOW_OK;
-
   WavpackHeader wph;
-
   const guint8 *tmp_buf;
 
   if (!wvparse->adapter) {
@@ -1279,7 +1240,6 @@ static GstStateChangeReturn
 gst_wavpack_parse_change_state (GstElement * element, GstStateChange transition)
 {
   GstWavpackParse *wvparse = GST_WAVPACK_PARSE (element);
-
   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
 
   switch (transition) {
diff --git a/ext/wavpack/gstwavpackstreamreader.c b/ext/wavpack/gstwavpackstreamreader.c
index 074a2e7..da1fdc2 100644
--- a/ext/wavpack/gstwavpackstreamreader.c
+++ b/ext/wavpack/gstwavpackstreamreader.c
@@ -78,9 +78,10 @@ gst_wavpack_stream_reader_push_back_byte (void *id, int c)
 
   GST_DEBUG ("Pushing back one byte: 0x%x", c);
 
+  if (rid->position == 0)
+    return rid->position;
+
   rid->position -= 1;
-  if (rid->position < 0)
-    rid->position = 0;
   return rid->position;
 }
 
diff --git a/gst-plugins-good.doap b/gst-plugins-good.doap
index 02c2cd7..f4cc81e 100644
--- a/gst-plugins-good.doap
+++ b/gst-plugins-good.doap
@@ -34,18 +34,6 @@ the plug-in code, LGPL or LGPL-compatible for the supporting library).
 
  <release>
   <Version>
-   <revision>0.10.31</revision>
-   <branch>0.10</branch>
-   <name>Faster</name>
-   <created>2012-02-20</created>
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gst-plugins-good/gst-plugins-good-0.10.31.tar.bz2" />
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gst-plugins-good/gst-plugins-good-0.10.31.tar.gz" />
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gst-plugins-good/gst-plugins-good-0.10.31.tar.xz" />
-  </Version>
- </release>
-
- <release>
-  <Version>
    <revision>0.10.30</revision>
    <branch>0.10</branch>
    <name>Adagio</name>
diff --git a/gst/audiofx/audiofirfilter.c b/gst/audiofx/audiofirfilter.c
index bd5a51b..e693b43 100644
--- a/gst/audiofx/audiofirfilter.c
+++ b/gst/audiofx/audiofirfilter.c
@@ -45,6 +45,10 @@
  * </refsect2>
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/gst/audiofx/audioiirfilter.c b/gst/audiofx/audioiirfilter.c
index ff5f9ca..48ead7a 100644
--- a/gst/audiofx/audioiirfilter.c
+++ b/gst/audiofx/audioiirfilter.c
@@ -41,6 +41,10 @@
  * </refsect2>
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/gst/audioparsers/Makefile.am b/gst/audioparsers/Makefile.am
index 22bc81f..4d4d53e 100644
--- a/gst/audioparsers/Makefile.am
+++ b/gst/audioparsers/Makefile.am
@@ -3,7 +3,7 @@ plugin_LTLIBRARIES = libgstaudioparsers.la
 libgstaudioparsers_la_SOURCES = \
 	gstaacparse.c gstamrparse.c gstac3parse.c \
 	gstdcaparse.c gstflacparse.c gstmpegaudioparse.c \
-	plugin.c
+	gstwavpackparse.c plugin.c
 
 libgstaudioparsers_la_CFLAGS = \
 	$(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(GST_CFLAGS)
@@ -15,4 +15,4 @@ libgstaudioparsers_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstaudioparsers_la_LIBTOOLFLAGS = --tag=disable-static
 
 noinst_HEADERS = gstaacparse.h gstamrparse.h gstac3parse.h \
-	gstdcaparse.h gstflacparse.h gstmpegaudioparse.h
+	gstdcaparse.h gstflacparse.h gstmpegaudioparse.h gstwavpackparse.h
diff --git a/gst/audioparsers/gstaacparse.c b/gst/audioparsers/gstaacparse.c
index d8c0995..57f5aff 100644
--- a/gst/audioparsers/gstaacparse.c
+++ b/gst/audioparsers/gstaacparse.c
@@ -44,6 +44,7 @@
 
 #include <string.h>
 
+#include <gst/base/gstbitreader.h>
 #include "gstaacparse.h"
 
 
@@ -52,7 +53,7 @@ static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("audio/mpeg, "
         "framed = (boolean) true, " "mpegversion = (int) { 2, 4 }, "
-        "stream-format = (string) { raw, adts, adif };"));
+        "stream-format = (string) { raw, adts, adif, loas };"));
 
 static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
@@ -65,10 +66,21 @@ GST_DEBUG_CATEGORY_STATIC (aacparse_debug);
 
 #define ADIF_MAX_SIZE 40        /* Should be enough */
 #define ADTS_MAX_SIZE 10        /* Should be enough */
+#define LOAS_MAX_SIZE 3         /* Should be enough */
 
 
 #define AAC_FRAME_DURATION(parse) (GST_SECOND/parse->frames_per_sec)
 
+static const gint loas_sample_rate_table[32] = {
+  96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050,
+  16000, 12000, 11025, 8000, 7350, 0, 0, 0
+};
+
+static const gint loas_channels_table[32] = {
+  0, 1, 2, 3, 4, 5, 6, 8,
+  0, 0, 0, 0, 0, 0, 0, 0
+};
+
 static gboolean gst_aac_parse_start (GstBaseParse * parse);
 static gboolean gst_aac_parse_stop (GstBaseParse * parse);
 
@@ -192,6 +204,9 @@ gst_aac_parse_set_src_caps (GstAacParse * aacparse, GstCaps * sink_caps)
     case DSPAAC_HEADER_ADIF:
       stream_format = "adif";
       break;
+    case DSPAAC_HEADER_LOAS:
+      stream_format = "loas";
+      break;
     default:
       stream_format = NULL;
   }
@@ -327,6 +342,8 @@ gst_aac_parse_check_adts_frame (GstAacParse * aacparse,
     const guint8 * data, const guint avail, gboolean drain,
     guint * framesize, guint * needed_data)
 {
+  *needed_data = 0;
+
   if (G_UNLIKELY (avail < 2))
     return FALSE;
 
@@ -365,6 +382,292 @@ gst_aac_parse_check_adts_frame (GstAacParse * aacparse,
   return FALSE;
 }
 
+static gboolean
+gst_aac_parse_latm_get_value (GstAacParse * aacparse, GstBitReader * br,
+    guint32 * value)
+{
+  guint8 bytes, i, byte;
+
+  *value = 0;
+  if (!gst_bit_reader_get_bits_uint8 (br, &bytes, 2))
+    return FALSE;
+  for (i = 0; i < bytes; ++i) {
+    *value <<= 8;
+    if (!gst_bit_reader_get_bits_uint8 (br, &byte, 8))
+      return FALSE;
+    *value += byte;
+  }
+  return TRUE;
+}
+
+static gboolean
+gst_aac_parse_get_audio_object_type (GstAacParse * aacparse, GstBitReader * br,
+    guint8 * audio_object_type)
+{
+  if (!gst_bit_reader_get_bits_uint8 (br, audio_object_type, 5))
+    return FALSE;
+  if (*audio_object_type == 31) {
+    if (!gst_bit_reader_get_bits_uint8 (br, audio_object_type, 6))
+      return FALSE;
+    *audio_object_type += 32;
+  }
+  GST_LOG_OBJECT (aacparse, "audio object type %u", *audio_object_type);
+  return TRUE;
+}
+
+static gboolean
+gst_aac_parse_get_audio_sample_rate (GstAacParse * aacparse, GstBitReader * br,
+    gint * sample_rate)
+{
+  guint8 sampling_frequency_index;
+  if (!gst_bit_reader_get_bits_uint8 (br, &sampling_frequency_index, 4))
+    return FALSE;
+  GST_LOG_OBJECT (aacparse, "sampling_frequency_index: %u",
+      sampling_frequency_index);
+  if (sampling_frequency_index == 0xf) {
+    guint32 sampling_rate;
+    if (!gst_bit_reader_get_bits_uint32 (br, &sampling_rate, 24))
+      return FALSE;
+    *sample_rate = sampling_rate;
+  } else {
+    *sample_rate = loas_sample_rate_table[sampling_frequency_index];
+    if (!*sample_rate)
+      return FALSE;
+  }
+  return TRUE;
+}
+
+/* See table 1.13 in ISO/IEC 14496-3 */
+static gboolean
+gst_aac_parse_read_loas_audio_specific_config (GstAacParse * aacparse,
+    GstBitReader * br, gint * sample_rate, gint * channels, guint32 * bits)
+{
+  guint8 audio_object_type, channel_configuration;
+
+  if (!gst_aac_parse_get_audio_object_type (aacparse, br, &audio_object_type))
+    return FALSE;
+
+  if (!gst_aac_parse_get_audio_sample_rate (aacparse, br, sample_rate))
+    return FALSE;
+
+  if (!gst_bit_reader_get_bits_uint8 (br, &channel_configuration, 4))
+    return FALSE;
+  GST_LOG_OBJECT (aacparse, "channel_configuration: %d", channel_configuration);
+  *channels = loas_channels_table[channel_configuration];
+  if (!*channels)
+    return FALSE;
+
+  if (audio_object_type == 5) {
+    GST_LOG_OBJECT (aacparse,
+        "Audio object type 5, so rereading sampling rate...");
+    if (!gst_aac_parse_get_audio_sample_rate (aacparse, br, sample_rate))
+      return FALSE;
+  }
+
+  GST_INFO_OBJECT (aacparse, "Found LOAS config: %d Hz, %d channels",
+      *sample_rate, *channels);
+
+  /* There's LOTS of stuff next, but we ignore it for now as we have
+     what we want (sample rate and number of channels */
+  GST_DEBUG_OBJECT (aacparse,
+      "Need more code to parse humongous LOAS data, currently ignored");
+  if (bits)
+    *bits = 0;
+  return TRUE;
+}
+
+
+static gboolean
+gst_aac_parse_read_loas_config (GstAacParse * aacparse, const guint8 * data,
+    guint avail, gint * sample_rate, gint * channels, gint * version)
+{
+  GstBitReader br;
+  guint8 u8, v, vA;
+
+  /* No version in the bitstream, but the spec has LOAS in the MPEG-4 section */
+  if (version)
+    *version = 4;
+
+  gst_bit_reader_init (&br, data, avail);
+
+  /* skip sync word (11 bits) and size (13 bits) */
+  gst_bit_reader_skip (&br, 11 + 13);
+
+  /* First bit is "use last config" */
+  if (!gst_bit_reader_get_bits_uint8 (&br, &u8, 1))
+    return FALSE;
+  if (u8) {
+    GST_DEBUG_OBJECT (aacparse, "Frame uses previous config");
+    if (!aacparse->sample_rate || !aacparse->channels) {
+      GST_WARNING_OBJECT (aacparse, "No previous config to use");
+    }
+    *sample_rate = aacparse->sample_rate;
+    *channels = aacparse->channels;
+    return TRUE;
+  }
+
+  GST_DEBUG_OBJECT (aacparse, "Frame contains new config");
+
+  if (!gst_bit_reader_get_bits_uint8 (&br, &v, 1))
+    return FALSE;
+  if (v) {
+    if (!gst_bit_reader_get_bits_uint8 (&br, &vA, 1))
+      return FALSE;
+  } else
+    vA = 0;
+
+  GST_LOG_OBJECT (aacparse, "v %d, vA %d", v, vA);
+  if (vA == 0) {
+    guint8 same_time, subframes, num_program, prog;
+    if (v == 1) {
+      guint32 value;
+      if (!gst_aac_parse_latm_get_value (aacparse, &br, &value))
+        return FALSE;
+    }
+    if (!gst_bit_reader_get_bits_uint8 (&br, &same_time, 1))
+      return FALSE;
+    if (!gst_bit_reader_get_bits_uint8 (&br, &subframes, 6))
+      return FALSE;
+    if (!gst_bit_reader_get_bits_uint8 (&br, &num_program, 4))
+      return FALSE;
+    GST_LOG_OBJECT (aacparse, "same_time %d, subframes %d, num_program %d",
+        same_time, subframes, num_program);
+
+    for (prog = 0; prog <= num_program; ++prog) {
+      guint8 num_layer, layer;
+      if (!gst_bit_reader_get_bits_uint8 (&br, &num_layer, 3))
+        return FALSE;
+      GST_LOG_OBJECT (aacparse, "Program %d: %d layers", prog, num_layer);
+
+      for (layer = 0; layer <= num_layer; ++layer) {
+        guint8 use_same_config;
+        if (prog == 0 && layer == 0) {
+          use_same_config = 0;
+        } else {
+          if (!gst_bit_reader_get_bits_uint8 (&br, &use_same_config, 1))
+            return FALSE;
+        }
+        if (!use_same_config) {
+          if (v == 0) {
+            if (!gst_aac_parse_read_loas_audio_specific_config (aacparse, &br,
+                    sample_rate, channels, NULL))
+              return FALSE;
+          } else {
+            guint32 bits, asc_len;
+            if (!gst_aac_parse_latm_get_value (aacparse, &br, &asc_len))
+              return FALSE;
+            if (!gst_aac_parse_read_loas_audio_specific_config (aacparse, &br,
+                    sample_rate, channels, &bits))
+              return FALSE;
+            asc_len -= bits;
+            gst_bit_reader_skip (&br, asc_len);
+          }
+        }
+      }
+    }
+    GST_WARNING_OBJECT (aacparse, "More data ignored");
+  } else {
+    GST_WARNING_OBJECT (aacparse, "Spec says \"TBD\"...");
+  }
+  return TRUE;
+}
+
+/**
+ * gst_aac_parse_loas_get_frame_len:
+ * @data: block of data containing a LOAS header.
+ *
+ * This function calculates LOAS frame length from the given header.
+ *
+ * Returns: size of the LOAS frame.
+ */
+static inline guint
+gst_aac_parse_loas_get_frame_len (const guint8 * data)
+{
+  return (((data[1] & 0x1f) << 8) | data[2]) + 3;
+}
+
+
+/**
+ * gst_aac_parse_check_loas_frame:
+ * @aacparse: #GstAacParse.
+ * @data: Data to be checked.
+ * @avail: Amount of data passed.
+ * @framesize: If valid LOAS frame was found, this will be set to tell the
+ *             found frame size in bytes.
+ * @needed_data: If frame was not found, this may be set to tell how much
+ *               more data is needed in the next round to detect the frame
+ *               reliably. This may happen when a frame header candidate
+ *               is found but it cannot be guaranteed to be the header without
+ *               peeking the following data.
+ *
+ * Check if the given data contains contains LOAS frame. The algorithm
+ * will examine LOAS frame header and calculate the frame size. Also, another
+ * consecutive LOAS frame header need to be present after the found frame.
+ * Otherwise the data is not considered as a valid LOAS frame. However, this
+ * "extra check" is omitted when EOS has been received. In this case it is
+ * enough when data[0] contains a valid LOAS header.
+ *
+ * This function may set the #needed_data to indicate that a possible frame
+ * candidate has been found, but more data (#needed_data bytes) is needed to
+ * be absolutely sure. When this situation occurs, FALSE will be returned.
+ *
+ * When a valid frame is detected, this function will use
+ * gst_base_parse_set_min_frame_size() function from #GstBaseParse class
+ * to set the needed bytes for next frame.This way next data chunk is already
+ * of correct size.
+ *
+ * LOAS can have three different formats, if I read the spec correctly. Only
+ * one of them is supported here, as the two samples I have use this one.
+ *
+ * Returns: TRUE if the given data contains a valid LOAS header.
+ */
+static gboolean
+gst_aac_parse_check_loas_frame (GstAacParse * aacparse,
+    const guint8 * data, const guint avail, gboolean drain,
+    guint * framesize, guint * needed_data)
+{
+  *needed_data = 0;
+
+  /* 3 byte header */
+  if (G_UNLIKELY (avail < 3))
+    return FALSE;
+
+  if ((data[0] == 0x56) && ((data[1] & 0xe0) == 0xe0)) {
+    *framesize = gst_aac_parse_loas_get_frame_len (data);
+    GST_DEBUG_OBJECT (aacparse, "Found %u byte LOAS frame", *framesize);
+
+    /* In EOS mode this is enough. No need to examine the data further.
+       We also relax the check when we have sync, on the assumption that
+       if we're not looking at random data, we have a much higher chance
+       to get the correct sync, and this avoids losing two frames when
+       a single bit corruption happens. */
+    if (drain || !GST_BASE_PARSE_LOST_SYNC (aacparse)) {
+      return TRUE;
+    }
+
+    if (*framesize + LOAS_MAX_SIZE > avail) {
+      /* We have found a possible frame header candidate, but can't be
+         sure since we don't have enough data to check the next frame */
+      GST_DEBUG ("NEED MORE DATA: we need %d, available %d",
+          *framesize + LOAS_MAX_SIZE, avail);
+      *needed_data = *framesize + LOAS_MAX_SIZE;
+      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),
+          *framesize + LOAS_MAX_SIZE);
+      return FALSE;
+    }
+
+    if ((data[*framesize] == 0x56) && ((data[*framesize + 1] & 0xe0) == 0xe0)) {
+      guint nextlen = gst_aac_parse_loas_get_frame_len (data + (*framesize));
+
+      GST_LOG ("LOAS frame found, len: %d bytes", *framesize);
+      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),
+          nextlen + LOAS_MAX_SIZE);
+      return TRUE;
+    }
+  }
+  return FALSE;
+}
+
 /* caller ensure sufficient data */
 static inline void
 gst_aac_parse_parse_adts_header (GstAacParse * aacparse, const guint8 * data,
@@ -410,7 +713,7 @@ gst_aac_parse_detect_stream (GstAacParse * aacparse,
     guint * framesize, gint * skipsize)
 {
   gboolean found = FALSE;
-  guint need_data = 0;
+  guint need_data_adts = 0, need_data_loas;
   guint i = 0;
 
   GST_DEBUG_OBJECT (aacparse, "Parsing header data");
@@ -419,12 +722,16 @@ gst_aac_parse_detect_stream (GstAacParse * aacparse,
      stream */
 
   /* Can we even parse the header? */
-  if (avail < ADTS_MAX_SIZE)
+  if (avail < MAX (ADTS_MAX_SIZE, LOAS_MAX_SIZE)) {
+    GST_DEBUG_OBJECT (aacparse, "Not enough data to check");
     return FALSE;
+  }
 
   for (i = 0; i < avail - 4; i++) {
     if (((data[i] == 0xff) && ((data[i + 1] & 0xf6) == 0xf0)) ||
+        ((data[0] == 0x56) && ((data[1] & 0xe0) == 0xe0)) ||
         strncmp ((char *) data + i, "ADIF", 4) == 0) {
+      GST_DEBUG_OBJECT (aacparse, "Found ADIF signature at offset %u", i);
       found = TRUE;
 
       if (i) {
@@ -444,7 +751,7 @@ gst_aac_parse_detect_stream (GstAacParse * aacparse,
   }
 
   if (gst_aac_parse_check_adts_frame (aacparse, data, avail, drain,
-          framesize, &need_data)) {
+          framesize, &need_data_adts)) {
     gint rate, channels;
 
     GST_INFO ("ADTS ID: %d, framesize: %d", (data[1] & 0x08) >> 3, *framesize);
@@ -462,7 +769,38 @@ gst_aac_parse_detect_stream (GstAacParse * aacparse,
     gst_base_parse_set_syncable (GST_BASE_PARSE (aacparse), TRUE);
 
     return TRUE;
-  } else if (need_data) {
+  }
+
+  if (gst_aac_parse_check_loas_frame (aacparse, data, avail, drain,
+          framesize, &need_data_loas)) {
+    gint rate, channels;
+
+    GST_INFO ("LOAS, framesize: %d", *framesize);
+
+    aacparse->header_type = DSPAAC_HEADER_LOAS;
+
+    if (!gst_aac_parse_read_loas_config (aacparse, data, avail, &rate,
+            &channels, &aacparse->mpegversion)) {
+      GST_WARNING_OBJECT (aacparse, "Error reading LOAS config");
+      return FALSE;
+    }
+
+    if (rate && channels) {
+      gst_base_parse_set_frame_rate (GST_BASE_PARSE (aacparse), rate,
+          aacparse->frame_samples, 2, 2);
+
+      GST_DEBUG ("LOAS: samplerate %d, channels %d, objtype %d, version %d",
+          rate, channels, aacparse->object_type, aacparse->mpegversion);
+      aacparse->sample_rate = rate;
+      aacparse->channels = channels;
+    }
+
+    gst_base_parse_set_syncable (GST_BASE_PARSE (aacparse), TRUE);
+
+    return TRUE;
+  }
+
+  if (need_data_adts || need_data_loas) {
     /* This tells the parent class not to skip any data */
     *skipsize = 0;
     return FALSE;
@@ -607,6 +945,19 @@ gst_aac_parse_check_valid_frame (GstBaseParse * parse,
           needed_data);
     }
 
+  } else if (aacparse->header_type == DSPAAC_HEADER_LOAS) {
+    guint needed_data = 1024;
+
+    ret = gst_aac_parse_check_loas_frame (aacparse, data,
+        GST_BUFFER_SIZE (buffer), GST_BASE_PARSE_DRAINING (parse),
+        framesize, &needed_data);
+
+    if (!ret) {
+      GST_DEBUG ("buffer didn't contain valid frame");
+      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),
+          needed_data);
+    }
+
   } else {
     GST_DEBUG ("buffer didn't contain valid frame");
     gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),
@@ -626,7 +977,7 @@ gst_aac_parse_check_valid_frame (GstBaseParse * parse,
  *
  * Also determines frame overhead.
  * ADTS streams have a 7 byte header in each frame. MP4 and ADIF streams don't have
- * a per-frame header.
+ * a per-frame header. LOAS has 3 bytes.
  *
  * We're making a couple of simplifying assumptions:
  *
@@ -651,29 +1002,59 @@ gst_aac_parse_parse_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
   aacparse = GST_AAC_PARSE (parse);
   buffer = frame->buffer;
 
-  if (G_UNLIKELY (aacparse->header_type != DSPAAC_HEADER_ADTS))
-    return ret;
+  if (aacparse->header_type == DSPAAC_HEADER_ADTS) {
+    /* see above */
+    frame->overhead = 7;
 
-  /* see above */
-  frame->overhead = 7;
+    gst_aac_parse_parse_adts_header (aacparse, GST_BUFFER_DATA (buffer),
+        &rate, &channels, NULL, NULL);
+    GST_LOG_OBJECT (aacparse, "rate: %d, chans: %d", rate, channels);
 
-  gst_aac_parse_parse_adts_header (aacparse, GST_BUFFER_DATA (buffer),
-      &rate, &channels, NULL, NULL);
-  GST_LOG_OBJECT (aacparse, "rate: %d, chans: %d", rate, channels);
+    if (G_UNLIKELY (rate != aacparse->sample_rate
+            || channels != aacparse->channels)) {
+      aacparse->sample_rate = rate;
+      aacparse->channels = channels;
 
-  if (G_UNLIKELY (rate != aacparse->sample_rate
-          || channels != aacparse->channels)) {
-    aacparse->sample_rate = rate;
-    aacparse->channels = channels;
+      if (!gst_aac_parse_set_src_caps (aacparse,
+              GST_PAD_CAPS (GST_BASE_PARSE (aacparse)->sinkpad))) {
+        /* If linking fails, we need to return appropriate error */
+        ret = GST_FLOW_NOT_LINKED;
+      }
 
-    if (!gst_aac_parse_set_src_caps (aacparse,
-            GST_PAD_CAPS (GST_BASE_PARSE (aacparse)->sinkpad))) {
-      /* If linking fails, we need to return appropriate error */
-      ret = GST_FLOW_NOT_LINKED;
+      gst_base_parse_set_frame_rate (GST_BASE_PARSE (aacparse),
+          aacparse->sample_rate, aacparse->frame_samples, 2, 2);
+    }
+  } else if (aacparse->header_type == DSPAAC_HEADER_LOAS) {
+    gboolean setcaps = FALSE;
+
+    /* see above */
+    frame->overhead = 3;
+
+    if (!gst_aac_parse_read_loas_config (aacparse, GST_BUFFER_DATA (buffer),
+            GST_BUFFER_SIZE (buffer), &rate, &channels, NULL)) {
+      GST_WARNING_OBJECT (aacparse, "Error reading LOAS config");
+    } else if (G_UNLIKELY (rate != aacparse->sample_rate
+            || channels != aacparse->channels)) {
+      aacparse->sample_rate = rate;
+      aacparse->channels = channels;
+      setcaps = TRUE;
+      GST_INFO_OBJECT (aacparse, "New LOAS config: %d Hz, %d channels", rate,
+          channels);
     }
 
-    gst_base_parse_set_frame_rate (GST_BASE_PARSE (aacparse),
-        aacparse->sample_rate, aacparse->frame_samples, 2, 2);
+    /* We want to set caps both at start, and when rate/channels change.
+       Since only some LOAS frames have that info, we may receive frames
+       before knowing about rate/channels. */
+    if (setcaps || !GST_PAD_CAPS (GST_BASE_PARSE_SRC_PAD (aacparse))) {
+      if (!gst_aac_parse_set_src_caps (aacparse,
+              GST_PAD_CAPS (GST_BASE_PARSE (aacparse)->sinkpad))) {
+        /* If linking fails, we need to return appropriate error */
+        ret = GST_FLOW_NOT_LINKED;
+      }
+
+      gst_base_parse_set_frame_rate (GST_BASE_PARSE (aacparse),
+          aacparse->sample_rate, aacparse->frame_samples, 2, 2);
+    }
   }
 
   return ret;
@@ -737,7 +1118,7 @@ gst_aac_parse_sink_getcaps (GstBaseParse * parse)
 
     res =
         gst_caps_intersect_full (peercaps,
-        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SRC_PAD (parse)),
+        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SINK_PAD (parse)),
         GST_CAPS_INTERSECT_FIRST);
     gst_caps_unref (peercaps);
   } else {
diff --git a/gst/audioparsers/gstaacparse.h b/gst/audioparsers/gstaacparse.h
index 1907c2e..11f75e6 100644
--- a/gst/audioparsers/gstaacparse.h
+++ b/gst/audioparsers/gstaacparse.h
@@ -45,6 +45,7 @@ G_BEGIN_DECLS
  * @DSPAAC_HEADER_UNKNOWN: Unknown (not recognized) header.
  * @DSPAAC_HEADER_ADIF: ADIF header found.
  * @DSPAAC_HEADER_ADTS: ADTS header found.
+ * @DSPAAC_HEADER_LOAS: LOAS header found.
  * @DSPAAC_HEADER_NONE: Raw stream, no header.
  *
  * Type header enumeration set in #header_type.
@@ -54,6 +55,7 @@ typedef enum {
   DSPAAC_HEADER_UNKNOWN,
   DSPAAC_HEADER_ADIF,
   DSPAAC_HEADER_ADTS,
+  DSPAAC_HEADER_LOAS,
   DSPAAC_HEADER_NONE
 } GstAacHeaderType;
 
diff --git a/gst/audioparsers/gstac3parse.c b/gst/audioparsers/gstac3parse.c
index 6fa4658..0777ee2 100644
--- a/gst/audioparsers/gstac3parse.c
+++ b/gst/audioparsers/gstac3parse.c
@@ -688,7 +688,7 @@ gst_ac3_parse_get_sink_caps (GstBaseParse * parse)
 
     res =
         gst_caps_intersect_full (peercaps,
-        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SRC_PAD (parse)),
+        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SINK_PAD (parse)),
         GST_CAPS_INTERSECT_FIRST);
     gst_caps_unref (peercaps);
   } else {
diff --git a/gst/audioparsers/gstamrparse.c b/gst/audioparsers/gstamrparse.c
index 8f6ef94..128efa1 100644
--- a/gst/audioparsers/gstamrparse.c
+++ b/gst/audioparsers/gstamrparse.c
@@ -418,7 +418,7 @@ gst_amr_parse_sink_getcaps (GstBaseParse * parse)
 
     res =
         gst_caps_intersect_full (peercaps,
-        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SRC_PAD (parse)),
+        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SINK_PAD (parse)),
         GST_CAPS_INTERSECT_FIRST);
     gst_caps_unref (peercaps);
   } else {
diff --git a/gst/audioparsers/gstdcaparse.c b/gst/audioparsers/gstdcaparse.c
index c34d83e..641bd4d 100644
--- a/gst/audioparsers/gstdcaparse.c
+++ b/gst/audioparsers/gstdcaparse.c
@@ -473,7 +473,7 @@ gst_dca_parse_get_sink_caps (GstBaseParse * parse)
 
     res =
         gst_caps_intersect_full (peercaps,
-        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SRC_PAD (parse)),
+        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SINK_PAD (parse)),
         GST_CAPS_INTERSECT_FIRST);
     gst_caps_unref (peercaps);
   } else {
diff --git a/gst/audioparsers/gstflacparse.c b/gst/audioparsers/gstflacparse.c
index 9cfdb98..b331f66 100644
--- a/gst/audioparsers/gstflacparse.c
+++ b/gst/audioparsers/gstflacparse.c
@@ -381,7 +381,8 @@ typedef enum
 
 static FrameHeaderCheckReturn
 gst_flac_parse_frame_header_is_valid (GstFlacParse * flacparse,
-    const guint8 * data, guint size, gboolean set, guint16 * block_size_ret)
+    const guint8 * data, guint size, gboolean set, guint16 * block_size_ret,
+    gboolean * suspect)
 {
   GstBitReader reader = GST_BIT_READER_INIT (data, size);
   guint8 blocking_strategy;
@@ -575,6 +576,8 @@ gst_flac_parse_frame_header_is_valid (GstFlacParse * flacparse,
         /* TODO: can we know we're on the last frame, to avoid warning ? */
         GST_WARNING_OBJECT (flacparse, "Block size is not constant");
         block_size = flacparse->block_size;
+        if (suspect)
+          *suspect = TRUE;
       }
     }
   }
@@ -623,6 +626,7 @@ gst_flac_parse_frame_is_valid (GstFlacParse * flacparse,
   guint i, search_start, search_end;
   FrameHeaderCheckReturn header_ret;
   guint16 block_size;
+  gboolean suspect_start = FALSE, suspect_end = FALSE;
 
   buffer = frame->buffer;
   data = GST_BUFFER_DATA (buffer);
@@ -633,7 +637,7 @@ gst_flac_parse_frame_is_valid (GstFlacParse * flacparse,
 
   header_ret =
       gst_flac_parse_frame_header_is_valid (flacparse, data, size, TRUE,
-      &block_size);
+      &block_size, &suspect_start);
   if (header_ret == FRAME_HEADER_INVALID) {
     *ret = 0;
     return FALSE;
@@ -653,16 +657,23 @@ gst_flac_parse_frame_is_valid (GstFlacParse * flacparse,
 
   for (i = search_start; i < search_end; i++, remaining--) {
     if ((GST_READ_UINT16_BE (data + i) & 0xfffe) == 0xfff8) {
+      GST_LOG_OBJECT (flacparse, "possible frame end at offset %d", i);
+      suspect_end = FALSE;
       header_ret =
           gst_flac_parse_frame_header_is_valid (flacparse, data + i, remaining,
-          FALSE, NULL);
+          FALSE, NULL, &suspect_end);
       if (header_ret == FRAME_HEADER_VALID) {
-        if (flacparse->check_frame_checksums) {
+        if (flacparse->check_frame_checksums || suspect_start || suspect_end) {
           guint16 actual_crc = gst_flac_calculate_crc16 (data, i - 2);
           guint16 expected_crc = GST_READ_UINT16_BE (data + i - 2);
 
-          if (actual_crc != expected_crc)
+          GST_LOG_OBJECT (flacparse,
+              "checking checksum, frame suspect (%d, %d)",
+              suspect_start, suspect_end);
+          if (actual_crc != expected_crc) {
+            GST_DEBUG_OBJECT (flacparse, "checksum did not match");
             continue;
+          }
         }
         *ret = i;
         flacparse->block_size = block_size;
@@ -691,6 +702,15 @@ gst_flac_parse_frame_is_valid (GstFlacParse * flacparse,
     }
   }
 
+  /* so we searched to expected end and found nothing,
+   * give up on this frame (start) */
+  if (flacparse->max_framesize && i > 2 * flacparse->max_framesize) {
+    GST_LOG_OBJECT (flacparse,
+        "could not determine valid frame end, discarding frame (start)");
+    *ret = 1;
+    return FALSE;
+  }
+
 need_more:
   max = flacparse->max_framesize + 16;
   if (max == 16)
@@ -1313,7 +1333,7 @@ gst_flac_parse_parse_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
       flacparse->offset = GST_BUFFER_OFFSET (buffer);
       ret =
           gst_flac_parse_frame_header_is_valid (flacparse,
-          GST_BUFFER_DATA (buffer), GST_BUFFER_SIZE (buffer), TRUE, NULL);
+          GST_BUFFER_DATA (buffer), GST_BUFFER_SIZE (buffer), TRUE, NULL, NULL);
       if (ret != FRAME_HEADER_VALID) {
         GST_ERROR_OBJECT (flacparse,
             "Baseclass didn't provide a complete frame");
@@ -1454,7 +1474,7 @@ gst_flac_parse_get_sink_caps (GstBaseParse * parse)
 
     res =
         gst_caps_intersect_full (peercaps,
-        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SRC_PAD (parse)),
+        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SINK_PAD (parse)),
         GST_CAPS_INTERSECT_FIRST);
     gst_caps_unref (peercaps);
   } else {
diff --git a/gst/audioparsers/gstmpegaudioparse.c b/gst/audioparsers/gstmpegaudioparse.c
index 2381fc3..43c330c 100644
--- a/gst/audioparsers/gstmpegaudioparse.c
+++ b/gst/audioparsers/gstmpegaudioparse.c
@@ -146,8 +146,7 @@ gst_mpeg_audio_parse_base_init (gpointer klass)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 
-  gst_element_class_add_static_pad_template (element_class,
-      &sink_template);
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
   gst_element_class_add_static_pad_template (element_class, &src_template);
 
   gst_element_class_set_details_simple (element_class, "MPEG1 Audio Parser",
@@ -200,6 +199,7 @@ gst_mpeg_audio_parse_reset (GstMpegAudioParse * mp3parse)
   mp3parse->sent_codec_tag = FALSE;
   mp3parse->last_posted_crc = CRC_UNKNOWN;
   mp3parse->last_posted_channel_mode = MPEG_AUDIO_CHANNEL_MODE_UNKNOWN;
+  mp3parse->freerate = 0;
 
   mp3parse->hdr_bitrate = 0;
 
@@ -307,14 +307,16 @@ mp3_type_frame_length_from_header (GstMpegAudioParse * mp3parse, guint32 header,
 
   bitrate = (header >> 12) & 0xF;
   bitrate = mp3types_bitrates[lsf][layer - 1][bitrate] * 1000;
-  /* The caller has ensured we have a valid header, so bitrate can't be
-     zero here. */
-  g_assert (bitrate != 0);
+  if (!bitrate) {
+    GST_LOG_OBJECT (mp3parse, "using freeform bitrate");
+    bitrate = mp3parse->freerate;
+  }
 
   samplerate = (header >> 10) & 0x3;
   samplerate = mp3types_freqs[lsf + mpg25][samplerate];
 
-  padding = (header >> 9) & 0x1;
+  /* force 0 length if 0 bitrate */
+  padding = (bitrate > 0) ? (header >> 9) & 0x1 : 0;
 
   mode = (header >> 6) & 0x3;
   channels = (mode == 3) ? 1 : 2;
@@ -419,8 +421,7 @@ gst_mp3parse_validate_extended (GstMpegAudioParse * mp3parse, GstBuffer * buf,
           (guint) next_header & HDRMASK, bpf);
       *valid = FALSE;
       return TRUE;
-    } else if ((((next_header >> 12) & 0xf) == 0) ||
-        (((next_header >> 12) & 0xf) == 0xf)) {
+    } else if (((next_header >> 12) & 0xf) == 0xf) {
       /* The essential parts were the same, but the bitrate held an
          invalid value - also reject */
       GST_DEBUG_OBJECT (mp3parse, "next header invalid (bitrate)");
@@ -431,6 +432,13 @@ gst_mp3parse_validate_extended (GstMpegAudioParse * mp3parse, GstBuffer * buf,
     bpf = mp3_type_frame_length_from_header (mp3parse, next_header,
         NULL, NULL, NULL, NULL, NULL, NULL, NULL);
 
+    /* if no bitrate, and no freeform rate known, then fail */
+    if (G_UNLIKELY (!bpf)) {
+      GST_DEBUG_OBJECT (mp3parse, "next header invalid (bitrate 0)");
+      *valid = FALSE;
+      return TRUE;
+    }
+
     offset += bpf;
     frames_found++;
   }
@@ -461,11 +469,6 @@ gst_mpeg_audio_parse_head_check (GstMpegAudioParse * mp3parse,
     return FALSE;
   }
   /* if it's an invalid bitrate */
-  if (((head >> 12) & 0xf) == 0x0) {
-    GST_WARNING_OBJECT (mp3parse, "invalid bitrate: 0x%lx."
-        "Free format files are not supported yet", (head >> 12) & 0xf);
-    return FALSE;
-  }
   if (((head >> 12) & 0xf) == 0xf) {
     GST_WARNING_OBJECT (mp3parse, "invalid bitrate: 0x%lx", (head >> 12) & 0xf);
     return FALSE;
@@ -486,6 +489,115 @@ gst_mpeg_audio_parse_head_check (GstMpegAudioParse * mp3parse,
   return TRUE;
 }
 
+/* Determines possible freeform frame rate/size by looking for next
+ * header with valid bitrate (0 or otherwise valid) (and sufficiently
+ * matching current header).
+ *
+ * Returns TRUE if we've found such one, and *rate then contains rate
+ * (or *rate contains 0 if decided no freeframe size could be determined).
+ * If not enough data, returns FALSE.
+ */
+static gboolean
+gst_mp3parse_find_freerate (GstMpegAudioParse * mp3parse, GstBuffer * buf,
+    guint32 header, gboolean at_eos, gint * _rate)
+{
+  guint32 next_header;
+  const guint8 *data;
+  guint available;
+  int offset = 4;
+  gulong samplerate, rate, layer, padding;
+  gboolean valid;
+  gint lsf, mpg25;
+
+  available = GST_BUFFER_SIZE (buf);
+  data = GST_BUFFER_DATA (buf);
+
+  *_rate = 0;
+
+  /* pick apart header again partially */
+  if (header & (1 << 20)) {
+    lsf = (header & (1 << 19)) ? 0 : 1;
+    mpg25 = 0;
+  } else {
+    lsf = 1;
+    mpg25 = 1;
+  }
+  layer = 4 - ((header >> 17) & 0x3);
+  samplerate = (header >> 10) & 0x3;
+  samplerate = mp3types_freqs[lsf + mpg25][samplerate];
+  padding = (header >> 9) & 0x1;
+
+  for (; offset < available; ++offset) {
+    /* Check if we have enough data for all these frames, plus the next
+       frame header. */
+    if (available < offset + 4) {
+      if (at_eos) {
+        /* Running out of data; failed to determine size */
+        return TRUE;
+      } else {
+        return FALSE;
+      }
+    }
+
+    valid = FALSE;
+    next_header = GST_READ_UINT32_BE (data + offset);
+    if ((next_header & 0xFFE00000) != 0xFFE00000)
+      goto next;
+
+    GST_DEBUG_OBJECT (mp3parse, "At %d: header=%08X, header2=%08X",
+        offset, (unsigned int) header, (unsigned int) next_header);
+
+    if ((next_header & HDRMASK) != (header & HDRMASK)) {
+      /* If any of the unmasked bits don't match, then it's not valid */
+      GST_DEBUG_OBJECT (mp3parse, "next header doesn't match "
+          "(header=%08X (%08X), header2=%08X (%08X))",
+          (guint) header, (guint) header & HDRMASK, (guint) next_header,
+          (guint) next_header & HDRMASK);
+      goto next;
+    } else if (((next_header >> 12) & 0xf) == 0xf) {
+      /* The essential parts were the same, but the bitrate held an
+         invalid value - also reject */
+      GST_DEBUG_OBJECT (mp3parse, "next header invalid (bitrate)");
+      goto next;
+    }
+
+    valid = TRUE;
+
+  next:
+    /* almost accept as free frame */
+    if (layer == 1) {
+      rate = samplerate * (offset - 4 * padding + 4) / 48000;
+    } else {
+      rate = samplerate * (offset - padding + 1) / (144 >> lsf) / 1000;
+    }
+
+    if (valid) {
+      GST_LOG_OBJECT (mp3parse, "calculated rate %lu", rate * 1000);
+      if (rate < 8 || (layer == 3 && rate > 640)) {
+        GST_DEBUG_OBJECT (mp3parse, "rate invalid");
+        if (rate < 8) {
+          /* maybe some hope */
+          continue;
+        } else {
+          GST_DEBUG_OBJECT (mp3parse, "aborting");
+          /* give up */
+          break;
+        }
+      }
+      *_rate = rate * 1000;
+      break;
+    } else {
+      /* avoid indefinite searching */
+      if (rate > 1000) {
+        GST_DEBUG_OBJECT (mp3parse, "exceeded sanity rate; aborting");
+        break;
+      }
+    }
+  }
+
+  return TRUE;
+}
+
 static gboolean
 gst_mpeg_audio_parse_check_valid_frame (GstBaseParse * parse,
     GstBaseParseFrame * frame, guint * framesize, gint * skipsize)
@@ -527,9 +639,14 @@ gst_mpeg_audio_parse_check_valid_frame (GstBaseParse * parse,
 
   GST_LOG_OBJECT (parse, "got frame");
 
+  lost_sync = GST_BASE_PARSE_LOST_SYNC (parse);
+  draining = GST_BASE_PARSE_DRAINING (parse);
+
+  if (G_UNLIKELY (lost_sync))
+    mp3parse->freerate = 0;
+
   bpf = mp3_type_frame_length_from_header (mp3parse, header,
       &version, &layer, &channels, &bitrate, &rate, &mode, &crc);
-  g_assert (bpf != 0);
 
   if (channels != mp3parse->channels || rate != mp3parse->rate ||
       layer != mp3parse->layer || version != mp3parse->version)
@@ -537,8 +654,30 @@ gst_mpeg_audio_parse_check_valid_frame (GstBaseParse * parse,
   else
     caps_change = FALSE;
 
-  lost_sync = GST_BASE_PARSE_LOST_SYNC (parse);
-  draining = GST_BASE_PARSE_DRAINING (parse);
+  /* maybe free format */
+  if (bpf == 0) {
+    GST_LOG_OBJECT (mp3parse, "possibly free format");
+    if (lost_sync || mp3parse->freerate == 0) {
+      GST_DEBUG_OBJECT (mp3parse, "finding free format rate");
+      if (!gst_mp3parse_find_freerate (mp3parse, buf, header, draining, &valid)) {
+        /* not enough data */
+        *framesize = G_MAXUINT;
+        *skipsize = 0;
+        return FALSE;
+      } else {
+        GST_DEBUG_OBJECT (parse, "determined freeform size %d", valid);
+        mp3parse->freerate = valid;
+      }
+    }
+    /* try again */
+    bpf = mp3_type_frame_length_from_header (mp3parse, header,
+        &version, &layer, &channels, &bitrate, &rate, &mode, &crc);
+    if (!bpf) {
+      /* did not come up with valid freeform length, reject after all */
+      *skipsize = 1;
+      return FALSE;
+    }
+  }
 
   if (!draining && (lost_sync || caps_change)) {
     if (!gst_mp3parse_validate_extended (mp3parse, buf, header, bpf, draining,
@@ -791,9 +930,7 @@ gst_mpeg_audio_parse_handle_first_frame (GstMpegAudioParse * mp3parse,
       GST_DEBUG_OBJECT (mp3parse, "Encoder delay %u, encoder padding %u",
           encoder_delay, encoder_padding);
     }
-  }
-
-  if (read_id_vbri == vbri_id) {
+  } else if (read_id_vbri == vbri_id) {
     gint64 total_bytes, total_frames;
     GstClockTime total_time;
     guint16 nseek_points;
@@ -1293,7 +1430,7 @@ gst_mpeg_audio_parse_get_sink_caps (GstBaseParse * parse)
 
     res =
         gst_caps_intersect_full (peercaps,
-        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SRC_PAD (parse)),
+        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SINK_PAD (parse)),
         GST_CAPS_INTERSECT_FIRST);
     gst_caps_unref (peercaps);
   } else {
diff --git a/gst/audioparsers/gstmpegaudioparse.h b/gst/audioparsers/gstmpegaudioparse.h
index 7580001..6b42673 100644
--- a/gst/audioparsers/gstmpegaudioparse.h
+++ b/gst/audioparsers/gstmpegaudioparse.h
@@ -60,6 +60,8 @@ struct _GstMpegAudioParse {
   /* samples per frame */
   gint        spf;
 
+  gint         freerate;
+
   gboolean     sent_codec_tag;
   guint        last_posted_bitrate;
   gint         last_posted_crc, last_crc;
diff --git a/gst/audioparsers/gstwavpackparse.c b/gst/audioparsers/gstwavpackparse.c
new file mode 100644
index 0000000..18c2fc2
--- /dev/null
+++ b/gst/audioparsers/gstwavpackparse.c
@@ -0,0 +1,648 @@
+/* GStreamer Wavpack parser
+ * Copyright (C) 2012 Mark Nauwelaerts <mark.nauwelaerts@collabora.co.uk>
+ * Copyright (C) 2012 Nokia Corporation. All rights reserved.
+ *   Contact: Stefan Kost <stefan.kost@nokia.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/**
+ * SECTION:element-wavpackparse
+ * @short_description: Wavpack parser
+ * @see_also: #GstAmrParse, #GstAACParse
+ *
+ * This is an Wavpack parser.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch filesrc location=abc.wavpack ! wavpackparse ! wavpackdec ! audioresample ! audioconvert ! autoaudiosink
+ * ]|
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "gstwavpackparse.h"
+
+#include <gst/base/gstbytereader.h>
+#include <gst/audio/multichannel.h>
+
+GST_DEBUG_CATEGORY_STATIC (wavpack_parse_debug);
+#define GST_CAT_DEFAULT wavpack_parse_debug
+
+static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/x-wavpack, "
+        "width = (int) [ 1, 32 ], "
+        "channels = (int) [ 1, 8 ], "
+        "rate = (int) [ 6000, 192000 ], " "framed = (boolean) TRUE; "
+        "audio/x-wavpack-correction, " "framed = (boolean) TRUE")
+    );
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/x-wavpack"));
+
+static void gst_wavpack_parse_finalize (GObject * object);
+
+static gboolean gst_wavpack_parse_start (GstBaseParse * parse);
+static gboolean gst_wavpack_parse_stop (GstBaseParse * parse);
+static gboolean gst_wavpack_parse_check_valid_frame (GstBaseParse * parse,
+    GstBaseParseFrame * frame, guint * size, gint * skipsize);
+static GstFlowReturn gst_wavpack_parse_parse_frame (GstBaseParse * parse,
+    GstBaseParseFrame * frame);
+static GstCaps *gst_wavpack_parse_get_sink_caps (GstBaseParse * parse);
+
+/* FIXME remove when all properly renamed */
+typedef GstWavpackParse GstWavpackParse2;
+typedef GstWavpackParseClass GstWavpackParse2Class;
+
+GST_BOILERPLATE (GstWavpackParse2, gst_wavpack_parse, GstBaseParse,
+    GST_TYPE_BASE_PARSE);
+
+static void
+gst_wavpack_parse_base_init (gpointer klass)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
+  gst_element_class_add_static_pad_template (element_class, &src_template);
+
+  gst_element_class_set_details_simple (element_class,
+      "Wavpack audio stream parser", "Codec/Parser/Audio",
+      "Wavpack parser", "Mark Nauwelaerts <mark.nauwelaerts@collabora.co.uk>");
+}
+
+static void
+gst_wavpack_parse_class_init (GstWavpackParseClass * klass)
+{
+  GstBaseParseClass *parse_class = GST_BASE_PARSE_CLASS (klass);
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  GST_DEBUG_CATEGORY_INIT (wavpack_parse_debug, "wavpackparse", 0,
+      "Wavpack audio stream parser");
+
+  object_class->finalize = gst_wavpack_parse_finalize;
+
+  parse_class->start = GST_DEBUG_FUNCPTR (gst_wavpack_parse_start);
+  parse_class->stop = GST_DEBUG_FUNCPTR (gst_wavpack_parse_stop);
+  parse_class->check_valid_frame =
+      GST_DEBUG_FUNCPTR (gst_wavpack_parse_check_valid_frame);
+  parse_class->parse_frame = GST_DEBUG_FUNCPTR (gst_wavpack_parse_parse_frame);
+  parse_class->get_sink_caps =
+      GST_DEBUG_FUNCPTR (gst_wavpack_parse_get_sink_caps);
+}
+
+static void
+gst_wavpack_parse_reset (GstWavpackParse * wvparse)
+{
+  wvparse->channels = -1;
+  wvparse->channel_mask = 0;
+  wvparse->sample_rate = -1;
+  wvparse->width = -1;
+  wvparse->total_samples = 0;
+}
+
+static void
+gst_wavpack_parse_init (GstWavpackParse * wvparse, GstWavpackParseClass * klass)
+{
+  gst_wavpack_parse_reset (wvparse);
+}
+
+static void
+gst_wavpack_parse_finalize (GObject * object)
+{
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_wavpack_parse_start (GstBaseParse * parse)
+{
+  GstWavpackParse *wvparse = GST_WAVPACK_PARSE (parse);
+
+  GST_DEBUG_OBJECT (parse, "starting");
+
+  gst_wavpack_parse_reset (wvparse);
+
+  /* need header at least */
+  gst_base_parse_set_min_frame_size (GST_BASE_PARSE (wvparse),
+      sizeof (WavpackHeader));
+
+  /* inform baseclass we can come up with ts, based on counters in packets */
+  gst_base_parse_set_has_timing_info (GST_BASE_PARSE_CAST (wvparse), TRUE);
+  gst_base_parse_set_syncable (GST_BASE_PARSE_CAST (wvparse), TRUE);
+
+  return TRUE;
+}
+
+static gboolean
+gst_wavpack_parse_stop (GstBaseParse * parse)
+{
+  GST_DEBUG_OBJECT (parse, "stopping");
+
+  return TRUE;
+}
+
+static gint
+gst_wavpack_get_default_channel_mask (gint nchannels)
+{
+  gint channel_mask = 0;
+
+  /* Set the default channel mask for the given number of channels.
+   * It's the same as for WAVE_FORMAT_EXTENDED:
+   * http://www.microsoft.com/whdc/device/audio/multichaud.mspx
+   */
+  switch (nchannels) {
+    case 11:
+      channel_mask |= 0x00400;
+      channel_mask |= 0x00200;
+    case 9:
+      channel_mask |= 0x00100;
+    case 8:
+      channel_mask |= 0x00080;
+      channel_mask |= 0x00040;
+    case 6:
+      channel_mask |= 0x00020;
+      channel_mask |= 0x00010;
+    case 4:
+      channel_mask |= 0x00008;
+    case 3:
+      channel_mask |= 0x00004;
+    case 2:
+      channel_mask |= 0x00002;
+      channel_mask |= 0x00001;
+      break;
+    case 1:
+      /* For mono use front center */
+      channel_mask |= 0x00004;
+      break;
+  }
+
+  return channel_mask;
+}
+
+static const struct
+{
+  const guint32 ms_mask;
+  const GstAudioChannelPosition gst_pos;
+} layout_mapping[] = {
+  {
+  0x00001, GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT}, {
+  0x00002, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT}, {
+  0x00004, GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER}, {
+  0x00008, GST_AUDIO_CHANNEL_POSITION_LFE}, {
+  0x00010, GST_AUDIO_CHANNEL_POSITION_REAR_LEFT}, {
+  0x00020, GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT}, {
+  0x00040, GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER}, {
+  0x00080, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER}, {
+  0x00100, GST_AUDIO_CHANNEL_POSITION_REAR_CENTER}, {
+  0x00200, GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT}, {
+  0x00400, GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT}, {
+  0x00800, GST_AUDIO_CHANNEL_POSITION_INVALID}, /* TOP_CENTER       */
+  {
+  0x01000, GST_AUDIO_CHANNEL_POSITION_INVALID}, /* TOP_FRONT_LEFT   */
+  {
+  0x02000, GST_AUDIO_CHANNEL_POSITION_INVALID}, /* TOP_FRONT_CENTER */
+  {
+  0x04000, GST_AUDIO_CHANNEL_POSITION_INVALID}, /* TOP_FRONT_RIGHT  */
+  {
+  0x08000, GST_AUDIO_CHANNEL_POSITION_INVALID}, /* TOP_BACK_LEFT    */
+  {
+  0x10000, GST_AUDIO_CHANNEL_POSITION_INVALID}, /* TOP_BACK_CENTER  */
+  {
+  0x20000, GST_AUDIO_CHANNEL_POSITION_INVALID}  /* TOP_BACK_RIGHT   */
+};
+
+#define MAX_CHANNEL_POSITIONS G_N_ELEMENTS (layout_mapping)
+
+static gboolean
+gst_wavpack_set_channel_layout (GstCaps * caps, gint layout)
+{
+  GstAudioChannelPosition pos[MAX_CHANNEL_POSITIONS];
+  GstStructure *s;
+  gint num_channels, i, p;
+
+  s = gst_caps_get_structure (caps, 0);
+  if (!gst_structure_get_int (s, "channels", &num_channels))
+    g_return_val_if_reached (FALSE);
+
+  if (num_channels == 1 && layout == 0x00004) {
+    pos[0] = GST_AUDIO_CHANNEL_POSITION_FRONT_MONO;
+    gst_audio_set_channel_positions (s, pos);
+    return TRUE;
+  }
+
+  p = 0;
+  for (i = 0; i < MAX_CHANNEL_POSITIONS; ++i) {
+    if ((layout & layout_mapping[i].ms_mask) != 0) {
+      if (p >= num_channels) {
+        GST_WARNING ("More bits set in the channel layout map than there "
+            "are channels! Broken file");
+        return FALSE;
+      }
+      if (layout_mapping[i].gst_pos == GST_AUDIO_CHANNEL_POSITION_INVALID) {
+        GST_WARNING ("Unsupported channel position (mask 0x%08x) in channel "
+            "layout map - ignoring those channels", layout_mapping[i].ms_mask);
+        /* what to do? just ignore it and let downstream deal with a channel
+         * layout that has INVALID positions in it for now ... */
+      }
+      pos[p] = layout_mapping[i].gst_pos;
+      ++p;
+    }
+  }
+
+  if (p != num_channels) {
+    GST_WARNING ("Only %d bits set in the channel layout map, but there are "
+        "supposed to be %d channels! Broken file", p, num_channels);
+    return FALSE;
+  }
+
+  gst_audio_set_channel_positions (s, pos);
+  return TRUE;
+}
+
+static const guint32 sample_rates[] = {
+  6000, 8000, 9600, 11025, 12000, 16000, 22050,
+  24000, 32000, 44100, 48000, 64000, 88200, 96000, 192000
+};
+
+#define CHECK(call) { \
+  if (!call) \
+    goto read_failed; \
+}
+
+/* caller ensures properly sync'ed with enough data */
+static gboolean
+gst_wavpack_parse_frame_metadata (GstWavpackParse * parse, GstBuffer * buf,
+    gint skip, WavpackHeader * wph, WavpackInfo * wpi)
+{
+  GstByteReader br;
+  gint i;
+
+  g_return_val_if_fail (wph != NULL || wpi != NULL, FALSE);
+  g_return_val_if_fail (GST_BUFFER_SIZE (buf) >= skip + sizeof (WavpackHeader),
+      FALSE);
+
+  gst_byte_reader_init (&br, GST_BUFFER_DATA (buf) + skip, wph->ckSize + 8);
+  /* skip past header */
+  gst_byte_reader_skip_unchecked (&br, sizeof (WavpackHeader));
+
+  /* get some basics from header */
+  i = (wph->flags >> 23) & 0xF;
+  if (!wpi->rate)
+    wpi->rate = (i < G_N_ELEMENTS (sample_rates)) ? sample_rates[i] : 44100;
+  wpi->width = ((wph->flags & 0x3) + 1) * 8;
+  if (!wpi->channels)
+    wpi->channels = (wph->flags & 0x4) ? 1 : 2;
+  if (!wpi->channel_mask)
+    wpi->channel_mask = 5 - wpi->channels;
+
+  /* need to dig metadata blocks for some more */
+  while (gst_byte_reader_get_remaining (&br)) {
+    gint size = 0;
+    guint16 size2 = 0;
+    guint8 c, id;
+    const guint8 *data;
+    GstByteReader mbr;
+
+    CHECK (gst_byte_reader_get_uint8 (&br, &id));
+    CHECK (gst_byte_reader_get_uint8 (&br, &c));
+    if (id & ID_LARGE)
+      CHECK (gst_byte_reader_get_uint16_le (&br, &size2));
+    size = size2;
+    size <<= 8;
+    size += c;
+    size <<= 1;
+    if (id & ID_ODD_SIZE)
+      size--;
+
+    CHECK (gst_byte_reader_get_data (&br, size + (size & 1), &data));
+    gst_byte_reader_init (&mbr, data, size);
+
+    switch (id) {
+      case ID_WVC_BITSTREAM:
+        GST_LOG_OBJECT (parse, "correction bitstream");
+        wpi->correction = TRUE;
+        break;
+      case ID_WV_BITSTREAM:
+      case ID_WVX_BITSTREAM:
+        break;
+      case ID_SAMPLE_RATE:
+        if (size == 3) {
+          CHECK (gst_byte_reader_get_uint24_le (&mbr, &wpi->rate));
+          GST_LOG_OBJECT (parse, "updated with custom rate %d", wpi->rate);
+        } else {
+          GST_DEBUG_OBJECT (parse, "unexpected size for SAMPLE_RATE metadata");
+        }
+        break;
+      case ID_CHANNEL_INFO:
+      {
+        guint16 channels;
+        guint32 mask = 0;
+
+        if (size == 6) {
+          CHECK (gst_byte_reader_get_uint16_le (&mbr, &channels));
+          channels = channels & 0xFFF;
+          CHECK (gst_byte_reader_get_uint24_le (&mbr, &mask));
+        } else if (size) {
+          CHECK (gst_byte_reader_get_uint8 (&mbr, &c));
+          channels = c;
+          while (gst_byte_reader_get_uint8 (&mbr, &c))
+            mask |= (((guint32) c) << 8);
+        } else {
+          GST_DEBUG_OBJECT (parse, "unexpected size for CHANNEL_INFO metadata");
+          break;
+        }
+        wpi->channels = channels;
+        wpi->channel_mask = mask;
+        break;
+      }
+      default:
+        GST_LOG_OBJECT (parse, "unparsed ID 0x%x", id);
+        break;
+    }
+  }
+
+  return TRUE;
+
+  /* ERRORS */
+read_failed:
+  {
+    GST_DEBUG_OBJECT (parse, "short read while parsing metadata");
+    /* let's look the other way anyway */
+    return TRUE;
+  }
+}
+
+/* caller ensures properly sync'ed with enough data */
+static gboolean
+gst_wavpack_parse_frame_header (GstWavpackParse * parse, GstBuffer * buf,
+    gint skip, WavpackHeader * _wph)
+{
+  GstByteReader br = GST_BYTE_READER_INIT_FROM_BUFFER (buf);
+  WavpackHeader wph = { {0,}, 0, };
+
+  g_return_val_if_fail (GST_BUFFER_SIZE (buf) >= skip + sizeof (WavpackHeader),
+      FALSE);
+
+  /* marker */
+  gst_byte_reader_skip_unchecked (&br, skip + 4);
+
+  /* read */
+  gst_byte_reader_get_uint32_le (&br, &wph.ckSize);
+  gst_byte_reader_get_uint16_le (&br, &wph.version);
+  gst_byte_reader_get_uint8 (&br, &wph.track_no);
+  gst_byte_reader_get_uint8 (&br, &wph.index_no);
+  gst_byte_reader_get_uint32_le (&br, &wph.total_samples);
+  gst_byte_reader_get_uint32_le (&br, &wph.block_index);
+  gst_byte_reader_get_uint32_le (&br, &wph.block_samples);
+  gst_byte_reader_get_uint32_le (&br, &wph.flags);
+  gst_byte_reader_get_uint32_le (&br, &wph.crc);
+
+  /* dump */
+  GST_LOG_OBJECT (parse, "size %d", wph.ckSize);
+  GST_LOG_OBJECT (parse, "version 0x%x", wph.version);
+  GST_LOG_OBJECT (parse, "total samples %d", wph.total_samples);
+  GST_LOG_OBJECT (parse, "block index %d", wph.block_index);
+  GST_LOG_OBJECT (parse, "block samples %d", wph.block_samples);
+  GST_LOG_OBJECT (parse, "flags 0x%x", wph.flags);
+  GST_LOG_OBJECT (parse, "crc 0x%x", wph.flags);
+
+  if (!parse->total_samples && wph.block_index == 0 && wph.total_samples != -1) {
+    GST_DEBUG_OBJECT (parse, "determined duration of %u samples",
+        wph.total_samples);
+    parse->total_samples = wph.total_samples;
+  }
+
+  if (_wph)
+    *_wph = wph;
+
+  return TRUE;
+}
+
+static gboolean
+gst_wavpack_parse_check_valid_frame (GstBaseParse * parse,
+    GstBaseParseFrame * frame, guint * framesize, gint * skipsize)
+{
+  GstWavpackParse *wvparse = GST_WAVPACK_PARSE (parse);
+  GstBuffer *buf = frame->buffer;
+  GstByteReader reader = GST_BYTE_READER_INIT_FROM_BUFFER (buf);
+  gint off;
+  gboolean lost_sync, draining, final;
+  guint frmsize = 0;
+  WavpackHeader wph;
+  WavpackInfo wpi = { 0, };
+
+  if (G_UNLIKELY (GST_BUFFER_SIZE (buf) < sizeof (WavpackHeader)))
+    return FALSE;
+
+  /* scan for 'wvpk' marker */
+  off = gst_byte_reader_masked_scan_uint32 (&reader, 0xffffffff, 0x7776706b,
+      0, GST_BUFFER_SIZE (buf));
+
+  GST_LOG_OBJECT (parse, "possible sync at buffer offset %d", off);
+
+  /* didn't find anything that looks like a sync word, skip */
+  if (off < 0) {
+    *skipsize = GST_BUFFER_SIZE (buf) - 3;
+    goto skip;
+  }
+
+  /* possible frame header, but not at offset 0? skip bytes before sync */
+  if (off > 0) {
+    *skipsize = off;
+    goto skip;
+  }
+
+  /* make sure the values in the frame header look sane */
+  gst_wavpack_parse_frame_header (wvparse, buf, 0, &wph);
+  frmsize = wph.ckSize + 8;
+
+  /* need the entire frame for parsing */
+  if (gst_byte_reader_get_remaining (&reader) < frmsize)
+    goto more;
+
+  /* got a frame, now we can dig for some more metadata */
+  GST_LOG_OBJECT (parse, "got frame");
+  gst_wavpack_parse_frame_metadata (wvparse, buf, 0, &wph, &wpi);
+
+  lost_sync = GST_BASE_PARSE_LOST_SYNC (parse);
+  draining = GST_BASE_PARSE_DRAINING (parse);
+
+  while (!(final = (wph.flags & FLAG_FINAL_BLOCK)) || (lost_sync && !draining)) {
+    guint32 word = 0;
+
+    GST_LOG_OBJECT (wvparse, "checking next frame syncword; "
+        "lost_sync: %d, draining: %d, final: %d", lost_sync, draining, final);
+
+    if (!gst_byte_reader_skip (&reader, wph.ckSize + 8) ||
+        !gst_byte_reader_peek_uint32_be (&reader, &word)) {
+      GST_DEBUG_OBJECT (wvparse, "... but not sufficient data");
+      frmsize += 4;
+      goto more;
+    } else {
+      if (word != 0x7776706b) {
+        GST_DEBUG_OBJECT (wvparse, "0x%x not OK", word);
+        *skipsize = off + 2;
+        goto skip;
+      }
+      /* need to parse each frame/block for metadata if several ones */
+      if (!final) {
+        gint av;
+
+        GST_LOG_OBJECT (wvparse, "checking frame at offset %d (0x%x)",
+            frmsize, frmsize);
+        av = gst_byte_reader_get_remaining (&reader);
+        if (av < sizeof (WavpackHeader)) {
+          frmsize += sizeof (WavpackHeader);
+          goto more;
+        }
+        gst_wavpack_parse_frame_header (wvparse, buf, frmsize, &wph);
+        off = frmsize;
+        frmsize += wph.ckSize + 8;
+        if (av < wph.ckSize + 8)
+          goto more;
+        gst_wavpack_parse_frame_metadata (wvparse, buf, off, &wph, &wpi);
+        /* could also check for matching block_index and block_samples ?? */
+      }
+    }
+
+    /* resynced if we make it here */
+    lost_sync = FALSE;
+  }
+
+  /* found frame (up to final), record gathered metadata */
+  wvparse->wpi = wpi;
+  wvparse->wph = wph;
+
+  *framesize = frmsize;
+  gst_base_parse_set_min_frame_size (parse, sizeof (WavpackHeader));
+
+  return TRUE;
+
+skip:
+  GST_LOG_OBJECT (wvparse, "skipping %d", *skipsize);
+  return FALSE;
+
+more:
+  GST_LOG_OBJECT (wvparse, "need at least %u", frmsize);
+  gst_base_parse_set_min_frame_size (parse, frmsize);
+  *skipsize = 0;
+  return FALSE;
+}
+
+static GstFlowReturn
+gst_wavpack_parse_parse_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
+{
+  GstWavpackParse *wvparse = GST_WAVPACK_PARSE (parse);
+  GstBuffer *buf = frame->buffer;
+  guint rate, chans, width, mask;
+
+  /* re-use previously parsed data */
+  rate = wvparse->wpi.rate;
+  width = wvparse->wpi.width;
+  chans = wvparse->wpi.channels;
+  mask = wvparse->wpi.channel_mask;
+
+  GST_LOG_OBJECT (parse, "rate: %u, width: %u, chans: %u", rate, width, chans);
+
+  GST_BUFFER_TIMESTAMP (buf) =
+      gst_util_uint64_scale_int (wvparse->wph.block_index, GST_SECOND, rate);
+  GST_BUFFER_DURATION (buf) =
+      gst_util_uint64_scale_int (wvparse->wph.block_index +
+      wvparse->wph.block_samples, GST_SECOND, rate) -
+      GST_BUFFER_TIMESTAMP (buf);
+
+  if (G_UNLIKELY (wvparse->sample_rate != rate || wvparse->channels != chans
+          || wvparse->width != width || wvparse->channel_mask != mask)) {
+    GstCaps *caps;
+
+    if (wvparse->wpi.correction) {
+      caps = gst_caps_new_simple ("audio/x-wavpack-correction",
+          "framed", G_TYPE_BOOLEAN, TRUE, NULL);
+    } else {
+      caps = gst_caps_new_simple ("audio/x-wavpack",
+          "channels", G_TYPE_INT, chans,
+          "rate", G_TYPE_INT, rate,
+          "width", G_TYPE_INT, width, "framed", G_TYPE_BOOLEAN, TRUE, NULL);
+
+      if (!mask)
+        mask = gst_wavpack_get_default_channel_mask (wvparse->channels);
+      if (mask != 0) {
+        if (!gst_wavpack_set_channel_layout (caps, mask)) {
+          GST_WARNING_OBJECT (wvparse, "Failed to set channel layout");
+        }
+      }
+    }
+
+    gst_buffer_set_caps (buf, caps);
+    gst_pad_set_caps (GST_BASE_PARSE_SRC_PAD (parse), caps);
+    gst_caps_unref (caps);
+
+    wvparse->sample_rate = rate;
+    wvparse->channels = chans;
+    wvparse->width = width;
+    wvparse->channel_mask = mask;
+
+    if (wvparse->total_samples) {
+      GST_DEBUG_OBJECT (wvparse, "setting duration");
+      gst_base_parse_set_duration (GST_BASE_PARSE (wvparse),
+          GST_FORMAT_TIME, gst_util_uint64_scale_int (wvparse->total_samples,
+              GST_SECOND, wvparse->sample_rate), 0);
+    }
+  }
+
+  return GST_FLOW_OK;
+}
+
+static GstCaps *
+gst_wavpack_parse_get_sink_caps (GstBaseParse * parse)
+{
+  GstCaps *peercaps;
+  GstCaps *res;
+
+  peercaps = gst_pad_get_allowed_caps (GST_BASE_PARSE_SRC_PAD (parse));
+  if (peercaps) {
+    guint i, n;
+
+    /* Remove the framed field */
+    peercaps = gst_caps_make_writable (peercaps);
+    n = gst_caps_get_size (peercaps);
+    for (i = 0; i < n; i++) {
+      GstStructure *s = gst_caps_get_structure (peercaps, i);
+
+      gst_structure_remove_field (s, "framed");
+    }
+
+    res =
+        gst_caps_intersect_full (peercaps,
+        gst_pad_get_pad_template_caps (GST_BASE_PARSE_SINK_PAD (parse)),
+        GST_CAPS_INTERSECT_FIRST);
+    gst_caps_unref (peercaps);
+  } else {
+    res =
+        gst_caps_copy (gst_pad_get_pad_template_caps (GST_BASE_PARSE_SINK_PAD
+            (parse)));
+  }
+
+  return res;
+}
diff --git a/gst/audioparsers/gstwavpackparse.h b/gst/audioparsers/gstwavpackparse.h
new file mode 100644
index 0000000..7fc246e
--- /dev/null
+++ b/gst/audioparsers/gstwavpackparse.h
@@ -0,0 +1,134 @@
+/* GStreamer Wavpack parser
+ * Copyright (C) 2012 Mark Nauwelaerts <mark.nauwelaerts@collabora.co.uk>
+ * Copyright (C) 2012 Nokia Corporation. All rights reserved.
+ *   Contact: Stefan Kost <stefan.kost@nokia.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_WAVPACK_PARSE_H__
+#define __GST_WAVPACK_PARSE_H__
+
+#include <gst/gst.h>
+#include <gst/base/gstbaseparse.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_WAVPACK_PARSE \
+  (gst_wavpack_parse_get_type())
+#define GST_WAVPACK_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_WAVPACK_PARSE, GstWavpackParse))
+#define GST_WAVPACK_PARSE_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_WAVPACK_PARSE, GstWavpackParseClass))
+#define GST_IS_WAVPACK_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_WAVPACK_PARSE))
+#define GST_IS_WAVPACK_PARSE_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_WAVPACK_PARSE))
+
+
+#define ID_UNIQUE               0x3f
+#define ID_OPTIONAL_DATA        0x20
+#define ID_ODD_SIZE             0x40
+#define ID_LARGE                0x80
+
+#define ID_DUMMY                0x0
+#define ID_ENCODER_INFO         0x1
+#define ID_DECORR_TERMS         0x2
+#define ID_DECORR_WEIGHTS       0x3
+#define ID_DECORR_SAMPLES       0x4
+#define ID_ENTROPY_VARS         0x5
+#define ID_HYBRID_PROFILE       0x6
+#define ID_SHAPING_WEIGHTS      0x7
+#define ID_FLOAT_INFO           0x8
+#define ID_INT32_INFO           0x9
+#define ID_WV_BITSTREAM         0xa
+#define ID_WVC_BITSTREAM        0xb
+#define ID_WVX_BITSTREAM        0xc
+#define ID_CHANNEL_INFO         0xd
+
+#define ID_RIFF_HEADER          (ID_OPTIONAL_DATA | 0x1)
+#define ID_RIFF_TRAILER         (ID_OPTIONAL_DATA | 0x2)
+#define ID_REPLAY_GAIN          (ID_OPTIONAL_DATA | 0x3)
+#define ID_CUESHEET             (ID_OPTIONAL_DATA | 0x4)
+#define ID_CONFIG_BLOCK         (ID_OPTIONAL_DATA | 0x5)
+#define ID_MD5_CHECKSUM         (ID_OPTIONAL_DATA | 0x6)
+#define ID_SAMPLE_RATE          (ID_OPTIONAL_DATA | 0x7)
+
+#define FLAG_FINAL_BLOCK        (1 << 12)
+
+typedef struct {
+  char ckID [4];             /* "wvpk" */
+  guint32 ckSize;            /* size of entire block (minus 8, of course) */
+  guint16 version;           /* 0x402 to 0x410 are currently valid for decode */
+  guchar track_no;           /* track number (0 if not used, like now) */
+  guchar index_no;           /* track sub-index (0 if not used, like now) */
+  guint32 total_samples;     /* total samples for entire file, but this is
+                              * only valid if block_index == 0 and a value of
+                              * -1 indicates unknown length */
+  guint32 block_index;       /* index of first sample in block relative to
+                              * beginning of file (normally this would start
+                              * at 0 for the first block) */
+  guint32 block_samples;     /* number of samples in this block (0 = no audio) */
+  guint32 flags;             /* various flags for id and decoding */
+  guint32 crc;               /* crc for actual decoded data */
+} WavpackHeader;
+
+typedef struct {
+  gboolean correction;
+  guint rate;
+  guint width;
+  guint channels;
+  guint channel_mask;
+} WavpackInfo;
+
+typedef struct _GstWavpackParse GstWavpackParse;
+typedef struct _GstWavpackParseClass GstWavpackParseClass;
+
+/**
+ * GstWavpackParse:
+ *
+ * The opaque GstWavpackParse object
+ */
+struct _GstWavpackParse {
+  GstBaseParse baseparse;
+
+  /*< private >*/
+  gint          sample_rate;
+  gint          channels;
+  gint          width;
+  gint          channel_mask;
+
+  guint         total_samples;
+
+  WavpackHeader wph;
+  WavpackInfo   wpi;
+};
+
+/**
+ * GstWavpackParseClass:
+ * @parent_class: Element parent class.
+ *
+ * The opaque GstWavpackParseClass data structure.
+ */
+struct _GstWavpackParseClass {
+  GstBaseParseClass baseparse_class;
+};
+
+GType gst_wavpack_parse_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_WAVPACK_PARSE_H__ */
diff --git a/gst/audioparsers/plugin.c b/gst/audioparsers/plugin.c
index ae8332d..16f98ff 100644
--- a/gst/audioparsers/plugin.c
+++ b/gst/audioparsers/plugin.c
@@ -27,6 +27,7 @@
 #include "gstdcaparse.h"
 #include "gstflacparse.h"
 #include "gstmpegaudioparse.h"
+#include "gstwavpackparse.h"
 
 static gboolean
 plugin_init (GstPlugin * plugin)
@@ -45,6 +46,8 @@ plugin_init (GstPlugin * plugin)
       GST_RANK_PRIMARY + 1, GST_TYPE_FLAC_PARSE);
   ret &= gst_element_register (plugin, "mpegaudioparse",
       GST_RANK_PRIMARY + 2, GST_TYPE_MPEG_AUDIO_PARSE);
+  ret &= gst_element_register (plugin, "wavpackparse2",
+      GST_RANK_SECONDARY, GST_TYPE_WAVPACK_PARSE);
 
   return ret;
 }
diff --git a/gst/avi/gstavidemux.c b/gst/avi/gstavidemux.c
index b6c065f..43096ff 100644
--- a/gst/avi/gstavidemux.c
+++ b/gst/avi/gstavidemux.c
@@ -573,7 +573,7 @@ gst_avi_demux_handle_src_query (GstPad * pad, GstQuery * query)
           GST_DEBUG_OBJECT (query, "total frames is %" G_GUINT32_FORMAT,
               stream->idx_n);
 
-          if (stream->idx_n >= 0)
+          if (stream->idx_n > 0)
             gst_query_set_duration (query, fmt, stream->idx_n);
           else if (gst_pad_query_convert (pad, GST_FORMAT_TIME,
                   duration, &fmt, &dur))
diff --git a/gst/avi/gstavimux.c b/gst/avi/gstavimux.c
index fe50cef..17b1d1e 100644
--- a/gst/avi/gstavimux.c
+++ b/gst/avi/gstavimux.c
@@ -180,7 +180,7 @@ static GstStaticPadTemplate audio_sink_factory =
         "rate = (int) [ 1000, 96000 ], " "channels = (int) [ 1, 2 ]; "
 #endif*/
         "audio/x-ac3, "
-        "rate = (int) [ 1000, 96000 ], " "channels = (int) [ 1, 2 ]; "
+        "rate = (int) [ 1000, 96000 ], " "channels = (int) [ 1, 6 ]; "
         "audio/x-alaw, "
         "rate = (int) [ 1000, 48000 ], " "channels = (int) [ 1, 2 ]; "
         "audio/x-mulaw, "
@@ -195,9 +195,10 @@ static void gst_avi_mux_class_init (GstAviMuxClass * klass);
 static void gst_avi_mux_init (GstAviMux * avimux);
 static void gst_avi_mux_pad_reset (GstAviPad * avipad, gboolean free);
 
-static GstFlowReturn gst_avi_mux_collect_pads (GstCollectPads * pads,
+static GstFlowReturn gst_avi_mux_collect_pads (GstCollectPads2 * pads,
     GstAviMux * avimux);
-static gboolean gst_avi_mux_handle_event (GstPad * pad, GstEvent * event);
+static gboolean gst_avi_mux_handle_event (GstCollectPads2 * pad,
+    GstCollectData2 * data, GstEvent * event, gpointer user_data);
 static GstPad *gst_avi_mux_request_new_pad (GstElement * element,
     GstPadTemplate * templ, const gchar * name);
 static void gst_avi_mux_release_pad (GstElement * element, GstPad * pad);
@@ -418,10 +419,13 @@ gst_avi_mux_init (GstAviMux * avimux)
   /* property */
   avimux->enable_large_avi = DEFAULT_BIGFILE;
 
-  avimux->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (avimux->collect,
-      (GstCollectPadsFunction) (GST_DEBUG_FUNCPTR (gst_avi_mux_collect_pads)),
+  avimux->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (avimux->collect,
+      (GstCollectPads2Function) (GST_DEBUG_FUNCPTR (gst_avi_mux_collect_pads)),
       avimux);
+  gst_collect_pads2_set_event_function (avimux->collect,
+      (GstCollectPads2EventFunction) (GST_DEBUG_FUNCPTR
+          (gst_avi_mux_handle_event)), avimux);
 
   /* set to clean state */
   gst_avi_mux_reset (avimux);
@@ -1024,16 +1028,9 @@ gst_avi_mux_request_new_pad (GstElement * element,
 
   g_free (name);
 
-  avipad->collect = gst_collect_pads_add_pad (avimux->collect,
+  avipad->collect = gst_collect_pads2_add_pad (avimux->collect,
       newpad, sizeof (GstAviCollectData));
   ((GstAviCollectData *) (avipad->collect))->avipad = avipad;
-  /* FIXME: hacked way to override/extend the event function of
-   * GstCollectPads; because it sets its own event function giving the
-   * element no access to events */
-  avimux->collect_event = (GstPadEventFunction) GST_PAD_EVENTFUNC (newpad);
-  gst_pad_set_event_function (newpad,
-      GST_DEBUG_FUNCPTR (gst_avi_mux_handle_event));
-
   if (!gst_element_add_pad (element, newpad))
     goto pad_add_failed;
 
@@ -1085,7 +1082,7 @@ gst_avi_mux_release_pad (GstElement * element, GstPad * pad)
        * as it also represent number of streams present */
       avipad->collect = NULL;
       GST_DEBUG_OBJECT (avimux, "removed pad '%s'", GST_PAD_NAME (pad));
-      gst_collect_pads_remove_pad (avimux->collect, pad);
+      gst_collect_pads2_remove_pad (avimux->collect, pad);
       gst_element_remove_pad (element, pad);
       /* if not started yet, we can remove any sign this pad ever existed */
       /* in this case _start will take care of the real pad count */
@@ -1861,12 +1858,12 @@ gst_avi_mux_restart_file (GstAviMux * avimux)
 
 /* handle events (search) */
 static gboolean
-gst_avi_mux_handle_event (GstPad * pad, GstEvent * event)
+gst_avi_mux_handle_event (GstCollectPads2 * pads, GstCollectData2 * data,
+    GstEvent * event, gpointer user_data)
 {
   GstAviMux *avimux;
-  gboolean ret;
 
-  avimux = GST_AVI_MUX (gst_pad_get_parent (pad));
+  avimux = GST_AVI_MUX (user_data);
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_TAG:{
@@ -1882,12 +1879,8 @@ gst_avi_mux_handle_event (GstPad * pad, GstEvent * event)
       break;
   }
 
-  /* now GstCollectPads can take care of the rest, e.g. EOS */
-  ret = avimux->collect_event (pad, event);
-
-  gst_object_unref (avimux);
-
-  return ret;
+  /* now GstCollectPads2 can take care of the rest, e.g. EOS */
+  return FALSE;
 }
 
 /* send extra 'padding' data */
@@ -1911,7 +1904,7 @@ gst_avi_mux_do_buffer (GstAviMux * avimux, GstAviPad * avipad)
   gulong total_size, pad_bytes = 0;
   guint flags;
 
-  data = gst_collect_pads_pop (avimux->collect, avipad->collect);
+  data = gst_collect_pads2_pop (avimux->collect, avipad->collect);
   /* arrange downstream running time */
   data = gst_buffer_make_metadata_writable (data);
   GST_BUFFER_TIMESTAMP (data) =
@@ -2037,7 +2030,7 @@ gst_avi_mux_do_one_buffer (GstAviMux * avimux)
     if (!avipad->hdr.fcc_handler)
       goto not_negotiated;
 
-    buffer = gst_collect_pads_peek (avimux->collect, avipad->collect);
+    buffer = gst_collect_pads2_peek (avimux->collect, avipad->collect);
     if (!buffer)
       continue;
     time = GST_BUFFER_TIMESTAMP (buffer);
@@ -2050,7 +2043,7 @@ gst_avi_mux_do_one_buffer (GstAviMux * avimux)
       if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time))) {
         GST_DEBUG_OBJECT (avimux, "clipping buffer on pad %s outside segment",
             GST_PAD_NAME (avipad->collect->pad));
-        buffer = gst_collect_pads_pop (avimux->collect, avipad->collect);
+        buffer = gst_collect_pads2_pop (avimux->collect, avipad->collect);
         gst_buffer_unref (buffer);
         return GST_FLOW_OK;
       }
@@ -2089,7 +2082,7 @@ not_negotiated:
 }
 
 static GstFlowReturn
-gst_avi_mux_collect_pads (GstCollectPads * pads, GstAviMux * avimux)
+gst_avi_mux_collect_pads (GstCollectPads2 * pads, GstAviMux * avimux)
 {
   GstFlowReturn res;
 
@@ -2148,12 +2141,12 @@ gst_avi_mux_change_state (GstElement * element, GstStateChange transition)
 
   switch (transition) {
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (avimux->collect);
+      gst_collect_pads2_start (avimux->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_collect_pads_stop (avimux->collect);
+      gst_collect_pads2_stop (avimux->collect);
       break;
     default:
       break;
diff --git a/gst/avi/gstavimux.h b/gst/avi/gstavimux.h
index 0d90392..cb0cdb7 100644
--- a/gst/avi/gstavimux.h
+++ b/gst/avi/gstavimux.h
@@ -23,7 +23,7 @@
 
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 #include <gst/riff/riff-ids.h>
 #include "avi-ids.h"
 
@@ -74,7 +74,7 @@ typedef GstFlowReturn (*GstAviPadHook) (GstAviMux * avi, GstAviPad * avipad,
 struct _GstAviPad {
   /* do not extend, link to it */
   /* is NULL if original sink request pad has been removed */
-  GstCollectData *collect;
+  GstCollectData2 *collect;
 
   /* type */
   gboolean is_video;
@@ -129,7 +129,7 @@ typedef struct _GstAviAudioPad {
 
 typedef struct _GstAviCollectData {
   /* extend the CollectData */
-  GstCollectData collect;
+  GstCollectData2 collect;
 
   GstAviPad      *avipad;
 } GstAviCollectData;
@@ -143,8 +143,7 @@ struct _GstAviMux {
   GSList              *sinkpads;
   /* video restricted to 1 pad */
   guint               video_pads, audio_pads;
-  GstCollectPads      *collect;
-  GstPadEventFunction  collect_event;
+  GstCollectPads2     *collect;
 
   /* the AVI header */
   /* still some single stream video data in mux struct */
diff --git a/gst/deinterlace/gstdeinterlace.c b/gst/deinterlace/gstdeinterlace.c
index a79b836..dfb03ad 100644
--- a/gst/deinterlace/gstdeinterlace.c
+++ b/gst/deinterlace/gstdeinterlace.c
@@ -1982,7 +1982,8 @@ gst_deinterlace_chain (GstPad * pad, GstBuffer * buf)
       self->fields = self->new_fields;
     if (self->new_mode != -1)
       self->mode = self->new_mode;
-    self->new_mode = self->new_fields = -1;
+    self->new_mode = -1;
+    self->new_fields = -1;
 
     self->reconfigure = FALSE;
     GST_OBJECT_UNLOCK (self);
diff --git a/gst/deinterlace/tvtime-dist.c b/gst/deinterlace/tvtime-dist.c
index a278f75..e1f7ed3 100644
--- a/gst/deinterlace/tvtime-dist.c
+++ b/gst/deinterlace/tvtime-dist.c
@@ -325,7 +325,7 @@ deinterlace_line_vfir (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s4, const guint8 * ORC_RESTRICT s5, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -468,7 +468,7 @@ deinterlace_line_linear (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -638,7 +638,7 @@ deinterlace_line_linear_blend (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -921,7 +921,7 @@ deinterlace_line_greedy (orc_uint8 * ORC_RESTRICT d1,
     int p1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
diff --git a/gst/deinterlace/tvtime/greedyh.asm b/gst/deinterlace/tvtime/greedyh.asm
index d87b9e3..c710b4a 100644
--- a/gst/deinterlace/tvtime/greedyh.asm
+++ b/gst/deinterlace/tvtime/greedyh.asm
@@ -43,7 +43,7 @@ FUNCT_NAME_YUY2 (GstDeinterlaceMethodGreedyH *self, const guint8 * L1, const gui
   gint64 MotionSense;
   gint64 i;
   glong LoopCtr;
-  glong oldbx;
+  glong oldbx = 0;
 
   gint64 QW256B;
   gint64 LastAvg = 0;          //interp value from left qword
@@ -262,7 +262,7 @@ FUNCT_NAME_UYVY (GstDeinterlaceMethodGreedyH *self, const guint8 * L1, const gui
   gint64 MotionSense;
   gint64 i;
   glong LoopCtr;
-  glong oldbx;
+  glong oldbx = 0;
 
   gint64 QW256B;
   gint64 LastAvg = 0;          //interp value from left qword
diff --git a/gst/deinterlace/tvtime/tomsmocomp/SearchLoopTop.inc b/gst/deinterlace/tvtime/tomsmocomp/SearchLoopTop.inc
index 9d6a490..275c7dd 100644
--- a/gst/deinterlace/tvtime/tomsmocomp/SearchLoopTop.inc
+++ b/gst/deinterlace/tvtime/tomsmocomp/SearchLoopTop.inc
@@ -92,7 +92,7 @@ long     Last8;
           int64_t Max_Vals  = 0x0000000000000000ull;
           int64_t ShiftMask = 0xfefffefffefffeffull;
 
-          long oldbx;
+          long oldbx = 0;
 
 		// pretend it's indented -->>
         __asm__ __volatile__
diff --git a/gst/flv/gstflvmux.c b/gst/flv/gstflvmux.c
index 44ed7ea..c347ff0 100644
--- a/gst/flv/gstflvmux.c
+++ b/gst/flv/gstflvmux.c
@@ -100,7 +100,11 @@ GST_BOILERPLATE_FULL (GstFlvMux, gst_flv_mux, GstElement, GST_TYPE_ELEMENT,
 
 static void gst_flv_mux_finalize (GObject * object);
 static GstFlowReturn
-gst_flv_mux_collected (GstCollectPads * pads, gpointer user_data);
+gst_flv_mux_handle_buffer (GstCollectPads2 * pads, GstCollectData2 * cdata,
+    GstBuffer * buf, gpointer user_data);
+static gboolean
+gst_flv_mux_handle_sink_event (GstCollectPads2 * pads, GstCollectData2 * data,
+    GstEvent * event, gpointer user_data);
 
 static gboolean gst_flv_mux_handle_src_event (GstPad * pad, GstEvent * event);
 static GstPad *gst_flv_mux_request_new_pad (GstElement * element,
@@ -136,10 +140,8 @@ gst_flv_mux_base_init (gpointer g_class)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
 
-  gst_element_class_add_static_pad_template (element_class,
-      &videosink_templ);
-  gst_element_class_add_static_pad_template (element_class,
-      &audiosink_templ);
+  gst_element_class_add_static_pad_template (element_class, &videosink_templ);
+  gst_element_class_add_static_pad_template (element_class, &audiosink_templ);
   gst_element_class_add_static_pad_template (element_class, &src_templ);
   gst_element_class_set_details_simple (element_class, "FLV muxer",
       "Codec/Muxer",
@@ -198,9 +200,13 @@ gst_flv_mux_init (GstFlvMux * mux, GstFlvMuxClass * g_class)
 
   mux->new_tags = FALSE;
 
-  mux->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (mux->collect,
-      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (gst_flv_mux_collected), mux);
+  mux->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_buffer_function (mux->collect,
+      GST_DEBUG_FUNCPTR (gst_flv_mux_handle_buffer), mux);
+  gst_collect_pads2_set_event_function (mux->collect,
+      GST_DEBUG_FUNCPTR (gst_flv_mux_handle_sink_event), mux);
+  gst_collect_pads2_set_clip_function (mux->collect,
+      GST_DEBUG_FUNCPTR (gst_collect_pads2_clip_running_time), mux);
 
   gst_flv_mux_reset (GST_ELEMENT (mux));
 }
@@ -261,10 +267,10 @@ gst_flv_mux_handle_src_event (GstPad * pad, GstEvent * event)
 }
 
 static gboolean
-gst_flv_mux_handle_sink_event (GstPad * pad, GstEvent * event)
+gst_flv_mux_handle_sink_event (GstCollectPads2 * pads, GstCollectData2 * data,
+    GstEvent * event, gpointer user_data)
 {
-  GstFlvMux *mux = GST_FLV_MUX (gst_pad_get_parent (pad));
-  gboolean ret = TRUE;
+  GstFlvMux *mux = GST_FLV_MUX (user_data);
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_TAG:{
@@ -281,12 +287,8 @@ gst_flv_mux_handle_sink_event (GstPad * pad, GstEvent * event)
       break;
   }
 
-  /* now GstCollectPads can take care of the rest, e.g. EOS */
-  if (ret)
-    ret = mux->collect_event (pad, event);
-  gst_object_unref (mux);
-
-  return ret;
+  /* now GstCollectPads2 can take care of the rest, e.g. EOS */
+  return FALSE;
 }
 
 static gboolean
@@ -537,20 +539,12 @@ gst_flv_mux_request_new_pad (GstElement * element,
 
   pad = gst_pad_new_from_template (templ, name);
   cpad = (GstFlvPad *)
-      gst_collect_pads_add_pad (mux->collect, pad, sizeof (GstFlvPad));
+      gst_collect_pads2_add_pad (mux->collect, pad, sizeof (GstFlvPad));
 
   cpad->audio_codec_data = NULL;
   cpad->video_codec_data = NULL;
   gst_flv_mux_reset_pad (mux, cpad, video);
 
-  /* FIXME: hacked way to override/extend the event function of
-   * GstCollectPads; because it sets its own event function giving the
-   * element no access to events.
-   */
-  mux->collect_event = (GstPadEventFunction) GST_PAD_EVENTFUNC (pad);
-  gst_pad_set_event_function (pad,
-      GST_DEBUG_FUNCPTR (gst_flv_mux_handle_sink_event));
-
   gst_pad_set_setcaps_function (pad, setcapsfunc);
   gst_pad_set_active (pad, TRUE);
   gst_element_add_pad (element, pad);
@@ -565,7 +559,7 @@ gst_flv_mux_release_pad (GstElement * element, GstPad * pad)
   GstFlvPad *cpad = (GstFlvPad *) gst_pad_get_element_private (pad);
 
   gst_flv_mux_reset_pad (mux, cpad, cpad->video);
-  gst_collect_pads_remove_pad (mux->collect, pad);
+  gst_collect_pads2_remove_pad (mux->collect, pad);
   gst_element_remove_pad (element, pad);
 }
 
@@ -765,7 +759,7 @@ tags:
     guint64 dur;
 
     for (l = mux->collect->data; l; l = l->next) {
-      GstCollectData *cdata = l->data;
+      GstCollectData2 *cdata = l->data;
 
       fmt = GST_FORMAT_TIME;
 
@@ -1110,6 +1104,30 @@ gst_flv_mux_write_header (GstFlvMux * mux)
   GSList *l;
   GstFlowReturn ret;
 
+  /* if not streaming, check if downstream is seekable */
+  if (!mux->streamable) {
+    gboolean seekable;
+    GstQuery *query;
+
+    query = gst_query_new_seeking (GST_FORMAT_BYTES);
+    if (gst_pad_peer_query (mux->srcpad, query)) {
+      gst_query_parse_seeking (query, NULL, &seekable, NULL, NULL);
+      GST_INFO_OBJECT (mux, "downstream is %sseekable", seekable ? "" : "not ");
+      if (!seekable) {
+        mux->streamable = TRUE;
+        g_object_notify (G_OBJECT (mux), "streamable");
+        GST_WARNING_OBJECT (mux, "downstream is not seekable, but "
+            "streamable=false. Will ignore that and create streamable output "
+            "instead");
+      }
+    } else {
+      /* have to assume seeking is supported if query not handled downstream */
+      /* FIXME 0.11: change to query not handled => seeking not supported */
+      GST_WARNING_OBJECT (mux, "downstream did not handle seeking query");
+    }
+    gst_query_unref (query);
+  }
+
   header = gst_flv_mux_create_header (mux);
   metadata = gst_flv_mux_create_metadata (mux, TRUE);
   video_codec_data = NULL;
@@ -1215,18 +1233,12 @@ gst_flv_mux_update_index (GstFlvMux * mux, GstBuffer * buffer, GstFlvPad * cpad)
 }
 
 static GstFlowReturn
-gst_flv_mux_write_buffer (GstFlvMux * mux, GstFlvPad * cpad)
+gst_flv_mux_write_buffer (GstFlvMux * mux, GstFlvPad * cpad, GstBuffer * buffer)
 {
   GstBuffer *tag;
-  GstBuffer *buffer =
-      gst_collect_pads_pop (mux->collect, (GstCollectData *) cpad);
   GstFlowReturn ret;
 
-  /* arrange downstream running time */
-  buffer = gst_buffer_make_metadata_writable (buffer);
-  GST_BUFFER_TIMESTAMP (buffer) =
-      gst_segment_to_running_time (&cpad->collect.segment,
-      GST_FORMAT_TIME, GST_BUFFER_TIMESTAMP (buffer));
+  /* clipping function arranged for running_time */
 
   if (!mux->streamable)
     gst_flv_mux_update_index (mux, buffer, cpad);
@@ -1406,14 +1418,13 @@ gst_flv_mux_rewrite_header (GstFlvMux * mux)
 }
 
 static GstFlowReturn
-gst_flv_mux_collected (GstCollectPads * pads, gpointer user_data)
+gst_flv_mux_handle_buffer (GstCollectPads2 * pads, GstCollectData2 * cdata,
+    GstBuffer * buffer, gpointer user_data)
 {
   GstFlvMux *mux = GST_FLV_MUX (user_data);
   GstFlvPad *best;
   GstClockTime best_time;
   GstFlowReturn ret;
-  GSList *sl;
-  gboolean eos = TRUE;
 
   if (mux->state == GST_FLV_MUX_STATE_HEADER) {
     if (mux->collect->data == NULL) {
@@ -1440,46 +1451,12 @@ gst_flv_mux_collected (GstCollectPads * pads, gpointer user_data)
     mux->new_tags = FALSE;
   }
 
-
-  best = NULL;
-  best_time = GST_CLOCK_TIME_NONE;
-  for (sl = mux->collect->data; sl; sl = sl->next) {
-    GstFlvPad *cpad = sl->data;
-    GstBuffer *buffer = gst_collect_pads_peek (pads, (GstCollectData *) cpad);
-    GstClockTime time;
-
-    if (!buffer)
-      continue;
-
-    eos = FALSE;
-
-    time = GST_BUFFER_TIMESTAMP (buffer);
-    gst_buffer_unref (buffer);
-
-    /* Use buffers without valid timestamp first */
-    if (!GST_CLOCK_TIME_IS_VALID (time)) {
-      GST_WARNING_OBJECT (pads, "Buffer without valid timestamp");
-
-      best_time = cpad->last_timestamp;
-      best = cpad;
-      break;
-    }
-
-    time = gst_segment_to_running_time (&cpad->collect.segment,
-        GST_FORMAT_TIME, time);
-    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time))) {
-      GST_DEBUG_OBJECT (mux, "clipping buffer on pad %s outside segment",
-          GST_PAD_NAME (cpad->collect.pad));
-      buffer = gst_collect_pads_pop (pads, (GstCollectData *) cpad);
-      gst_buffer_unref (buffer);
-      return GST_FLOW_OK;
-    }
-
-    if (best == NULL || (GST_CLOCK_TIME_IS_VALID (best_time)
-            && time < best_time)) {
-      best = cpad;
-      best_time = time;
-    }
+  best = (GstFlvPad *) cdata;
+  if (best) {
+    g_assert (buffer);
+    best_time = GST_BUFFER_TIMESTAMP (buffer);
+  } else {
+    best_time = GST_CLOCK_TIME_NONE;
   }
 
   /* The FLV timestamp is an int32 field. For non-live streams error out if a
@@ -1488,17 +1465,17 @@ gst_flv_mux_collected (GstCollectPads * pads, gpointer user_data)
   if (!mux->streamable && GST_CLOCK_TIME_IS_VALID (best_time)
       && best_time / GST_MSECOND > G_MAXINT32) {
     GST_WARNING_OBJECT (mux, "Timestamp larger than FLV supports - EOS");
-    eos = TRUE;
+    gst_buffer_unref (buffer);
+    buffer = NULL;
+    best = NULL;
   }
 
-  if (!eos && best) {
-    return gst_flv_mux_write_buffer (mux, best);
-  } else if (eos) {
+  if (best) {
+    return gst_flv_mux_write_buffer (mux, best, buffer);
+  } else {
     gst_flv_mux_rewrite_header (mux);
     gst_pad_push_event (mux->srcpad, gst_event_new_eos ());
     return GST_FLOW_UNEXPECTED;
-  } else {
-    return GST_FLOW_OK;
   }
 }
 
@@ -1550,12 +1527,12 @@ gst_flv_mux_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_NULL_TO_READY:
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (mux->collect);
+      gst_collect_pads2_start (mux->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_collect_pads_stop (mux->collect);
+      gst_collect_pads2_stop (mux->collect);
       break;
     default:
       break;
diff --git a/gst/flv/gstflvmux.h b/gst/flv/gstflvmux.h
index fff51b9..b0e10ea 100644
--- a/gst/flv/gstflvmux.h
+++ b/gst/flv/gstflvmux.h
@@ -22,7 +22,7 @@
 #define __GST_FLV_MUX_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 G_BEGIN_DECLS
 
@@ -39,7 +39,7 @@ G_BEGIN_DECLS
 
 typedef struct
 {
-  GstCollectData collect;
+  GstCollectData2 collect;
 
   gboolean video;
 
@@ -65,11 +65,9 @@ typedef struct _GstFlvMux {
   GstElement     element;
 
   GstPad         *srcpad;
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
 
   /* <private> */
-  GstPadEventFunction collect_event;
-
   GstFlvMuxState state;
   gboolean have_audio;
   gboolean have_video;
diff --git a/gst/interleave/interleave.c b/gst/interleave/interleave.c
index bc672d1..020d576 100644
--- a/gst/interleave/interleave.c
+++ b/gst/interleave/interleave.c
@@ -57,6 +57,10 @@
  * </refsect2>
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
@@ -227,7 +231,7 @@ static gboolean gst_interleave_sink_setcaps (GstPad * pad, GstCaps * caps);
 
 static GstCaps *gst_interleave_sink_getcaps (GstPad * pad);
 
-static GstFlowReturn gst_interleave_collected (GstCollectPads * pads,
+static GstFlowReturn gst_interleave_collected (GstCollectPads2 * pads,
     GstInterleave * self);
 
 static void
@@ -405,9 +409,9 @@ gst_interleave_init (GstInterleave * self, GstInterleaveClass * klass)
 
   gst_element_add_pad (GST_ELEMENT (self), self->src);
 
-  self->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (self->collect,
-      (GstCollectPadsFunction) gst_interleave_collected, self);
+  self->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (self->collect,
+      (GstCollectPads2Function) gst_interleave_collected, self);
 
   self->input_channel_positions = g_value_array_new (0);
   self->channel_positions_from_input = TRUE;
@@ -498,10 +502,10 @@ gst_interleave_request_new_pad (GstElement * element, GstPadTemplate * templ,
   gst_pad_set_getcaps_function (new_pad,
       GST_DEBUG_FUNCPTR (gst_interleave_sink_getcaps));
 
-  gst_collect_pads_add_pad (self->collect, new_pad, sizeof (GstCollectData));
+  gst_collect_pads2_add_pad (self->collect, new_pad, sizeof (GstCollectData2));
 
   /* FIXME: hacked way to override/extend the event function of
-   * GstCollectPads; because it sets its own event function giving the
+   * GstCollectPads2; because it sets its own event function giving the
    * element no access to events */
   self->collect_event = (GstPadEventFunction) GST_PAD_EVENTFUNC (new_pad);
   gst_pad_set_event_function (new_pad,
@@ -547,7 +551,7 @@ not_sink_pad:
 could_not_add:
   {
     GST_DEBUG_OBJECT (self, "could not add pad %s", GST_PAD_NAME (new_pad));
-    gst_collect_pads_remove_pad (self->collect, new_pad);
+    gst_collect_pads2_remove_pad (self->collect, new_pad);
     gst_object_unref (new_pad);
     return NULL;
   }
@@ -601,7 +605,7 @@ gst_interleave_release_pad (GstElement * element, GstPad * pad)
 
   GST_OBJECT_UNLOCK (self->collect);
 
-  gst_collect_pads_remove_pad (self->collect, pad);
+  gst_collect_pads2_remove_pad (self->collect, pad);
   gst_element_remove_pad (element, pad);
 }
 
@@ -623,7 +627,7 @@ gst_interleave_change_state (GstElement * element, GstStateChange transition)
       self->segment_position = 0;
       self->segment_rate = 1.0;
       gst_segment_init (&self->segment, GST_FORMAT_UNDEFINED);
-      gst_collect_pads_start (self->collect);
+      gst_collect_pads2_start (self->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
@@ -632,11 +636,11 @@ gst_interleave_change_state (GstElement * element, GstStateChange transition)
   }
 
   /* Stop before calling the parent's state change function as
-   * GstCollectPads might take locks and we would deadlock in that
+   * GstCollectPads2 might take locks and we would deadlock in that
    * case
    */
   if (transition == GST_STATE_CHANGE_PAUSED_TO_READY)
-    gst_collect_pads_stop (self->collect);
+    gst_collect_pads2_stop (self->collect);
 
   ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
 
@@ -876,7 +880,7 @@ gst_interleave_sink_event (GstPad * pad, GstEvent * event)
       break;
   }
 
-  /* now GstCollectPads can take care of the rest, e.g. EOS */
+  /* now GstCollectPads2 can take care of the rest, e.g. EOS */
   ret = self->collect_event (pad, event);
 
   gst_object_unref (self);
@@ -1157,7 +1161,7 @@ gst_interleave_src_event (GstPad * pad, GstEvent * event)
       /* check if we are flushing */
       if (flags & GST_SEEK_FLAG_FLUSH) {
         /* make sure we accept nothing anymore and return WRONG_STATE */
-        gst_collect_pads_set_flushing (self->collect, TRUE);
+        gst_collect_pads2_set_flushing (self->collect, TRUE);
 
         /* flushing seek, start flush downstream, the flush will be done
          * when all pads received a FLUSH_STOP. */
@@ -1192,7 +1196,7 @@ gst_interleave_src_event (GstPad * pad, GstEvent * event)
 }
 
 static GstFlowReturn
-gst_interleave_collected (GstCollectPads * pads, GstInterleave * self)
+gst_interleave_collected (GstCollectPads2 * pads, GstInterleave * self)
 {
   guint size;
   GstBuffer *outbuf;
@@ -1208,7 +1212,7 @@ gst_interleave_collected (GstCollectPads * pads, GstInterleave * self)
   g_return_val_if_fail (self->channels > 0, GST_FLOW_NOT_NEGOTIATED);
   g_return_val_if_fail (self->rate > 0, GST_FLOW_NOT_NEGOTIATED);
 
-  size = gst_collect_pads_available (pads);
+  size = gst_collect_pads2_available (pads);
 
   g_return_val_if_fail (size % width == 0, GST_FLOW_ERROR);
 
@@ -1235,13 +1239,13 @@ gst_interleave_collected (GstCollectPads * pads, GstInterleave * self)
   memset (GST_BUFFER_DATA (outbuf), 0, size * self->channels);
 
   for (collected = pads->data; collected != NULL; collected = collected->next) {
-    GstCollectData *cdata;
+    GstCollectData2 *cdata;
     GstBuffer *inbuf;
     guint8 *outdata;
 
-    cdata = (GstCollectData *) collected->data;
+    cdata = (GstCollectData2 *) collected->data;
 
-    inbuf = gst_collect_pads_take_buffer (pads, cdata, size);
+    inbuf = gst_collect_pads2_take_buffer (pads, cdata, size);
     if (inbuf == NULL) {
       GST_DEBUG_OBJECT (cdata->pad, "No buffer available");
       goto next;
diff --git a/gst/interleave/interleave.h b/gst/interleave/interleave.h
index fb3b274..abe3439 100644
--- a/gst/interleave/interleave.h
+++ b/gst/interleave/interleave.h
@@ -27,7 +27,7 @@
 #define __INTERLEAVE_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 G_BEGIN_DECLS
 
@@ -49,7 +49,7 @@ struct _GstInterleave
   GstElement element;
 
   /*< private >*/
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
 
   gint channels;
   gint padcounter;
diff --git a/gst/isomp4/gstqtmux.c b/gst/isomp4/gstqtmux.c
index 5e9fcdd..ad2baf0 100644
--- a/gst/isomp4/gstqtmux.c
+++ b/gst/isomp4/gstqtmux.c
@@ -224,10 +224,11 @@ static GstPad *gst_qt_mux_request_new_pad (GstElement * element,
 static void gst_qt_mux_release_pad (GstElement * element, GstPad * pad);
 
 /* event */
-static gboolean gst_qt_mux_sink_event (GstPad * pad, GstEvent * event);
+static gboolean gst_qt_mux_sink_event (GstCollectPads2 * pads,
+    GstCollectData2 * data, GstEvent * event, gpointer user_data);
 
-static GstFlowReturn gst_qt_mux_collected (GstCollectPads * pads,
-    gpointer user_data);
+static GstFlowReturn gst_qt_mux_handle_buffer (GstCollectPads2 * pads,
+    GstCollectData2 * cdata, GstBuffer * buf, gpointer user_data);
 static GstFlowReturn gst_qt_mux_add_buffer (GstQTMux * qtmux, GstQTPad * pad,
     GstBuffer * buf);
 
@@ -482,9 +483,13 @@ gst_qt_mux_init (GstQTMux * qtmux, GstQTMuxClass * qtmux_klass)
   gst_element_add_pad (GST_ELEMENT (qtmux), qtmux->srcpad);
 
   qtmux->sinkpads = NULL;
-  qtmux->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (qtmux->collect,
-      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (gst_qt_mux_collected), qtmux);
+  qtmux->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_buffer_function (qtmux->collect,
+      GST_DEBUG_FUNCPTR (gst_qt_mux_handle_buffer), qtmux);
+  gst_collect_pads2_set_event_function (qtmux->collect,
+      GST_DEBUG_FUNCPTR (gst_qt_mux_sink_event), qtmux);
+  gst_collect_pads2_set_clip_function (qtmux->collect,
+      GST_DEBUG_FUNCPTR (gst_collect_pads2_clip_running_time), qtmux);
 
   /* properties set to default upon construction */
 
@@ -1608,6 +1613,31 @@ gst_qt_mux_start_file (GstQTMux * qtmux)
   gst_pad_set_caps (qtmux->srcpad, caps);
   gst_caps_unref (caps);
 
+  /* if not streaming, check if downstream is seekable */
+  if (!qtmux->streamable) {
+    gboolean seekable;
+    GstQuery *query;
+
+    query = gst_query_new_seeking (GST_FORMAT_BYTES);
+    if (gst_pad_peer_query (qtmux->srcpad, query)) {
+      gst_query_parse_seeking (query, NULL, &seekable, NULL, NULL);
+      GST_INFO_OBJECT (qtmux, "downstream is %sseekable",
+          seekable ? "" : "not ");
+      if (!seekable) {
+        qtmux->streamable = TRUE;
+        g_object_notify (G_OBJECT (qtmux), "streamable");
+        GST_WARNING_OBJECT (qtmux, "downstream is not seekable, but "
+            "streamable=false. Will ignore that and create streamable output "
+            "instead");
+      }
+    } else {
+      /* have to assume seeking is supported if query not handled downstream */
+      /* FIXME 0.11: change to query not handled => seeking not supported */
+      GST_WARNING_OBJECT (qtmux, "downstream did not handle seeking query");
+    }
+    gst_query_unref (query);
+  }
+
   /* let downstream know we think in BYTES and expect to do seeking later on */
   gst_pad_push_event (qtmux->srcpad,
       gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_BYTES, 0, -1, 0));
@@ -1642,7 +1672,7 @@ gst_qt_mux_start_file (GstQTMux * qtmux)
         gst_buffer_unref (prefix);
 
       for (walk = qtmux->sinkpads; walk && !fail; walk = g_slist_next (walk)) {
-        GstCollectData *cdata = (GstCollectData *) walk->data;
+        GstCollectData2 *cdata = (GstCollectData2 *) walk->data;
         GstQTPad *qpad = (GstQTPad *) cdata;
         /* write info for each stream */
         fail = atoms_recov_write_trak_info (qtmux->moov_recov_file, qpad->trak);
@@ -1742,7 +1772,7 @@ gst_qt_mux_stop_file (GstQTMux * qtmux)
 
   /* pushing last buffers for each pad */
   for (walk = qtmux->collect->data; walk; walk = g_slist_next (walk)) {
-    GstCollectData *cdata = (GstCollectData *) walk->data;
+    GstCollectData2 *cdata = (GstCollectData2 *) walk->data;
     GstQTPad *qtpad = (GstQTPad *) cdata;
 
     /* avoid add_buffer complaining if not negotiated
@@ -1835,7 +1865,7 @@ gst_qt_mux_stop_file (GstQTMux * qtmux)
   /* check for late streams */
   first_ts = GST_CLOCK_TIME_NONE;
   for (walk = qtmux->collect->data; walk; walk = g_slist_next (walk)) {
-    GstCollectData *cdata = (GstCollectData *) walk->data;
+    GstCollectData2 *cdata = (GstCollectData2 *) walk->data;
     GstQTPad *qtpad = (GstQTPad *) cdata;
 
     if (!GST_CLOCK_TIME_IS_VALID (first_ts) ||
@@ -1848,7 +1878,7 @@ gst_qt_mux_stop_file (GstQTMux * qtmux)
       GST_TIME_ARGS (first_ts));
   /* add EDTSs for late streams */
   for (walk = qtmux->collect->data; walk; walk = g_slist_next (walk)) {
-    GstCollectData *cdata = (GstCollectData *) walk->data;
+    GstCollectData2 *cdata = (GstCollectData2 *) walk->data;
     GstQTPad *qtpad = (GstQTPad *) cdata;
     guint32 lateness;
     guint32 duration;
@@ -2501,14 +2531,13 @@ not_negotiated:
 }
 
 static GstFlowReturn
-gst_qt_mux_collected (GstCollectPads * pads, gpointer user_data)
+gst_qt_mux_handle_buffer (GstCollectPads2 * pads, GstCollectData2 * cdata,
+    GstBuffer * buf, gpointer user_data)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   GstQTMux *qtmux = GST_QT_MUX_CAST (user_data);
-  GSList *walk;
   GstQTPad *best_pad = NULL;
-  GstClockTime time, best_time = GST_CLOCK_TIME_NONE;
-  GstBuffer *buf;
+  GstClockTime best_time = GST_CLOCK_TIME_NONE;
 
   if (G_UNLIKELY (qtmux->state == GST_QT_MUX_STATE_STARTED)) {
     if ((ret = gst_qt_mux_start_file (qtmux)) != GST_FLOW_OK)
@@ -2520,52 +2549,14 @@ gst_qt_mux_collected (GstCollectPads * pads, gpointer user_data)
   if (G_UNLIKELY (qtmux->state == GST_QT_MUX_STATE_EOS))
     return GST_FLOW_UNEXPECTED;
 
-  /* select the best buffer */
-  walk = qtmux->collect->data;
-  while (walk) {
-    GstQTPad *pad;
-    GstCollectData *data;
-
-    data = (GstCollectData *) walk->data;
-    pad = (GstQTPad *) data;
-
-    walk = g_slist_next (walk);
-
-    buf = gst_collect_pads_peek (pads, data);
-    if (buf == NULL) {
-      GST_LOG_OBJECT (qtmux, "Pad %s has no buffers",
-          GST_PAD_NAME (pad->collect.pad));
-      continue;
-    }
-    time = GST_BUFFER_TIMESTAMP (buf);
-    gst_buffer_unref (buf);
-
-    /* invalid should pass */
-    if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (time))) {
-      time =
-          gst_segment_to_running_time (&data->segment, GST_FORMAT_TIME, time);
-      if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time))) {
-        GST_DEBUG_OBJECT (qtmux, "clipping buffer on pad %s outside segment",
-            GST_PAD_NAME (data->pad));
-        buf = gst_collect_pads_pop (pads, data);
-        gst_buffer_unref (buf);
-        return GST_FLOW_OK;
-      }
-    }
-
-    if (best_pad == NULL || !GST_CLOCK_TIME_IS_VALID (time) ||
-        (GST_CLOCK_TIME_IS_VALID (best_time) && time < best_time)) {
-      best_pad = pad;
-      best_time = time;
-    }
-  }
+  best_pad = (GstQTPad *) cdata;
 
+  /* clipping already converted to running time */
   if (best_pad != NULL) {
+    g_assert (buf);
+    best_time = GST_BUFFER_TIMESTAMP (buf);
     GST_LOG_OBJECT (qtmux, "selected pad %s with time %" GST_TIME_FORMAT,
         GST_PAD_NAME (best_pad->collect.pad), GST_TIME_ARGS (best_time));
-    buf = gst_collect_pads_pop (pads, &best_pad->collect);
-    buf = gst_buffer_make_metadata_writable (buf);
-    GST_BUFFER_TIMESTAMP (buf) = best_time;
     ret = gst_qt_mux_add_buffer (qtmux, best_pad, buf);
   } else {
     ret = gst_qt_mux_stop_file (qtmux);
@@ -3263,13 +3254,14 @@ refuse_renegotiation:
 }
 
 static gboolean
-gst_qt_mux_sink_event (GstPad * pad, GstEvent * event)
+gst_qt_mux_sink_event (GstCollectPads2 * pads, GstCollectData2 * data,
+    GstEvent * event, gpointer user_data)
 {
-  gboolean ret;
   GstQTMux *qtmux;
   guint32 avg_bitrate = 0, max_bitrate = 0;
+  GstPad *pad = data->pad;
 
-  qtmux = GST_QT_MUX_CAST (gst_pad_get_parent (pad));
+  qtmux = GST_QT_MUX_CAST (user_data);
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_TAG:{
       GstTagList *list;
@@ -3279,8 +3271,9 @@ gst_qt_mux_sink_event (GstPad * pad, GstEvent * event)
       GST_OBJECT_LOCK (qtmux);
       mode = gst_tag_setter_get_tag_merge_mode (setter);
 
-      GST_DEBUG_OBJECT (qtmux, "received tag event");
       gst_event_parse_tag (event, &list);
+      GST_DEBUG_OBJECT (qtmux, "received tag event on pad %s:%s : %"
+          GST_PTR_FORMAT, GST_DEBUG_PAD_NAME (pad), list);
 
       gst_tag_setter_merge_tags (setter, list, mode);
       GST_OBJECT_UNLOCK (qtmux);
@@ -3302,10 +3295,8 @@ gst_qt_mux_sink_event (GstPad * pad, GstEvent * event)
       break;
   }
 
-  ret = qtmux->collect_event (pad, event);
-  gst_object_unref (qtmux);
-
-  return ret;
+  /* now GstCollectPads2 can take care of the rest, e.g. EOS */
+  return FALSE;
 }
 
 static void
@@ -3327,7 +3318,7 @@ gst_qt_mux_release_pad (GstElement * element, GstPad * pad)
     }
   }
 
-  gst_collect_pads_remove_pad (mux->collect, pad);
+  gst_collect_pads2_remove_pad (mux->collect, pad);
 }
 
 static GstPad *
@@ -3362,8 +3353,8 @@ gst_qt_mux_request_new_pad (GstElement * element,
   newpad = gst_pad_new_from_template (templ, name);
   g_free (name);
   collect_pad = (GstQTPad *)
-      gst_collect_pads_add_pad_full (qtmux->collect, newpad, sizeof (GstQTPad),
-      (GstCollectDataDestroyNotify) (gst_qt_mux_pad_reset));
+      gst_collect_pads2_add_pad_full (qtmux->collect, newpad, sizeof (GstQTPad),
+      (GstCollectData2DestroyNotify) (gst_qt_mux_pad_reset), TRUE);
   /* set up pad */
   gst_qt_mux_pad_reset (collect_pad);
   collect_pad->trak = atom_trak_new (qtmux->context);
@@ -3379,14 +3370,6 @@ gst_qt_mux_request_new_pad (GstElement * element,
     gst_pad_set_setcaps_function (newpad,
         GST_DEBUG_FUNCPTR (gst_qt_mux_video_sink_set_caps));
 
-  /* FIXME: hacked way to override/extend the event function of
-   * GstCollectPads; because it sets its own event function giving the
-   * element no access to events.
-   */
-  qtmux->collect_event = (GstPadEventFunction) GST_PAD_EVENTFUNC (newpad);
-  gst_pad_set_event_function (newpad,
-      GST_DEBUG_FUNCPTR (gst_qt_mux_sink_event));
-
   gst_pad_set_active (newpad, TRUE);
   gst_element_add_pad (element, newpad);
 
@@ -3523,13 +3506,13 @@ gst_qt_mux_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_NULL_TO_READY:
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (qtmux->collect);
+      gst_collect_pads2_start (qtmux->collect);
       qtmux->state = GST_QT_MUX_STATE_STARTED;
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_collect_pads_stop (qtmux->collect);
+      gst_collect_pads2_stop (qtmux->collect);
       break;
     default:
       break;
diff --git a/gst/isomp4/gstqtmux.h b/gst/isomp4/gstqtmux.h
index 1851973..b23982b 100644
--- a/gst/isomp4/gstqtmux.h
+++ b/gst/isomp4/gstqtmux.h
@@ -44,7 +44,7 @@
 #define __GST_QT_MUX_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 #include "fourcc.h"
 #include "atoms.h"
@@ -82,7 +82,7 @@ typedef GstBuffer * (*GstQTPadPrepareBufferFunc) (GstQTPad * pad,
 
 struct _GstQTPad
 {
-  GstCollectData collect;       /* we extend the CollectData */
+  GstCollectData2 collect;       /* we extend the CollectData2 */
 
   /* fourcc id of stream */
   guint32 fourcc;
@@ -144,7 +144,7 @@ struct _GstQTMux
   GstElement element;
 
   GstPad *srcpad;
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
   GSList *sinkpads;
 
   /* state */
@@ -191,9 +191,6 @@ struct _GstQTMux
   guint32 fragment_duration;
   gboolean streamable;
 
-  /* for collect pads event handling function */
-  GstPadEventFunction collect_event;
-
   /* for request pad naming */
   guint video_pads, audio_pads;
 };
diff --git a/gst/matroska/matroska-demux.c b/gst/matroska/matroska-demux.c
index 6e49baa..ab75060 100644
--- a/gst/matroska/matroska-demux.c
+++ b/gst/matroska/matroska-demux.c
@@ -1910,6 +1910,7 @@ gst_matroska_demux_handle_seek_event (GstMatroskaDemux * demux,
   GstMatroskaTrackContext *track = NULL;
   GstSegment seeksegment = { 0, };
   gboolean update = TRUE;
+  gboolean pad_locked = FALSE;
 
   if (pad)
     track = gst_pad_get_element_private (pad);
@@ -2011,6 +2012,7 @@ next:
    * forever. */
   GST_DEBUG_OBJECT (demux, "Waiting for streaming to stop");
   GST_PAD_STREAM_LOCK (demux->common.sinkpad);
+  pad_locked = TRUE;
 
   /* pull mode without index can do some scanning */
   if (!demux->streaming && !entry) {
@@ -2093,13 +2095,17 @@ exit:
       (GstTaskFunction) gst_matroska_demux_loop, demux->common.sinkpad);
 
   /* streaming can continue now */
-  GST_PAD_STREAM_UNLOCK (demux->common.sinkpad);
+  if (pad_locked) {
+    GST_PAD_STREAM_UNLOCK (demux->common.sinkpad);
+  }
 
   return TRUE;
 
 seek_error:
   {
-    GST_PAD_STREAM_UNLOCK (demux->common.sinkpad);
+    if (pad_locked) {
+      GST_PAD_STREAM_UNLOCK (demux->common.sinkpad);
+    }
     GST_ELEMENT_ERROR (demux, STREAM, DEMUX, (NULL), ("Got a seek error"));
     return FALSE;
   }
diff --git a/gst/matroska/matroska-mux.c b/gst/matroska/matroska-mux.c
index 30c0cdb..168b2a9 100644
--- a/gst/matroska/matroska-mux.c
+++ b/gst/matroska/matroska-mux.c
@@ -2,6 +2,7 @@
  * (c) 2003 Ronald Bultje <rbultje@ronald.bitfreak.net>
  * (c) 2005 Michal Benes <michal.benes@xeris.cz>
  * (c) 2008 Sebastian Dröge <sebastian.droege@collabora.co.uk>
+ * (c) 2011 Mark Nauwelaerts <mark.nauwelaerts@collabora.co.uk>
  *
  * matroska-mux.c: matroska file/stream muxer
  *
@@ -205,10 +206,14 @@ static GstStaticPadTemplate audiosink_templ =
     );
 
 static GstStaticPadTemplate subtitlesink_templ =
-GST_STATIC_PAD_TEMPLATE ("subtitle_%d",
+    GST_STATIC_PAD_TEMPLATE ("subtitle_%d",
     GST_PAD_SINK,
     GST_PAD_REQUEST,
-    GST_STATIC_CAPS ("subtitle/x-kate"));
+    GST_STATIC_CAPS ("subtitle/x-kate; "
+        "text/plain; application/x-ssa; application/x-ass; "
+        "application/x-usf; video/x-dvd-subpicture; "
+        "application/x-subtitle-unknown")
+    );
 
 static GArray *used_uids;
 G_LOCK_DEFINE_STATIC (used_uids);
@@ -222,8 +227,10 @@ GST_BOILERPLATE_FULL (GstMatroskaMux, gst_matroska_mux, GstElement,
 static void gst_matroska_mux_finalize (GObject * object);
 
 /* Pads collected callback */
-static GstFlowReturn
-gst_matroska_mux_collected (GstCollectPads * pads, gpointer user_data);
+static GstFlowReturn gst_matroska_mux_handle_buffer (GstCollectPads2 * pads,
+    GstCollectData2 * data, GstBuffer * buf, gpointer user_data);
+static gboolean gst_matroska_mux_handle_sink_event (GstCollectPads2 * pads,
+    GstCollectData2 * data, GstEvent * event, gpointer user_data);
 
 /* pad functions */
 static gboolean gst_matroska_mux_handle_src_event (GstPad * pad,
@@ -450,10 +457,13 @@ gst_matroska_mux_init (GstMatroskaMux * mux, GstMatroskaMuxClass * g_class)
   gst_pad_set_event_function (mux->srcpad, gst_matroska_mux_handle_src_event);
   gst_element_add_pad (GST_ELEMENT (mux), mux->srcpad);
 
-  mux->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (mux->collect,
-      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (gst_matroska_mux_collected),
-      mux);
+  mux->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_clip_function (mux->collect,
+      GST_DEBUG_FUNCPTR (gst_collect_pads2_clip_running_time), mux);
+  gst_collect_pads2_set_buffer_function (mux->collect,
+      GST_DEBUG_FUNCPTR (gst_matroska_mux_handle_buffer), mux);
+  gst_collect_pads2_set_event_function (mux->collect,
+      GST_DEBUG_FUNCPTR (gst_matroska_mux_handle_sink_event), mux);
 
   mux->ebml_write = gst_ebml_write_new (mux->srcpad);
   mux->doctype = GST_MATROSKA_DOCTYPE_MATROSKA;
@@ -570,12 +580,6 @@ gst_matroska_pad_reset (GstMatroskaPad * collect_pad, gboolean full)
     collect_pad->track = NULL;
   }
 
-  /* free cached buffer */
-  if (collect_pad->buffer != NULL) {
-    gst_buffer_unref (collect_pad->buffer);
-    collect_pad->buffer = NULL;
-  }
-
   if (!full && type != 0) {
     GstMatroskaTrackContext *context;
 
@@ -603,7 +607,6 @@ gst_matroska_pad_reset (GstMatroskaPad * collect_pad, gboolean full)
     /* TODO: check default values for the context */
     context->flags = GST_MATROSKA_TRACK_ENABLED | GST_MATROSKA_TRACK_DEFAULT;
     collect_pad->track = context;
-    collect_pad->buffer = NULL;
     collect_pad->duration = 0;
     collect_pad->start_ts = GST_CLOCK_TIME_NONE;
     collect_pad->end_ts = GST_CLOCK_TIME_NONE;
@@ -699,6 +702,55 @@ gst_matroska_mux_handle_src_event (GstPad * pad, GstEvent * event)
   return gst_pad_event_default (pad, event);
 }
 
+
+static void
+gst_matroska_mux_free_codec_priv (GstMatroskaTrackContext * context)
+{
+  if (context->codec_priv != NULL) {
+    g_free (context->codec_priv);
+    context->codec_priv = NULL;
+    context->codec_priv_size = 0;
+  }
+}
+
+static void
+gst_matroska_mux_build_vobsub_private (GstMatroskaTrackContext * context,
+    const guint * clut)
+{
+  gchar *clutv[17];
+  gchar *sclut;
+  gint i;
+  guint32 col;
+  gdouble y, u, v;
+  guint8 r, g, b;
+
+  /* produce comma-separated list in hex format */
+  for (i = 0; i < 16; ++i) {
+    col = clut[i];
+    /* replicate vobsub's slightly off RGB conversion calculation */
+    y = (((col >> 16) & 0xff) - 16) * 255 / 219;
+    u = ((col >> 8) & 0xff) - 128;
+    v = (col & 0xff) - 128;
+    r = CLAMP (1.0 * y + 1.4022 * u, 0, 255);
+    g = CLAMP (1.0 * y - 0.3456 * u - 0.7145 * v, 0, 255);
+    b = CLAMP (1.0 * y + 1.7710 * v, 0, 255);
+    clutv[i] = g_strdup_printf ("%02x%02x%02x", r, g, b);
+  }
+  clutv[i] = NULL;
+  sclut = g_strjoinv (",", clutv);
+
+  /* build codec private; only palette for now */
+  gst_matroska_mux_free_codec_priv (context);
+  context->codec_priv = (guint8 *) g_strdup_printf ("palette: %s", sclut);
+  /* include terminating 0 */
+  context->codec_priv_size = strlen ((gchar *) context->codec_priv) + 1;
+  g_free (sclut);
+  for (i = 0; i < 16; ++i) {
+    g_free (clutv[i]);
+  }
+}
+
+
 /**
  * gst_matroska_mux_handle_sink_event:
  * @pad: Pad which received the event.
@@ -709,15 +761,20 @@ gst_matroska_mux_handle_src_event (GstPad * pad, GstEvent * event)
  * Returns: #TRUE on success.
  */
 static gboolean
-gst_matroska_mux_handle_sink_event (GstPad * pad, GstEvent * event)
+gst_matroska_mux_handle_sink_event (GstCollectPads2 * pads,
+    GstCollectData2 * data, GstEvent * event, gpointer user_data)
 {
   GstMatroskaTrackContext *context;
   GstMatroskaPad *collect_pad;
   GstMatroskaMux *mux;
+  GstPad *pad;
   GstTagList *list;
-  gboolean ret = TRUE;
 
-  mux = GST_MATROSKA_MUX (gst_pad_get_parent (pad));
+  mux = GST_MATROSKA_MUX (user_data);
+  collect_pad = (GstMatroskaPad *) data;
+  pad = data->pad;
+  context = collect_pad->track;
+  g_assert (context);
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_TAG:{
@@ -726,11 +783,6 @@ gst_matroska_mux_handle_sink_event (GstPad * pad, GstEvent * event)
       GST_DEBUG_OBJECT (mux, "received tag event");
       gst_event_parse_tag (event, &list);
 
-      collect_pad = (GstMatroskaPad *) gst_pad_get_element_private (pad);
-      g_assert (collect_pad);
-      context = collect_pad->track;
-      g_assert (context);
-
       /* Matroska wants ISO 639-2B code, taglist most likely contains 639-1 */
       if (gst_tag_list_get_string (list, GST_TAG_LANGUAGE_CODE, &lang)) {
         const gchar *lang_code;
@@ -760,7 +812,6 @@ gst_matroska_mux_handle_sink_event (GstPad * pad, GstEvent * event)
       gst_event_parse_new_segment (event, NULL, NULL, &format, NULL, NULL,
           NULL);
       if (format != GST_FORMAT_TIME) {
-        ret = FALSE;
         gst_event_unref (event);
         event = NULL;
       }
@@ -774,6 +825,31 @@ gst_matroska_mux_handle_sink_event (GstPad * pad, GstEvent * event)
         gst_event_replace (&mux->force_key_unit_event, NULL);
         mux->force_key_unit_event = event;
         event = NULL;
+      } else if (gst_structure_has_name (structure, "application/x-gst-dvd") &&
+          !strcmp ("dvd-spu-clut-change",
+              gst_structure_get_string (structure, "event"))) {
+        gchar name[16];
+        gint i, value;
+        guint clut[16];
+
+        GST_DEBUG_OBJECT (pad, "New DVD colour table received");
+        if (context->type != GST_MATROSKA_TRACK_TYPE_SUBTITLE) {
+          GST_DEBUG_OBJECT (pad, "... discarding");
+          break;
+        }
+        /* first transform event data into table form */
+        for (i = 0; i < 16; i++) {
+          g_snprintf (name, sizeof (name), "clut%02d", i);
+          if (!gst_structure_get_int (structure, name, &value)) {
+            GST_ERROR_OBJECT (mux, "dvd-spu-clut-change event did not "
+                "contain %s field", name);
+            break;
+          }
+          clut[i] = value;
+        }
+
+        /* transform into private data for stream; text form */
+        gst_matroska_mux_build_vobsub_private (context, clut);
       }
       break;
     }
@@ -781,15 +857,22 @@ gst_matroska_mux_handle_sink_event (GstPad * pad, GstEvent * event)
       break;
   }
 
-  /* now GstCollectPads can take care of the rest, e.g. EOS */
+  /* now GstCollectPads2 can take care of the rest, e.g. EOS */
   if (event)
-    ret = mux->collect_event (pad, event);
-
-  gst_object_unref (mux);
-
-  return ret;
+    return FALSE;
+  else
+    return TRUE;
 }
 
+static void
+gst_matroska_mux_set_codec_id (GstMatroskaTrackContext * context,
+    const char *id)
+{
+  g_assert (context && id);
+  if (context->codec_id)
+    g_free (context->codec_id);
+  context->codec_id = g_strdup (id);
+}
 
 /**
  * gst_matroska_mux_video_pad_setcaps:
@@ -898,7 +981,8 @@ skip_details:
 
   /* find type */
   if (!strcmp (mimetype, "video/x-raw-yuv")) {
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_UNCOMPRESSED);
+    gst_matroska_mux_set_codec_id (context,
+        GST_MATROSKA_CODEC_ID_VIDEO_UNCOMPRESSED);
     gst_structure_get_fourcc (structure, "format", &videocontext->fourcc);
   } else if (!strcmp (mimetype, "video/x-xvid") /* MS/VfW compatibility cases */
       ||!strcmp (mimetype, "video/x-huffyuv")
@@ -990,18 +1074,15 @@ skip_details:
           GST_BUFFER_DATA (codec_buf), GST_BUFFER_SIZE (codec_buf));
     }
 
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC);
+    gst_matroska_mux_set_codec_id (context,
+        GST_MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC);
+    gst_matroska_mux_free_codec_priv (context);
     context->codec_priv = (gpointer) bih;
     context->codec_priv_size = size;
   } else if (!strcmp (mimetype, "video/x-h264")) {
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_AVC);
-
-    if (context->codec_priv != NULL) {
-      g_free (context->codec_priv);
-      context->codec_priv = NULL;
-      context->codec_priv_size = 0;
-    }
-
+    gst_matroska_mux_set_codec_id (context,
+        GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_AVC);
+    gst_matroska_mux_free_codec_priv (context);
     /* Create avcC header */
     if (codec_buf != NULL) {
       context->codec_priv_size = GST_BUFFER_SIZE (codec_buf);
@@ -1012,13 +1093,9 @@ skip_details:
   } else if (!strcmp (mimetype, "video/x-theora")) {
     const GValue *streamheader;
 
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_THEORA);
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_VIDEO_THEORA);
 
-    if (context->codec_priv != NULL) {
-      g_free (context->codec_priv);
-      context->codec_priv = NULL;
-      context->codec_priv_size = 0;
-    }
+    gst_matroska_mux_free_codec_priv (context);
 
     streamheader = gst_structure_get_value (structure, "streamheader");
     if (!theora_streamheader_to_codecdata (streamheader, context)) {
@@ -1027,22 +1104,25 @@ skip_details:
       goto refuse_caps;
     }
   } else if (!strcmp (mimetype, "video/x-dirac")) {
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_DIRAC);
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_VIDEO_DIRAC);
   } else if (!strcmp (mimetype, "video/x-vp8")) {
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_VP8);
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_VIDEO_VP8);
   } else if (!strcmp (mimetype, "video/mpeg")) {
     gint mpegversion;
 
     gst_structure_get_int (structure, "mpegversion", &mpegversion);
     switch (mpegversion) {
       case 1:
-        context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_MPEG1);
+        gst_matroska_mux_set_codec_id (context,
+            GST_MATROSKA_CODEC_ID_VIDEO_MPEG1);
         break;
       case 2:
-        context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_MPEG2);
+        gst_matroska_mux_set_codec_id (context,
+            GST_MATROSKA_CODEC_ID_VIDEO_MPEG2);
         break;
       case 4:
-        context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_ASP);
+        gst_matroska_mux_set_codec_id (context,
+            GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_ASP);
         break;
       default:
         goto refuse_caps;
@@ -1050,6 +1130,7 @@ skip_details:
 
     /* global headers may be in codec data */
     if (codec_buf != NULL) {
+      gst_matroska_mux_free_codec_priv (context);
       context->codec_priv_size = GST_BUFFER_SIZE (codec_buf);
       context->codec_priv = g_malloc0 (context->codec_priv_size);
       memcpy (context->codec_priv, GST_BUFFER_DATA (codec_buf),
@@ -1066,16 +1147,20 @@ skip_details:
     gst_structure_get_int (structure, "rmversion", &rmversion);
     switch (rmversion) {
       case 1:
-        context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO1);
+        gst_matroska_mux_set_codec_id (context,
+            GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO1);
         break;
       case 2:
-        context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO2);
+        gst_matroska_mux_set_codec_id (context,
+            GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO2);
         break;
       case 3:
-        context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO3);
+        gst_matroska_mux_set_codec_id (context,
+            GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO3);
         break;
       case 4:
-        context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO4);
+        gst_matroska_mux_set_codec_id (context,
+            GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO4);
         break;
       default:
         goto refuse_caps;
@@ -1093,6 +1178,7 @@ skip_details:
 
       memcpy (priv_data, GST_BUFFER_DATA (codec_data_buf), priv_data_size);
 
+      gst_matroska_mux_free_codec_priv (context);
       context->codec_priv = priv_data;
       context->codec_priv_size = priv_data_size;
     }
@@ -1177,6 +1263,7 @@ xiphN_streamheader_to_codecdata (const GValue * streamheader,
     offset += GST_BUFFER_SIZE (buf[i]);
   }
 
+  gst_matroska_mux_free_codec_priv (context);
   context->codec_priv = priv_data;
   context->codec_priv_size = priv_data_size;
 
@@ -1356,6 +1443,7 @@ flac_streamheader_to_codecdata (const GValue * streamheader,
     return FALSE;
   }
 
+  gst_matroska_mux_free_codec_priv (context);
   context->codec_priv = g_malloc (GST_BUFFER_SIZE (buffer) - 9);
   context->codec_priv_size = GST_BUFFER_SIZE (buffer) - 9;
   memcpy (context->codec_priv, GST_BUFFER_DATA (buffer) + 9,
@@ -1365,9 +1453,7 @@ flac_streamheader_to_codecdata (const GValue * streamheader,
     bufval = &g_array_index (bufarr, GValue, i);
 
     if (G_VALUE_TYPE (bufval) != GST_TYPE_BUFFER) {
-      g_free (context->codec_priv);
-      context->codec_priv = NULL;
-      context->codec_priv_size = 0;
+      gst_matroska_mux_free_codec_priv (context);
       GST_WARNING ("streamheaders array does not contain GstBuffers");
       return FALSE;
     }
@@ -1421,6 +1507,7 @@ speex_streamheader_to_codecdata (const GValue * streamheader,
     return FALSE;
   }
 
+  gst_matroska_mux_free_codec_priv (context);
   context->codec_priv = g_malloc (GST_BUFFER_SIZE (buffer));
   context->codec_priv_size = GST_BUFFER_SIZE (buffer);
   memcpy (context->codec_priv, GST_BUFFER_DATA (buffer),
@@ -1429,9 +1516,7 @@ speex_streamheader_to_codecdata (const GValue * streamheader,
   bufval = &g_array_index (bufarr, GValue, 1);
 
   if (G_VALUE_TYPE (bufval) != GST_TYPE_BUFFER) {
-    g_free (context->codec_priv);
-    context->codec_priv = NULL;
-    context->codec_priv_size = 0;
+    gst_matroska_mux_free_codec_priv (context);
     GST_WARNING ("streamheaders array does not contain GstBuffers");
     return FALSE;
   }
@@ -1571,13 +1656,16 @@ gst_matroska_mux_audio_pad_setcaps (GstPad * pad, GstCaps * caps)
 
         switch (layer) {
           case 1:
-            context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L1);
+            gst_matroska_mux_set_codec_id (context,
+                GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L1);
             break;
           case 2:
-            context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L2);
+            gst_matroska_mux_set_codec_id (context,
+                GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L2);
             break;
           case 3:
-            context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L3);
+            gst_matroska_mux_set_codec_id (context,
+                GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L3);
             break;
           default:
             goto refuse_caps;
@@ -1648,9 +1736,11 @@ gst_matroska_mux_audio_pad_setcaps (GstPad * pad, GstCaps * caps)
 
     audiocontext->bitdepth = depth;
     if (endianness == G_BIG_ENDIAN)
-      context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_PCM_INT_BE);
+      gst_matroska_mux_set_codec_id (context,
+          GST_MATROSKA_CODEC_ID_AUDIO_PCM_INT_BE);
     else
-      context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_PCM_INT_LE);
+      gst_matroska_mux_set_codec_id (context,
+          GST_MATROSKA_CODEC_ID_AUDIO_PCM_INT_LE);
 
   } else if (!strcmp (mimetype, "audio/x-raw-float")) {
     gint width;
@@ -1661,18 +1751,15 @@ gst_matroska_mux_audio_pad_setcaps (GstPad * pad, GstCaps * caps)
     }
 
     audiocontext->bitdepth = width;
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_PCM_FLOAT);
+    gst_matroska_mux_set_codec_id (context,
+        GST_MATROSKA_CODEC_ID_AUDIO_PCM_FLOAT);
 
   } else if (!strcmp (mimetype, "audio/x-vorbis")) {
     const GValue *streamheader;
 
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_VORBIS);
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_AUDIO_VORBIS);
 
-    if (context->codec_priv != NULL) {
-      g_free (context->codec_priv);
-      context->codec_priv = NULL;
-      context->codec_priv_size = 0;
-    }
+    gst_matroska_mux_free_codec_priv (context);
 
     streamheader = gst_structure_get_value (structure, "streamheader");
     if (!vorbis_streamheader_to_codecdata (streamheader, context)) {
@@ -1683,12 +1770,9 @@ gst_matroska_mux_audio_pad_setcaps (GstPad * pad, GstCaps * caps)
   } else if (!strcmp (mimetype, "audio/x-flac")) {
     const GValue *streamheader;
 
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_FLAC);
-    if (context->codec_priv != NULL) {
-      g_free (context->codec_priv);
-      context->codec_priv = NULL;
-      context->codec_priv_size = 0;
-    }
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_AUDIO_FLAC);
+
+    gst_matroska_mux_free_codec_priv (context);
 
     streamheader = gst_structure_get_value (structure, "streamheader");
     if (!flac_streamheader_to_codecdata (streamheader, context)) {
@@ -1699,12 +1783,8 @@ gst_matroska_mux_audio_pad_setcaps (GstPad * pad, GstCaps * caps)
   } else if (!strcmp (mimetype, "audio/x-speex")) {
     const GValue *streamheader;
 
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_SPEEX);
-    if (context->codec_priv != NULL) {
-      g_free (context->codec_priv);
-      context->codec_priv = NULL;
-      context->codec_priv_size = 0;
-    }
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_AUDIO_SPEEX);
+    gst_matroska_mux_free_codec_priv (context);
 
     streamheader = gst_structure_get_value (structure, "streamheader");
     if (!speex_streamheader_to_codecdata (streamheader, context)) {
@@ -1713,11 +1793,11 @@ gst_matroska_mux_audio_pad_setcaps (GstPad * pad, GstCaps * caps)
       goto refuse_caps;
     }
   } else if (!strcmp (mimetype, "audio/x-ac3")) {
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_AC3);
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_AUDIO_AC3);
   } else if (!strcmp (mimetype, "audio/x-eac3")) {
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_EAC3);
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_AUDIO_EAC3);
   } else if (!strcmp (mimetype, "audio/x-dts")) {
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_DTS);
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_AUDIO_DTS);
   } else if (!strcmp (mimetype, "audio/x-tta")) {
     gint width;
 
@@ -1726,7 +1806,7 @@ gst_matroska_mux_audio_pad_setcaps (GstPad * pad, GstCaps * caps)
 
     gst_structure_get_int (structure, "width", &width);
     audiocontext->bitdepth = width;
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_TTA);
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_AUDIO_TTA);
 
   } else if (!strcmp (mimetype, "audio/x-pn-realaudio")) {
     gint raversion;
@@ -1735,13 +1815,16 @@ gst_matroska_mux_audio_pad_setcaps (GstPad * pad, GstCaps * caps)
     gst_structure_get_int (structure, "raversion", &raversion);
     switch (raversion) {
       case 1:
-        context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_REAL_14_4);
+        gst_matroska_mux_set_codec_id (context,
+            GST_MATROSKA_CODEC_ID_AUDIO_REAL_14_4);
         break;
       case 2:
-        context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_REAL_28_8);
+        gst_matroska_mux_set_codec_id (context,
+            GST_MATROSKA_CODEC_ID_AUDIO_REAL_28_8);
         break;
       case 8:
-        context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_REAL_COOK);
+        gst_matroska_mux_set_codec_id (context,
+            GST_MATROSKA_CODEC_ID_AUDIO_REAL_COOK);
         break;
       default:
         goto refuse_caps;
@@ -1759,6 +1842,8 @@ gst_matroska_mux_audio_pad_setcaps (GstPad * pad, GstCaps * caps)
 
       memcpy (priv_data, GST_BUFFER_DATA (codec_data_buf), priv_data_size);
 
+      gst_matroska_mux_free_codec_priv (context);
+
       context->codec_priv = priv_data;
       context->codec_priv_size = priv_data_size;
     }
@@ -1842,7 +1927,8 @@ gst_matroska_mux_audio_pad_setcaps (GstPad * pad, GstCaps * caps)
           GST_BUFFER_DATA (buf), GST_BUFFER_SIZE (buf));
     }
 
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_AUDIO_ACM);
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_AUDIO_ACM);
+    gst_matroska_mux_free_codec_priv (context);
     context->codec_priv = (gpointer) codec_priv;
     context->codec_priv_size = codec_priv_size;
   }
@@ -1858,6 +1944,10 @@ refuse_caps:
   }
 }
 
+/* we probably don't have the data at start,
+ * so have to reserve (a maximum) space to write this at the end.
+ * bit spacy, but some formats can hold quite some */
+#define SUBTITLE_MAX_CODEC_PRIVATE   2048       /* must be > 128 */
 
 /**
  * gst_matroska_mux_subtitle_pad_setcaps:
@@ -1871,11 +1961,6 @@ refuse_caps:
 static gboolean
 gst_matroska_mux_subtitle_pad_setcaps (GstPad * pad, GstCaps * caps)
 {
-  /* FIXME:
-   * Consider this as boilerplate code for now. There is
-   * no single subtitle creation element in GStreamer,
-   * neither do I know how subtitling works at all. */
-
   /* There is now (at least) one such alement (kateenc), and I'm going
      to handle it here and claim it works when it can be piped back
      through GStreamer and VLC */
@@ -1886,6 +1971,9 @@ gst_matroska_mux_subtitle_pad_setcaps (GstPad * pad, GstCaps * caps)
   GstMatroskaPad *collect_pad;
   const gchar *mimetype;
   GstStructure *structure;
+  const GValue *value = NULL;
+  const GstBuffer *buf = NULL;
+  gboolean ret = TRUE;
 
   mux = GST_MATROSKA_MUX (GST_PAD_PARENT (pad));
 
@@ -1905,29 +1993,68 @@ gst_matroska_mux_subtitle_pad_setcaps (GstPad * pad, GstCaps * caps)
   scontext->invalid_utf8 = 0;
   context->default_duration = 0;
 
-  /* TODO: - other format than Kate */
-
   if (!strcmp (mimetype, "subtitle/x-kate")) {
     const GValue *streamheader;
 
-    context->codec_id = g_strdup (GST_MATROSKA_CODEC_ID_SUBTITLE_KATE);
+    gst_matroska_mux_set_codec_id (context,
+        GST_MATROSKA_CODEC_ID_SUBTITLE_KATE);
 
-    if (context->codec_priv != NULL) {
-      g_free (context->codec_priv);
-      context->codec_priv = NULL;
-      context->codec_priv_size = 0;
-    }
+    gst_matroska_mux_free_codec_priv (context);
 
     streamheader = gst_structure_get_value (structure, "streamheader");
     if (!kate_streamheader_to_codecdata (streamheader, context)) {
       GST_ELEMENT_ERROR (mux, STREAM, MUX, (NULL),
           ("kate stream headers missing or malformed"));
-      return FALSE;
+      ret = FALSE;
+      goto exit;
+    }
+  } else if (!strcmp (mimetype, "text/plain")) {
+    gst_matroska_mux_set_codec_id (context,
+        GST_MATROSKA_CODEC_ID_SUBTITLE_UTF8);
+  } else if (!strcmp (mimetype, "application/x-ssa")) {
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_SUBTITLE_SSA);
+  } else if (!strcmp (mimetype, "application/x-ass")) {
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_SUBTITLE_ASS);
+  } else if (!strcmp (mimetype, "application/x-usf")) {
+    gst_matroska_mux_set_codec_id (context, GST_MATROSKA_CODEC_ID_SUBTITLE_USF);
+  } else if (!strcmp (mimetype, "video/x-dvd-subpicture")) {
+    gst_matroska_mux_set_codec_id (context,
+        GST_MATROSKA_CODEC_ID_SUBTITLE_VOBSUB);
+  } else {
+    ret = FALSE;
+    goto exit;
+  }
+
+  /* maybe some private data, e.g. vobsub */
+  value = gst_structure_get_value (structure, "codec_data");
+  if (value)
+    buf = gst_value_get_buffer (value);
+  if (buf != NULL) {
+    guint8 *priv_data = NULL;
+    guint priv_data_size = 0;
+
+    priv_data_size = GST_BUFFER_SIZE (buf);
+    if (priv_data_size > SUBTITLE_MAX_CODEC_PRIVATE) {
+      GST_WARNING_OBJECT (mux, "pad %" GST_PTR_FORMAT " subtitle private data"
+          " exceeded maximum (%d); discarding", pad,
+          SUBTITLE_MAX_CODEC_PRIVATE);
+      return TRUE;
     }
-    return TRUE;
+
+    gst_matroska_mux_free_codec_priv (context);
+
+    priv_data = g_malloc0 (priv_data_size);
+    memcpy (priv_data, GST_BUFFER_DATA (buf), priv_data_size);
+    context->codec_priv = priv_data;
+    context->codec_priv_size = priv_data_size;
   }
 
-  return FALSE;
+  GST_DEBUG_OBJECT (pad, "codec_id %s, codec data size %u",
+      GST_STR_NULL (context->codec_id), context->codec_priv_size);
+
+exit:
+
+  return ret;
 }
 
 
@@ -1954,6 +2081,8 @@ gst_matroska_mux_request_new_pad (GstElement * element,
   GstPadSetCapsFunction setcapsfunc = NULL;
   GstMatroskaTrackContext *context = NULL;
   gint pad_id;
+  gboolean locked = TRUE;
+  gchar *id = NULL;
 
   if (templ == gst_element_class_get_pad_template (klass, "audio_%d")) {
     /* don't mix named and unnamed pads, if the pad already exists we fail when
@@ -1997,6 +2126,9 @@ gst_matroska_mux_request_new_pad (GstElement * element,
         g_new0 (GstMatroskaTrackSubtitleContext, 1);
     context->type = GST_MATROSKA_TRACK_TYPE_SUBTITLE;
     context->name = g_strdup ("Subtitle");
+    /* setcaps may only provide proper one a lot later */
+    id = g_strdup ("S_SUB_UNKNOWN");
+    locked = FALSE;
   } else {
     GST_WARNING_OBJECT (mux, "This is not our template!");
     return NULL;
@@ -2008,24 +2140,13 @@ gst_matroska_mux_request_new_pad (GstElement * element,
 
   gst_matroskamux_pad_init (newpad);
   collect_pad = (GstMatroskaPad *)
-      gst_collect_pads_add_pad_full (mux->collect, GST_PAD (newpad),
+      gst_collect_pads2_add_pad_full (mux->collect, GST_PAD (newpad),
       sizeof (GstMatroskamuxPad),
-      (GstCollectDataDestroyNotify) gst_matroska_pad_free);
+      (GstCollectData2DestroyNotify) gst_matroska_pad_free, locked);
 
   collect_pad->track = context;
   gst_matroska_pad_reset (collect_pad, FALSE);
-
-  /* FIXME: hacked way to override/extend the event function of
-   * GstCollectPads; because it sets its own event function giving the
-   * element no access to events.
-   * TODO GstCollectPads should really give its 'users' a clean chance to
-   * properly handle events that are not meant for collectpads itself.
-   * Perhaps a callback or so, though rejected (?) in #340060.
-   * This would allow (clean) transcoding of info from demuxer/streams
-   * to another muxer */
-  mux->collect_event = (GstPadEventFunction) GST_PAD_EVENTFUNC (newpad);
-  gst_pad_set_event_function (GST_PAD (newpad),
-      GST_DEBUG_FUNCPTR (gst_matroska_mux_handle_sink_event));
+  collect_pad->track->codec_id = id;
 
   gst_pad_set_setcaps_function (GST_PAD (newpad), setcapsfunc);
   gst_pad_set_active (GST_PAD (newpad), TRUE);
@@ -2063,7 +2184,7 @@ gst_matroska_mux_release_pad (GstElement * element, GstPad * pad)
   mux = GST_MATROSKA_MUX (GST_PAD_PARENT (pad));
 
   for (walk = mux->collect->data; walk; walk = g_slist_next (walk)) {
-    GstCollectData *cdata = (GstCollectData *) walk->data;
+    GstCollectData2 *cdata = (GstCollectData2 *) walk->data;
     GstMatroskaPad *collect_pad = (GstMatroskaPad *) cdata;
 
     if (cdata->pad == pad) {
@@ -2084,7 +2205,7 @@ gst_matroska_mux_release_pad (GstElement * element, GstPad * pad)
     }
   }
 
-  gst_collect_pads_remove_pad (mux->collect, pad);
+  gst_collect_pads2_remove_pad (mux->collect, pad);
   if (gst_element_remove_pad (element, pad))
     mux->num_streams--;
 }
@@ -2121,6 +2242,14 @@ gst_matroska_mux_track_header (GstMatroskaMux * mux,
         context->language);
   }
 
+  /* FIXME: until we have a nice way of getting the codecname
+   * out of the caps, I'm not going to enable this. Too much
+   * (useless, double, boring) work... */
+  /* TODO: Use value from tags if any */
+  /*gst_ebml_write_utf8 (ebml, GST_MATROSKA_ID_CODECNAME,
+     context->codec_name); */
+  gst_ebml_write_utf8 (ebml, GST_MATROSKA_ID_TRACKNAME, context->name);
+
   /* type-specific stuff */
   switch (context->type) {
     case GST_MATROSKA_TRACK_TYPE_VIDEO:{
@@ -2171,6 +2300,24 @@ gst_matroska_mux_track_header (GstMatroskaMux * mux,
       break;
     }
 
+      /* this is what we write for now and must be filled
+       * and remainder void'ed later on */
+#define SUBTITLE_DUMMY_SIZE   (1 + 1 + 14 + 1 + 2 + SUBTITLE_MAX_CODEC_PRIVATE)
+
+    case GST_MATROSKA_TRACK_TYPE_SUBTITLE:{
+      gpointer buf;
+
+      context->pos = ebml->pos;
+      /* CodecID is mandatory ... */
+      gst_ebml_write_ascii (ebml, GST_MATROSKA_ID_CODECID, "S_SUB_UNKNOWN");
+      /* reserve space */
+      buf = g_malloc0 (SUBTITLE_MAX_CODEC_PRIVATE);
+      gst_ebml_write_binary (ebml, GST_EBML_ID_VOID, buf,
+          SUBTITLE_MAX_CODEC_PRIVATE);
+      g_free (buf);
+      /* real data has to be written at finish */
+      return;
+    }
     default:
       /* doesn't need type-specific data */
       break;
@@ -2180,13 +2327,6 @@ gst_matroska_mux_track_header (GstMatroskaMux * mux,
   if (context->codec_priv)
     gst_ebml_write_binary (ebml, GST_MATROSKA_ID_CODECPRIVATE,
         context->codec_priv, context->codec_priv_size);
-  /* FIXME: until we have a nice way of getting the codecname
-   * out of the caps, I'm not going to enable this. Too much
-   * (useless, double, boring) work... */
-  /* TODO: Use value from tags if any */
-  /*gst_ebml_write_utf8 (ebml, GST_MATROSKA_ID_CODECNAME,
-     context->codec_name); */
-  gst_ebml_write_utf8 (ebml, GST_MATROSKA_ID_TRACKNAME, context->name);
 }
 
 
@@ -2215,6 +2355,30 @@ gst_matroska_mux_start (GstMatroskaMux * mux)
   guint32 segment_uid[4];
   GTimeVal time = { 0, 0 };
 
+  /* if not streaming, check if downstream is seekable */
+  if (!mux->streamable) {
+    gboolean seekable;
+    GstQuery *query;
+
+    query = gst_query_new_seeking (GST_FORMAT_BYTES);
+    if (gst_pad_peer_query (mux->srcpad, query)) {
+      gst_query_parse_seeking (query, NULL, &seekable, NULL, NULL);
+      GST_INFO_OBJECT (mux, "downstream is %sseekable", seekable ? "" : "not ");
+      if (!seekable) {
+        mux->streamable = TRUE;
+        g_object_notify (G_OBJECT (mux), "streamable");
+        GST_WARNING_OBJECT (mux, "downstream is not seekable, but "
+            "streamable=false. Will ignore that and create streamable output "
+            "instead");
+      }
+    } else {
+      /* have to assume seeking is supported if query not handled downstream */
+      /* FIXME 0.11: change to query not handled => seeking not supported */
+      GST_WARNING_OBJECT (mux, "downstream did not handle seeking query");
+    }
+    gst_query_unref (query);
+  }
+
   if (!strcmp (mux->doctype, GST_MATROSKA_DOCTYPE_WEBM)) {
     ebml->caps = gst_caps_new_simple ("video/webm", NULL);
   } else {
@@ -2256,7 +2420,7 @@ gst_matroska_mux_start (GstMatroskaMux * mux)
     if (tags != NULL && !gst_tag_list_is_empty (tags)) {
       guint64 master_tags, master_tag;
 
-      GST_DEBUG ("Writing tags");
+      GST_DEBUG_OBJECT (mux, "Writing tags");
 
       /* TODO: maybe limit via the TARGETS id by looking at the source pad */
       mux->tags_pos = ebml->pos;
@@ -2331,7 +2495,7 @@ gst_matroska_mux_start (GstMatroskaMux * mux)
       child = gst_ebml_write_master_start (ebml, GST_MATROSKA_ID_TRACKENTRY);
       gst_matroska_mux_track_header (mux, collect_pad->track);
       gst_ebml_write_master_finish (ebml, child);
-      /* some remaing pad/track setup */
+      /* some remaining pad/track setup */
       collect_pad->default_duration_scaled =
           gst_util_uint64_scale (collect_pad->track->default_duration,
           1, mux->time_scale);
@@ -2458,7 +2622,7 @@ gst_matroska_mux_finish (GstMatroskaMux * mux)
   if (tags != NULL && !gst_tag_list_is_empty (tags)) {
     guint64 master_tags, master_tag;
 
-    GST_DEBUG ("Writing tags");
+    GST_DEBUG_OBJECT (mux, "Writing tags");
 
     /* TODO: maybe limit via the TARGETS id by looking at the source pad */
     mux->tags_pos = ebml->pos;
@@ -2506,16 +2670,23 @@ gst_matroska_mux_finish (GstMatroskaMux * mux)
     gst_ebml_write_seek (ebml, my_pos);
   }
 
-  /* update duration */
-  /* first get the overall duration */
-  /* a released track may have left a duration in here */
+  /* loop tracks:
+   * - first get the overall duration
+   *   (a released track may have left a duration in here)
+   * - write some track header data for subtitles
+   */
   duration = mux->duration;
+  pos = ebml->pos;
   for (collected = mux->collect->data; collected;
       collected = g_slist_next (collected)) {
     GstMatroskaPad *collect_pad;
     GstClockTime min_duration;  /* observed minimum duration */
+    GstMatroskaTrackContext *context;
+    gint voidleft = 0, fill = 0;
+    gpointer codec_id;
 
     collect_pad = (GstMatroskaPad *) collected->data;
+    context = collect_pad->track;
 
     GST_DEBUG_OBJECT (mux,
         "Pad %" GST_PTR_FORMAT " start ts %" GST_TIME_FORMAT
@@ -2537,7 +2708,41 @@ gst_matroska_mux_finish (GstMatroskaMux * mux)
     if (GST_CLOCK_TIME_IS_VALID (collect_pad->duration) &&
         duration < collect_pad->duration)
       duration = collect_pad->duration;
-  }
+
+    if (context->type != GST_MATROSKA_TRACK_TYPE_SUBTITLE || !context->pos)
+      continue;
+
+  again:
+    /* write subtitle type and possible private data */
+    gst_ebml_write_seek (ebml, context->pos);
+    /* complex way to write ascii to account for extra filling */
+    codec_id = g_malloc0 (strlen (context->codec_id) + 1 + fill);
+    strcpy (codec_id, context->codec_id);
+    gst_ebml_write_binary (ebml, GST_MATROSKA_ID_CODECID,
+        codec_id, strlen (context->codec_id) + 1 + fill);
+    g_free (codec_id);
+    if (context->codec_priv)
+      gst_ebml_write_binary (ebml, GST_MATROSKA_ID_CODECPRIVATE,
+          context->codec_priv, context->codec_priv_size);
+    voidleft = SUBTITLE_DUMMY_SIZE - (ebml->pos - context->pos);
+    /* void'ify; sigh, variable sized length field */
+    if (voidleft == 1) {
+      fill = 1;
+      goto again;
+    } else if (voidleft && voidleft <= 128)
+      gst_ebml_write_buffer_header (ebml, GST_EBML_ID_VOID, voidleft - 2);
+    else if (voidleft >= 130)
+      gst_ebml_write_buffer_header (ebml, GST_EBML_ID_VOID, voidleft - 3);
+    else if (voidleft == 129) {
+      gst_ebml_write_buffer_header (ebml, GST_EBML_ID_VOID, 64);
+      gst_ebml_write_buffer_header (ebml, GST_EBML_ID_VOID, 63);
+    }
+  }
+
+  /* seek back (optional, but do anyway) */
+  gst_ebml_write_seek (ebml, pos);
+
+  /* update duration */
   if (duration != 0) {
     GST_DEBUG_OBJECT (mux, "final total duration: %" GST_TIME_FORMAT,
         GST_TIME_ARGS (duration));
@@ -2560,77 +2765,6 @@ gst_matroska_mux_finish (GstMatroskaMux * mux)
   gst_ebml_write_master_finish (ebml, mux->segment_pos);
 }
 
-
-/**
- * gst_matroska_mux_best_pad:
- * @mux: #GstMatroskaMux
- * @popped: True if at least one buffer was popped from #GstCollectPads
- *
- * Find a pad with the oldest data
- * (data from this pad should be written first).
- *
- * Returns: Selected pad.
- */
-static GstMatroskaPad *
-gst_matroska_mux_best_pad (GstMatroskaMux * mux, gboolean * popped)
-{
-  GSList *collected;
-  GstMatroskaPad *best = NULL;
-
-  *popped = FALSE;
-  for (collected = mux->collect->data; collected;
-      collected = g_slist_next (collected)) {
-    GstMatroskaPad *collect_pad;
-
-    collect_pad = (GstMatroskaPad *) collected->data;
-    /* fetch a new buffer if needed */
-    if (collect_pad->buffer == NULL) {
-      collect_pad->buffer = gst_collect_pads_pop (mux->collect,
-          (GstCollectData *) collect_pad);
-
-      if (collect_pad->buffer != NULL) {
-        GstClockTime time;
-
-        *popped = TRUE;
-        /* convert to running time */
-        time = GST_BUFFER_TIMESTAMP (collect_pad->buffer);
-        /* invalid should pass */
-        if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (time))) {
-          time = gst_segment_to_running_time (&collect_pad->collect.segment,
-              GST_FORMAT_TIME, time);
-          if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time))) {
-            GST_DEBUG_OBJECT (mux, "clipping buffer on pad %s outside segment",
-                GST_PAD_NAME (collect_pad->collect.pad));
-            gst_buffer_unref (collect_pad->buffer);
-            collect_pad->buffer = NULL;
-            return NULL;
-          } else {
-            GST_LOG_OBJECT (mux, "buffer ts %" GST_TIME_FORMAT " -> %"
-                GST_TIME_FORMAT " running time",
-                GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (collect_pad->buffer)),
-                GST_TIME_ARGS (time));
-            collect_pad->buffer =
-                gst_buffer_make_metadata_writable (collect_pad->buffer);
-            GST_BUFFER_TIMESTAMP (collect_pad->buffer) = time;
-          }
-        }
-      }
-    }
-
-    /* if we have a buffer check if it is better then the current best one */
-    if (collect_pad->buffer != NULL) {
-      if (best == NULL || !GST_BUFFER_TIMESTAMP_IS_VALID (collect_pad->buffer)
-          || (GST_BUFFER_TIMESTAMP_IS_VALID (best->buffer)
-              && GST_BUFFER_TIMESTAMP (collect_pad->buffer) <
-              GST_BUFFER_TIMESTAMP (best->buffer))) {
-        best = collect_pad;
-      }
-    }
-  }
-
-  return best;
-}
-
 /**
  * gst_matroska_mux_buffer_header:
  * @track: Track context.
@@ -2769,10 +2903,11 @@ gst_matroska_mux_stop_streamheader (GstMatroskaMux * mux)
  * Returns: Result of the gst_pad_push issued to write the data.
  */
 static GstFlowReturn
-gst_matroska_mux_write_data (GstMatroskaMux * mux, GstMatroskaPad * collect_pad)
+gst_matroska_mux_write_data (GstMatroskaMux * mux, GstMatroskaPad * collect_pad,
+    GstBuffer * buf)
 {
   GstEbmlWrite *ebml = mux->ebml_write;
-  GstBuffer *buf, *hdr;
+  GstBuffer *hdr;
   guint64 blockgroup;
   gboolean write_duration;
   gint16 relative_timestamp;
@@ -2782,8 +2917,6 @@ gst_matroska_mux_write_data (GstMatroskaMux * mux, GstMatroskaPad * collect_pad)
   GstMatroskamuxPad *pad;
 
   /* write data */
-  buf = collect_pad->buffer;
-  collect_pad->buffer = NULL;
   pad = GST_MATROSKAMUX_PAD_CAST (collect_pad->collect.pad);
 
   /* vorbis/theora headers are retrieved from caps and put in CodecPrivate */
@@ -2972,10 +3105,9 @@ gst_matroska_mux_write_data (GstMatroskaMux * mux, GstMatroskaPad * collect_pad)
   }
 }
 
-
 /**
- * gst_matroska_mux_collected:
- * @pads: #GstCollectPads
+ * gst_matroska_mux_handle_buffer:
+ * @pads: #GstCollectPads2
  * @uuser_data: #GstMatroskaMux
  *
  * Collectpads callback.
@@ -2983,12 +3115,12 @@ gst_matroska_mux_write_data (GstMatroskaMux * mux, GstMatroskaPad * collect_pad)
  * Returns: #GstFlowReturn
  */
 static GstFlowReturn
-gst_matroska_mux_collected (GstCollectPads * pads, gpointer user_data)
+gst_matroska_mux_handle_buffer (GstCollectPads2 * pads, GstCollectData2 * data,
+    GstBuffer * buf, gpointer user_data)
 {
   GstMatroskaMux *mux = GST_MATROSKA_MUX (user_data);
   GstEbmlWrite *ebml = mux->ebml_write;
   GstMatroskaPad *best;
-  gboolean popped;
   GstFlowReturn ret = GST_FLOW_OK;
 
   GST_DEBUG_OBJECT (mux, "Collected pads");
@@ -3007,53 +3139,53 @@ gst_matroska_mux_collected (GstCollectPads * pads, gpointer user_data)
     mux->state = GST_MATROSKA_MUX_STATE_DATA;
   }
 
-  do {
-    /* which stream to write from? */
-    best = gst_matroska_mux_best_pad (mux, &popped);
+  /* provided with stream to write from */
+  best = (GstMatroskaPad *) data;
 
-    /* if there is no best pad, we have reached EOS */
-    if (best == NULL) {
-      /* buffer popped, but none returned means it was clipped */
-      if (popped)
-        break;
-      GST_DEBUG_OBJECT (mux, "No best pad finishing...");
-      if (!mux->streamable) {
-        gst_matroska_mux_finish (mux);
-      } else {
-        GST_DEBUG_OBJECT (mux, "... but streamable, nothing to finish");
-      }
-      gst_pad_push_event (mux->srcpad, gst_event_new_eos ());
-      ret = GST_FLOW_UNEXPECTED;
-      break;
-    }
-    GST_DEBUG_OBJECT (best->collect.pad, "best pad - buffer ts %"
-        GST_TIME_FORMAT " dur %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (best->buffer)),
-        GST_TIME_ARGS (GST_BUFFER_DURATION (best->buffer)));
-
-    /* make note of first and last encountered timestamps, so we can calculate
-     * the actual duration later when we send an updated header on eos */
-    if (GST_BUFFER_TIMESTAMP_IS_VALID (best->buffer)) {
-      GstClockTime start_ts = GST_BUFFER_TIMESTAMP (best->buffer);
-      GstClockTime end_ts = start_ts;
-
-      if (GST_BUFFER_DURATION_IS_VALID (best->buffer))
-        end_ts += GST_BUFFER_DURATION (best->buffer);
-      else if (best->track->default_duration)
-        end_ts += best->track->default_duration;
-
-      if (!GST_CLOCK_TIME_IS_VALID (best->end_ts) || end_ts > best->end_ts)
-        best->end_ts = end_ts;
-
-      if (G_UNLIKELY (best->start_ts == GST_CLOCK_TIME_NONE ||
-              start_ts < best->start_ts))
-        best->start_ts = start_ts;
+  /* if there is no best pad, we have reached EOS */
+  if (best == NULL) {
+    GST_DEBUG_OBJECT (mux, "No best pad finishing...");
+    if (!mux->streamable) {
+      gst_matroska_mux_finish (mux);
+    } else {
+      GST_DEBUG_OBJECT (mux, "... but streamable, nothing to finish");
     }
+    gst_pad_push_event (mux->srcpad, gst_event_new_eos ());
+    ret = GST_FLOW_UNEXPECTED;
+    goto exit;
+  }
+
+  /* if we have a best stream, should also have a buffer */
+  g_assert (buf);
+
+  GST_DEBUG_OBJECT (best->collect.pad, "best pad - buffer ts %"
+      GST_TIME_FORMAT " dur %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+      GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
+
+  /* make note of first and last encountered timestamps, so we can calculate
+   * the actual duration later when we send an updated header on eos */
+  if (GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
+    GstClockTime start_ts = GST_BUFFER_TIMESTAMP (buf);
+    GstClockTime end_ts = start_ts;
+
+    if (GST_BUFFER_DURATION_IS_VALID (buf))
+      end_ts += GST_BUFFER_DURATION (buf);
+    else if (best->track->default_duration)
+      end_ts += best->track->default_duration;
+
+    if (!GST_CLOCK_TIME_IS_VALID (best->end_ts) || end_ts > best->end_ts)
+      best->end_ts = end_ts;
+
+    if (G_UNLIKELY (best->start_ts == GST_CLOCK_TIME_NONE ||
+            start_ts < best->start_ts))
+      best->start_ts = start_ts;
+  }
 
-    /* write one buffer */
-    ret = gst_matroska_mux_write_data (mux, best);
-  } while (ret == GST_FLOW_OK && !popped);
+  /* write one buffer */
+  ret = gst_matroska_mux_write_data (mux, best, buf);
 
+exit:
   return ret;
 }
 
@@ -3077,12 +3209,12 @@ gst_matroska_mux_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_NULL_TO_READY:
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (mux->collect);
+      gst_collect_pads2_start (mux->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_collect_pads_stop (mux->collect);
+      gst_collect_pads2_stop (mux->collect);
       break;
     default:
       break;
diff --git a/gst/matroska/matroska-mux.h b/gst/matroska/matroska-mux.h
index 73bdc09..6eb584d 100644
--- a/gst/matroska/matroska-mux.h
+++ b/gst/matroska/matroska-mux.h
@@ -24,7 +24,7 @@
 #define __GST_MATROSKA_MUX_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 #include "ebml-write.h"
 #include "matroska-ids.h"
@@ -56,11 +56,9 @@ typedef struct _GstMatroskaMetaSeekIndex {
 /* all information needed for one matroska stream */
 typedef struct
 {
-  GstCollectData collect;       /* we extend the CollectData */
+  GstCollectData2 collect;       /* we extend the CollectData */
   GstMatroskaTrackContext *track;
 
-  GstBuffer *buffer;            /* the queued buffer for this pad */
-
   guint64 duration;
   GstClockTime start_ts;
   GstClockTime end_ts;    /* last timestamp + (if available) duration */
@@ -76,8 +74,7 @@ typedef struct _GstMatroskaMux {
 
   /* pads */
   GstPad        *srcpad;
-  GstCollectPads *collect;
-  GstPadEventFunction collect_event;
+  GstCollectPads2 *collect;
   GstEbmlWrite *ebml_write;
 
   guint          num_streams,
diff --git a/gst/multipart/multipartmux.c b/gst/multipart/multipartmux.c
index 9d3e56a..0417b76 100644
--- a/gst/multipart/multipartmux.c
+++ b/gst/multipart/multipartmux.c
@@ -88,7 +88,7 @@ static GstPad *gst_multipart_mux_request_new_pad (GstElement * element,
 static GstStateChangeReturn gst_multipart_mux_change_state (GstElement *
     element, GstStateChange transition);
 
-static GstFlowReturn gst_multipart_mux_collected (GstCollectPads * pads,
+static GstFlowReturn gst_multipart_mux_collected (GstCollectPads2 * pads,
     GstMultipartMux * mux);
 
 static void gst_multipart_mux_set_property (GObject * object, guint prop_id,
@@ -180,9 +180,9 @@ gst_multipart_mux_init (GstMultipartMux * multipart_mux)
 
   multipart_mux->boundary = g_strdup (DEFAULT_BOUNDARY);
 
-  multipart_mux->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (multipart_mux->collect,
-      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (gst_multipart_mux_collected),
+  multipart_mux->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (multipart_mux->collect,
+      (GstCollectPads2Function) GST_DEBUG_FUNCPTR (gst_multipart_mux_collected),
       multipart_mux);
 }
 
@@ -226,7 +226,7 @@ gst_multipart_mux_request_new_pad (GstElement * element,
     GstMultipartPadData *multipartpad;
 
     multipartpad = (GstMultipartPadData *)
-        gst_collect_pads_add_pad (multipart_mux->collect, newpad,
+        gst_collect_pads2_add_pad (multipart_mux->collect, newpad,
         sizeof (GstMultipartPadData));
 
     /* save a pointer to our data in the pad */
@@ -375,7 +375,7 @@ gst_multipart_mux_queue_pads (GstMultipartMux * mux)
   /* try to make sure we have a buffer from each usable pad first */
   walk = mux->collect->data;
   while (walk) {
-    GstCollectData *data = (GstCollectData *) walk->data;
+    GstCollectData2 *data = (GstCollectData2 *) walk->data;
     GstMultipartPadData *pad = (GstMultipartPadData *) data;
 
     walk = g_slist_next (walk);
@@ -384,7 +384,7 @@ gst_multipart_mux_queue_pads (GstMultipartMux * mux)
     if (pad->buffer == NULL) {
       GstBuffer *buf = NULL;
 
-      buf = gst_collect_pads_pop (mux->collect, data);
+      buf = gst_collect_pads2_pop (mux->collect, data);
 
       /* Store timestamp with segment_start and preroll */
       if (buf && GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
@@ -418,7 +418,7 @@ gst_multipart_mux_queue_pads (GstMultipartMux * mux)
  * 3) push both buffers on best pad, go to 1
  */
 static GstFlowReturn
-gst_multipart_mux_collected (GstCollectPads * pads, GstMultipartMux * mux)
+gst_multipart_mux_collected (GstCollectPads2 * pads, GstMultipartMux * mux)
 {
   GstMultipartPadData *best;
   GstFlowReturn ret = GST_FLOW_OK;
@@ -648,11 +648,11 @@ gst_multipart_mux_change_state (GstElement * element, GstStateChange transition)
       multipart_mux->negotiated = FALSE;
       multipart_mux->need_segment = TRUE;
       GST_DEBUG_OBJECT (multipart_mux, "starting collect pads");
-      gst_collect_pads_start (multipart_mux->collect);
+      gst_collect_pads2_start (multipart_mux->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
       GST_DEBUG_OBJECT (multipart_mux, "stopping collect pads");
-      gst_collect_pads_stop (multipart_mux->collect);
+      gst_collect_pads2_stop (multipart_mux->collect);
       break;
     default:
       break;
diff --git a/gst/multipart/multipartmux.h b/gst/multipart/multipartmux.h
index a52db36..1ea2d8a 100644
--- a/gst/multipart/multipartmux.h
+++ b/gst/multipart/multipartmux.h
@@ -23,7 +23,7 @@
 #define __GST_MULTIPART_MUX__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 #include <string.h>
 
@@ -42,7 +42,7 @@ typedef struct _GstMultipartMuxClass GstMultipartMuxClass;
 /* all information needed for one multipart stream */
 typedef struct
 {
-  GstCollectData collect;       /* we extend the CollectData */
+  GstCollectData2 collect;       /* we extend the CollectData2 */
 
   GstBuffer *buffer;            /* the queued buffer for this pad */
   GstClockTime timestamp;       /* its timestamp, converted to running_time so that we can
@@ -63,7 +63,7 @@ struct _GstMultipartMux
   GstPad *srcpad;
 
   /* sinkpads */
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
 
   gint numpads;
 
diff --git a/gst/rtp/gstrtpdvdepay.c b/gst/rtp/gstrtpdvdepay.c
index 4098c39..43e6aa1 100644
--- a/gst/rtp/gstrtpdvdepay.c
+++ b/gst/rtp/gstrtpdvdepay.c
@@ -336,12 +336,14 @@ gst_rtp_dv_depay_process (GstBaseRTPDepayload * base, GstBuffer * in)
       GST_LOG_OBJECT (dvdepay, "got block at location %d", location);
     }
 
-    /* get the byte offset of the dif block */
-    offset = location * 80;
+    if (location != -1) {
+      /* get the byte offset of the dif block */
+      offset = location * 80;
 
-    /* And copy it in, provided the location is sane. */
-    if (offset >= 0 && offset <= dvdepay->frame_size - 80)
-      memcpy (GST_BUFFER_DATA (dvdepay->acc) + offset, payload, 80);
+      /* And copy it in, provided the location is sane. */
+      if (offset <= dvdepay->frame_size - 80)
+        memcpy (GST_BUFFER_DATA (dvdepay->acc) + offset, payload, 80);
+    }
 
     payload += 80;
     payload_len -= 80;
diff --git a/gst/rtp/gstrtph264depay.c b/gst/rtp/gstrtph264depay.c
index efe1725..1a92dd2 100644
--- a/gst/rtp/gstrtph264depay.c
+++ b/gst/rtp/gstrtph264depay.c
@@ -24,6 +24,7 @@
 #include <stdio.h>
 #include <string.h>
 
+#include <gst/base/gstbitreader.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include "gstrtph264depay.h"
 
@@ -46,10 +47,13 @@ enum
 static const guint8 sync_bytes[] = { 0, 0, 0, 1 };
 
 static GstStaticPadTemplate gst_rtp_h264_depay_src_template =
-GST_STATIC_PAD_TEMPLATE ("src",
+    GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("video/x-h264")
+    GST_STATIC_CAPS ("video/x-h264, "
+        "stream-format = (string) avc, alignment = (string) au; "
+        "video/x-h264, "
+        "stream-format = (string) byte-stream, alignment = (string) { nal, au }")
     );
 
 static GstStaticPadTemplate gst_rtp_h264_depay_sink_template =
@@ -157,6 +161,10 @@ gst_rtp_h264_depay_init (GstRtpH264Depay * rtph264depay,
   rtph264depay->picture_adapter = gst_adapter_new ();
   rtph264depay->byte_stream = DEFAULT_BYTE_STREAM;
   rtph264depay->merge = DEFAULT_ACCESS_UNIT;
+  rtph264depay->sps = g_ptr_array_new_with_free_func (
+      (GDestroyNotify) gst_buffer_unref);
+  rtph264depay->pps = g_ptr_array_new_with_free_func (
+      (GDestroyNotify) gst_buffer_unref);
 }
 
 static void
@@ -169,6 +177,9 @@ gst_rtp_h264_depay_reset (GstRtpH264Depay * rtph264depay)
   rtph264depay->last_keyframe = FALSE;
   rtph264depay->last_ts = 0;
   rtph264depay->current_fu_type = 0;
+  rtph264depay->new_codec_data = FALSE;
+  g_ptr_array_set_size (rtph264depay->sps, 0);
+  g_ptr_array_set_size (rtph264depay->pps, 0);
 }
 
 static void
@@ -184,6 +195,9 @@ gst_rtp_h264_depay_finalize (GObject * object)
   g_object_unref (rtph264depay->adapter);
   g_object_unref (rtph264depay->picture_adapter);
 
+  g_ptr_array_free (rtph264depay->sps, TRUE);
+  g_ptr_array_free (rtph264depay->pps, TRUE);
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -288,17 +302,261 @@ gst_rtp_h264_depay_negotiate (GstRtpH264Depay * rtph264depay)
   }
 }
 
+/* Stolen from bad/gst/mpegtsdemux/payloader_parsers.c */
+/* variable length Exp-Golomb parsing according to H.264 spec 9.1*/
 static gboolean
-gst_rtp_h264_depay_setcaps (GstBaseRTPDepayload * depayload, GstCaps * caps)
+read_golomb (GstBitReader * br, guint32 * value)
+{
+  guint8 b, leading_zeros = -1;
+  *value = 1;
+
+  for (b = 0; !b; leading_zeros++) {
+    if (!gst_bit_reader_get_bits_uint8 (br, &b, 1))
+      return FALSE;
+    *value *= 2;
+  }
+
+  *value = (*value >> 1) - 1;
+  if (leading_zeros > 0) {
+    guint32 tmp = 0;
+    if (!gst_bit_reader_get_bits_uint32 (br, &tmp, leading_zeros))
+      return FALSE;
+    *value += tmp;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+parse_sps (GstBuffer * nal, guint32 * sps_id)
+{
+  GstBitReader br = GST_BIT_READER_INIT (GST_BUFFER_DATA (nal) + 4,
+      GST_BUFFER_SIZE (nal) - 4);
+
+  if (GST_BUFFER_SIZE (nal) < 5)
+    return FALSE;
+
+  if (!read_golomb (&br, sps_id))
+    return FALSE;
+
+  return TRUE;
+}
+
+static gboolean
+parse_pps (GstBuffer * nal, guint32 * sps_id, guint32 * pps_id)
+{
+  GstBitReader br = GST_BIT_READER_INIT (GST_BUFFER_DATA (nal) + 1,
+      GST_BUFFER_SIZE (nal) - 1);
+
+  if (GST_BUFFER_SIZE (nal) < 2)
+    return FALSE;
+
+  if (!read_golomb (&br, pps_id))
+    return FALSE;
+  if (!read_golomb (&br, sps_id))
+    return FALSE;
+
+  return TRUE;
+}
+
+static gboolean
+gst_rtp_h264_set_src_caps (GstRtpH264Depay * rtph264depay)
 {
+  gboolean res;
   GstCaps *srccaps;
+  guchar level = 0;
+  guchar profile_compat = G_MAXUINT8;
+
+  if (!rtph264depay->byte_stream &&
+      (!rtph264depay->new_codec_data ||
+          rtph264depay->sps->len == 0 || rtph264depay->pps->len == 0))
+    return TRUE;
+
+  srccaps = gst_caps_new_simple ("video/x-h264",
+      "stream-format", G_TYPE_STRING,
+      rtph264depay->byte_stream ? "byte-stream" : "avc",
+      "alignment", G_TYPE_STRING, rtph264depay->merge ? "au" : "nal", NULL);
+
+  if (!rtph264depay->byte_stream) {
+    GstBuffer *codec_data;
+    guchar *data;
+    guint len;
+    guint i;
+
+    /* start with 7 bytes header */
+    len = 7;
+    /* count sps & pps */
+    for (i = 0; i < rtph264depay->sps->len; i++)
+      len += 2 + GST_BUFFER_SIZE (g_ptr_array_index (rtph264depay->sps, i));
+    for (i = 0; i < rtph264depay->pps->len; i++)
+      len += 2 + GST_BUFFER_SIZE (g_ptr_array_index (rtph264depay->pps, i));
+
+    codec_data = gst_buffer_new_and_alloc (len);
+    g_debug ("alloc_len: %u", len);
+    data = GST_BUFFER_DATA (codec_data);
+
+    /* 8 bits version == 1 */
+    *data++ = 1;
+
+    /* According to: ISO/IEC 14496-15:2004(E) section 5.2.4.1
+     * The level is the max level of all SPSes
+     * A profile compat bit can only be set if all SPSes include that bit
+     */
+    for (i = 0; i < rtph264depay->sps->len; i++) {
+      guchar *nal = GST_BUFFER_DATA (g_ptr_array_index (rtph264depay->sps, i));
+
+      profile_compat &= nal[2];
+      level = MAX (level, nal[3]);
+    }
+
+    /* Assume all SPSes use the same profile, so extract from the first SPS */
+    *data++ = GST_BUFFER_DATA (g_ptr_array_index (rtph264depay->sps, 0))[1];
+    *data++ = profile_compat;
+    *data++ = level;
+
+    /* 6 bits reserved | 2 bits lengthSizeMinusOn */
+    *data++ = 0xff;
+    /* 3 bits reserved | 5 bits numOfSequenceParameterSets */
+    *data++ = 0xe0 | (rtph264depay->sps->len & 0x1f);
+
+    /* copy all SPS */
+    for (i = 0; i < rtph264depay->sps->len; i++) {
+      GstBuffer *sps = g_ptr_array_index (rtph264depay->sps, i);
+
+      GST_DEBUG_OBJECT (rtph264depay, "copy SPS %d of length %d", i,
+          GST_BUFFER_SIZE (sps));
+      GST_WRITE_UINT16_BE (data, GST_BUFFER_SIZE (sps));
+      data += 2;
+      memcpy (data, GST_BUFFER_DATA (sps), GST_BUFFER_SIZE (sps));
+      data += GST_BUFFER_SIZE (sps);
+    }
+
+    /* 8 bits numOfPictureParameterSets */
+    *data++ = rtph264depay->pps->len;
+    /* copy all PPS */
+    for (i = 0; i < rtph264depay->pps->len; i++) {
+      GstBuffer *pps = g_ptr_array_index (rtph264depay->pps, i);
+
+      GST_DEBUG_OBJECT (rtph264depay, "copy PPS %d of length %d", i,
+          GST_BUFFER_SIZE (pps));
+      GST_WRITE_UINT16_BE (data, GST_BUFFER_SIZE (pps));
+      data += 2;
+      memcpy (data, GST_BUFFER_DATA (pps), GST_BUFFER_SIZE (pps));
+      data += GST_BUFFER_SIZE (pps);
+    }
+
+    GST_BUFFER_SIZE (codec_data) = data - GST_BUFFER_DATA (codec_data);
+
+    gst_caps_set_simple (srccaps,
+        "codec_data", GST_TYPE_BUFFER, codec_data, NULL);
+    gst_buffer_unref (codec_data);
+  }
+
+  res = gst_pad_set_caps (GST_BASE_RTP_DEPAYLOAD_SRCPAD (rtph264depay),
+      srccaps);
+  gst_caps_unref (srccaps);
+
+  if (res)
+    rtph264depay->new_codec_data = FALSE;
+
+  return res;
+}
+
+static gboolean
+gst_rtp_h264_add_sps_pps (GstRtpH264Depay * rtph264depay, GstBuffer * nal)
+{
+  guchar type = GST_BUFFER_DATA (nal)[0] & 0x1f;
+  guint i;
+
+  if (type == 7) {
+    guint32 sps_id;
+
+    if (!parse_sps (nal, &sps_id)) {
+      GST_WARNING_OBJECT (rtph264depay, "Invalid SPS,"
+          " can't parse seq_parameter_set_id");
+      goto drop;
+    }
+
+    for (i = 0; i < rtph264depay->sps->len; i++) {
+      GstBuffer *sps = g_ptr_array_index (rtph264depay->sps, i);
+      guint32 tmp_sps_id;
+
+      parse_sps (sps, &tmp_sps_id);
+      if (sps_id == tmp_sps_id) {
+        if (GST_BUFFER_SIZE (nal) == GST_BUFFER_SIZE (sps) &&
+            memcmp (GST_BUFFER_DATA (nal), GST_BUFFER_DATA (sps),
+                GST_BUFFER_SIZE (sps)) == 0) {
+          GST_LOG_OBJECT (rtph264depay, "Unchanged SPS %u, not updating",
+              sps_id);
+          goto drop;
+        } else {
+          g_ptr_array_remove_index_fast (rtph264depay->sps, i);
+          g_ptr_array_add (rtph264depay->sps, nal);
+          GST_LOG_OBJECT (rtph264depay, "Modified SPS %u, replacing", sps_id);
+          goto done;
+        }
+      }
+    }
+    GST_LOG_OBJECT (rtph264depay, "Adding new SPS %u", sps_id);
+    g_ptr_array_add (rtph264depay->sps, nal);
+  } else if (type == 8) {
+    guint32 sps_id;
+    guint32 pps_id;
+
+    if (!parse_pps (nal, &sps_id, &pps_id)) {
+      GST_WARNING_OBJECT (rtph264depay, "Invalid PPS,"
+          " can't parse seq_parameter_set_id or pic_parameter_set_id");
+      goto drop;
+    }
+
+    for (i = 0; i < rtph264depay->pps->len; i++) {
+      GstBuffer *pps = g_ptr_array_index (rtph264depay->pps, i);
+      guint32 tmp_sps_id;
+      guint32 tmp_pps_id;
+
+      parse_pps (pps, &tmp_sps_id, &tmp_pps_id);
+      if (sps_id == tmp_sps_id && pps_id == tmp_pps_id) {
+        if (GST_BUFFER_SIZE (nal) == GST_BUFFER_SIZE (pps) &&
+            memcmp (GST_BUFFER_DATA (nal), GST_BUFFER_DATA (pps),
+                GST_BUFFER_SIZE (pps)) == 0) {
+          GST_LOG_OBJECT (rtph264depay, "Unchanged PPS %u:%u, not updating",
+              sps_id, pps_id);
+          goto drop;
+        } else {
+          g_ptr_array_remove_index_fast (rtph264depay->pps, i);
+          g_ptr_array_add (rtph264depay->pps, nal);
+          GST_LOG_OBJECT (rtph264depay, "Modified PPS %u:%u, replacing",
+              sps_id, pps_id);
+          goto done;
+        }
+      }
+    }
+    GST_LOG_OBJECT (rtph264depay, "Adding new PPS %u:%i", sps_id, pps_id);
+    g_ptr_array_add (rtph264depay->pps, nal);
+  } else {
+    goto drop;
+  }
+
+done:
+  rtph264depay->new_codec_data = TRUE;
+
+  return TRUE;
+
+drop:
+  gst_buffer_unref (nal);
+
+  return FALSE;
+}
+
+static gboolean
+gst_rtp_h264_depay_setcaps (GstBaseRTPDepayload * depayload, GstCaps * caps)
+{
   gint clock_rate;
   GstStructure *structure = gst_caps_get_structure (caps, 0);
   GstRtpH264Depay *rtph264depay;
-  const gchar *ps, *profile;
+  const gchar *ps;
   GstBuffer *codec_data;
   guint8 *b64;
-  gboolean res;
 
   rtph264depay = GST_RTP_H264_DEPAY (depayload);
 
@@ -306,12 +564,8 @@ gst_rtp_h264_depay_setcaps (GstBaseRTPDepayload * depayload, GstCaps * caps)
     clock_rate = 90000;
   depayload->clock_rate = clock_rate;
 
-  srccaps = gst_caps_new_simple ("video/x-h264", NULL);
-
   /* Base64 encoded, comma separated config NALs */
   ps = gst_structure_get_string (structure, "sprop-parameter-sets");
-  /* hex: AVCProfileIndication:8 | profile_compat:8 | AVCLevelIndication:8 */
-  profile = gst_structure_get_string (structure, "profile-level-id");
 
   /* negotiate with downstream w.r.t. output format and alignment */
   gst_rtp_h264_depay_negotiate (rtph264depay);
@@ -361,123 +615,51 @@ gst_rtp_h264_depay_setcaps (GstBaseRTPDepayload * depayload, GstCaps * caps)
     rtph264depay->codec_data = codec_data;
   } else if (!rtph264depay->byte_stream) {
     gchar **params;
-    guint8 **sps, **pps;
-    guint len, num_sps, num_pps;
     gint i;
-    guint8 *data;
 
     if (ps == NULL)
       goto incomplete_caps;
 
     params = g_strsplit (ps, ",", 0);
-    len = g_strv_length (params);
-
-    GST_DEBUG_OBJECT (depayload, "we have %d params", len);
 
-    sps = g_new0 (guint8 *, len + 1);
-    pps = g_new0 (guint8 *, len + 1);
-    num_sps = num_pps = 0;
+    GST_DEBUG_OBJECT (depayload, "we have %d params", g_strv_length (params));
 
     /* start with 7 bytes header */
-    len = 7;
     for (i = 0; params[i]; i++) {
+      GstBuffer *nal;
       gsize nal_len;
-      guint8 *nalp;
       guint save = 0;
       gint state = 0;
 
       nal_len = strlen (params[i]);
-      nalp = g_malloc (nal_len + 2);
+      nal = gst_buffer_new_and_alloc (nal_len);
 
       nal_len =
-          g_base64_decode_step (params[i], nal_len, nalp + 2, &state, &save);
-      nalp[0] = (nal_len >> 8) & 0xff;
-      nalp[1] = nal_len & 0xff;
-      len += nal_len + 2;
-
-      /* copy to the right list */
-      if ((nalp[2] & 0x1f) == 7) {
-        GST_DEBUG_OBJECT (depayload, "adding param %d as SPS %d", i, num_sps);
-        sps[num_sps++] = nalp;
-      } else {
-        GST_DEBUG_OBJECT (depayload, "adding param %d as PPS %d", i, num_pps);
-        pps[num_pps++] = nalp;
-      }
-    }
-    g_strfreev (params);
+          g_base64_decode_step (params[i], nal_len, GST_BUFFER_DATA (nal),
+          &state, &save);
 
-    if (num_sps == 0 || (GST_READ_UINT16_BE (sps[0]) < 3) || num_pps == 0) {
-      g_strfreev ((gchar **) pps);
-      g_strfreev ((gchar **) sps);
-      goto incomplete_caps;
-    }
+      GST_BUFFER_SIZE (nal) = nal_len;
 
-    codec_data = gst_buffer_new_and_alloc (len);
-    data = GST_BUFFER_DATA (codec_data);
+      GST_DEBUG_OBJECT (depayload, "adding param %d as %s", i,
+          ((GST_BUFFER_DATA (nal)[0] & 0x1f) == 7) ? "SPS" : "PPS");
 
-    /* 8 bits version == 1 */
-    *data++ = 1;
-    if (profile) {
-      guint32 profile_id;
-
-      /* hex: AVCProfileIndication:8 | profile_compat:8 | AVCLevelIndication:8 */
-      sscanf (profile, "%6x", &profile_id);
-      *data++ = (profile_id >> 16) & 0xff;
-      *data++ = (profile_id >> 8) & 0xff;
-      *data++ = profile_id & 0xff;
-    } else {
-      /* extract from SPS */
-      *data++ = sps[0][3];
-      *data++ = sps[0][4];
-      *data++ = sps[0][5];
+      gst_rtp_h264_add_sps_pps (rtph264depay, nal);
     }
-    /* 6 bits reserved | 2 bits lengthSizeMinusOn */
-    *data++ = 0xff;
-    /* 3 bits reserved | 5 bits numOfSequenceParameterSets */
-    *data++ = 0xe0 | (num_sps & 0x1f);
+    g_strfreev (params);
 
-    /* copy all SPS */
-    for (i = 0; sps[i]; i++) {
-      len = ((sps[i][0] << 8) | sps[i][1]) + 2;
-      GST_DEBUG_OBJECT (depayload, "copy SPS %d of length %d", i, len);
-      memcpy (data, sps[i], len);
-      g_free (sps[i]);
-      data += len;
-    }
-    g_free (sps);
-    /* 8 bits numOfPictureParameterSets */
-    *data++ = num_pps;
-    /* copy all PPS */
-    for (i = 0; pps[i]; i++) {
-      len = ((pps[i][0] << 8) | pps[i][1]) + 2;
-      GST_DEBUG_OBJECT (depayload, "copy PPS %d of length %d", i, len);
-      memcpy (data, pps[i], len);
-      g_free (pps[i]);
-      data += len;
-    }
-    g_free (pps);
-    GST_BUFFER_SIZE (codec_data) = data - GST_BUFFER_DATA (codec_data);
+    if (rtph264depay->sps->len == 0 || rtph264depay->pps->len == 0)
+      goto incomplete_caps;
 
-    gst_caps_set_simple (srccaps,
-        "codec_data", GST_TYPE_BUFFER, codec_data, NULL);
-    gst_buffer_unref (codec_data);
   }
 
-  gst_caps_set_simple (srccaps, "stream-format", G_TYPE_STRING,
-      rtph264depay->byte_stream ? "byte-stream" : "avc",
-      "alignment", G_TYPE_STRING, rtph264depay->merge ? "au" : "nal", NULL);
-
-  res = gst_pad_set_caps (depayload->srcpad, srccaps);
-  gst_caps_unref (srccaps);
-
-  return res;
+  return gst_rtp_h264_set_src_caps (rtph264depay);
 
   /* ERRORS */
 incomplete_caps:
   {
-    GST_DEBUG_OBJECT (depayload, "we have incomplete caps");
-    gst_caps_unref (srccaps);
-    return FALSE;
+    GST_DEBUG_OBJECT (depayload, "we have incomplete caps,"
+        " doing setcaps later");
+    return TRUE;
   }
 }
 
@@ -532,6 +714,30 @@ gst_rtp_h264_depay_handle_nal (GstRtpH264Depay * rtph264depay, GstBuffer * nal,
   out_keyframe = keyframe;
   out_timestamp = in_timestamp;
 
+  if (!rtph264depay->byte_stream) {
+    if (nal_type == 7 || nal_type == 8) {
+      gst_rtp_h264_add_sps_pps (rtph264depay, gst_buffer_create_sub (nal, 4,
+              GST_BUFFER_SIZE (nal) - 4));
+      gst_buffer_unref (nal);
+      return NULL;
+    } else if (rtph264depay->sps->len == 0 || rtph264depay->pps->len == 0) {
+      /* Down push down any buffer in non-bytestream mode if the SPS/PPS haven't
+       * go through yet
+       */
+      gst_pad_push_event (GST_BASE_RTP_DEPAYLOAD_SINKPAD (depayload),
+          gst_event_new_custom (GST_EVENT_CUSTOM_UPSTREAM,
+              gst_structure_new ("GstForceKeyUnit",
+                  "all-headers", G_TYPE_BOOLEAN, TRUE, NULL)));
+      gst_buffer_unref (nal);
+      return FALSE;
+    }
+
+    if (rtph264depay->new_codec_data &&
+        rtph264depay->sps->len > 0 && rtph264depay->pps->len > 0)
+      gst_rtp_h264_set_src_caps (rtph264depay);
+  }
+
+
   if (rtph264depay->merge) {
     gboolean start = FALSE, complete = FALSE;
 
diff --git a/gst/rtp/gstrtph264depay.h b/gst/rtp/gstrtph264depay.h
index f50ffe6..fd2603f 100644
--- a/gst/rtp/gstrtph264depay.h
+++ b/gst/rtp/gstrtph264depay.h
@@ -61,6 +61,11 @@ struct _GstRtpH264Depay
   guint8 current_fu_type;
   GstClockTime fu_timestamp;
   gboolean fu_marker;
+
+  /* misc */
+  GPtrArray *sps;
+  GPtrArray *pps;
+  gboolean new_codec_data;
 };
 
 struct _GstRtpH264DepayClass
diff --git a/gst/rtp/gstrtph264pay.c b/gst/rtp/gstrtph264pay.c
index 1d0721e..87c9b7e 100644
--- a/gst/rtp/gstrtph264pay.c
+++ b/gst/rtp/gstrtph264pay.c
@@ -45,10 +45,13 @@ GST_DEBUG_CATEGORY_STATIC (rtph264pay_debug);
  */
 
 static GstStaticPadTemplate gst_rtp_h264_pay_sink_template =
-GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("video/x-h264")
+    GST_STATIC_CAPS ("video/x-h264, "
+        "stream-format = (string) byte-stream, alignment = (string) { nal, au };"
+        "video/x-h264, "
+        "stream-format = (string) avc, alignment = (string) au")
     );
 
 static GstStaticPadTemplate gst_rtp_h264_pay_src_template =
@@ -271,108 +274,120 @@ static const gchar *all_levels[] = {
 static GstCaps *
 gst_rtp_h264_pay_getcaps (GstBaseRTPPayload * payload, GstPad * pad)
 {
+  GstCaps *template_caps;
   GstCaps *allowed_caps;
+  GstCaps *caps, *icaps;
+  guint i;
 
   allowed_caps =
       gst_pad_peer_get_caps_reffed (GST_BASE_RTP_PAYLOAD_SRCPAD (payload));
 
-  if (allowed_caps) {
-    GstCaps *caps = NULL;
-    guint i;
+  if (allowed_caps == NULL)
+    return NULL;
 
-    if (gst_caps_is_any (allowed_caps)) {
-      gst_caps_unref (allowed_caps);
-      goto any;
-    }
+  template_caps =
+      gst_static_pad_template_get_caps (&gst_rtp_h264_pay_sink_template);
 
-    if (gst_caps_is_empty (allowed_caps))
-      return allowed_caps;
+  if (gst_caps_is_any (allowed_caps)) {
+    caps = gst_caps_ref (template_caps);
+    goto done;
+  }
 
-    caps = gst_caps_new_empty ();
+  if (gst_caps_is_empty (allowed_caps)) {
+    caps = gst_caps_ref (allowed_caps);
+    goto done;
+  }
 
-    for (i = 0; i < gst_caps_get_size (allowed_caps); i++) {
-      GstStructure *s = gst_caps_get_structure (allowed_caps, i);
-      GstStructure *new_s = gst_structure_new ("video/x-h264", NULL);
-      const gchar *profile_level_id;
+  caps = gst_caps_new_empty ();
 
-      profile_level_id = gst_structure_get_string (s, "profile-level-id");
+  for (i = 0; i < gst_caps_get_size (allowed_caps); i++) {
+    GstStructure *s = gst_caps_get_structure (allowed_caps, i);
+    GstStructure *new_s = gst_structure_new ("video/x-h264", NULL);
+    const gchar *profile_level_id;
 
-      if (profile_level_id && strlen (profile_level_id) == 6) {
-        const gchar *profile;
-        const gchar *level;
-        long int spsint;
-        guint8 sps[3];
+    profile_level_id = gst_structure_get_string (s, "profile-level-id");
 
-        spsint = strtol (profile_level_id, NULL, 16);
-        sps[0] = spsint >> 16;
-        sps[1] = spsint >> 8;
-        sps[2] = spsint;
+    if (profile_level_id && strlen (profile_level_id) == 6) {
+      const gchar *profile;
+      const gchar *level;
+      long int spsint;
+      guint8 sps[3];
 
-        profile = gst_codec_utils_h264_get_profile (sps, 3);
-        level = gst_codec_utils_h264_get_level (sps, 3);
+      spsint = strtol (profile_level_id, NULL, 16);
+      sps[0] = spsint >> 16;
+      sps[1] = spsint >> 8;
+      sps[2] = spsint;
 
-        if (profile && level) {
-          GST_LOG_OBJECT (payload, "In caps, have profile %s and level %s",
-              profile, level);
+      profile = gst_codec_utils_h264_get_profile (sps, 3);
+      level = gst_codec_utils_h264_get_level (sps, 3);
 
-          if (!strcmp (profile, "constrained-baseline"))
-            gst_structure_set (new_s, "profile", G_TYPE_STRING, profile, NULL);
-          else {
-            GValue val = { 0, };
-            GValue profiles = { 0, };
+      if (profile && level) {
+        GST_LOG_OBJECT (payload, "In caps, have profile %s and level %s",
+            profile, level);
 
-            g_value_init (&profiles, GST_TYPE_LIST);
-            g_value_init (&val, G_TYPE_STRING);
+        if (!strcmp (profile, "constrained-baseline"))
+          gst_structure_set (new_s, "profile", G_TYPE_STRING, profile, NULL);
+        else {
+          GValue val = { 0, };
+          GValue profiles = { 0, };
 
-            g_value_set_static_string (&val, profile);
-            gst_value_list_append_value (&profiles, &val);
+          g_value_init (&profiles, GST_TYPE_LIST);
+          g_value_init (&val, G_TYPE_STRING);
 
-            g_value_set_static_string (&val, "constrained-baseline");
-            gst_value_list_append_value (&profiles, &val);
+          g_value_set_static_string (&val, profile);
+          gst_value_list_append_value (&profiles, &val);
 
-            gst_structure_take_value (new_s, "profile", &profiles);
-          }
+          g_value_set_static_string (&val, "constrained-baseline");
+          gst_value_list_append_value (&profiles, &val);
 
-          if (!strcmp (level, "1"))
-            gst_structure_set (new_s, "level", G_TYPE_STRING, level, NULL);
-          else {
-            GValue levels = { 0, };
-            GValue val = { 0, };
-            int j;
-
-            g_value_init (&levels, GST_TYPE_LIST);
-            g_value_init (&val, G_TYPE_STRING);
-
-            for (j = 0; all_levels[j]; j++) {
-              g_value_set_static_string (&val, all_levels[j]);
-              gst_value_list_prepend_value (&levels, &val);
-              if (!strcmp (level, all_levels[j]))
-                break;
-            }
-            gst_structure_take_value (new_s, "level", &levels);
-          }
-        } else {
-          /* Invalid profile-level-id means baseline */
+          gst_structure_take_value (new_s, "profile", &profiles);
+        }
 
-          gst_structure_set (new_s,
-              "profile", G_TYPE_STRING, "constrained-baseline", NULL);
+        if (!strcmp (level, "1"))
+          gst_structure_set (new_s, "level", G_TYPE_STRING, level, NULL);
+        else {
+          GValue levels = { 0, };
+          GValue val = { 0, };
+          int j;
+
+          g_value_init (&levels, GST_TYPE_LIST);
+          g_value_init (&val, G_TYPE_STRING);
+
+          for (j = 0; all_levels[j]; j++) {
+            g_value_set_static_string (&val, all_levels[j]);
+            gst_value_list_prepend_value (&levels, &val);
+            if (!strcmp (level, all_levels[j]))
+              break;
+          }
+          gst_structure_take_value (new_s, "level", &levels);
         }
       } else {
-        /* No profile-level-id also means baseline */
+        /* Invalid profile-level-id means baseline */
 
         gst_structure_set (new_s,
             "profile", G_TYPE_STRING, "constrained-baseline", NULL);
       }
+    } else {
+      /* No profile-level-id also means baseline */
 
-      gst_caps_merge_structure (caps, new_s);
+      gst_structure_set (new_s,
+          "profile", G_TYPE_STRING, "constrained-baseline", NULL);
     }
 
-    gst_caps_unref (allowed_caps);
-    return caps;
+    gst_caps_merge_structure (caps, new_s);
   }
 
-any:
-  return gst_caps_new_simple ("video/x-h264", NULL);
+  icaps = gst_caps_intersect (caps, template_caps);
+  gst_caps_unref (caps);
+  caps = icaps;
+
+done:
+
+  gst_caps_unref (template_caps);
+  gst_caps_unref (allowed_caps);
+
+  GST_LOG_OBJECT (payload, "returning caps %" GST_PTR_FORMAT, caps);
+  return caps;
 }
 
 /* take the currently configured SPS and PPS lists and set them on the caps as
diff --git a/gst/rtp/gstrtptheoradepay.c b/gst/rtp/gstrtptheoradepay.c
index 1e38262..c808c2a 100644
--- a/gst/rtp/gstrtptheoradepay.c
+++ b/gst/rtp/gstrtptheoradepay.c
@@ -322,10 +322,6 @@ gst_rtp_theora_depay_setcaps (GstBaseRTPDepayload * depayload, GstCaps * caps)
     guint8 *data;
     gsize size;
 
-    /* configure string should be in the caps */
-    if (configuration == NULL)
-      goto no_configuration;
-
     /* deserialize base64 to buffer */
     data = g_base64_decode (configuration, &size);
 
@@ -349,11 +345,6 @@ gst_rtp_theora_depay_setcaps (GstBaseRTPDepayload * depayload, GstCaps * caps)
   return res;
 
   /* ERRORS */
-no_configuration:
-  {
-    GST_ERROR_OBJECT (rtptheoradepay, "no configuration specified");
-    return FALSE;
-  }
 invalid_configuration:
   {
     GST_ERROR_OBJECT (rtptheoradepay, "invalid configuration specified");
diff --git a/gst/rtpmanager/gstrtpbin.c b/gst/rtpmanager/gstrtpbin.c
index f843ed2..ca5d66b 100644
--- a/gst/rtpmanager/gstrtpbin.c
+++ b/gst/rtpmanager/gstrtpbin.c
@@ -1188,8 +1188,11 @@ gst_rtp_bin_associate (GstRtpBin * bin, GstRtpBinStream * stream, guint8 len,
        * now equating rtptime obtained from RTP-Info,
        * where the large time represent the otherwise irrelevant npt/ntp time */
       stream->rtp_delta = (GST_SECOND << 28) - rtp_clock_base;
+    } else {
+      clock_base = rtp_clock_base;
     }
 
+    all_sync = TRUE;
     for (walk = client->streams; walk; walk = g_slist_next (walk)) {
       GstRtpBinStream *ostream = (GstRtpBinStream *) walk->data;
 
@@ -1215,7 +1218,7 @@ gst_rtp_bin_associate (GstRtpBin * bin, GstRtpBinStream * stream, guint8 len,
 
     /* arrange to re-sync for each stream upon significant change,
      * e.g. post-seek */
-    all_sync = (stream->clock_base == clock_base);
+    all_sync = all_sync && (stream->clock_base == clock_base);
     stream->clock_base = clock_base;
 
     /* may need init performed above later on, but nothing more to do now */
diff --git a/gst/rtpmanager/rtpsession.c b/gst/rtpmanager/rtpsession.c
index 9f15bd6..24e752b 100644
--- a/gst/rtpmanager/rtpsession.c
+++ b/gst/rtpmanager/rtpsession.c
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 
 #include <gst/rtp/gstrtpbuffer.h>
diff --git a/gst/rtsp/gstrtspsrc.c b/gst/rtsp/gstrtspsrc.c
index de14225..d344adf 100644
--- a/gst/rtsp/gstrtspsrc.c
+++ b/gst/rtsp/gstrtspsrc.c
@@ -178,6 +178,7 @@ gst_rtsp_src_buffer_mode_get_type (void)
 #define DEFAULT_CONNECTION_SPEED 0
 #define DEFAULT_NAT_METHOD       GST_RTSP_NAT_DUMMY
 #define DEFAULT_DO_RTCP          TRUE
+#define DEFAULT_DO_RTSP_KEEP_ALIVE       TRUE
 #define DEFAULT_PROXY            NULL
 #define DEFAULT_RTP_BLOCKSIZE    0
 #define DEFAULT_USER_ID          NULL
@@ -199,6 +200,7 @@ enum
   PROP_CONNECTION_SPEED,
   PROP_NAT_METHOD,
   PROP_DO_RTCP,
+  PROP_DO_RTSP_KEEP_ALIVE,
   PROP_PROXY,
   PROP_RTP_BLOCKSIZE,
   PROP_USER_ID,
@@ -409,6 +411,20 @@ gst_rtspsrc_class_init (GstRTSPSrcClass * klass)
           DEFAULT_DO_RTCP, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   /**
+   * GstRTSPSrc::do-rtsp-keep-alive
+   *
+   * Enable RTSP keep laive support. Some old server don't like RTSP
+   * keep alive and then this property needs to be set to FALSE.
+   *
+   * Since: 0.10.32
+   */
+  g_object_class_install_property (gobject_class, PROP_DO_RTSP_KEEP_ALIVE,
+      g_param_spec_boolean ("do-rtsp-keep-alive", "Do RTSP Keep Alive",
+          "Send RTSP keep alive packets, disable for old incompatible server.",
+          DEFAULT_DO_RTSP_KEEP_ALIVE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
    * GstRTSPSrc::proxy
    *
    * Set the proxy parameters. This has to be a string of the format
@@ -526,6 +542,7 @@ gst_rtspsrc_init (GstRTSPSrc * src, GstRTSPSrcClass * g_class)
   src->connection_speed = DEFAULT_CONNECTION_SPEED;
   src->nat_method = DEFAULT_NAT_METHOD;
   src->do_rtcp = DEFAULT_DO_RTCP;
+  src->do_rtsp_keep_alive = DEFAULT_DO_RTSP_KEEP_ALIVE;
   gst_rtspsrc_set_proxy (src, DEFAULT_PROXY);
   src->rtp_blocksize = DEFAULT_RTP_BLOCKSIZE;
   src->user_id = g_strdup (DEFAULT_USER_ID);
@@ -692,6 +709,9 @@ gst_rtspsrc_set_property (GObject * object, guint prop_id, const GValue * value,
     case PROP_DO_RTCP:
       rtspsrc->do_rtcp = g_value_get_boolean (value);
       break;
+    case PROP_DO_RTSP_KEEP_ALIVE:
+      rtspsrc->do_rtsp_keep_alive = g_value_get_boolean (value);
+      break;
     case PROP_PROXY:
       gst_rtspsrc_set_proxy (rtspsrc, g_value_get_string (value));
       break;
@@ -782,6 +802,9 @@ gst_rtspsrc_get_property (GObject * object, guint prop_id, GValue * value,
     case PROP_DO_RTCP:
       g_value_set_boolean (value, rtspsrc->do_rtcp);
       break;
+    case PROP_DO_RTSP_KEEP_ALIVE:
+      g_value_set_boolean (value, rtspsrc->do_rtsp_keep_alive);
+      break;
     case PROP_PROXY:
     {
       gchar *str;
@@ -3485,6 +3508,12 @@ gst_rtspsrc_send_keep_alive (GstRTSPSrc * src)
   GstRTSPMethod method;
   gchar *control;
 
+  if (src->do_rtsp_keep_alive == FALSE) {
+    GST_DEBUG_OBJECT (src, "do-rtsp-keep-alive is FALSE, not sending.");
+    gst_rtsp_connection_reset_timeout (src->conninfo.connection);
+    return GST_RTSP_OK;
+  }
+
   GST_DEBUG_OBJECT (src, "creating server keep-alive");
 
   /* find a method to use for keep-alive */
@@ -3836,7 +3865,11 @@ gst_rtspsrc_loop_udp (GstRTSPSrc * src)
           goto connect_error;
 
         continue;
+      case GST_RTSP_ENET:
+        GST_DEBUG_OBJECT (src, "An ethernet problem occured.");
       default:
+        GST_ELEMENT_WARNING (src, RESOURCE, READ, (NULL),
+            ("Unhandled return value %d.", res));
         goto receive_error;
     }
 
@@ -3995,17 +4028,17 @@ no_protocols:
         ("Could not receive any UDP packets for %.4f seconds, maybe your "
             "firewall is blocking it. No other protocols to try.",
             gst_guint64_to_gdouble (src->udp_timeout / 1000000.0)));
-    return GST_FLOW_ERROR;
+    return GST_RTSP_ERROR;
   }
 open_failed:
   {
     GST_DEBUG_OBJECT (src, "open failed");
-    return GST_FLOW_OK;
+    return GST_RTSP_OK;
   }
 play_failed:
   {
     GST_DEBUG_OBJECT (src, "play failed");
-    return GST_FLOW_OK;
+    return GST_RTSP_OK;
   }
 }
 
diff --git a/gst/rtsp/gstrtspsrc.h b/gst/rtsp/gstrtspsrc.h
index cf8f81c..4085712 100644
--- a/gst/rtsp/gstrtspsrc.h
+++ b/gst/rtsp/gstrtspsrc.h
@@ -204,6 +204,7 @@ struct _GstRTSPSrc {
   guint             connection_speed;
   GstRTSPNatMethod  nat_method;
   gboolean          do_rtcp;
+  gboolean          do_rtsp_keep_alive;
   gchar            *proxy_host;
   guint             proxy_port;
   gchar            *proxy_user;
diff --git a/gst/smpte/gstsmpte.c b/gst/smpte/gstsmpte.c
index 4b21cd0..294d68f 100644
--- a/gst/smpte/gstsmpte.c
+++ b/gst/smpte/gstsmpte.c
@@ -152,7 +152,7 @@ static void gst_smpte_base_init (GstSMPTEClass * klass);
 static void gst_smpte_init (GstSMPTE * smpte);
 static void gst_smpte_finalize (GstSMPTE * smpte);
 
-static GstFlowReturn gst_smpte_collected (GstCollectPads * pads,
+static GstFlowReturn gst_smpte_collected (GstCollectPads2 * pads,
     GstSMPTE * smpte);
 
 static void gst_smpte_set_property (GObject * object, guint prop_id,
@@ -360,15 +360,14 @@ gst_smpte_init (GstSMPTE * smpte)
       gst_pad_new_from_static_template (&gst_smpte_src_template, "src");
   gst_element_add_pad (GST_ELEMENT (smpte), smpte->srcpad);
 
-  smpte->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (smpte->collect,
-      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (gst_smpte_collected), smpte);
-  gst_collect_pads_start (smpte->collect);
+  smpte->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (smpte->collect,
+      (GstCollectPads2Function) GST_DEBUG_FUNCPTR (gst_smpte_collected), smpte);
 
-  gst_collect_pads_add_pad (smpte->collect, smpte->sinkpad1,
-      sizeof (GstCollectData));
-  gst_collect_pads_add_pad (smpte->collect, smpte->sinkpad2,
-      sizeof (GstCollectData));
+  gst_collect_pads2_add_pad (smpte->collect, smpte->sinkpad1,
+      sizeof (GstCollectData2));
+  gst_collect_pads2_add_pad (smpte->collect, smpte->sinkpad2,
+      sizeof (GstCollectData2));
 
   smpte->fps = DEFAULT_PROP_FPS;
   smpte->type = DEFAULT_PROP_TYPE;
@@ -408,8 +407,7 @@ gst_smpte_blend_i420 (guint8 * in1, guint8 * in2, guint8 * out, GstMask * mask,
   gint i, j;
   gint min, max;
   guint8 *in1u, *in1v, *in2u, *in2v, *outu, *outv;
-  gint lumsize = width * height;
-  gint chromsize = lumsize >> 2;
+  gint uoffset, voffset, ystr, ustr, vstr;
 
   if (border == 0)
     border++;
@@ -417,12 +415,19 @@ gst_smpte_blend_i420 (guint8 * in1, guint8 * in2, guint8 * out, GstMask * mask,
   min = pos - border;
   max = pos;
 
-  in1u = in1 + lumsize;
-  in1v = in1u + chromsize;
-  in2u = in2 + lumsize;
-  in2v = in2u + chromsize;
-  outu = out + lumsize;
-  outv = outu + chromsize;
+  uoffset = I420_U_OFFSET (width, height);
+  voffset = I420_V_OFFSET (width, height);
+
+  ystr = I420_Y_ROWSTRIDE (width);
+  ustr = I420_U_ROWSTRIDE (width);
+  vstr = I420_V_ROWSTRIDE (width);
+
+  in1u = in1 + uoffset;
+  in1v = in1 + voffset;
+  in2u = in2 + uoffset;
+  in2v = in2 + voffset;
+  outu = out + uoffset;
+  outv = out + voffset;
 
   maskp = mask->data;
 
@@ -431,17 +436,30 @@ gst_smpte_blend_i420 (guint8 * in1, guint8 * in2, guint8 * out, GstMask * mask,
       value = *maskp++;
       value = ((CLAMP (value, min, max) - min) << 8) / border;
 
-      *out++ = ((*in1++ * value) + (*in2++ * (256 - value))) >> 8;
+      out[j] = ((in1[j] * value) + (in2[j] * (256 - value))) >> 8;
       if (!(i & 1) && !(j & 1)) {
-        *outu++ = ((*in1u++ * value) + (*in2u++ * (256 - value))) >> 8;
-        *outv++ = ((*in1v++ * value) + (*in2v++ * (256 - value))) >> 8;
+        outu[j / 2] =
+            ((in1u[j / 2] * value) + (in2u[j / 2] * (256 - value))) >> 8;
+        outv[j / 2] =
+            ((in1v[j / 2] * value) + (in2v[j / 2] * (256 - value))) >> 8;
       }
     }
+    out += ystr;
+    in1 += ystr;
+    in2 += ystr;
+    if (!(i & 1)) {
+      outu += ustr;
+      in1u += ustr;
+      in2u += ustr;
+      outv += vstr;
+      in1v += vstr;
+      in2v += vstr;
+    }
   }
 }
 
 static GstFlowReturn
-gst_smpte_collected (GstCollectPads * pads, GstSMPTE * smpte)
+gst_smpte_collected (GstCollectPads2 * pads, GstSMPTE * smpte)
 {
   GstBuffer *outbuf;
   GstClockTime ts;
@@ -458,14 +476,14 @@ gst_smpte_collected (GstCollectPads * pads, GstSMPTE * smpte)
       smpte->fps_denom, smpte->fps_num);
 
   for (collected = pads->data; collected; collected = g_slist_next (collected)) {
-    GstCollectData *data;
+    GstCollectData2 *data;
 
-    data = (GstCollectData *) collected->data;
+    data = (GstCollectData2 *) collected->data;
 
     if (data->pad == smpte->sinkpad1)
-      in1 = gst_collect_pads_pop (pads, data);
+      in1 = gst_collect_pads2_pop (pads, data);
     else if (data->pad == smpte->sinkpad2)
-      in2 = gst_collect_pads_pop (pads, data);
+      in2 = gst_collect_pads2_pop (pads, data);
   }
 
   if (in1 == NULL) {
@@ -623,11 +641,11 @@ gst_smpte_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_READY_TO_PAUSED:
       gst_smpte_reset (smpte);
       GST_LOG_OBJECT (smpte, "starting collectpads");
-      gst_collect_pads_start (smpte->collect);
+      gst_collect_pads2_start (smpte->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
       GST_LOG_OBJECT (smpte, "stopping collectpads");
-      gst_collect_pads_stop (smpte->collect);
+      gst_collect_pads2_stop (smpte->collect);
       break;
     default:
       break;
diff --git a/gst/smpte/gstsmpte.h b/gst/smpte/gstsmpte.h
index dc6bc6d..ac138f4 100644
--- a/gst/smpte/gstsmpte.h
+++ b/gst/smpte/gstsmpte.h
@@ -22,7 +22,7 @@
 #define __GST_SMPTE_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 G_BEGIN_DECLS
 
@@ -49,7 +49,7 @@ struct _GstSMPTE {
   GstPad        *srcpad,
                 *sinkpad1,
                 *sinkpad2;
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
 
   /* properties */
   gint           type;
diff --git a/gst/udp/gstdynudpsink.c b/gst/udp/gstdynudpsink.c
index 18c58ca..a92cb6b 100644
--- a/gst/udp/gstdynudpsink.c
+++ b/gst/udp/gstdynudpsink.c
@@ -19,6 +19,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/gst/udp/gstmultiudpsink.c b/gst/udp/gstmultiudpsink.c
index b65ab8c..2a4c41c 100644
--- a/gst/udp/gstmultiudpsink.c
+++ b/gst/udp/gstmultiudpsink.c
@@ -27,6 +27,10 @@
  * It can be combined with rtp payload encoders to implement RTP streaming.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/gst/videobox/gstvideoboxorc-dist.c b/gst/videobox/gstvideoboxorc-dist.c
index 1e00246..6e9cd10 100644
--- a/gst/videobox/gstvideoboxorc-dist.c
+++ b/gst/videobox/gstvideoboxorc-dist.c
@@ -181,7 +181,7 @@ void
 orc_splat_u32 (guint32 * ORC_RESTRICT d1, int p1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
diff --git a/gst/videomixer/blendorc-dist.c b/gst/videomixer/blendorc-dist.c
index ee783d8..21b6ae1 100644
--- a/gst/videomixer/blendorc-dist.c
+++ b/gst/videomixer/blendorc-dist.c
@@ -193,7 +193,7 @@ void
 orc_splat_u32 (guint32 * ORC_RESTRICT d1, int p1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -285,7 +285,7 @@ orc_memcpy_u32 (guint32 * ORC_RESTRICT d1, const guint32 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -438,7 +438,7 @@ orc_blend_u8 (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int p1, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -742,7 +742,7 @@ orc_blend_argb (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int p1, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1076,7 +1076,7 @@ orc_blend_bgra (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int p1, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1562,7 +1562,7 @@ orc_overlay_argb (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int p1, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2086,7 +2086,7 @@ orc_overlay_bgra (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int p1, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
diff --git a/gst/wavparse/gstwavparse.c b/gst/wavparse/gstwavparse.c
index 6c5e77b..719359b 100644
--- a/gst/wavparse/gstwavparse.c
+++ b/gst/wavparse/gstwavparse.c
@@ -87,6 +87,19 @@ static gboolean gst_wavparse_sink_event (GstPad * pad, GstEvent * event);
 static void gst_wavparse_loop (GstPad * pad);
 static gboolean gst_wavparse_srcpad_event (GstPad * pad, GstEvent * event);
 
+static void gst_wavparse_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_wavparse_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+#define DEFAULT_IGNORE_LENGTH FALSE
+
+enum
+{
+  PROP_0,
+  PROP_IGNORE_LENGTH,
+};
+
 static GstStaticPadTemplate sink_template_factory =
 GST_STATIC_PAD_TEMPLATE ("wavparse_sink",
     GST_PAD_SINK,
@@ -134,6 +147,27 @@ gst_wavparse_class_init (GstWavParseClass * klass)
 
   object_class->dispose = gst_wavparse_dispose;
 
+  object_class->set_property = gst_wavparse_set_property;
+  object_class->get_property = gst_wavparse_get_property;
+
+  /**
+   * GstWavParse:ignore-length
+   * 
+   * This selects whether the length found in a data chunk
+   * should be ignored. This may be useful for streamed audio
+   * where the length is unknown until the end of streaming,
+   * and various software/hardware just puts some random value
+   * in there and hopes it doesn't break too much.
+   *
+   * Since: 0.10.36
+   */
+  g_object_class_install_property (object_class, PROP_IGNORE_LENGTH,
+      g_param_spec_boolean ("ignore-length",
+          "Ignore length",
+          "Ignore length from the Wave header",
+          DEFAULT_IGNORE_LENGTH, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)
+      );
+
   gstelement_class->change_state = gst_wavparse_change_state;
   gstelement_class->send_event = gst_wavparse_send_event;
 }
@@ -247,37 +281,6 @@ gst_wavparse_create_sourcepad (GstWavParse * wavparse)
   GST_DEBUG_OBJECT (wavparse, "srcpad created");
 }
 
-/* Compute (value * nom) % denom, avoiding overflow.  This can be used
- * to perform ceiling or rounding division together with
- * gst_util_uint64_scale[_int]. */
-#define uint64_scale_modulo(val, nom, denom) \
-  ((val % denom) * (nom % denom) % denom)
-
-/* Like gst_util_uint64_scale, but performs ceiling division. */
-static guint64
-uint64_ceiling_scale_int (guint64 val, gint num, gint denom)
-{
-  guint64 result = gst_util_uint64_scale_int (val, num, denom);
-
-  if (uint64_scale_modulo (val, num, denom) == 0)
-    return result;
-  else
-    return result + 1;
-}
-
-/* Like gst_util_uint64_scale, but performs ceiling division. */
-static guint64
-uint64_ceiling_scale (guint64 val, guint64 num, guint64 denom)
-{
-  guint64 result = gst_util_uint64_scale (val, num, denom);
-
-  if (uint64_scale_modulo (val, num, denom) == 0)
-    return result;
-  else
-    return result + 1;
-}
-
-
 /* FIXME: why is that not in use? */
 #if 0
 static void
@@ -565,7 +568,7 @@ gst_wavparse_fmt (GstWavParse * wav)
   gst_element_add_pad (GST_ELEMENT_CAST (wav), wav->srcpad);
   gst_element_no_more_pads (GST_ELEMENT_CAST (wav));
 
-  GST_DEBUG ("frequency %d, channels %d", wav->rate, wav->channels);
+  GST_DEBUG ("frequency %u, channels %u", wav->rate, wav->channels);
 
   return TRUE;
 
@@ -606,8 +609,8 @@ gst_wavparse_other (GstWavParse * wav)
     GST_WARNING_OBJECT (wav, "could not peek head");
     return FALSE;
   }
-  GST_DEBUG_OBJECT (wav, "got tag (%08x) %4.4s, length %d", tag,
-      (gchar *) & tag, length);
+  GST_DEBUG_OBJECT (wav, "got tag (%08x) %4.4s, length %u", tag,
+      (const gchar *) &tag, length);
 
   switch (tag) {
     case GST_RIFF_TAG_LIST:
@@ -758,12 +761,12 @@ gst_wavparse_time_to_bytepos (GstWavParse * wav, gint64 ts, gint64 * bytepos)
   }
 
   if (wav->bps > 0) {
-    *bytepos = uint64_ceiling_scale (ts, (guint64) wav->bps, GST_SECOND);
+    *bytepos = gst_util_uint64_scale_ceil (ts, (guint64) wav->bps, GST_SECOND);
     return TRUE;
   } else if (wav->fact) {
     guint64 bps =
         gst_util_uint64_scale_int (wav->datasize, wav->rate, wav->fact);
-    *bytepos = uint64_ceiling_scale (ts, bps, GST_SECOND);
+    *bytepos = gst_util_uint64_scale_ceil (ts, bps, GST_SECOND);
     return TRUE;
   }
 
@@ -1060,7 +1063,7 @@ gst_wavparse_peek_chunk_info (GstWavParse * wav, guint32 * tag, guint32 * size)
   *tag = GST_READ_UINT32_LE (data);
   *size = GST_READ_UINT32_LE (data + 4);
 
-  GST_DEBUG ("Next chunk size is %d bytes, type %" GST_FOURCC_FORMAT, *size,
+  GST_DEBUG ("Next chunk size is %u bytes, type %" GST_FOURCC_FORMAT, *size,
       GST_FOURCC_ARGS (*tag));
 
   return TRUE;
@@ -1090,7 +1093,7 @@ gst_wavparse_peek_chunk (GstWavParse * wav, guint32 * tag, guint32 * size)
    * so we throw poor man's exception, which can be caught if caller really
    * wants to handle 0 size chunk */
   if (!(*size) || (*size) >= (1 << 30)) {
-    GST_INFO ("Invalid/unexpected chunk size %d for tag %" GST_FOURCC_FORMAT,
+    GST_INFO ("Invalid/unexpected chunk size %u for tag %" GST_FOURCC_FORMAT,
         *size, GST_FOURCC_ARGS (*tag));
     /* chain should give up */
     wav->abort_buffering = TRUE;
@@ -1125,12 +1128,14 @@ gst_wavparse_calculate_duration (GstWavParse * wav)
   if (wav->bps > 0) {
     GST_INFO_OBJECT (wav, "Got datasize %" G_GUINT64_FORMAT, wav->datasize);
     wav->duration =
-        uint64_ceiling_scale (wav->datasize, GST_SECOND, (guint64) wav->bps);
+        gst_util_uint64_scale_ceil (wav->datasize, GST_SECOND,
+        (guint64) wav->bps);
     GST_INFO_OBJECT (wav, "Got duration (bps) %" GST_TIME_FORMAT,
         GST_TIME_ARGS (wav->duration));
     return TRUE;
   } else if (wav->fact) {
-    wav->duration = uint64_ceiling_scale_int (GST_SECOND, wav->fact, wav->rate);
+    wav->duration =
+        gst_util_uint64_scale_int_ceil (GST_SECOND, wav->fact, wav->rate);
     GST_INFO_OBJECT (wav, "Got duration (fact) %" GST_TIME_FORMAT,
         GST_TIME_ARGS (wav->duration));
     return TRUE;
@@ -1263,12 +1268,12 @@ gst_wavparse_stream_headers (GstWavParse * wav)
       {
         /* Note: workaround for mp2/mp3 embedded in wav, that relies on the
          * bitrate inside the mpeg stream */
-        GST_INFO ("resetting bps from %d to 0 for mp2/3", wav->av_bps);
+        GST_INFO ("resetting bps from %u to 0 for mp2/3", wav->av_bps);
         wav->bps = 0;
         break;
       }
       case GST_RIFF_WAVE_FORMAT_PCM:
-        if (wav->blockalign > wav->channels * (guint) ceil (wav->depth / 8.0))
+        if (wav->blockalign > wav->channels * ((wav->depth + 7) / 8))
           goto invalid_blockalign;
         /* fall through */
       default:
@@ -1347,7 +1352,11 @@ gst_wavparse_stream_headers (GstWavParse * wav)
      */
     switch (tag) {
       case GST_RIFF_TAG_data:{
-        GST_DEBUG_OBJECT (wav, "Got 'data' TAG, size : %d", size);
+        GST_DEBUG_OBJECT (wav, "Got 'data' TAG, size : %u", size);
+        if (wav->ignore_length) {
+          GST_DEBUG_OBJECT (wav, "Ignoring length");
+          size = 0;
+        }
         if (wav->streaming) {
           gst_adapter_flush (wav->adapter, 8);
           gotdata = TRUE;
@@ -1372,7 +1381,7 @@ gst_wavparse_stream_headers (GstWavParse * wav)
           /* We will continue parsing tags 'till end */
           wav->offset += size;
         }
-        GST_DEBUG_OBJECT (wav, "datasize = %d", size);
+        GST_DEBUG_OBJECT (wav, "datasize = %u", size);
         break;
       }
       case GST_RIFF_TAG_fact:{
@@ -1386,7 +1395,7 @@ gst_wavparse_stream_headers (GstWavParse * wav)
               /* need more data */
               goto exit;
             }
-            GST_DEBUG_OBJECT (wav, "need %d, available %d; ignoring chunk",
+            GST_DEBUG_OBJECT (wav, "need %u, available %u; ignoring chunk",
                 data_size, size);
             break;
           }
@@ -1431,7 +1440,7 @@ gst_wavparse_stream_headers (GstWavParse * wav)
             /* need more data */
             goto exit;
           }
-          GST_DEBUG_OBJECT (wav, "need %d, available %d; ignoring chunk",
+          GST_DEBUG_OBJECT (wav, "need %u, available %u; ignoring chunk",
               data_size, size);
           break;
         }
@@ -1559,18 +1568,20 @@ gst_wavparse_stream_headers (GstWavParse * wav)
     wav->bps =
         (guint32) gst_util_uint64_scale ((guint64) wav->rate, wav->datasize,
         (guint64) wav->fact);
-    GST_INFO_OBJECT (wav, "calculated bps : %d, enabling VBR", wav->bps);
+    GST_INFO_OBJECT (wav, "calculated bps : %u, enabling VBR", wav->bps);
 #endif
     wav->vbr = TRUE;
   }
 
   if (gst_wavparse_calculate_duration (wav)) {
     gst_segment_init (&wav->segment, GST_FORMAT_TIME);
-    gst_segment_set_duration (&wav->segment, GST_FORMAT_TIME, wav->duration);
+    if (!wav->ignore_length)
+      gst_segment_set_duration (&wav->segment, GST_FORMAT_TIME, wav->duration);
   } else {
     /* no bitrate, let downstream peer do the math, we'll feed it bytes. */
     gst_segment_init (&wav->segment, GST_FORMAT_BYTES);
-    gst_segment_set_duration (&wav->segment, GST_FORMAT_BYTES, wav->datasize);
+    if (!wav->ignore_length)
+      gst_segment_set_duration (&wav->segment, GST_FORMAT_BYTES, wav->datasize);
   }
 
   /* now we have all the info to perform a pending seek if any, if no
@@ -1597,7 +1608,7 @@ gst_wavparse_stream_headers (GstWavParse * wav)
   if (wav->blockalign > 0)
     wav->max_buf_size -= (wav->max_buf_size % wav->blockalign);
 
-  GST_DEBUG_OBJECT (wav, "max buffer size %d", wav->max_buf_size);
+  GST_DEBUG_OBJECT (wav, "max buffer size %u", wav->max_buf_size);
 
   return GST_FLOW_OK;
 
@@ -1646,7 +1657,7 @@ invalid_blockalign:
   {
     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
         ("Stream claims blockalign = %u, which is more than %u - invalid data",
-            wav->blockalign, wav->channels * (guint) ceil (wav->depth / 8.0)));
+            wav->blockalign, wav->channels * ((wav->depth + 7) / 8)));
     goto fail;
   }
 invalid_bps:
@@ -1665,7 +1676,7 @@ no_bytes_per_sample:
 unknown_format:
   {
     GST_ELEMENT_ERROR (wav, STREAM, TYPE_NOT_FOUND, (NULL),
-        ("No caps found for format 0x%x, %d channels, %d Hz",
+        ("No caps found for format 0x%x, %u channels, %u Hz",
             wav->format, wav->channels, wav->rate));
     goto fail;
   }
@@ -1868,13 +1879,13 @@ iterate_adapter:
     if (G_UNLIKELY (extra)) {
       extra = wav->bytes_per_sample - extra;
       if (extra <= avail) {
-        GST_DEBUG_OBJECT (wav, "flushing %d bytes to sample boundary", extra);
+        GST_DEBUG_OBJECT (wav, "flushing %u bytes to sample boundary", extra);
         gst_adapter_flush (wav->adapter, extra);
         wav->offset += extra;
         wav->dataleft -= extra;
         goto iterate_adapter;
       } else {
-        GST_DEBUG_OBJECT (wav, "flushing %d bytes", avail);
+        GST_DEBUG_OBJECT (wav, "flushing %u bytes", avail);
         gst_adapter_clear (wav->adapter);
         wav->offset += avail;
         wav->dataleft -= avail;
@@ -1883,7 +1894,7 @@ iterate_adapter:
     }
 
     if (avail < desired) {
-      GST_LOG_OBJECT (wav, "Got only %d bytes of data from the sinkpad", avail);
+      GST_LOG_OBJECT (wav, "Got only %u bytes of data from the sinkpad", avail);
       return GST_FLOW_OK;
     }
 
@@ -1936,9 +1947,10 @@ iterate_adapter:
 
   if (wav->bps > 0) {
     /* and timestamps if we have a bitrate, be careful for overflows */
-    timestamp = uint64_ceiling_scale (pos, GST_SECOND, (guint64) wav->bps);
+    timestamp =
+        gst_util_uint64_scale_ceil (pos, GST_SECOND, (guint64) wav->bps);
     next_timestamp =
-        uint64_ceiling_scale (nextpos, GST_SECOND, (guint64) wav->bps);
+        gst_util_uint64_scale_ceil (nextpos, GST_SECOND, (guint64) wav->bps);
     duration = next_timestamp - timestamp;
 
     /* update current running segment position */
@@ -1949,8 +1961,8 @@ iterate_adapter:
     guint64 bps =
         gst_util_uint64_scale_int (wav->datasize, wav->rate, wav->fact);
     /* and timestamps if we have a bitrate, be careful for overflows */
-    timestamp = uint64_ceiling_scale (pos, GST_SECOND, bps);
-    next_timestamp = uint64_ceiling_scale (nextpos, GST_SECOND, bps);
+    timestamp = gst_util_uint64_scale_ceil (pos, GST_SECOND, bps);
+    next_timestamp = gst_util_uint64_scale_ceil (nextpos, GST_SECOND, bps);
     duration = next_timestamp - timestamp;
   } else {
     /* no bitrate, all we know is that the first sample has timestamp 0, all
@@ -2237,10 +2249,12 @@ gst_wavparse_sink_event (GstPad * pad, GstEvent * event)
           if (bps) {
             if (start >= 0)
               start =
-                  uint64_ceiling_scale (start, GST_SECOND, (guint64) wav->bps);
+                  gst_util_uint64_scale_ceil (start, GST_SECOND,
+                  (guint64) wav->bps);
             if (stop >= 0)
               stop =
-                  uint64_ceiling_scale (stop, GST_SECOND, (guint64) wav->bps);
+                  gst_util_uint64_scale_ceil (stop, GST_SECOND,
+                  (guint64) wav->bps);
           }
         }
       } else {
@@ -2355,13 +2369,14 @@ gst_wavparse_pad_convert (GstPad * pad,
               "src=%" G_GINT64_FORMAT ", offset=%" G_GINT64_FORMAT, src_value,
               wavparse->offset);
           if (wavparse->bps > 0)
-            *dest_value = uint64_ceiling_scale (src_value, GST_SECOND,
+            *dest_value = gst_util_uint64_scale_ceil (src_value, GST_SECOND,
                 (guint64) wavparse->bps);
           else if (wavparse->fact) {
-            guint64 bps = uint64_ceiling_scale_int (wavparse->datasize,
+            guint64 bps = gst_util_uint64_scale_int_ceil (wavparse->datasize,
                 wavparse->rate, wavparse->fact);
 
-            *dest_value = uint64_ceiling_scale_int (src_value, GST_SECOND, bps);
+            *dest_value =
+                gst_util_uint64_scale_int_ceil (src_value, GST_SECOND, bps);
           } else {
             res = FALSE;
           }
@@ -2489,6 +2504,11 @@ gst_wavparse_pad_query (GstPad * pad, GstQuery * query)
       gint64 duration = 0;
       GstFormat format;
 
+      if (wav->ignore_length) {
+        res = FALSE;
+        break;
+      }
+
       gst_query_parse_duration (query, &format, NULL);
 
       switch (format) {
@@ -2657,6 +2677,43 @@ gst_wavparse_change_state (GstElement * element, GstStateChange transition)
   return ret;
 }
 
+static void
+gst_wavparse_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstWavParse *self;
+
+  g_return_if_fail (GST_IS_WAVPARSE (object));
+  self = GST_WAVPARSE (object);
+
+  switch (prop_id) {
+    case PROP_IGNORE_LENGTH:
+      self->ignore_length = g_value_get_boolean (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+  }
+
+}
+
+static void
+gst_wavparse_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstWavParse *self;
+
+  g_return_if_fail (GST_IS_WAVPARSE (object));
+  self = GST_WAVPARSE (object);
+
+  switch (prop_id) {
+    case PROP_IGNORE_LENGTH:
+      g_value_set_boolean (value, self->ignore_length);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+  }
+}
+
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
diff --git a/gst/wavparse/gstwavparse.h b/gst/wavparse/gstwavparse.h
index ecac968..972463f 100644
--- a/gst/wavparse/gstwavparse.h
+++ b/gst/wavparse/gstwavparse.h
@@ -118,6 +118,8 @@ struct _GstWavParse {
   gboolean first;
   /* discont after seek */
   gboolean discont;
+
+  gboolean ignore_length;
 };
 
 struct _GstWavParseClass {
diff --git a/sys/Makefile.am b/sys/Makefile.am
index ab08d04..7ccd9e7 100644
--- a/sys/Makefile.am
+++ b/sys/Makefile.am
@@ -23,6 +23,12 @@ else
 DIRECTSOUND_DIR=
 endif
 
+if USE_WAVEFORM
+WAVEFORM_DIR=waveform
+else
+WAVEFORM_DIR=
+endif
+
 if USE_SUNAUDIO
 SUNAUDIO_DIR=sunaudio
 else
@@ -77,7 +83,7 @@ else
 XIMAGE_DIR=
 endif
 
-SUBDIRS=$(DIRECTSOUND_DIR) $(OSS_DIR) $(OSS4_DIR) $(OSX_AUDIO_DIR) $(OSX_VIDEO_DIR) $(SUNAUDIO_DIR) $(V4L2_DIR) $(XIMAGE_DIR)
+SUBDIRS=$(DIRECTSOUND_DIR) $(WAVEFORM_DIR) $(OSS_DIR) $(OSS4_DIR) $(OSX_AUDIO_DIR) $(OSX_VIDEO_DIR) $(SUNAUDIO_DIR) $(V4L2_DIR) $(XIMAGE_DIR)
 
 DIST_SUBDIRS=directsound oss oss4 osxaudio osxvideo sunaudio v4l2 waveform ximage
 
diff --git a/sys/oss4/oss4-audio.c b/sys/oss4/oss4-audio.c
index 09f8495..6317400 100644
--- a/sys/oss4/oss4-audio.c
+++ b/sys/oss4/oss4-audio.c
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/sys/oss4/oss4-property-probe.c b/sys/oss4/oss4-property-probe.c
index a99410e..5674da5 100644
--- a/sys/oss4/oss4-property-probe.c
+++ b/sys/oss4/oss4-property-probe.c
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
diff --git a/sys/v4l2/gstv4l2bufferpool.c b/sys/v4l2/gstv4l2bufferpool.c
index b81c6a4..a0b4c84 100644
--- a/sys/v4l2/gstv4l2bufferpool.c
+++ b/sys/v4l2/gstv4l2bufferpool.c
@@ -98,6 +98,7 @@ gst_v4l2_buffer_finalize (GstV4l2Buffer * buffer)
     GST_LOG_OBJECT (pool->v4l2elem, "reviving buffer %p, %d", buffer, index);
     gst_buffer_ref (GST_BUFFER (buffer));
     GST_BUFFER_SIZE (buffer) = 0;
+    GST_BUFFER_FLAG_UNSET (buffer, GST_BUFFER_FLAG_DISCONT);
     pool->buffers[index] = buffer;
   }
 
@@ -106,9 +107,9 @@ gst_v4l2_buffer_finalize (GstV4l2Buffer * buffer)
   if (!resuscitated) {
     GST_LOG_OBJECT (pool->v4l2elem,
         "buffer %p (data %p, len %u) not recovered, unmapping",
-        buffer, GST_BUFFER_DATA (buffer), buffer->vbuffer.length);
+        buffer, GST_BUFFER_DATA (buffer), buffer->mmap_length);
     gst_mini_object_unref (GST_MINI_OBJECT (pool));
-    v4l2_munmap ((void *) GST_BUFFER_DATA (buffer), buffer->vbuffer.length);
+    v4l2_munmap ((void *) GST_BUFFER_DATA (buffer), buffer->mmap_length);
 
     GST_MINI_OBJECT_CLASS (v4l2buffer_parent_class)->finalize (GST_MINI_OBJECT
         (buffer));
@@ -183,6 +184,7 @@ gst_v4l2_buffer_new (GstV4l2BufferPool * pool, guint index, GstCaps * caps)
   GST_LOG_OBJECT (pool->v4l2elem, "  length:    %u", ret->vbuffer.length);
   GST_LOG_OBJECT (pool->v4l2elem, "  input:     %u", ret->vbuffer.input);
 
+  ret->mmap_length = ret->vbuffer.length;
   data = (guint8 *) v4l2_mmap (0, ret->vbuffer.length,
       PROT_READ | PROT_WRITE, MAP_SHARED, pool->video_fd,
       ret->vbuffer.m.offset);
diff --git a/sys/v4l2/gstv4l2bufferpool.h b/sys/v4l2/gstv4l2bufferpool.h
index caad9ac..36ea323 100644
--- a/sys/v4l2/gstv4l2bufferpool.h
+++ b/sys/v4l2/gstv4l2bufferpool.h
@@ -70,6 +70,9 @@ struct _GstV4l2Buffer {
   GstBuffer   buffer;
 
   struct v4l2_buffer vbuffer;
+  /* warning: the size of mmap buffer and
+   * the actual frame-buffer can be different. */
+  size_t mmap_length;
 
   /* FIXME: have GstV4l2Src* instead, as this has GstV4l2BufferPool* */
   /* FIXME: do we really want to fix this if GstV4l2Buffer/Pool is shared
diff --git a/sys/v4l2/gstv4l2object.c b/sys/v4l2/gstv4l2object.c
index 81d1cb7..6ff5ab4 100644
--- a/sys/v4l2/gstv4l2object.c
+++ b/sys/v4l2/gstv4l2object.c
@@ -18,6 +18,10 @@
  * USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
diff --git a/sys/v4l2/gstv4l2xoverlay.c b/sys/v4l2/gstv4l2xoverlay.c
index 60d0919..f1c4d51 100644
--- a/sys/v4l2/gstv4l2xoverlay.c
+++ b/sys/v4l2/gstv4l2xoverlay.c
@@ -32,6 +32,8 @@
 #include <X11/extensions/Xv.h>
 #include <X11/extensions/Xvlib.h>
 #include <sys/stat.h>
+/* for XkbKeycodeToKeysym */
+#include <X11/XKBlib.h>
 
 #include <gst/interfaces/navigation.h>
 
@@ -323,7 +325,7 @@ event_refresh (gpointer data)
           case KeyPress:
           case KeyRelease:
             g_mutex_lock (v4l2xv->mutex);
-            keysym = XKeycodeToKeysym (v4l2xv->dpy, e.xkey.keycode, 0);
+            keysym = XkbKeycodeToKeysym (v4l2xv->dpy, e.xkey.keycode, 0, 0);
             if (keysym != NoSymbol) {
               key_str = XKeysymToString (keysym);
             } else {
diff --git a/sys/waveform/Makefile.am b/sys/waveform/Makefile.am
index a9562a8..9a9fac3 100644
--- a/sys/waveform/Makefile.am
+++ b/sys/waveform/Makefile.am
@@ -1,19 +1,15 @@
 plugin_LTLIBRARIES = libgstwaveformsink.la
 
-# FIXME: Replace DIRECTSOUND CFLAGS+LIBS with waveform related ones and fix
-# the configure.ac + sys/Makefile.am to get this stuff building in MingW
-# For now, it's just disted for use in the VS builds.
-
 libgstwaveformsink_la_SOURCES =  gstwaveformsink.c gstwaveformplugin.c
 libgstwaveformsink_la_CFLAGS = $(GST_CFLAGS) $(GST_BASE_CFLAGS) \
-        $(GST_PLUGINS_BASE_CFLAGS) $(DIRECTSOUND_CFLAGS)
+        $(GST_PLUGINS_BASE_CFLAGS)
 libgstwaveformsink_la_LIBADD = \
 	$(GST_PLUGINS_BASE_LIBS) \
         -lgstaudio-$(GST_MAJORMINOR) -lgstinterfaces-$(GST_MAJORMINOR) \
         $(GST_BASE_LIBS) \
 	$(GST_LIBS) \
-	$(DIRECTSOUND_LIBS)
-libgstwaveformsink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS) $(DIRECTSOUND_LDFLAGS)
+	-lwinmm
+libgstwaveformsink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstwaveformsink_la_LIBTOOLFLAGS = --tag=disable-static
 
 noinst_HEADERS = gstwaveformsink.h
diff --git a/sys/waveform/gstwaveformsink.c b/sys/waveform/gstwaveformsink.c
index 0c59829..3ff72a9 100644
--- a/sys/waveform/gstwaveformsink.c
+++ b/sys/waveform/gstwaveformsink.c
@@ -49,10 +49,6 @@
 
 GST_DEBUG_CATEGORY_STATIC (waveformsink_debug);
 
-static void gst_waveform_sink_base_init (gpointer g_class);
-static void gst_waveform_sink_class_init (GstWaveFormSinkClass * klass);
-static void gst_waveform_sink_init (GstWaveFormSink * wfsink,
-    GstWaveFormSinkClass * g_class);
 static void gst_waveform_sink_finalise (GObject * object);
 static void gst_waveform_sink_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec);
@@ -154,7 +150,7 @@ static void
 gst_waveform_sink_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec)
 {
-  GstWaveFormSink *wfsink = GST_WAVEFORM_SINK (object);
+  /* GstWaveFormSink *wfsink = GST_WAVEFORM_SINK (object); */
 
   switch (prop_id) {
     default:
@@ -167,7 +163,7 @@ static void
 gst_waveform_sink_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec)
 {
-  GstWaveFormSink *wfsink = GST_WAVEFORM_SINK (object);
+  /* GstWaveFormSink *wfsink = GST_WAVEFORM_SINK (object); */
 
   switch (prop_id) {
     default:
@@ -348,7 +344,7 @@ gst_waveform_sink_getcaps (GstBaseSink * bsink)
 static gboolean
 gst_waveform_sink_open (GstAudioSink * asink)
 {
-  GstWaveFormSink *wfsink = GST_WAVEFORM_SINK (asink);
+  /* GstWaveFormSink *wfsink = GST_WAVEFORM_SINK (asink); */
 
   /* nothing to do here as the device needs to be opened with the format we will use */
 
@@ -448,7 +444,7 @@ gst_waveform_sink_unprepare (GstAudioSink * asink)
 static gboolean
 gst_waveform_sink_close (GstAudioSink * asink)
 {
-  GstWaveFormSink *wfsink = GST_WAVEFORM_SINK (asink);
+  /* GstWaveFormSink *wfsink = GST_WAVEFORM_SINK (asink); */
 
   return TRUE;
 }
diff --git a/sys/ximage/gstximagesrc.c b/sys/ximage/gstximagesrc.c
index 36c0b44..9740312 100644
--- a/sys/ximage/gstximagesrc.c
+++ b/sys/ximage/gstximagesrc.c
@@ -1074,8 +1074,7 @@ gst_ximage_src_get_caps (GstBaseSrc * bs)
   if (s->endx >= s->startx && s->endy >= s->starty) {
     /* this means user has put in values */
     if (s->startx < xcontext->width && s->endx < xcontext->width &&
-        s->starty < xcontext->height && s->endy < xcontext->height &&
-        s->startx >= 0 && s->starty >= 0) {
+        s->starty < xcontext->height && s->endy < xcontext->height) {
       /* values are fine */
       s->width = width = s->endx - s->startx + 1;
       s->height = height = s->endy - s->starty + 1;
diff --git a/tests/check/Makefile.am b/tests/check/Makefile.am
index 27dde40..d16e985 100644
--- a/tests/check/Makefile.am
+++ b/tests/check/Makefile.am
@@ -147,6 +147,7 @@ check_PROGRAMS = \
 	elements/shapewipe \
 	elements/spectrum \
 	elements/udpsink \
+	elements/udpsrc \
 	elements/videocrop \
 	elements/videofilter \
 	elements/y4menc \
@@ -261,6 +262,9 @@ elements_sunaudio_LDADD = \
 	$(GST_PLUGINS_BASE_LIBS) -lgstinterfaces-@GST_MAJORMINOR@ \
 	$(LDADD)
 
+elements_udpsrc_CFLAGS = $(AM_CFLAGS) $(GIO_CFLAGS)
+elements_udpsrc_LDADD = $(LDADD) $(GIO_LIBS)
+
 elements_videocrop_LDADD = $(GST_BASE_LIBS) $(LDADD)
 elements_videocrop_CFLAGS = $(GST_BASE_CFLAGS) $(CFLAGS) $(AM_CFLAGS)
 
diff --git a/tests/check/elements/audiofirfilter.c b/tests/check/elements/audiofirfilter.c
index c4eb723..3741061 100644
--- a/tests/check/elements/audiofirfilter.c
+++ b/tests/check/elements/audiofirfilter.c
@@ -18,6 +18,10 @@
  * 02110-1301 USA
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/gst.h>
 #include <gst/check/gstcheck.h>
 
diff --git a/tests/check/elements/audioiirfilter.c b/tests/check/elements/audioiirfilter.c
index d144792..dd64031 100644
--- a/tests/check/elements/audioiirfilter.c
+++ b/tests/check/elements/audioiirfilter.c
@@ -18,6 +18,11 @@
  * 02110-1301 USA
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
+
 #include <gst/gst.h>
 #include <gst/check/gstcheck.h>
 
diff --git a/tests/check/elements/cmmldec.c b/tests/check/elements/cmmldec.c
index a6b8559..142a904 100644
--- a/tests/check/elements/cmmldec.c
+++ b/tests/check/elements/cmmldec.c
@@ -21,6 +21,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/check/gstcheck.h>
 #include <gst/tag/tag.h>
 
diff --git a/tests/check/elements/interleave.c b/tests/check/elements/interleave.c
index 1497a49..b645227 100644
--- a/tests/check/elements/interleave.c
+++ b/tests/check/elements/interleave.c
@@ -18,6 +18,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 # include "config.h"
 #endif
diff --git a/tests/check/elements/rtp-payloading.c b/tests/check/elements/rtp-payloading.c
index b2160f4..7b4985b 100644
--- a/tests/check/elements/rtp-payloading.c
+++ b/tests/check/elements/rtp-payloading.c
@@ -31,13 +31,11 @@
 typedef struct
 {
   GstElement *pipeline;
-  GstElement *fdsrc;
-  GstElement *capsfilter;
+  GstElement *appsrc;
   GstElement *rtppay;
   GstElement *rtpdepay;
   GstElement *fakesink;
-  int fd[2];
-  const char *frame_data;
+  const guint8 *frame_data;
   int frame_data_size;
   int frame_count;
 } rtp_pipeline;
@@ -140,13 +138,11 @@ rtp_bus_callback (GstBus * bus, GstMessage * message, gpointer data)
  * The user must free the RTP pipeline when it's not used anymore.
  */
 static rtp_pipeline *
-rtp_pipeline_create (const char *frame_data, int frame_data_size,
+rtp_pipeline_create (const guint8 * frame_data, int frame_data_size,
     int frame_count, const char *filtercaps, const char *pay, const char *depay)
 {
   gchar *pipeline_name;
-
   rtp_pipeline *p;
-
   GstCaps *caps;
 
   /* Check parameters. */
@@ -165,60 +161,39 @@ rtp_pipeline_create (const char *frame_data, int frame_data_size,
   pipeline_name = g_strdup_printf ("%s-%s-pipeline", pay, depay);
   p->pipeline = gst_pipeline_new (pipeline_name);
   g_free (pipeline_name);
-  p->fdsrc = gst_element_factory_make ("fdsrc", NULL);
-  p->capsfilter = gst_element_factory_make ("capsfilter", NULL);
+  p->appsrc = gst_element_factory_make ("appsrc", NULL);
   p->rtppay = gst_element_factory_make (pay, NULL);
   p->rtpdepay = gst_element_factory_make (depay, NULL);
   p->fakesink = gst_element_factory_make ("fakesink", NULL);
 
   /* One or more elements are not created successfully or failed to create p? */
-  if (!p->pipeline || !p->fdsrc || !p->capsfilter || !p->rtppay || !p->rtpdepay
-      || !p->fakesink || pipe (p->fd) == -1) {
+  if (!p->pipeline || !p->appsrc || !p->rtppay || !p->rtpdepay || !p->fakesink) {
     /* Release created elements. */
     RELEASE_ELEMENT (p->pipeline);
-    RELEASE_ELEMENT (p->fdsrc);
-    RELEASE_ELEMENT (p->capsfilter);
+    RELEASE_ELEMENT (p->appsrc);
     RELEASE_ELEMENT (p->rtppay);
     RELEASE_ELEMENT (p->rtpdepay);
     RELEASE_ELEMENT (p->fakesink);
 
-    /* Close pipe. */
-    if (p->fd[0]) {
-      close (p->fd[0]);
-    }
-
-    if (p->fd[1]) {
-      close (p->fd[1]);
-    }
-
     /* Release allocated memory. */
     free (p);
 
     return NULL;
   }
 
-  /* Set fdsrc properties. */
-  g_object_set (p->fdsrc, "fd", p->fd[0], NULL);
-  g_object_set (p->fdsrc, "do-timestamp", TRUE, NULL);
-  g_object_set (p->fdsrc, "blocksize", p->frame_data_size, NULL);
-  g_object_set (p->fdsrc, "num-buffers", p->frame_count * LOOP_COUNT, NULL);
-
-  /* Set caps filters. */
+  /* Set src properties. */
   caps = gst_caps_from_string (filtercaps);
-
-  g_object_set (p->capsfilter, "caps", caps, NULL);
+  g_object_set (p->appsrc, "do-timestamp", TRUE, "caps", caps, NULL);
   gst_caps_unref (caps);
 
   /* Add elements to the pipeline. */
-  gst_bin_add (GST_BIN (p->pipeline), p->fdsrc);
-  gst_bin_add (GST_BIN (p->pipeline), p->capsfilter);
+  gst_bin_add (GST_BIN (p->pipeline), p->appsrc);
   gst_bin_add (GST_BIN (p->pipeline), p->rtppay);
   gst_bin_add (GST_BIN (p->pipeline), p->rtpdepay);
   gst_bin_add (GST_BIN (p->pipeline), p->fakesink);
 
   /* Link elements. */
-  gst_element_link (p->fdsrc, p->capsfilter);
-  gst_element_link (p->capsfilter, p->rtppay);
+  gst_element_link (p->appsrc, p->rtppay);
   gst_element_link (p->rtppay, p->rtpdepay);
   gst_element_link (p->rtpdepay, p->fakesink);
 
@@ -240,15 +215,6 @@ rtp_pipeline_destroy (rtp_pipeline * p)
   /* Release pipeline. */
   RELEASE_ELEMENT (p->pipeline);
 
-  /* Close pipe. */
-  if (p->fd[0]) {
-    close (p->fd[0]);
-  }
-
-  if (p->fd[1]) {
-    close (p->fd[1]);
-  }
-
   /* Release allocated memory. */
   free (p);
 }
@@ -260,11 +226,10 @@ rtp_pipeline_destroy (rtp_pipeline * p)
 static void
 rtp_pipeline_run (rtp_pipeline * p)
 {
+  GstFlowReturn flow_ret;
   GMainLoop *mainloop = NULL;
-
   GstBus *bus;
-
-  gint i;
+  gint i, j;
 
   /* Check parameters. */
   if (p == NULL) {
@@ -286,22 +251,28 @@ rtp_pipeline_run (rtp_pipeline * p)
   /* Set pipeline to PLAYING. */
   gst_element_set_state (p->pipeline, GST_STATE_PLAYING);
 
-  /* TODO: Writing may need some changes... */
-
+  /* Push data into the pipeline */
   for (i = 0; i < LOOP_COUNT; i++) {
-    const char *frame_data_pointer = p->frame_data;
-    int res;
-    int frame_count = p->frame_count;
-
-    /* Write in to the pipe. */
-    while (frame_count > 0) {
-      res = write (p->fd[1], frame_data_pointer, p->frame_data_size);
-      fail_unless_equals_int (res, p->frame_data_size);
-      frame_data_pointer += p->frame_data_size;
-      frame_count--;
+    const guint8 *data = p->frame_data;
+
+    for (j = 0; j < p->frame_count; j++) {
+      GstBuffer *buf;
+
+      buf = gst_buffer_new ();
+      GST_BUFFER_DATA (buf) = (guint8 *) data;
+      GST_BUFFER_SIZE (buf) = p->frame_data_size;
+      GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_READONLY);
+
+      g_signal_emit_by_name (p->appsrc, "push-buffer", buf, &flow_ret);
+      fail_unless_equals_int (flow_ret, GST_FLOW_OK);
+      data += p->frame_data_size;
+
+      gst_buffer_unref (buf);
     }
   }
 
+  g_signal_emit_by_name (p->appsrc, "end-of-stream", &flow_ret);
+
   /* Run mainloop. */
   g_main_loop_run (mainloop);
 
@@ -350,8 +321,8 @@ rtp_pipeline_enable_lists (rtp_pipeline * p, guint mtu_size)
  * @use_lists enable buffer lists
  */
 static void
-rtp_pipeline_test (const char *frame_data, int frame_data_size, int frame_count,
-    const char *filtercaps, const char *pay, const char *depay,
+rtp_pipeline_test (const guint8 * frame_data, int frame_data_size,
+    int frame_count, const char *filtercaps, const char *pay, const char *depay,
     guint bytes_sent, guint mtu_size, gboolean use_lists)
 {
   /* Create RTP pipeline. */
@@ -380,7 +351,7 @@ rtp_pipeline_test (const char *frame_data, int frame_data_size, int frame_count,
   }
 }
 
-static char rtp_ilbc_frame_data[] =
+static const guint8 rtp_ilbc_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -397,7 +368,7 @@ GST_START_TEST (rtp_ilbc)
 }
 
 GST_END_TEST;
-static char rtp_gsm_frame_data[] =
+static const guint8 rtp_gsm_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -414,7 +385,7 @@ GST_START_TEST (rtp_gsm)
 }
 
 GST_END_TEST;
-static char rtp_amr_frame_data[] =
+static const guint8 rtp_amr_frame_data[] =
     { 0x3c, 0x24, 0x03, 0xb3, 0x48, 0x10, 0x68, 0x46, 0x6c, 0xec, 0x03,
   0x7a, 0x37, 0x16, 0x41, 0x41, 0xc0, 0x00, 0x0d, 0xcd, 0x12, 0xed,
   0xad, 0x80, 0x00, 0x00, 0x11, 0x31, 0x00, 0x00, 0x0d, 0xa0
@@ -432,7 +403,7 @@ GST_START_TEST (rtp_amr)
 }
 
 GST_END_TEST;
-static char rtp_pcma_frame_data[] =
+static const guint8 rtp_pcma_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -449,7 +420,7 @@ GST_START_TEST (rtp_pcma)
 }
 
 GST_END_TEST;
-static char rtp_pcmu_frame_data[] =
+static const guint8 rtp_pcmu_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -466,7 +437,7 @@ GST_START_TEST (rtp_pcmu)
 }
 
 GST_END_TEST;
-static char rtp_mpa_frame_data[] =
+static const guint8 rtp_mpa_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -483,7 +454,7 @@ GST_START_TEST (rtp_mpa)
 }
 
 GST_END_TEST;
-static char rtp_h263_frame_data[] =
+static const guint8 rtp_h263_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -495,12 +466,12 @@ static int rtp_h263_frame_count = 1;
 GST_START_TEST (rtp_h263)
 {
   rtp_pipeline_test (rtp_h263_frame_data, rtp_h263_frame_data_size,
-      rtp_h263_frame_count, "video/x-h263,variant=itu,h263version=h263",
+      rtp_h263_frame_count, "video/x-h263,variant=(string)itu,h263version=h263",
       "rtph263pay", "rtph263depay", 0, 0, FALSE);
 }
 
 GST_END_TEST;
-static char rtp_h263p_frame_data[] =
+static const guint8 rtp_h263p_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -512,12 +483,12 @@ static int rtp_h263p_frame_count = 1;
 GST_START_TEST (rtp_h263p)
 {
   rtp_pipeline_test (rtp_h263p_frame_data, rtp_h263p_frame_data_size,
-      rtp_h263p_frame_count, "video/x-h263,variant=itu", "rtph263ppay",
+      rtp_h263p_frame_count, "video/x-h263,variant=(string)itu", "rtph263ppay",
       "rtph263pdepay", 0, 0, FALSE);
 }
 
 GST_END_TEST;
-static char rtp_h264_frame_data[] =
+static const guint8 rtp_h264_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -528,13 +499,14 @@ static int rtp_h264_frame_count = 1;
 
 GST_START_TEST (rtp_h264)
 {
+  /* FIXME 0.11: fully specify h264 caps (and make payloader check) */
   rtp_pipeline_test (rtp_h264_frame_data, rtp_h264_frame_data_size,
       rtp_h264_frame_count, "video/x-h264", "rtph264pay", "rtph264depay",
       0, 0, FALSE);
 }
 
 GST_END_TEST;
-static char rtp_h264_list_lt_mtu_frame_data[] =
+static const guint8 rtp_h264_list_lt_mtu_frame_data[] =
     /* not packetized, next NAL starts with 0001 */
 { 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
@@ -552,6 +524,7 @@ static int rtp_h264_list_lt_mtu_mtu_size = 1024;
 
 GST_START_TEST (rtp_h264_list_lt_mtu)
 {
+  /* FIXME 0.11: fully specify h264 caps (and make payloader check) */
   rtp_pipeline_test (rtp_h264_list_lt_mtu_frame_data,
       rtp_h264_list_lt_mtu_frame_data_size, rtp_h264_list_lt_mtu_frame_count,
       "video/x-h264", "rtph264pay", "rtph264depay",
@@ -559,7 +532,7 @@ GST_START_TEST (rtp_h264_list_lt_mtu)
 }
 
 GST_END_TEST;
-static char rtp_h264_list_gt_mtu_frame_data[] =
+static const guint8 rtp_h264_list_gt_mtu_frame_data[] =
     /* not packetized, next NAL starts with 0001 */
 { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -580,6 +553,7 @@ static int rtp_h264_list_gt_mtu_mty_size = 28;
 
 GST_START_TEST (rtp_h264_list_gt_mtu)
 {
+  /* FIXME 0.11: fully specify h264 caps (and make payloader check) */
   rtp_pipeline_test (rtp_h264_list_gt_mtu_frame_data,
       rtp_h264_list_gt_mtu_frame_data_size, rtp_h264_list_gt_mtu_frame_count,
       "video/x-h264", "rtph264pay", "rtph264depay",
@@ -587,7 +561,7 @@ GST_START_TEST (rtp_h264_list_gt_mtu)
 }
 
 GST_END_TEST;
-static char rtp_L16_frame_data[] =
+static const guint8 rtp_L16_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -605,7 +579,7 @@ GST_START_TEST (rtp_L16)
 }
 
 GST_END_TEST;
-static char rtp_mp2t_frame_data[] =
+static const guint8 rtp_mp2t_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -622,7 +596,7 @@ GST_START_TEST (rtp_mp2t)
 }
 
 GST_END_TEST;
-static char rtp_mp4v_frame_data[] =
+static const guint8 rtp_mp4v_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -639,7 +613,7 @@ GST_START_TEST (rtp_mp4v)
 }
 
 GST_END_TEST;
-static char rtp_mp4v_list_frame_data[] =
+static const guint8 rtp_mp4v_list_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -659,7 +633,7 @@ GST_START_TEST (rtp_mp4v_list)
 }
 
 GST_END_TEST;
-static char rtp_mp4g_frame_data[] =
+static const guint8 rtp_mp4g_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -677,7 +651,7 @@ GST_START_TEST (rtp_mp4g)
 }
 
 GST_END_TEST;
-static char rtp_theora_frame_data[] =
+static const guint8 rtp_theora_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -694,7 +668,7 @@ GST_START_TEST (rtp_theora)
 }
 
 GST_END_TEST;
-static char rtp_vorbis_frame_data[] =
+static const guint8 rtp_vorbis_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
@@ -711,7 +685,7 @@ GST_START_TEST (rtp_vorbis)
 }
 
 GST_END_TEST;
-static char rtp_jpeg_frame_data[] =
+static const guint8 rtp_jpeg_frame_data[] =
     { /* SOF */ 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x08, 0x00, 0x08,
   0x03, 0x00, 0x21, 0x08, 0x01, 0x11, 0x08, 0x02, 0x11, 0x08,
   /* DQT */ 0xFF, 0xDB, 0x00, 0x43, 0x08,
@@ -738,7 +712,7 @@ GST_START_TEST (rtp_jpeg)
 }
 
 GST_END_TEST;
-static char rtp_jpeg_list_frame_data[] =
+static const guint8 rtp_jpeg_list_frame_data[] =
     { /* SOF */ 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x08, 0x00, 0x08,
   0x03, 0x00, 0x21, 0x08, 0x01, 0x11, 0x08, 0x02, 0x11, 0x08,
   /* DQT */ 0xFF, 0xDB, 0x00, 0x43, 0x08,
@@ -767,7 +741,7 @@ GST_START_TEST (rtp_jpeg_list)
 }
 
 GST_END_TEST;
-static char rtp_g729_frame_data[] =
+static const guint8 rtp_g729_frame_data[] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
diff --git a/tests/check/elements/udpsrc.c b/tests/check/elements/udpsrc.c
new file mode 100644
index 0000000..d84334a
--- /dev/null
+++ b/tests/check/elements/udpsrc.c
@@ -0,0 +1,120 @@
+/* GStreamer UDP source unit tests
+ * Copyright (C) 2011 Tim-Philipp Müller <tim centricular net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#include <gst/check/gstcheck.h>
+#include <gio/gio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+GST_START_TEST (test_udpsrc_empty_packet)
+{
+  GstElement *udpsrc;
+  GSocket *socket;
+  GstPad *sinkpad;
+  int port = 0;
+
+  udpsrc = gst_check_setup_element ("udpsrc");
+  fail_unless (udpsrc != NULL);
+  g_object_set (udpsrc, "port", 0, NULL);
+
+  sinkpad = gst_check_setup_sink_pad_by_name (udpsrc, &sinktemplate, "src");
+  fail_unless (sinkpad != NULL);
+  gst_pad_set_active (sinkpad, TRUE);
+
+  gst_element_set_state (udpsrc, GST_STATE_PLAYING);
+  g_object_get (udpsrc, "port", &port, NULL);
+  GST_INFO ("udpsrc port = %d", port);
+
+  socket = g_socket_new (G_SOCKET_FAMILY_IPV4, G_SOCKET_TYPE_DATAGRAM,
+      G_SOCKET_PROTOCOL_UDP, NULL);
+
+  if (socket != NULL) {
+    GSocketAddress *sa;
+    GInetAddress *ia;
+    gchar *s;
+
+    ia = g_inet_address_new_loopback (G_SOCKET_FAMILY_IPV4);
+    s = g_inet_address_to_string (ia);
+    GST_LOG ("inet address %s", s);
+    g_free (s);
+    sa = g_inet_socket_address_new (ia, port);
+
+    if (g_socket_send_to (socket, sa, "HeLL0", 0, NULL, NULL) == 0) {
+      GST_INFO ("sent 0 bytes");
+      if (g_socket_send_to (socket, sa, "HeLL0", 6, NULL, NULL) == 6) {
+        GstBuffer *buf;
+        guint len;
+
+        GST_INFO ("sent 6 bytes");
+
+        g_usleep (G_USEC_PER_SEC / 2);
+
+        len = g_list_length (buffers);
+        GST_INFO ("%u buffers", len);
+        fail_unless (len == 1 || len == 2);
+
+        /* last buffer should be our HeLL0 string */
+        buf = GST_BUFFER (g_list_nth_data (buffers, len - 1));
+        fail_unless_equals_int (GST_BUFFER_SIZE (buf), 6);
+        fail_unless_equals_string ((gchar *) GST_BUFFER_DATA (buf), "HeLL0");
+
+        /* if there's another buffer, it should be 0 bytes */
+        if (len == 2) {
+          buf = GST_BUFFER (g_list_nth_data (buffers, 0));
+          fail_unless_equals_int (GST_BUFFER_SIZE (buf), 0);
+        }
+      } else {
+        GST_WARNING ("send_to(6 bytes) failed");
+      }
+    } else {
+      GST_WARNING ("send_to(0 bytes) failed");
+    }
+
+    g_object_unref (sa);
+    g_object_unref (ia);
+  } else {
+    GST_WARNING ("Could not create IPv4 UDP socket for unit test");
+  }
+
+  gst_element_set_state (udpsrc, GST_STATE_NULL);
+
+  gst_check_teardown_pad_by_name (udpsrc, "src");
+  gst_check_teardown_element (udpsrc);
+
+  g_object_unref (socket);
+}
+
+GST_END_TEST;
+
+static Suite *
+udpsrc_suite (void)
+{
+  Suite *s = suite_create ("udpsrc");
+  TCase *tc_chain = tcase_create ("udpsrc");
+
+  suite_add_tcase (s, tc_chain);
+  tcase_add_test (tc_chain, test_udpsrc_empty_packet);
+  return s;
+}
+
+GST_CHECK_MAIN (udpsrc)
diff --git a/tests/check/elements/wavpackdec.c b/tests/check/elements/wavpackdec.c
index 0d17323..b1498e1 100644
--- a/tests/check/elements/wavpackdec.c
+++ b/tests/check/elements/wavpackdec.c
@@ -52,7 +52,7 @@ static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("audio/x-raw-int, "
-        "width = (int) 32, "
+        "width = (int) 16, "
         "depth = (int) 16, "
         "channels = (int) 1, "
         "rate = (int) 44100, "
@@ -112,23 +112,20 @@ GST_START_TEST (test_decode_frame)
   memcpy (GST_BUFFER_DATA (inbuffer), test_frame, sizeof (test_frame));
   ASSERT_BUFFER_REFCOUNT (inbuffer, "inbuffer", 1);
   GST_BUFFER_TIMESTAMP (inbuffer) = 0;
-  gst_buffer_ref (inbuffer);
 
   gst_element_set_bus (wavpackdec, bus);
 
   /* should decode the buffer without problems */
   fail_unless_equals_int (gst_pad_push (mysrcpad, inbuffer), GST_FLOW_OK);
-  ASSERT_BUFFER_REFCOUNT (inbuffer, "inbuffer", 1);
-  gst_buffer_unref (inbuffer);
 
   outbuffer = GST_BUFFER (buffers->data);
 
   fail_if (outbuffer == NULL);
   /* uncompressed data should be 102400 bytes */
-  fail_unless_equals_int (GST_BUFFER_SIZE (outbuffer), 102400);
+  fail_unless_equals_int (GST_BUFFER_SIZE (outbuffer), 51200);
 
-  /* and all 102400 bytes must be 0, i.e. silence */
-  for (i = 0; i < 102400; i++)
+  /* and all bytes must be 0, i.e. silence */
+  for (i = 0; i < 51200; i++)
     fail_unless_equals_int (GST_BUFFER_DATA (outbuffer)[i], 0);
 
   ASSERT_BUFFER_REFCOUNT (outbuffer, "outbuffer", 1);
@@ -166,14 +163,11 @@ GST_START_TEST (test_decode_frame_with_broken_header)
   GST_BUFFER_DATA (inbuffer)[2] = 'e';
   ASSERT_BUFFER_REFCOUNT (inbuffer, "inbuffer", 1);
   GST_BUFFER_TIMESTAMP (inbuffer) = 0;
-  gst_buffer_ref (inbuffer);
 
   gst_element_set_bus (wavpackdec, bus);
 
   /* should fail gracefully */
   fail_unless_equals_int (gst_pad_push (mysrcpad, inbuffer), GST_FLOW_ERROR);
-  ASSERT_BUFFER_REFCOUNT (inbuffer, "inbuffer", 1);
-  gst_buffer_unref (inbuffer);
 
   fail_if ((message = gst_bus_pop (bus)) == NULL);
   fail_unless_message_error (message, STREAM, DECODE);
@@ -204,14 +198,11 @@ GST_START_TEST (test_decode_frame_with_incomplete_frame)
   memcpy (GST_BUFFER_DATA (inbuffer), test_frame, sizeof (test_frame) - 2);
   ASSERT_BUFFER_REFCOUNT (inbuffer, "inbuffer", 1);
   GST_BUFFER_TIMESTAMP (inbuffer) = 0;
-  gst_buffer_ref (inbuffer);
 
   gst_element_set_bus (wavpackdec, bus);
 
   /* should fail gracefully */
   fail_unless_equals_int (gst_pad_push (mysrcpad, inbuffer), GST_FLOW_ERROR);
-  ASSERT_BUFFER_REFCOUNT (inbuffer, "inbuffer", 1);
-  gst_buffer_unref (inbuffer);
 
   fail_if ((message = gst_bus_pop (bus)) == NULL);
   fail_unless_message_error (message, STREAM, DECODE);
diff --git a/tests/check/elements/wavpackenc.c b/tests/check/elements/wavpackenc.c
index 153668a..af852aa 100644
--- a/tests/check/elements/wavpackenc.c
+++ b/tests/check/elements/wavpackenc.c
@@ -32,14 +32,14 @@ static GstBus *bus;
 
 #define RAW_CAPS_STRING "audio/x-raw-int, " \
                         "width = (int) 32, " \
-                        "depth = (int) 16, " \
+                        "depth = (int) 32, " \
                         "channels = (int) 1, " \
                         "rate = (int) 44100, " \
                         "endianness = (int) BYTE_ORDER, " \
                         "signed = (boolean) true"
 
 #define WAVPACK_CAPS_STRING "audio/x-wavpack, " \
-                            "width = (int) 16, " \
+                            "width = (int) 32, " \
                             "channels = (int) 1, " \
                             "rate = (int) 44100, " \
                             "framed = (boolean) true"
@@ -48,7 +48,7 @@ static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("audio/x-wavpack, "
-        "width = (int) 16, "
+        "width = (int) 32, "
         "channels = (int) 1, "
         "rate = (int) 44100, " "framed = (boolean) true"));
 
@@ -57,7 +57,7 @@ static GstStaticPadTemplate srctemplate = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("audio/x-raw-int, "
         "width = (int) 32, "
-        "depth = (int) 16, "
+        "depth = (int) 32, "
         "channels = (int) 1, "
         "rate = (int) 44100, "
         "endianness = (int) BYTE_ORDER, " "signed = (boolean) true"));
@@ -118,13 +118,10 @@ GST_START_TEST (test_encode_silence)
   gst_caps_unref (caps);
   GST_BUFFER_TIMESTAMP (inbuffer) = 0;
   ASSERT_BUFFER_REFCOUNT (inbuffer, "inbuffer", 1);
-  gst_buffer_ref (inbuffer);
 
   gst_element_set_bus (wavpackenc, bus);
 
   fail_unless_equals_int (gst_pad_push (mysrcpad, inbuffer), GST_FLOW_OK);
-  ASSERT_BUFFER_REFCOUNT (inbuffer, "inbuffer", 1);
-  gst_buffer_unref (inbuffer);
 
   fail_if (gst_pad_push_event (mysrcpad, eos) != TRUE);
 
@@ -134,9 +131,7 @@ GST_START_TEST (test_encode_silence)
   fail_if (outbuffer == NULL);
 
   fail_unless_equals_int (GST_BUFFER_TIMESTAMP (outbuffer), 0);
-  fail_unless_equals_int (GST_BUFFER_OFFSET (outbuffer), 0);
   fail_unless_equals_int (GST_BUFFER_DURATION (outbuffer), 5668934);
-  fail_unless_equals_int (GST_BUFFER_OFFSET_END (outbuffer), 250);
 
   fail_unless (memcmp (GST_BUFFER_DATA (outbuffer), "wvpk", 4) == 0,
       "Failed to encode to valid Wavpack frames");
diff --git a/tests/check/pipelines/wavenc.c b/tests/check/pipelines/wavenc.c
index c5344a7..4bf76a0 100644
--- a/tests/check/pipelines/wavenc.c
+++ b/tests/check/pipelines/wavenc.c
@@ -20,6 +20,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/check/gstcheck.h>
 #include <gst/audio/multichannel.h>
 
diff --git a/tests/examples/audiofx/firfilter-example.c b/tests/examples/audiofx/firfilter-example.c
index b344e74..e2fa2dc 100644
--- a/tests/examples/audiofx/firfilter-example.c
+++ b/tests/examples/audiofx/firfilter-example.c
@@ -21,6 +21,10 @@
  * by transforming the frequency response to the filter kernel.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 #include <math.h>
 
diff --git a/tests/examples/audiofx/iirfilter-example.c b/tests/examples/audiofx/iirfilter-example.c
index 7fac2ac..708bde1 100644
--- a/tests/examples/audiofx/iirfilter-example.c
+++ b/tests/examples/audiofx/iirfilter-example.c
@@ -23,6 +23,10 @@
  * of the IIR filter that is used.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 #include <math.h>
 
diff --git a/tests/examples/pulse/pulse.c b/tests/examples/pulse/pulse.c
index 54c1a87..a0bd3b3 100644
--- a/tests/examples/pulse/pulse.c
+++ b/tests/examples/pulse/pulse.c
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/gst.h>
 
 #include <gst/interfaces/propertyprobe.h>
diff --git a/tests/examples/rtp/server-alsasrc-PCMA.c b/tests/examples/rtp/server-alsasrc-PCMA.c
index d61ec30..da16603 100644
--- a/tests/examples/rtp/server-alsasrc-PCMA.c
+++ b/tests/examples/rtp/server-alsasrc-PCMA.c
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 #include <math.h>
 
diff --git a/tests/examples/spectrum/Makefile.am b/tests/examples/spectrum/Makefile.am
index 8bb89da..4fc796e 100644
--- a/tests/examples/spectrum/Makefile.am
+++ b/tests/examples/spectrum/Makefile.am
@@ -7,8 +7,10 @@ demo_osssrc_CFLAGS  = $(GST_BASE_CFLAGS) $(GST_CFLAGS) $(GTK_CFLAGS)
 demo_osssrc_LDADD = $(GST_BASE_LIBS) $(GST_LIBS) $(GTK_LIBS)
 
 demo_audiotest_SOURCES = demo-audiotest.c
-demo_audiotest_CFLAGS  = $(GST_BASE_CFLAGS) $(GST_CFLAGS) $(GTK_CFLAGS)
-demo_audiotest_LDADD = $(GST_BASE_LIBS) $(GST_LIBS) $(GTK_LIBS)
+demo_audiotest_CFLAGS  = $(GST_PLUGINS_BASE_CFLAGS) \
+   $(GST_BASE_CFLAGS) $(GST_CFLAGS) $(GTK_CFLAGS)
+demo_audiotest_LDADD = $(GST_PLUGINS_BASE_LIBS) -lgstfft-$(GST_MAJORMINOR) \
+   $(GST_BASE_LIBS) $(GST_LIBS) $(GTK_LIBS)
 
 spectrum_example_SOURCES = spectrum-example.c
 spectrum_example_CFLAGS  = $(GST_BASE_CFLAGS) $(GST_CFLAGS) $(GTK_CFLAGS)
diff --git a/tests/examples/spectrum/demo-audiotest.c b/tests/examples/spectrum/demo-audiotest.c
index f9d1058..1095d75 100644
--- a/tests/examples/spectrum/demo-audiotest.c
+++ b/tests/examples/spectrum/demo-audiotest.c
@@ -17,6 +17,19 @@
  * Boston, MA 02111-1307, USA.
  */
 /* TODO: add wave selection */
+/* fast vs. slow mode - see update_spectrum_bands()
+ * we are still cheating below, we only draw the first spect_bands and ignore a few :/
+ *
+ * xtime gst-launch-0.10 -q audiotestsrc num-buffers=10000 ! spectrum bands=1441 ! fakesink
+ * 2.29u 0.02s 2.14r 25504kB gst-launch-0.10 -q audiotestsrc num-buffers=10000 ! spectrum bands=1441 ! fakesink
+ * 2.20u 0.05s 2.10r 25664kB gst-launch-0.10 -q audiotestsrc num-buffers=10000 ! spectrum bands=1441 ! fakesink
+ * 2.23u 0.04s 2.10r 25664kB gst-launch-0.10 -q audiotestsrc num-buffers=10000 ! spectrum bands=1441 ! fakesink
+ * 
+ * xtime gst-launch-0.10 -q audiotestsrc num-buffers=10000 ! spectrum bands=1440 ! fakesink
+ * 25.01u 0.08s 25.00r 25552kB gst-launch-0.10 -q audiotestsrc num-buffers=10000 ! spectrum bands=1440 ! fakesink
+ * 24.96u 0.03s 24.88r 25568kB gst-launch-0.10 -q audiotestsrc num-buffers=10000 ! spectrum bands=1440 ! fakesink
+ * 25.11u 0.03s 25.03r 25536kB gst-launch-0.10 -q audiotestsrc num-buffers=10000 ! spectrum bands=1440 ! fakesink
+ */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -27,6 +40,7 @@
 #include <string.h>
 #include <math.h>
 #include <gst/gst.h>
+#include <gst/fft/gstfft.h>
 #include <gtk/gtk.h>
 
 #ifndef DEFAULT_AUDIOSINK
@@ -36,8 +50,10 @@
 static guint spect_height = 64;
 static guint spect_bands = 256;
 static gfloat height_scale = 1.0;
+static gboolean fast = FALSE;
 
 static GtkWidget *drawingarea = NULL;
+static GtkWidget *bands_used = NULL;
 static GstClock *sync_clock = NULL;
 
 static void
@@ -57,21 +73,41 @@ on_frequency_changed (GtkRange * range, gpointer user_data)
   g_object_set (machine, "freq", value, NULL);
 }
 
+static void
+update_spectrum_bands (GstElement * spectrum)
+{
+  guint bands = spect_bands;
+  gchar str[50];
+
+  if (fast)
+    bands = ((gst_fft_next_fast_length (2 * bands - 2) + 2) / 2);
+
+  sprintf (str, "using %u bands", bands);
+
+  g_object_set (bands_used, "label", str, NULL);
+  g_object_set (G_OBJECT (spectrum), "bands", bands, NULL);
+}
+
 static gboolean
 on_configure_event (GtkWidget * widget, GdkEventConfigure * event,
     gpointer user_data)
 {
-  GstElement *spectrum = GST_ELEMENT (user_data);
-
   /*GST_INFO ("%d x %d", event->width, event->height); */
   spect_height = event->height;
   height_scale = event->height / 64.0;
   spect_bands = event->width;
 
-  g_object_set (G_OBJECT (spectrum), "bands", spect_bands, NULL);
+  update_spectrum_bands (GST_ELEMENT (user_data));
   return FALSE;
 }
 
+static void
+on_fast_slow_mode_changed (GtkToggleButton * togglebutton, gpointer user_data)
+{
+  fast = gtk_toggle_button_get_active (togglebutton);
+  update_spectrum_bands (GST_ELEMENT (user_data));
+}
+
 /* draw frequency spectrum as a bunch of bars */
 static void
 draw_spectrum (gfloat * data)
@@ -170,7 +206,7 @@ main (int argc, char *argv[])
   GstElement *bin;
   GstElement *src, *spectrum, *audioconvert, *sink;
   GstBus *bus;
-  GtkWidget *appwindow, *vbox, *widget;
+  GtkWidget *appwindow, *vbox, *hbox, *widget;
 
   gst_init (&argc, &argv);
   gtk_init (&argc, &argv);
@@ -205,6 +241,16 @@ main (int argc, char *argv[])
       G_CALLBACK (on_window_destroy), NULL);
   vbox = gtk_vbox_new (FALSE, 6);
 
+  hbox = gtk_hbox_new (FALSE, 6);
+  widget = gtk_check_button_new_with_label ("Fast");
+  g_signal_connect (G_OBJECT (widget), "toggled",
+      G_CALLBACK (on_fast_slow_mode_changed), (gpointer) spectrum);
+  gtk_box_pack_start (GTK_BOX (hbox), widget, FALSE, FALSE, 0);
+  bands_used = gtk_label_new ("");
+  gtk_box_pack_start (GTK_BOX (hbox), bands_used, FALSE, FALSE, 0);
+
+  gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
+
   widget = gtk_hscale_new_with_range (50.0, 20000.0, 10);
   gtk_scale_set_draw_value (GTK_SCALE (widget), TRUE);
   gtk_scale_set_value_pos (GTK_SCALE (widget), GTK_POS_TOP);
diff --git a/tests/examples/v4l2/probe.c b/tests/examples/v4l2/probe.c
index 169288a..3642bb6 100644
--- a/tests/examples/v4l2/probe.c
+++ b/tests/examples/v4l2/probe.c
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <stdlib.h>
 #include <gst/gst.h>
 #include <gst/interfaces/propertyprobe.h>
diff --git a/tests/icles/test-oss4.c b/tests/icles/test-oss4.c
index 233e891..63aeca4 100644
--- a/tests/icles/test-oss4.c
+++ b/tests/icles/test-oss4.c
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
diff --git a/win32/common/config.h b/win32/common/config.h
index ddc1bb1..3146889 100644
--- a/win32/common/config.h
+++ b/win32/common/config.h
@@ -43,13 +43,13 @@
 #define GST_LICENSE "LGPL"
 
 /* package name in plugins */
-#define GST_PACKAGE_NAME "GStreamer Good Plug-ins source release"
+#define GST_PACKAGE_NAME "GStreamer Good Plug-ins git"
 
 /* package origin */
 #define GST_PACKAGE_ORIGIN "Unknown package origin"
 
 /* GStreamer package release date/time for plugins as YYYY-MM-DD */
-#define GST_PACKAGE_RELEASE_DATETIME "2012-02-20"
+#define GST_PACKAGE_RELEASE_DATETIME "2012-02-23T10:45Z"
 
 /* struct v4l2_buffer missing */
 #undef GST_V4L2_MISSING_BUFDECL
@@ -343,6 +343,9 @@
 /* Define if valgrind should be used */
 #undef HAVE_VALGRIND
 
+/* Define to enable Win32 WaveForm (used by waveformsink). */
+#undef HAVE_WAVEFORM
+
 /* Define to enable wavpack plug-in (used by wavpack). */
 #undef HAVE_WAVPACK
 
@@ -384,7 +387,7 @@
 #define PACKAGE_NAME "GStreamer Good Plug-ins"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "GStreamer Good Plug-ins 0.10.31"
+#define PACKAGE_STRING "GStreamer Good Plug-ins 0.10.31.1"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "gst-plugins-good"
@@ -393,7 +396,7 @@
 #undef PACKAGE_URL
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "0.10.31"
+#define PACKAGE_VERSION "0.10.31.1"
 
 /* directory where plugins are located */
 #ifdef _DEBUG
@@ -424,7 +427,7 @@
 #undef STDC_HEADERS
 
 /* Version number of package */
-#define VERSION "0.10.31"
+#define VERSION "0.10.31.1"
 
 /* old wavpack API */
 #undef WAVPACK_OLD_API
