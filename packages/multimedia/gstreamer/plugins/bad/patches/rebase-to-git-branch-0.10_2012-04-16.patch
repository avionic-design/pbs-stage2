diff --git a/autogen.sh b/autogen.sh
index 8a56c7a..a7f26df 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -29,6 +29,10 @@ then
     ln -s ../../common/hooks/pre-commit.hook .git/hooks/pre-commit
 fi
 
+# GNU gettext automake support doesn't get along with git.
+# https://bugzilla.gnome.org/show_bug.cgi?id=661128
+touch -t 200001010000 po/$package-0.10.pot
+
 CONFIGURE_DEF_OPT='--enable-maintainer-mode --enable-gtk-doc'
 
 autogen_options $@
diff --git a/configure.ac b/configure.ac
index d56cd57..a2a265b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3,7 +3,7 @@ AC_PREREQ(2.60)
 dnl initialize autoconf
 dnl when going to/from release please set the nano (fourth number) right !
 dnl releases only do Wall, cvs and prerelease does Werror too
-AC_INIT(GStreamer Bad Plug-ins, 0.10.23,
+AC_INIT(GStreamer Bad Plug-ins, 0.10.23.1,
     http://bugzilla.gnome.org/enter_bug.cgi?product=GStreamer,
     gst-plugins-bad)
 
@@ -47,7 +47,7 @@ dnl - interfaces added/removed/changed -> increment CURRENT, REVISION = 0
 dnl - interfaces added -> increment AGE
 dnl - interfaces removed -> AGE = 0
 dnl sets GST_LT_LDFLAGS
-AS_LIBTOOL(GST, 23, 0, 0)
+AS_LIBTOOL(GST, 24, 0, 0)
 
 AG_GST_LIBTOOL_PREPARE
 
@@ -282,14 +287,14 @@ AG_GST_SET_PACKAGE_RELEASE_DATETIME_WITH_NANO([$PACKAGE_VERSION_NANO],
 dnl define an ERROR_CFLAGS Makefile variable
 dnl -Waggregate-return - libexif returns aggregates
 dnl -Wundef - Windows headers check _MSC_VER unconditionally
-AG_GST_SET_ERROR_CFLAGS($GST_GIT, [
+AG_GST_SET_ERROR_CFLAGS($FATAL_WARNINGS, [
     -Wmissing-declarations -Wmissing-prototypes -Wredundant-decls
     -Wwrite-strings -Wformat-security -Wold-style-definition
     -Winit-self -Wmissing-include-dirs -Waddress -Wno-multichar
     -Wnested-externs])
 
 dnl define an ERROR_CXXFLAGS Makefile variable
-AG_GST_SET_ERROR_CXXFLAGS($GST_GIT, [
+AG_GST_SET_ERROR_CXXFLAGS($FATAL_WARNINGS, [
     -Wmissing-declarations -Wredundant-decls
     -Wwrite-strings -Wformat-nonliteral -Wformat-security
     -Winit-self -Wmissing-include-dirs -Waddress -Wno-multichar ])
@@ -432,19 +437,14 @@ AG_GST_CHECK_FEATURE(DIRECTSOUND, [DirectSound], directsoundsrc, [
   LDFLAGS="$LDFLAGS $DIRECTX_LDFLAGS"
   LIBS="$LIBS -ldsound -ldxerr9 -luser32"
   AC_MSG_CHECKING(for DirectSound LDFLAGS)
-  AC_LINK_IFELSE([
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[
 #include <windows.h>
 #include <dxerr9.h>
 #include <dsound.h>
-
-int main ()
-{
+]], [[
   DXGetErrorString9 (0);
   DirectSoundCreate(NULL, NULL, NULL);
-
-  return 0;
-}
-],
+]])],
     [HAVE_DIRECTSOUND="yes"],
     [HAVE_DIRECTSOUND="no"])
   AC_MSG_RESULT($HAVE_DIRECTSOUND)
@@ -473,17 +473,12 @@ AG_GST_CHECK_FEATURE(DIRECT3D, [Direct3D plug-in], direct3dsink, [
   LDFLAGS="$LDFLAGS $DIRECTX_LDFLAGS"
   LIBS="$LIBS -ld3d9 -lgdi32"
   AC_MSG_CHECKING(for Direct3D LDFLAGS)
-  AC_LINK_IFELSE([
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[
 #include <windows.h>
 #include <d3d9.h>
-
-int main ()
-{
+]], [[
   Direct3DCreate9(D3D_SDK_VERSION);
-
-  return 0;
-}
-],
+]])],
     [HAVE_DIRECT3D="yes"],
     [HAVE_DIRECT3D="no"])
   AC_MSG_RESULT($HAVE_DIRECT3D)
@@ -509,18 +504,13 @@ AG_GST_CHECK_FEATURE(DIRECTDRAW, [DirectDraw plug-in], directdrawsink, [
   LDFLAGS="$LDFLAGS $DIRECTX_LDFLAGS"
   LIBS="$LIBS -lddraw -lgdi32"
   AC_MSG_CHECKING(for DirectDraw LDFLAGS)
-  AC_LINK_IFELSE([
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[
 #include <windows.h>
 #include <ddraw.h>
-
-int main ()
-{
+]], [[
   GetStockObject(0);
   DirectDrawCreate(NULL, NULL, NULL);
-
-  return 0;
-}
-],
+]])],
     [HAVE_DIRECTDRAW="yes"],
     [HAVE_DIRECTDRAW="no"])
   AC_MSG_RESULT($HAVE_DIRECTDRAW)
@@ -538,6 +528,36 @@ int main ()
   AC_SUBST(HAVE_DIRECTDRAW)
 ])
 
+dnl Direct3D9
+AM_CONDITIONAL(USE_DIRECT3D9, true)
+AG_GST_CHECK_FEATURE(DIRECT3D9, [Direct3D9], winscreencap, [
+  HAVE_DIRECT3D="no"
+
+  save_LIBS="$LIBS"
+
+  LIBS="$LIBS -ld3d9 -lgdi32"
+  AC_MSG_CHECKING(for Direct3D9 LDFLAGS)
+
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <windows.h>
+#include <d3d9.h>
+]], [[
+  Direct3DCreate9(D3D_SDK_VERSION);
+]])],
+    [HAVE_DIRECT3D9="yes"],
+    [HAVE_DIRECT3D9="no"])
+  AC_MSG_RESULT($HAVE_DIRECT3D9)
+
+  LIBS=$save_LIBS
+
+  if test "x$HAVE_DIRECT3D9" = "xyes";  then
+
+    DIRECT3D9_LIBS="-ld3d9 -lgdi32"
+    AC_SUBST(DIRECT3D9_LIBS)
+  fi
+  AC_SUBST(HAVE_DIRECT3D9)
+])
+
 dnl *** AppleMedia (OS X and iOS) ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_APPLE_MEDIA, true)
 HAVE_APPLE_MEDIA="no"
@@ -738,6 +758,16 @@ AG_GST_CHECK_FEATURE(CELT, [celt], celt, [
   AC_SUBST(CELT_LIBS)
 ])
 
+dnl *** chromaprint ***
+translit(dnm, m, l) AM_CONDITIONAL(USE_CHROMAPRINT, true)
+AG_GST_CHECK_FEATURE(CHROMAPRINT, [chromaprint], chromaprint, [
+  PKG_CHECK_MODULES(CHROMAPRINT, libchromaprint, HAVE_CHROMAPRINT="yes", [
+    HAVE_CHROMAPRINT="no"
+  ])
+  AC_SUBST(CHROMAPRINT_CFLAGS)
+  AC_SUBST(CHROMAPRINT_LIBS)
+])
+
 dnl *** Cog ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_COG, true)
 AG_GST_CHECK_FEATURE(COG, [Cog plugin], cog, [
@@ -796,11 +826,23 @@ AG_GST_CHECK_FEATURE(DECKLINK, [decklink], decklink, [
            ])
        fi
        ;;
+     *-*darwin*)
+       if test "x$HAVE_PTHREAD_H" = "xyes"; then
+         AC_CHECK_LIB(dl, dlopen,
+           [
+            HAVE_DECKLINK=yes
+            DECKLINK_CXXFLAGS=
+            DECKLINK_LIBS="-lpthread -ldl"
+	    HAVE_DECKLINK_OSX=yes
+           ])
+       fi
+       ;;
      *)
        HAVE_DECKLINK=no
        ;;
    esac
 
+   AM_CONDITIONAL(DECKLINK_OSX, test "x$HAVE_DECKLINK_OSX" = xyes)
    AC_SUBST(DECKLINK_CXXFLAGS)
    AC_SUBST(DECKLINK_LIBS)
 ])
@@ -813,6 +855,31 @@ AG_GST_CHECK_FEATURE(DIRECTFB, [directfb], dfbvideosink , [
   ])
 ])
 
+dnl **** Wayland ****
+translit(dnm, m, l) AM_CONDITIONAL(USE_WAYLAND, true)
+AG_GST_CHECK_FEATURE(WAYLAND, [wayland sink], wayland , [
+  PKG_CHECK_MODULES(WAYLAND, wayland-client >= 0.1, [
+    AC_CHECK_HEADER(wayland-client.h, HAVE_WAYLAND_CLIENT="yes", HAVE_WAYLAND_CLIENT="no")
+    AC_CHECK_HEADER(wayland-client-protocol.h, HAVE_WAYLAND_CLIENT_PROTOCOL="yes", HAVE_WAYLAND_CLIENT_PROTOCOL="no")
+    if test "x$HAVE_WAYLAND_CLIENT" = "xno"; then
+      AC_MSG_RESULT(wayland-client.h could not be found.)
+      HAVE_WAYLAND="no"
+    elif test "x$HAVE_WAYLAND_CLIENT_PROTOCOL" = "xno"; then
+      AC_MSG_RESULT(wayland-client-protocol.h could not be found.)
+      HAVE_WAYLAND="no"
+    else
+      HAVE_WAYLAND="yes"
+      WAYLAND_LIBS="-lwayland-client"
+    fi
+  ], [
+    AC_MSG_RESULT(no wayland.)
+    HAVE_WAYLAND="no"
+  ])
+WAYLAND_CFLAGS=""
+AC_SUBST(WAYLAND_CFLAGS)
+AC_SUBST(WAYLAND_LIBS)
+])
+
 dnl **** Dirac ****
 translit(dnm, m, l) AM_CONDITIONAL(USE_DIRAC, true)
 AG_GST_CHECK_FEATURE(DIRAC, [dirac], dirac, [
@@ -1377,22 +1444,22 @@ AG_GST_CHECK_FEATURE(OPENCV, [opencv plugins], opencv, [
     AC_LANG_CPLUSPLUS
     OLD_CPPFLAGS=$CPPFLAGS
     CPPFLAGS=$OPENCV_CFLAGS
-    AC_CHECK_HEADER(highgui.h, HAVE_HIGHGUI="yes", HAVE_HIGHGUI="no")
-    AC_CHECK_HEADER(cvaux.h, HAVE_CVAUX="yes", HAVE_CVAUX="no")
+    AC_CHECK_HEADERS([highgui.h opencv2/highgui/highgui_c.h])
     CPPFLAGS=$OLD_CPPFLAGS
     AC_LANG_C
-    if test "x$HAVE_HIGHGUI" = "xno"; then
-      AC_MSG_RESULT(highgui.h could not be found.)
-      HAVE_OPENCV="no"
-    elif test "x$HAVE_CVAUX" = "xno"; then
-      AC_MSG_RESULT(cvaux.h could not be found.)
-      HAVE_OPENCV="no"
-    else
+
+    if test $ac_cv_header_highgui_h = "yes" -o $ac_cv_header_opencv2_highgui_highgui_c_h = "yes" ; then
       HAVE_OPENCV="yes"
+    else
+      AC_MSG_RESULT([neither highgui.h nor opencv2/highgui/highgui_c.h could not be found])
+      HAVE_OPENCV="no"
     fi
   ], [
     HAVE_OPENCV="no"
   ])
+  OPENCV_PREFIX="`$PKG_CONFIG --variable=prefix opencv`"
+  AC_DEFINE_UNQUOTED(OPENCV_PREFIX, "$OPENCV_PREFIX", [opencv install prefix])
+  AC_SUBST(OPENCV_PREFIX)
   AC_SUBST(OPENCV_CFLAGS)
   AC_SUBST(OPENCV_LIBS)
 ])
@@ -1695,7 +1762,7 @@ AG_GST_CHECK_FEATURE(VDPAU, [VDPAU], vdpau, [
 dnl *** schroedinger ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_SCHRO, true)
 AG_GST_CHECK_FEATURE(SCHRO, [Schroedinger video codec], schro, [
-  AG_GST_PKG_CHECK_MODULES(SCHRO, schroedinger-1.0 >= 1.0.7)
+  AG_GST_PKG_CHECK_MODULES(SCHRO, schroedinger-1.0 >= 1.0.10)
 ])
 
 dnl *** zbar ***
@@ -1783,11 +1850,13 @@ AM_CONDITIONAL(USE_APEXSINK, false)
 AM_CONDITIONAL(USE_BZ2, false)
 AM_CONDITIONAL(USE_CDAUDIO, false)
 AM_CONDITIONAL(USE_CELT, false)
+AM_CONDITIONAL(USE_CHROMAPRINT, false)
 AM_CONDITIONAL(USE_COG, false)
 AM_CONDITIONAL(USE_CURL, false)
 AM_CONDITIONAL(USE_DC1394, false)
 AM_CONDITIONAL(USE_DECKLINK, false)
 AM_CONDITIONAL(USE_DIRECTFB, false)
+AM_CONDITIONAL(USE_WAYLAND, false)
 AM_CONDITIONAL(USE_DIRAC, false)
 AM_CONDITIONAL(USE_DTS, false)
 AM_CONDITIONAL(USE_DIVX, false)
@@ -2040,11 +2109,13 @@ ext/apexsink/Makefile
 ext/bz2/Makefile
 ext/cdaudio/Makefile
 ext/celt/Makefile
+ext/chromaprint/Makefile
 ext/cog/Makefile
 ext/curl/Makefile
 ext/dc1394/Makefile
 ext/dirac/Makefile
 ext/directfb/Makefile
+ext/wayland/Makefile
 ext/divx/Makefile
 ext/dts/Makefile
 ext/faac/Makefile
diff --git a/docs/libs/gst-plugins-bad-libs-sections.txt b/docs/libs/gst-plugins-bad-libs-sections.txt
index b949137..3cdf1a4 100644
--- a/docs/libs/gst-plugins-bad-libs-sections.txt
+++ b/docs/libs/gst-plugins-bad-libs-sections.txt
@@ -294,6 +294,7 @@ gst_base_video_encoder_get_oldest_frame
 gst_base_video_encoder_finish_frame
 gst_base_video_encoder_set_latency
 gst_base_video_encoder_set_latency_fields
+gst_base_video_encoder_set_headers
 <SUBSECTION Standard>
 GST_BASE_VIDEO_ENCODER
 GST_IS_BASE_VIDEO_ENCODER
@@ -326,6 +327,7 @@ gst_base_video_decoder_alloc_src_buffer
 gst_base_video_decoder_alloc_src_frame
 gst_base_video_decoder_get_state
 gst_base_video_decoder_get_max_decode_time
+gst_base_video_decoder_drop_frame
 gst_base_video_decoder_finish_frame
 <SUBSECTION Standard>
 GST_BASE_VIDEO_DECODER
@@ -336,10 +338,17 @@ GST_BASE_VIDEO_DECODER_CLASS
 GST_IS_BASE_VIDEO_DECODER_CLASS
 GST_BASE_VIDEO_DECODER_GET_CLASS
 </SECTION>
-
+yes
 <SECTION>
 <FILE>gstbasevideocodec</FILE>
 <TITLE>GstBaseVideoCodec</TITLE>
+GstBaseVideoCodec
+GstVideoFrame
+gst_video_frame_ref
+gst_video_frame_unref
+gst_base_video_codec_new_frame
+GstVideoState
+gst_video_state_get_timestamp
 GST_BASE_VIDEO_CODEC_SINK_NAME
 GST_BASE_VIDEO_CODEC_SRC_NAME
 GST_BASE_VIDEO_CODEC_SRC_PAD
@@ -347,13 +356,8 @@ GST_BASE_VIDEO_CODEC_SINK_PAD
 GST_BASE_VIDEO_CODEC_FLOW_NEED_DATA
 GST_BASE_VIDEO_CODEC_STREAM_LOCK
 GST_BASE_VIDEO_CODEC_STREAM_UNLOCK
-GstVideoState
-GstVideoFrame
-GstBaseVideoCodec
-GstBaseVideoCodecClass
-gst_base_video_codec_new_frame
-gst_base_video_codec_free_frame
 <SUBSECTION Standard>
+GstBaseVideoCodecClass
 GST_BASE_VIDEO_CODEC
 GST_IS_BASE_VIDEO_CODEC
 GST_TYPE_BASE_VIDEO_CODEC
@@ -361,6 +365,7 @@ gst_base_video_codec_get_type
 GST_BASE_VIDEO_CODEC_CLASS
 GST_IS_BASE_VIDEO_CODEC_CLASS
 GST_BASE_VIDEO_CODEC_GET_CLASS
+gst_video_frame_get_type
 </SECTION>
 
 <SECTION>
@@ -437,7 +442,6 @@ gst_camerabin_preview_set_caps
 <FILE>gstbasevideoutils</FILE>
 gst_base_video_rawvideo_convert
 gst_base_video_encoded_video_convert
-gst_video_state_get_timestamp
 </SECTION>
 
 <SECTION>
diff --git a/docs/plugins/gst-plugins-bad-plugins.args b/docs/plugins/gst-plugins-bad-plugins.args
index 31bb1b5..a52f378 100644
--- a/docs/plugins/gst-plugins-bad-plugins.args
+++ b/docs/plugins/gst-plugins-bad-plugins.args
@@ -51,7 +51,7 @@
 <ARG>
 <NAME>GstXvidEnc::averaging-period</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,100]</RANGE>
+<RANGE>[G_MAXULONG,100]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Averaging Period</NICK>
 <BLURB>[CBR] Number of frames for which XviD averages bitrate.</BLURB>
@@ -101,7 +101,7 @@
 <ARG>
 <NAME>GstXvidEnc::buffer</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Buffer Size</NICK>
 <BLURB>[CBR] Size of the video buffers.</BLURB>
@@ -131,7 +131,7 @@
 <ARG>
 <NAME>GstXvidEnc::container-frame-overhead</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,100]</RANGE>
+<RANGE>[G_MAXULONG,100]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Container Frame Overhead</NICK>
 <BLURB>[PASS2] Average container overhead per frame.</BLURB>
@@ -161,7 +161,7 @@
 <ARG>
 <NAME>GstXvidEnc::flow-control-strength</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,100]</RANGE>
+<RANGE>[G_MAXULONG,100]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Flow Control Strength</NICK>
 <BLURB>[PASS2] Overflow control strength per frame.</BLURB>
@@ -221,7 +221,7 @@
 <ARG>
 <NAME>GstXvidEnc::keyframe-reduction</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,100]</RANGE>
+<RANGE>[G_MAXULONG,100]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Keyframe Reduction</NICK>
 <BLURB>[PASS2] Keyframe size reduction in % of those within threshold.</BLURB>
@@ -231,7 +231,7 @@
 <ARG>
 <NAME>GstXvidEnc::keyframe-threshold</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,100]</RANGE>
+<RANGE>[G_MAXULONG,100]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Keyframe Threshold</NICK>
 <BLURB>[PASS2] Distance between keyframes not to be subject to reduction.</BLURB>
@@ -291,7 +291,7 @@
 <ARG>
 <NAME>GstXvidEnc::max-overflow-degradation</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,100]</RANGE>
+<RANGE>[G_MAXULONG,100]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Max Overflow Degradation</NICK>
 <BLURB>[PASS2] Amount in % that flow control can decrease frame size compared to ideal curve.</BLURB>
@@ -301,7 +301,7 @@
 <ARG>
 <NAME>GstXvidEnc::max-overflow-improvement</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,100]</RANGE>
+<RANGE>[G_MAXULONG,100]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Max Overflow Improvement</NICK>
 <BLURB>[PASS2] Amount in % that flow control can increase frame size compared to ideal curve.</BLURB>
@@ -431,7 +431,7 @@
 <ARG>
 <NAME>GstXvidEnc::reaction-delay-factor</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,100]</RANGE>
+<RANGE>[G_MAXULONG,100]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Reaction Delay Factor</NICK>
 <BLURB>[CBR] Reaction delay factor.</BLURB>
@@ -861,7 +861,7 @@
 <ARG>
 <NAME>GstMpeg2enc::max-gop-size</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,250]</RANGE>
+<RANGE>[G_MAXULONG,250]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Max. GOP size</NICK>
 <BLURB>Maximal size per Group-of-Pictures (-1=default).</BLURB>
@@ -871,7 +871,7 @@
 <ARG>
 <NAME>GstMpeg2enc::min-gop-size</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,250]</RANGE>
+<RANGE>[G_MAXULONG,250]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Min. GOP size</NICK>
 <BLURB>Minimal size per Group-of-Pictures (-1=default).</BLURB>
@@ -951,7 +951,7 @@
 <ARG>
 <NAME>GstMpeg2enc::quantisation</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,31]</RANGE>
+<RANGE>[G_MAXULONG,31]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Quantisation</NICK>
 <BLURB>Quantisation factor (-1=cbr, 0=default, 1=best, 31=worst).</BLURB>
@@ -1731,7 +1731,7 @@
 <ARG>
 <NAME>GstDvbSrc::diseqc-source</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,7]</RANGE>
+<RANGE>[G_MAXULONG,7]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>diseqc source</NICK>
 <BLURB>DISEqC selected source (-1 disabled) (DVB-S).</BLURB>
@@ -12121,7 +12121,7 @@
 <ARG>
 <NAME>ladspa-gate::Output-select</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,1]</RANGE>
+<RANGE>[G_MAXULONG,1]</RANGE>
 <FLAGS>rwx</FLAGS>
 <NICK>Output-select</NICK>
 <BLURB>Output-select.</BLURB>
@@ -17881,7 +17881,7 @@
 <ARG>
 <NAME>DvbBaseBin::diseqc-source</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,7]</RANGE>
+<RANGE>[G_MAXULONG,7]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>diseqc source</NICK>
 <BLURB>DISEqC selected source (-1 disabled) (DVB-S).</BLURB>
@@ -18826,7 +18826,7 @@
 <ARG>
 <NAME>GstAppSrc::size</NAME>
 <TYPE>gint64</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Size</NICK>
 <BLURB>The size of the data stream (-1 if unknown).</BLURB>
@@ -22056,7 +22056,7 @@
 <ARG>
 <NAME>GstDCCPClientSrc::sockfd</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Socket fd</NICK>
 <BLURB>The socket file descriptor.</BLURB>
@@ -22096,7 +22096,7 @@
 <ARG>
 <NAME>GstDCCPServerSink::sockfd</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Socket fd</NICK>
 <BLURB>The client socket file descriptor.</BLURB>
@@ -22156,7 +22156,7 @@
 <ARG>
 <NAME>GstDCCPClientSink::sockfd</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Socket fd</NICK>
 <BLURB>The socket file descriptor.</BLURB>
@@ -22216,7 +22216,7 @@
 <ARG>
 <NAME>GstDCCPServerSrc::sockfd</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Socket fd</NICK>
 <BLURB>The client socket file descriptor.</BLURB>
@@ -22276,7 +22276,7 @@
 <ARG>
 <NAME>GstMpegTSDemux::program-number</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Program Number</NICK>
 <BLURB>Program number to demux for (-1 to ignore).</BLURB>
@@ -22336,7 +22336,7 @@
 <ARG>
 <NAME>GstPcapParse::dst-port</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,65535]</RANGE>
+<RANGE>[G_MAXULONG,65535]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Destination port</NICK>
 <BLURB>Destination port to restrict to.</BLURB>
@@ -22356,7 +22356,7 @@
 <ARG>
 <NAME>GstPcapParse::src-port</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,65535]</RANGE>
+<RANGE>[G_MAXULONG,65535]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Source port</NICK>
 <BLURB>Source port to restrict to.</BLURB>
@@ -22376,7 +22376,7 @@
 <ARG>
 <NAME>GstPcapParse::ts-offset</NAME>
 <TYPE>gint64</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Timestamp Offset</NICK>
 <BLURB>Relative timestamp offset (ns) to apply (-1 = use absolute packet time).</BLURB>
@@ -23396,7 +23396,7 @@
 <ARG>
 <NAME>GstRTPDTMFSrc::seqnum-offset</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Sequence number Offset</NICK>
 <BLURB>Offset to add to all outgoing seqnum (-1 = random).</BLURB>
@@ -23426,7 +23426,7 @@
 <ARG>
 <NAME>GstRTPDTMFSrc::timestamp-offset</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Timestamp Offset</NICK>
 <BLURB>Offset to add to all outgoing timestamps (-1 = random).</BLURB>
@@ -23476,7 +23476,7 @@
 <ARG>
 <NAME>GstRTPMux::seqnum-offset</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Sequence number Offset</NICK>
 <BLURB>Offset to add to all outgoing seqnum (-1 = random).</BLURB>
@@ -23496,7 +23496,7 @@
 <ARG>
 <NAME>GstRTPMux::timestamp-offset</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Timestamp Offset</NICK>
 <BLURB>Offset to add to all outgoing timestamps (-1 = random).</BLURB>
@@ -26670,7 +26670,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>physics</NICK>
 <BLURB>water density: from 1 to 4.</BLURB>
-<DEFAULT>4.77831e-299</DEFAULT>
+<DEFAULT>7.7486e-304</DEFAULT>
 </ARG>
 
 <ARG>
@@ -26710,7 +26710,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>splash</NICK>
 <BLURB>make a big splash in the center.</BLURB>
-<DEFAULT>4.77773e-299</DEFAULT>
+<DEFAULT>8.20074e-304</DEFAULT>
 </ARG>
 
 <ARG>
@@ -26720,7 +26720,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>splash</NICK>
 <BLURB>make a big splash in the center.</BLURB>
-<DEFAULT>0</DEFAULT>
+<DEFAULT>4.77773e-299</DEFAULT>
 </ARG>
 
 <ARG>
@@ -26750,7 +26750,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>ratiox</NICK>
 <BLURB>x-ratio.</BLURB>
-<DEFAULT>0</DEFAULT>
+<DEFAULT>1.82049e-316</DEFAULT>
 </ARG>
 
 <ARG>
@@ -26760,7 +26760,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>ratioy</NICK>
 <BLURB>y-ratio.</BLURB>
-<DEFAULT>0</DEFAULT>
+<DEFAULT>-3.77929e+138</DEFAULT>
 </ARG>
 
 <ARG>
@@ -26820,7 +26820,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>Color-R</NICK>
 <BLURB>the color of the image.</BLURB>
-<DEFAULT>0</DEFAULT>
+<DEFAULT>1.30952e-37</DEFAULT>
 </ARG>
 
 <ARG>
@@ -27150,7 +27150,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>lredscale</NICK>
 <BLURB>multiplier for downscaling non-edge brightness.</BLURB>
-<DEFAULT>6.28747e-311</DEFAULT>
+<DEFAULT>2.34986e-310</DEFAULT>
 </ARG>
 
 <ARG>
@@ -27160,7 +27160,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>lthresh</NICK>
 <BLURB>threshold for edge lightening.</BLURB>
-<DEFAULT>6.9235e+228</DEFAULT>
+<DEFAULT>2.34969e-310</DEFAULT>
 </ARG>
 
 <ARG>
@@ -27170,7 +27170,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>lupscale</NICK>
 <BLURB>multiplier for upscaling edge brightness.</BLURB>
-<DEFAULT>1.36347e+161</DEFAULT>
+<DEFAULT>1.59292e-316</DEFAULT>
 </ARG>
 
 <ARG>
@@ -27340,7 +27340,7 @@
 <FLAGS>rw</FLAGS>
 <NICK>blend</NICK>
 <BLURB>blend factor.</BLURB>
-<DEFAULT>4.77831e-299</DEFAULT>
+<DEFAULT>0</DEFAULT>
 </ARG>
 
 <ARG>
@@ -47106,7 +47106,7 @@
 <ARG>
 <NAME>GstJP2kDecimator::max-decomposition-levels</NAME>
 <TYPE>gint</TYPE>
-<RANGE>[-1,32]</RANGE>
+<RANGE>[G_MAXULONG,32]</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Maximum Number of Decomposition Levels</NICK>
 <BLURB>Maximum number of decomposition levels to keep (-1 == all).</BLURB>
@@ -47496,7 +47496,7 @@
 <ARG>
 <NAME>GstTSDemux::program-number</NAME>
 <TYPE>gint</TYPE>
-<RANGE>>= -1</RANGE>
+<RANGE>>= G_MAXULONG</RANGE>
 <FLAGS>rw</FLAGS>
 <NICK>Program number</NICK>
 <BLURB>Program Number to demux for (-1 to ignore).</BLURB>
@@ -57934,6 +57934,46 @@
 </ARG>
 
 <ARG>
+<NAME>GstInterVideoSrc::channel</NAME>
+<TYPE>gchar*</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Channel</NICK>
+<BLURB>Channel name to match inter src and sink elements.</BLURB>
+<DEFAULT>"default"</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstInterVideoSink::channel</NAME>
+<TYPE>gchar*</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Channel</NICK>
+<BLURB>Channel name to match inter src and sink elements.</BLURB>
+<DEFAULT>"default"</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstInterAudioSrc::channel</NAME>
+<TYPE>gchar*</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Channel</NICK>
+<BLURB>Channel name to match inter src and sink elements.</BLURB>
+<DEFAULT>"default"</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstInterAudioSink::channel</NAME>
+<TYPE>gchar*</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Channel</NICK>
+<BLURB>Channel name to match inter src and sink elements.</BLURB>
+<DEFAULT>"default"</DEFAULT>
+</ARG>
+
+<ARG>
 <NAME>GstSmooth::active</NAME>
 <TYPE>gboolean</TYPE>
 <RANGE></RANGE>
@@ -58023,3 +58063,23 @@
 <DEFAULT>FALSE</DEFAULT>
 </ARG>
 
+<ARG>
+<NAME>GstChromaprint::duration</NAME>
+<TYPE>guint</TYPE>
+<RANGE></RANGE>
+<FLAGS>rw</FLAGS>
+<NICK>Duration limit</NICK>
+<BLURB>Number of seconds of audio to use for fingerprinting.</BLURB>
+<DEFAULT>120</DEFAULT>
+</ARG>
+
+<ARG>
+<NAME>GstChromaprint::fingerprint</NAME>
+<TYPE>gchar*</TYPE>
+<RANGE></RANGE>
+<FLAGS>r</FLAGS>
+<NICK>Resulting fingerprint</NICK>
+<BLURB>Resulting fingerprint.</BLURB>
+<DEFAULT>NULL</DEFAULT>
+</ARG>
+
diff --git a/docs/plugins/gst-plugins-bad-plugins.hierarchy b/docs/plugins/gst-plugins-bad-plugins.hierarchy
index ebd6684..a8cbd2f 100644
--- a/docs/plugins/gst-plugins-bad-plugins.hierarchy
+++ b/docs/plugins/gst-plugins-bad-plugins.hierarchy
@@ -1,28 +1,27 @@
 GObject
-  GstAdapter
   GstColorBalanceChannel
-  GstMixerTrack
-    GstMixerOptions
   GstObject
     GstBus
     GstClock
       GstSystemClock
         GstAudioClock
     GstElement
-      ADPCMDec
-      ADPCMEnc
       GstAiffMux
       GstAiffParse
       GstAsfMux
       GstAsfParse
       GstAssRender
       GstAudioDecoder
+        ADPCMDec
         GstCeltDec
         GstDtsDec
         GstFaad
+        GstGSMDec
       GstAudioEncoder
+        ADPCMEnc
         GstCeltEnc
         GstFaac
+        GstGSMEnc
       GstBaseAudioVisualizer
         GstSpaceScope
         GstSpectraScope
@@ -51,6 +50,7 @@ GObject
         GstDCCPServerSink
         GstFBDEVSink
         GstInterAudioSink
+        GstInterSubSink
         GstInterVideoSink
         GstLinsysSdiSink
         GstRTMPSink
@@ -63,6 +63,7 @@ GObject
         GstDTMFSrc
         GstDataURISrc
         GstInterAudioSrc
+        GstInterSubSrc
         GstInterVideoSrc
         GstLinsysSdiSrc
         GstPushSrc
@@ -88,6 +89,7 @@ GObject
       GstBaseTransform
         GstAudioFilter
           GstBPMDetect
+          GstChromaprint
           GstOFA
           GstStereo
         GstBayer2RGB
@@ -235,8 +237,6 @@ GObject
       GstFestival
       GstFieldAnalysis
       GstFreeze
-      GstGSMDec
-      GstGSMEnc
       GstHLSDemux
       GstInterlace
       GstIvfParse
diff --git a/docs/plugins/gst-plugins-bad-plugins.interfaces b/docs/plugins/gst-plugins-bad-plugins.interfaces
index 0420c8b..994ac3c 100644
--- a/docs/plugins/gst-plugins-bad-plugins.interfaces
+++ b/docs/plugins/gst-plugins-bad-plugins.interfaces
@@ -1,3 +1,4 @@
+ADPCMEnc GstPreset
 DvbBaseBin GstChildProxy GstURIHandler
 GstAmrWbEnc GstPreset
 GstApExSink GstImplementsInterface GstMixer
@@ -20,6 +21,7 @@ GstFPSDisplaySink GstChildProxy
 GstFaac GstPreset
 GstFaceOverlay GstChildProxy
 GstFreeverb GstPreset
+GstGSMEnc GstPreset
 GstGSettingsAudioSink GstChildProxy
 GstGSettingsAudioSrc GstChildProxy
 GstGSettingsSwitchSink GstChildProxy
diff --git a/docs/plugins/inspect/plugin-adpcmdec.xml b/docs/plugins/inspect/plugin-adpcmdec.xml
index 088b0ce..6c14c7c 100644
--- a/docs/plugins/inspect/plugin-adpcmdec.xml
+++ b/docs/plugins/inspect/plugin-adpcmdec.xml
@@ -3,10 +3,10 @@
   <description>ADPCM decoder</description>
   <filename>../../gst/adpcmdec/.libs/libgstadpcmdec.so</filename>
   <basename>libgstadpcmdec.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-adpcmenc.xml b/docs/plugins/inspect/plugin-adpcmenc.xml
index 7b4356b..6931a29 100644
--- a/docs/plugins/inspect/plugin-adpcmenc.xml
+++ b/docs/plugins/inspect/plugin-adpcmenc.xml
@@ -3,10 +3,10 @@
   <description>ADPCM encoder</description>
   <filename>../../gst/adpcmenc/.libs/libgstadpcmenc.so</filename>
   <basename>libgstadpcmenc.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-aiff.xml b/docs/plugins/inspect/plugin-aiff.xml
index 894b171..b6ed536 100644
--- a/docs/plugins/inspect/plugin-aiff.xml
+++ b/docs/plugins/inspect/plugin-aiff.xml
@@ -3,10 +3,10 @@
   <description>Create and parse Audio Interchange File Format (AIFF) files</description>
   <filename>../../gst/aiff/.libs/libgstaiff.so</filename>
   <basename>libgstaiff.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-apexsink.xml b/docs/plugins/inspect/plugin-apexsink.xml
index d3b56fd..ae6e639 100644
--- a/docs/plugins/inspect/plugin-apexsink.xml
+++ b/docs/plugins/inspect/plugin-apexsink.xml
@@ -3,10 +3,10 @@
   <description>Apple AirPort Express Plugin</description>
   <filename>../../ext/apexsink/.libs/libgstapexsink.so</filename>
   <basename>libgstapexsink.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-asfmux.xml b/docs/plugins/inspect/plugin-asfmux.xml
index 70d557b..20f137b 100644
--- a/docs/plugins/inspect/plugin-asfmux.xml
+++ b/docs/plugins/inspect/plugin-asfmux.xml
@@ -3,10 +3,10 @@
   <description>ASF Muxer Plugin</description>
   <filename>../../gst/asfmux/.libs/libgstasfmux.so</filename>
   <basename>libgstasfmux.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-assrender.xml b/docs/plugins/inspect/plugin-assrender.xml
index 1e8830a..b719d19 100644
--- a/docs/plugins/inspect/plugin-assrender.xml
+++ b/docs/plugins/inspect/plugin-assrender.xml
@@ -3,10 +3,10 @@
   <description>ASS/SSA subtitle renderer</description>
   <filename>../../ext/assrender/.libs/libgstassrender.so</filename>
   <basename>libgstassrender.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-audiovisualizers.xml b/docs/plugins/inspect/plugin-audiovisualizers.xml
index 2c7431d..39663fb 100644
--- a/docs/plugins/inspect/plugin-audiovisualizers.xml
+++ b/docs/plugins/inspect/plugin-audiovisualizers.xml
@@ -3,10 +3,10 @@
   <description>Creates video visualizations of audio input</description>
   <filename>../../gst/audiovisualizers/.libs/libgstaudiovisualizers.so</filename>
   <basename>libgstaudiovisualizers.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>GPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-autoconvert.xml b/docs/plugins/inspect/plugin-autoconvert.xml
index b26bef2..7083fed 100644
--- a/docs/plugins/inspect/plugin-autoconvert.xml
+++ b/docs/plugins/inspect/plugin-autoconvert.xml
@@ -3,10 +3,10 @@
   <description>Selects convertor element based on caps</description>
   <filename>../../gst/autoconvert/.libs/libgstautoconvert.so</filename>
   <basename>libgstautoconvert.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-bayer.xml b/docs/plugins/inspect/plugin-bayer.xml
index 59de637..8352a7c 100644
--- a/docs/plugins/inspect/plugin-bayer.xml
+++ b/docs/plugins/inspect/plugin-bayer.xml
@@ -3,10 +3,10 @@
   <description>Elements to convert Bayer images</description>
   <filename>../../gst/bayer/.libs/libgstbayer.so</filename>
   <basename>libgstbayer.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-bz2.xml b/docs/plugins/inspect/plugin-bz2.xml
index 41ccb5c..75ceedd 100644
--- a/docs/plugins/inspect/plugin-bz2.xml
+++ b/docs/plugins/inspect/plugin-bz2.xml
@@ -3,10 +3,10 @@
   <description>Compress or decompress streams</description>
   <filename>../../ext/bz2/.libs/libgstbz2.so</filename>
   <basename>libgstbz2.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-camerabin.xml b/docs/plugins/inspect/plugin-camerabin.xml
index 4a45cab..b9d6b0e 100644
--- a/docs/plugins/inspect/plugin-camerabin.xml
+++ b/docs/plugins/inspect/plugin-camerabin.xml
@@ -3,10 +3,10 @@
   <description>High level api for DC (Digital Camera) application</description>
   <filename>../../gst/camerabin/.libs/libgstcamerabin.so</filename>
   <basename>libgstcamerabin.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-camerabin2.xml b/docs/plugins/inspect/plugin-camerabin2.xml
index e556420..f61bb7c 100644
--- a/docs/plugins/inspect/plugin-camerabin2.xml
+++ b/docs/plugins/inspect/plugin-camerabin2.xml
@@ -3,10 +3,10 @@
   <description>camerabin2</description>
   <filename>../../gst/camerabin2/.libs/libgstcamerabin2.so</filename>
   <basename>libgstcamerabin2.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-cdaudio.xml b/docs/plugins/inspect/plugin-cdaudio.xml
index 625af0b..0bb15d0 100644
--- a/docs/plugins/inspect/plugin-cdaudio.xml
+++ b/docs/plugins/inspect/plugin-cdaudio.xml
@@ -3,10 +3,10 @@
   <description>Play CD audio through the CD Drive</description>
   <filename>../../ext/cdaudio/.libs/libgstcdaudio.so</filename>
   <basename>libgstcdaudio.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-cdxaparse.xml b/docs/plugins/inspect/plugin-cdxaparse.xml
index d210405..f870744 100644
--- a/docs/plugins/inspect/plugin-cdxaparse.xml
+++ b/docs/plugins/inspect/plugin-cdxaparse.xml
@@ -3,10 +3,10 @@
   <description>Parse a .dat file (VCD) into raw mpeg1</description>
   <filename>../../gst/cdxaparse/.libs/libgstcdxaparse.so</filename>
   <basename>libgstcdxaparse.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-celt.xml b/docs/plugins/inspect/plugin-celt.xml
index 4df3e44..d13e896 100644
--- a/docs/plugins/inspect/plugin-celt.xml
+++ b/docs/plugins/inspect/plugin-celt.xml
@@ -3,10 +3,10 @@
   <description>CELT plugin library</description>
   <filename>../../ext/celt/.libs/libgstcelt.so</filename>
   <basename>libgstcelt.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-chromaprint.xml b/docs/plugins/inspect/plugin-chromaprint.xml
new file mode 100644
index 0000000..0e88b0a
--- /dev/null
+++ b/docs/plugins/inspect/plugin-chromaprint.xml
@@ -0,0 +1,34 @@
+<plugin>
+  <name>chromaprint</name>
+  <description>Calculate Chromaprint fingerprint from audio files</description>
+  <filename>../../ext/chromaprint/.libs/libgstchromaprint.so</filename>
+  <basename>libgstchromaprint.so</basename>
+  <version>0.10.23.1</version>
+  <license>LGPL</license>
+  <source>gst-plugins-bad</source>
+  <package>GStreamer Bad Plug-ins git</package>
+  <origin>Unknown package origin</origin>
+  <elements>
+    <element>
+      <name>chromaprint</name>
+      <longname>Chromaprint fingerprinting element</longname>
+      <class>Filter/Analyzer/Audio</class>
+      <description>Find an audio fingerprint using the Chromaprint library</description>
+      <author>Lukáš Lalinský &lt;lalinsky@gmail.com&gt;</author>
+      <pads>
+        <caps>
+          <name>sink</name>
+          <direction>sink</direction>
+          <presence>always</presence>
+          <details>audio/x-raw-int, rate=(int)[ 1, 2147483647 ], channels=(int)[ 1, 2 ], endianness=(int){ 1234 }, width=(int){ 16 }, depth=(int){ 16 }, signed=(boolean)true</details>
+        </caps>
+        <caps>
+          <name>src</name>
+          <direction>source</direction>
+          <presence>always</presence>
+          <details>audio/x-raw-int, rate=(int)[ 1, 2147483647 ], channels=(int)[ 1, 2 ], endianness=(int){ 1234 }, width=(int){ 16 }, depth=(int){ 16 }, signed=(boolean)true</details>
+        </caps>
+      </pads>
+    </element>
+  </elements>
+</plugin>
\ No newline at end of file
diff --git a/docs/plugins/inspect/plugin-cog.xml b/docs/plugins/inspect/plugin-cog.xml
index 6e1152a..7b613c5 100644
--- a/docs/plugins/inspect/plugin-cog.xml
+++ b/docs/plugins/inspect/plugin-cog.xml
@@ -3,10 +3,10 @@
   <description>Cog plugin</description>
   <filename>../../ext/cog/.libs/libgstcog.so</filename>
   <basename>libgstcog.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-coloreffects.xml b/docs/plugins/inspect/plugin-coloreffects.xml
index 4ad7c73..e7291b4 100644
--- a/docs/plugins/inspect/plugin-coloreffects.xml
+++ b/docs/plugins/inspect/plugin-coloreffects.xml
@@ -3,10 +3,10 @@
   <description>Color Look-up Table filters</description>
   <filename>../../gst/coloreffects/.libs/libgstcoloreffects.so</filename>
   <basename>libgstcoloreffects.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-colorspace.xml b/docs/plugins/inspect/plugin-colorspace.xml
index 004d402..55b0b13 100644
--- a/docs/plugins/inspect/plugin-colorspace.xml
+++ b/docs/plugins/inspect/plugin-colorspace.xml
@@ -3,7 +3,7 @@
   <description>Colorspace conversion</description>
   <filename>../../gst/colorspace/.libs/libgstcolorspace.so</filename>
   <basename>libgstcolorspace.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package></package>
diff --git a/docs/plugins/inspect/plugin-curl.xml b/docs/plugins/inspect/plugin-curl.xml
index e0c62e7..4d315bd 100644
--- a/docs/plugins/inspect/plugin-curl.xml
+++ b/docs/plugins/inspect/plugin-curl.xml
@@ -3,10 +3,10 @@
   <description>libcurl-based elements</description>
   <filename>../../ext/curl/.libs/libgstcurl.so</filename>
   <basename>libgstcurl.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-dataurisrc.xml b/docs/plugins/inspect/plugin-dataurisrc.xml
index 46ede6a..038ab35 100644
--- a/docs/plugins/inspect/plugin-dataurisrc.xml
+++ b/docs/plugins/inspect/plugin-dataurisrc.xml
@@ -3,10 +3,10 @@
   <description>data: URI source</description>
   <filename>../../gst/dataurisrc/.libs/libgstdataurisrc.so</filename>
   <basename>libgstdataurisrc.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-dc1394.xml b/docs/plugins/inspect/plugin-dc1394.xml
index 5d85847..e998867 100644
--- a/docs/plugins/inspect/plugin-dc1394.xml
+++ b/docs/plugins/inspect/plugin-dc1394.xml
@@ -3,10 +3,10 @@
   <description>1394 IIDC Video Source</description>
   <filename>../../ext/dc1394/.libs/libgstdc1394.so</filename>
   <basename>libgstdc1394.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-dccp.xml b/docs/plugins/inspect/plugin-dccp.xml
index 7b0ae3e..5d9181a 100644
--- a/docs/plugins/inspect/plugin-dccp.xml
+++ b/docs/plugins/inspect/plugin-dccp.xml
@@ -3,7 +3,7 @@
   <description>transfer data over the network via DCCP.</description>
   <filename>../../gst/dccp/.libs/libgstdccp.so</filename>
   <basename>libgstdccp.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>DCCP</package>
diff --git a/docs/plugins/inspect/plugin-debugutilsbad.xml b/docs/plugins/inspect/plugin-debugutilsbad.xml
index 5c9c5c8..76e6440 100644
--- a/docs/plugins/inspect/plugin-debugutilsbad.xml
+++ b/docs/plugins/inspect/plugin-debugutilsbad.xml
@@ -3,10 +3,10 @@
   <description>Collection of elements that may or may not be useful for debugging</description>
   <filename>../../gst/debugutils/.libs/libgstdebugutilsbad.so</filename>
   <basename>libgstdebugutilsbad.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-decklink.xml b/docs/plugins/inspect/plugin-decklink.xml
index 3bc551c..d04375f 100644
--- a/docs/plugins/inspect/plugin-decklink.xml
+++ b/docs/plugins/inspect/plugin-decklink.xml
@@ -3,7 +3,7 @@
   <description>Blackmagic Decklink plugin</description>
   <filename>../../sys/decklink/.libs/libgstdecklink.so</filename>
   <basename>libgstdecklink.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer Bad Plug-ins</package>
@@ -26,7 +26,7 @@
           <name>videosink</name>
           <direction>sink</direction>
           <presence>always</presence>
-          <details>video/x-raw-yuv, format=(fourcc)UYVY, width=(int)720, height=(int)486, framerate=(fraction)30000/1001, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)720, height=(int)486, framerate=(fraction)24000/1001, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)720, height=(int)576, framerate=(fraction)25/1, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)720, height=(int)486, framerate=(fraction)30000/1001, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)720, height=(int)576, framerate=(fraction)25/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)24000/1001, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)24/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)25/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)30000/1001, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)30/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)25/1, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)30000/1001, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)30/1, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)60000/1001, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1920, height=(int)1080, framerate=(fraction)60/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1280, height=(int)720, framerate=(fraction)50/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1280, height=(int)720, framerate=(fraction)60000/1001, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc)UYVY, width=(int)1280, height=(int)720, framerate=(fraction)60/1, interlaced=(boolean)false</details>
+          <details>video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)720, height=(int)486, framerate=(fraction)30000/1001, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)720, height=(int)486, framerate=(fraction)24000/1001, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)720, height=(int)576, framerate=(fraction)25/1, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)720, height=(int)486, framerate=(fraction)30000/1001, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)720, height=(int)576, framerate=(fraction)25/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)24000/1001, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)24/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)25/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)30000/1001, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)30/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)25/1, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)30000/1001, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)30/1, interlaced=(boolean)true; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)60000/1001, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1920, height=(int)1080, framerate=(fraction)60/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1280, height=(int)720, framerate=(fraction)50/1, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1280, height=(int)720, framerate=(fraction)60000/1001, interlaced=(boolean)false; video/x-raw-yuv, format=(fourcc){ UYVY, v210 }, width=(int)1280, height=(int)720, framerate=(fraction)60/1, interlaced=(boolean)false</details>
         </caps>
       </pads>
     </element>
diff --git a/docs/plugins/inspect/plugin-dfbvideosink.xml b/docs/plugins/inspect/plugin-dfbvideosink.xml
index 7227fce..d9451a4 100644
--- a/docs/plugins/inspect/plugin-dfbvideosink.xml
+++ b/docs/plugins/inspect/plugin-dfbvideosink.xml
@@ -3,10 +3,10 @@
   <description>DirectFB video output plugin</description>
   <filename>../../ext/directfb/.libs/libgstdfbvideosink.so</filename>
   <basename>libgstdfbvideosink.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-dirac.xml b/docs/plugins/inspect/plugin-dirac.xml
index 96d7f24..8918e79 100644
--- a/docs/plugins/inspect/plugin-dirac.xml
+++ b/docs/plugins/inspect/plugin-dirac.xml
@@ -3,10 +3,10 @@
   <description>Dirac plugin</description>
   <filename>../../ext/dirac/.libs/libgstdirac.so</filename>
   <basename>libgstdirac.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-dtmf.xml b/docs/plugins/inspect/plugin-dtmf.xml
index 8f421c4..0e34206 100644
--- a/docs/plugins/inspect/plugin-dtmf.xml
+++ b/docs/plugins/inspect/plugin-dtmf.xml
@@ -3,10 +3,10 @@
   <description>DTMF plugins</description>
   <filename>../../gst/dtmf/.libs/libgstdtmf.so</filename>
   <basename>libgstdtmf.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-dtsdec.xml b/docs/plugins/inspect/plugin-dtsdec.xml
index a2badb7..d6ba5e1 100644
--- a/docs/plugins/inspect/plugin-dtsdec.xml
+++ b/docs/plugins/inspect/plugin-dtsdec.xml
@@ -3,10 +3,10 @@
   <description>Decodes DTS audio streams</description>
   <filename>../../ext/dts/.libs/libgstdtsdec.so</filename>
   <basename>libgstdtsdec.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>GPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-dvb.xml b/docs/plugins/inspect/plugin-dvb.xml
index 2b04eba..42788ff 100644
--- a/docs/plugins/inspect/plugin-dvb.xml
+++ b/docs/plugins/inspect/plugin-dvb.xml
@@ -3,10 +3,10 @@
   <description>DVB elements</description>
   <filename>../../sys/dvb/.libs/libgstdvb.so</filename>
   <basename>libgstdvb.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-dvbsuboverlay.xml b/docs/plugins/inspect/plugin-dvbsuboverlay.xml
index 7ab7755..9a9dd5f 100644
--- a/docs/plugins/inspect/plugin-dvbsuboverlay.xml
+++ b/docs/plugins/inspect/plugin-dvbsuboverlay.xml
@@ -3,10 +3,10 @@
   <description>DVB subtitle renderer</description>
   <filename>../../gst/dvbsuboverlay/.libs/libgstdvbsuboverlay.so</filename>
   <basename>libgstdvbsuboverlay.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-dvdspu.xml b/docs/plugins/inspect/plugin-dvdspu.xml
index 0670475..7c4e6c3 100644
--- a/docs/plugins/inspect/plugin-dvdspu.xml
+++ b/docs/plugins/inspect/plugin-dvdspu.xml
@@ -3,10 +3,10 @@
   <description>DVD Sub-picture Overlay element</description>
   <filename>../../gst/dvdspu/.libs/libgstdvdspu.so</filename>
   <basename>libgstdvdspu.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-faac.xml b/docs/plugins/inspect/plugin-faac.xml
index fbe3531..ccf870f 100644
--- a/docs/plugins/inspect/plugin-faac.xml
+++ b/docs/plugins/inspect/plugin-faac.xml
@@ -3,10 +3,10 @@
   <description>Free AAC Encoder (FAAC)</description>
   <filename>../../ext/faac/.libs/libgstfaac.so</filename>
   <basename>libgstfaac.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-faad.xml b/docs/plugins/inspect/plugin-faad.xml
index 82610b1..a36935b 100644
--- a/docs/plugins/inspect/plugin-faad.xml
+++ b/docs/plugins/inspect/plugin-faad.xml
@@ -3,10 +3,10 @@
   <description>Free AAC Decoder (FAAD)</description>
   <filename>../../ext/faad/.libs/libgstfaad.so</filename>
   <basename>libgstfaad.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>GPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-faceoverlay.xml b/docs/plugins/inspect/plugin-faceoverlay.xml
index 7116b79..970bf2f 100644
--- a/docs/plugins/inspect/plugin-faceoverlay.xml
+++ b/docs/plugins/inspect/plugin-faceoverlay.xml
@@ -3,7 +3,7 @@
   <description>SVG Face Overlay</description>
   <filename>../../gst/faceoverlay/.libs/libgstfaceoverlay.so</filename>
   <basename>libgstfaceoverlay.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer</package>
diff --git a/docs/plugins/inspect/plugin-fbdevsink.xml b/docs/plugins/inspect/plugin-fbdevsink.xml
index 8d551c5..09db197 100644
--- a/docs/plugins/inspect/plugin-fbdevsink.xml
+++ b/docs/plugins/inspect/plugin-fbdevsink.xml
@@ -3,10 +3,10 @@
   <description>linux framebuffer video sink</description>
   <filename>../../sys/fbdev/.libs/libgstfbdevsink.so</filename>
   <basename>libgstfbdevsink.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-festival.xml b/docs/plugins/inspect/plugin-festival.xml
index 2ff9191..d3d21ff 100644
--- a/docs/plugins/inspect/plugin-festival.xml
+++ b/docs/plugins/inspect/plugin-festival.xml
@@ -3,10 +3,10 @@
   <description>Synthesizes plain text into audio</description>
   <filename>../../gst/festival/.libs/libgstfestival.so</filename>
   <basename>libgstfestival.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-fieldanalysis.xml b/docs/plugins/inspect/plugin-fieldanalysis.xml
index de7b096..27a32cb 100644
--- a/docs/plugins/inspect/plugin-fieldanalysis.xml
+++ b/docs/plugins/inspect/plugin-fieldanalysis.xml
@@ -3,7 +3,7 @@
   <description>Video field analysis</description>
   <filename>../../gst/fieldanalysis/.libs/libgstfieldanalysis.so</filename>
   <basename>libgstfieldanalysis.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer</package>
diff --git a/docs/plugins/inspect/plugin-fragmented.xml b/docs/plugins/inspect/plugin-fragmented.xml
index 6ef8d2f..62650d6 100644
--- a/docs/plugins/inspect/plugin-fragmented.xml
+++ b/docs/plugins/inspect/plugin-fragmented.xml
@@ -3,7 +3,7 @@
   <description>Fragmented streaming plugins</description>
   <filename>../../gst/hls/.libs/libgstfragmented.so</filename>
   <basename>libgstfragmented.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer Bad Plug-ins</package>
diff --git a/docs/plugins/inspect/plugin-freeverb.xml b/docs/plugins/inspect/plugin-freeverb.xml
index f249107..e96a892 100644
--- a/docs/plugins/inspect/plugin-freeverb.xml
+++ b/docs/plugins/inspect/plugin-freeverb.xml
@@ -3,10 +3,10 @@
   <description>Reverberation/room effect</description>
   <filename>../../gst/freeverb/.libs/libgstfreeverb.so</filename>
   <basename>libgstfreeverb.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-freeze.xml b/docs/plugins/inspect/plugin-freeze.xml
index 8f21e8c..eaab6ab 100644
--- a/docs/plugins/inspect/plugin-freeze.xml
+++ b/docs/plugins/inspect/plugin-freeze.xml
@@ -3,10 +3,10 @@
   <description>Stream freezer</description>
   <filename>../../gst/freeze/.libs/libgstfreeze.so</filename>
   <basename>libgstfreeze.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-frei0r.xml b/docs/plugins/inspect/plugin-frei0r.xml
index 5c0edc4..ab8fbfa 100644
--- a/docs/plugins/inspect/plugin-frei0r.xml
+++ b/docs/plugins/inspect/plugin-frei0r.xml
@@ -3,10 +3,10 @@
   <description>frei0r plugin library</description>
   <filename>../../gst/frei0r/.libs/libgstfrei0r.so</filename>
   <basename>libgstfrei0r.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-gaudieffects.xml b/docs/plugins/inspect/plugin-gaudieffects.xml
index 116ec8e..c458ac8 100644
--- a/docs/plugins/inspect/plugin-gaudieffects.xml
+++ b/docs/plugins/inspect/plugin-gaudieffects.xml
@@ -3,7 +3,7 @@
   <description>Gaudi video effects.</description>
   <filename>../../gst/gaudieffects/.libs/libgstgaudieffects.so</filename>
   <basename>libgstgaudieffects.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer</package>
diff --git a/docs/plugins/inspect/plugin-geometrictransform.xml b/docs/plugins/inspect/plugin-geometrictransform.xml
index 2717c5d..f5e5320 100644
--- a/docs/plugins/inspect/plugin-geometrictransform.xml
+++ b/docs/plugins/inspect/plugin-geometrictransform.xml
@@ -3,10 +3,10 @@
   <description>Various geometric image transform elements</description>
   <filename>../../gst/geometrictransform/.libs/libgstgeometrictransform.so</filename>
   <basename>libgstgeometrictransform.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-gsettings.xml b/docs/plugins/inspect/plugin-gsettings.xml
index 2a5ac70..472fa4b 100644
--- a/docs/plugins/inspect/plugin-gsettings.xml
+++ b/docs/plugins/inspect/plugin-gsettings.xml
@@ -3,10 +3,10 @@
   <description>GSettings plugin</description>
   <filename>../../ext/gsettings/.libs/libgstgsettingselements.so</filename>
   <basename>libgstgsettingselements.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-gsm.xml b/docs/plugins/inspect/plugin-gsm.xml
index bd26d45..5e995d1 100644
--- a/docs/plugins/inspect/plugin-gsm.xml
+++ b/docs/plugins/inspect/plugin-gsm.xml
@@ -3,10 +3,10 @@
   <description>GSM encoder/decoder</description>
   <filename>../../ext/gsm/.libs/libgstgsm.so</filename>
   <basename>libgstgsm.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-gstsiren.xml b/docs/plugins/inspect/plugin-gstsiren.xml
index 7fbd1de..2548297 100644
--- a/docs/plugins/inspect/plugin-gstsiren.xml
+++ b/docs/plugins/inspect/plugin-gstsiren.xml
@@ -3,10 +3,10 @@
   <description>Siren encoder/decoder/payloader/depayloader plugins</description>
   <filename>../../gst/siren/.libs/libgstsiren.so</filename>
   <basename>libgstsiren.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-h264parse.xml b/docs/plugins/inspect/plugin-h264parse.xml
index c8b34a2..d037dc8 100644
--- a/docs/plugins/inspect/plugin-h264parse.xml
+++ b/docs/plugins/inspect/plugin-h264parse.xml
@@ -3,10 +3,10 @@
   <description>Element parsing raw h264 streams</description>
   <filename>../../gst/h264parse/.libs/libgsth264parse.so</filename>
   <basename>libgsth264parse.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-hdvparse.xml b/docs/plugins/inspect/plugin-hdvparse.xml
index 9a668fc..bfd251a 100644
--- a/docs/plugins/inspect/plugin-hdvparse.xml
+++ b/docs/plugins/inspect/plugin-hdvparse.xml
@@ -3,7 +3,7 @@
   <description>HDV private stream parser</description>
   <filename>../../gst/hdvparse/.libs/libgsthdvparse.so</filename>
   <basename>libgsthdvparse.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer</package>
diff --git a/docs/plugins/inspect/plugin-id3tag.xml b/docs/plugins/inspect/plugin-id3tag.xml
index 2034f4c..45f5cff 100644
--- a/docs/plugins/inspect/plugin-id3tag.xml
+++ b/docs/plugins/inspect/plugin-id3tag.xml
@@ -3,10 +3,10 @@
   <description>ID3 v1 and v2 muxing plugin</description>
   <filename>../../gst/id3tag/.libs/libgstid3tag.so</filename>
   <basename>libgstid3tag.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-inter.xml b/docs/plugins/inspect/plugin-inter.xml
index efbdd39..4883ad6 100644
--- a/docs/plugins/inspect/plugin-inter.xml
+++ b/docs/plugins/inspect/plugin-inter.xml
@@ -3,7 +3,7 @@
   <description>plugin for inter-pipeline communication</description>
   <filename>../../gst/inter/.libs/libgstinter.so</filename>
   <basename>libgstinter.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer Bad Plug-ins</package>
@@ -40,6 +40,36 @@
       </pads>
     </element>
     <element>
+      <name>intersubsink</name>
+      <longname>FIXME Long name</longname>
+      <class>Generic</class>
+      <description>FIXME Description</description>
+      <author>FIXME &lt;fixme@example.com&gt;</author>
+      <pads>
+        <caps>
+          <name>sink</name>
+          <direction>sink</direction>
+          <presence>always</presence>
+          <details>text/plain</details>
+        </caps>
+      </pads>
+    </element>
+    <element>
+      <name>intersubsrc</name>
+      <longname>Inter-pipeline subtitle source</longname>
+      <class>Source/Subtitle</class>
+      <description>Inter-pipeline subtitle source</description>
+      <author>David Schleef &lt;ds@entropywave.com&gt;</author>
+      <pads>
+        <caps>
+          <name>src</name>
+          <direction>source</direction>
+          <presence>always</presence>
+          <details>application/unknown</details>
+        </caps>
+      </pads>
+    </element>
+    <element>
       <name>intervideosink</name>
       <longname>FIXME Long name</longname>
       <class>Generic</class>
diff --git a/docs/plugins/inspect/plugin-interlace.xml b/docs/plugins/inspect/plugin-interlace.xml
index f84c6fe..ae157e8 100644
--- a/docs/plugins/inspect/plugin-interlace.xml
+++ b/docs/plugins/inspect/plugin-interlace.xml
@@ -3,10 +3,10 @@
   <description>Create an interlaced video stream</description>
   <filename>../../gst/interlace/.libs/libgstinterlace.so</filename>
   <basename>libgstinterlace.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-ivfparse.xml b/docs/plugins/inspect/plugin-ivfparse.xml
index b724818..8004f20 100644
--- a/docs/plugins/inspect/plugin-ivfparse.xml
+++ b/docs/plugins/inspect/plugin-ivfparse.xml
@@ -3,10 +3,10 @@
   <description>IVF parser</description>
   <filename>../../gst/ivfparse/.libs/libgstivfparse.so</filename>
   <basename>libgstivfparse.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-jp2kdecimator.xml b/docs/plugins/inspect/plugin-jp2kdecimator.xml
index 308ca79..805a1d9 100644
--- a/docs/plugins/inspect/plugin-jp2kdecimator.xml
+++ b/docs/plugins/inspect/plugin-jp2kdecimator.xml
@@ -3,10 +3,10 @@
   <description>JPEG2000 decimator</description>
   <filename>../../gst/jp2kdecimator/.libs/libgstjp2kdecimator.so</filename>
   <basename>libgstjp2kdecimator.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-jpegformat.xml b/docs/plugins/inspect/plugin-jpegformat.xml
index f80015e..b893f81 100644
--- a/docs/plugins/inspect/plugin-jpegformat.xml
+++ b/docs/plugins/inspect/plugin-jpegformat.xml
@@ -3,10 +3,10 @@
   <description>JPEG interchange format plugin</description>
   <filename>../../gst/jpegformat/.libs/libgstjpegformat.so</filename>
   <basename>libgstjpegformat.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-kate.xml b/docs/plugins/inspect/plugin-kate.xml
index c8ef18d..288b52f 100644
--- a/docs/plugins/inspect/plugin-kate.xml
+++ b/docs/plugins/inspect/plugin-kate.xml
@@ -3,10 +3,10 @@
   <description>Kate plugin</description>
   <filename>../../ext/kate/.libs/libgstkate.so</filename>
   <basename>libgstkate.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -110,13 +110,13 @@
           <name>video_sink</name>
           <direction>sink</direction>
           <presence>always</presence>
-          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc){ AYUV, I420, YV12, UYVY, NV12, NV21 }, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
+          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc){ I420, YV12, AYUV, YUY2, UYVY, v308, v210, v216, Y41B, Y42B, Y444, Y800, Y16 , NV12, NV21, UYVP, A420, YUV9, IYU1 }, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
         </caps>
         <caps>
           <name>src</name>
           <direction>source</direction>
           <presence>always</presence>
-          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc){ AYUV, I420, YV12, UYVY, NV12, NV21 }, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
+          <details>video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)24, endianness=(int)4321, red_mask=(int)65280, green_mask=(int)16711680, blue_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-yuv, format=(fourcc){ I420, YV12, AYUV, YUY2, UYVY, v308, v210, v216, Y41B, Y42B, Y444, Y800, Y16 , NV12, NV21, UYVP, A420, YUV9, IYU1 }, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
         </caps>
       </pads>
     </element>
diff --git a/docs/plugins/inspect/plugin-ladspa.xml b/docs/plugins/inspect/plugin-ladspa.xml
index 6d7d163..a8225e0 100644
--- a/docs/plugins/inspect/plugin-ladspa.xml
+++ b/docs/plugins/inspect/plugin-ladspa.xml
@@ -3,10 +3,10 @@
   <description>All LADSPA plugins</description>
   <filename>../../ext/ladspa/.libs/libgstladspa.so</filename>
   <basename>libgstladspa.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-legacyresample.xml b/docs/plugins/inspect/plugin-legacyresample.xml
index 077654c..77451a3 100644
--- a/docs/plugins/inspect/plugin-legacyresample.xml
+++ b/docs/plugins/inspect/plugin-legacyresample.xml
@@ -3,10 +3,10 @@
   <description>Resamples audio</description>
   <filename>../../gst/legacyresample/.libs/libgstlegacyresample.so</filename>
   <basename>libgstlegacyresample.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-linsys.xml b/docs/plugins/inspect/plugin-linsys.xml
index 9ce7b6f..d46bd38 100644
--- a/docs/plugins/inspect/plugin-linsys.xml
+++ b/docs/plugins/inspect/plugin-linsys.xml
@@ -3,7 +3,7 @@
   <description>FIXME</description>
   <filename>../../sys/linsys/.libs/libgstlinsys.so</filename>
   <basename>libgstlinsys.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer Bad Plug-ins</package>
diff --git a/docs/plugins/inspect/plugin-liveadder.xml b/docs/plugins/inspect/plugin-liveadder.xml
index 1088d04..aa3264a 100644
--- a/docs/plugins/inspect/plugin-liveadder.xml
+++ b/docs/plugins/inspect/plugin-liveadder.xml
@@ -3,10 +3,10 @@
   <description>Adds multiple live discontinuous streams</description>
   <filename>../../gst/liveadder/.libs/libgstliveadder.so</filename>
   <basename>libgstliveadder.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mimic.xml b/docs/plugins/inspect/plugin-mimic.xml
index 6e4569c..b44b5ad 100644
--- a/docs/plugins/inspect/plugin-mimic.xml
+++ b/docs/plugins/inspect/plugin-mimic.xml
@@ -3,10 +3,10 @@
   <description>Mimic codec</description>
   <filename>../../ext/mimic/.libs/libgstmimic.so</filename>
   <basename>libgstmimic.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mms.xml b/docs/plugins/inspect/plugin-mms.xml
index acbe053..9c7a89e 100644
--- a/docs/plugins/inspect/plugin-mms.xml
+++ b/docs/plugins/inspect/plugin-mms.xml
@@ -3,10 +3,10 @@
   <description>Microsoft Multi Media Server streaming protocol support</description>
   <filename>../../ext/libmms/.libs/libgstmms.so</filename>
   <basename>libgstmms.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-modplug.xml b/docs/plugins/inspect/plugin-modplug.xml
index b1582e1..f32d61a 100644
--- a/docs/plugins/inspect/plugin-modplug.xml
+++ b/docs/plugins/inspect/plugin-modplug.xml
@@ -3,10 +3,10 @@
   <description>.MOD audio decoding</description>
   <filename>../../ext/modplug/.libs/libgstmodplug.so</filename>
   <basename>libgstmodplug.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mpeg2enc.xml b/docs/plugins/inspect/plugin-mpeg2enc.xml
index 51d90ee..be6ccf5 100644
--- a/docs/plugins/inspect/plugin-mpeg2enc.xml
+++ b/docs/plugins/inspect/plugin-mpeg2enc.xml
@@ -3,10 +3,10 @@
   <description>High-quality MPEG-1/2 video encoder</description>
   <filename>../../ext/mpeg2enc/.libs/libgstmpeg2enc.so</filename>
   <basename>libgstmpeg2enc.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>GPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mpegdemux2.xml b/docs/plugins/inspect/plugin-mpegdemux2.xml
index bd5a9d5..06d4d5a 100644
--- a/docs/plugins/inspect/plugin-mpegdemux2.xml
+++ b/docs/plugins/inspect/plugin-mpegdemux2.xml
@@ -3,10 +3,10 @@
   <description>MPEG demuxers</description>
   <filename>../../gst/mpegdemux/.libs/libgstmpegdemux.so</filename>
   <basename>libgstmpegdemux.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>unknown</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mpegpsmux.xml b/docs/plugins/inspect/plugin-mpegpsmux.xml
index 51bb99e..47ff527 100644
--- a/docs/plugins/inspect/plugin-mpegpsmux.xml
+++ b/docs/plugins/inspect/plugin-mpegpsmux.xml
@@ -3,10 +3,10 @@
   <description>MPEG-PS muxer</description>
   <filename>../../gst/mpegpsmux/.libs/libgstmpegpsmux.so</filename>
   <basename>libgstmpegpsmux.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mpegtsdemux.xml b/docs/plugins/inspect/plugin-mpegtsdemux.xml
index 04c408e..b6c95d6 100644
--- a/docs/plugins/inspect/plugin-mpegtsdemux.xml
+++ b/docs/plugins/inspect/plugin-mpegtsdemux.xml
@@ -3,10 +3,10 @@
   <description>MPEG TS demuxer</description>
   <filename>../../gst/mpegtsdemux/.libs/libgstmpegtsdemux.so</filename>
   <basename>libgstmpegtsdemux.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>unknown</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -27,7 +27,7 @@ Edward Hervey &lt;edward.hervey@collabora.co.uk&gt;</author>
           <name>audio_%04x</name>
           <direction>source</direction>
           <presence>sometimes</presence>
-          <details>audio/mpeg, mpegversion=(int)1; audio/mpeg, mpegversion=(int)4, stream-format=(string)adts; audio/x-lpcm, width=(int){ 16, 20, 24 }, rate=(int){ 48000, 96000 }, channels=(int)[ 1, 8 ], dynamic_range=(int)[ 0, 255 ], emphasis=(boolean){ false, true }, mute=(boolean){ false, true }; audio/x-ac3; audio/x-eac3; audio/x-dts; audio/x-private-ts-lpcm</details>
+          <details>audio/mpeg, mpegversion=(int)1; audio/mpeg, mpegversion=(int)4, stream-format=(string){ adts, loas }; audio/x-lpcm, width=(int){ 16, 20, 24 }, rate=(int){ 48000, 96000 }, channels=(int)[ 1, 8 ], dynamic_range=(int)[ 0, 255 ], emphasis=(boolean){ false, true }, mute=(boolean){ false, true }; audio/x-ac3; audio/x-eac3; audio/x-dts; audio/x-private-ts-lpcm</details>
         </caps>
         <caps>
           <name>private_%04x</name>
diff --git a/docs/plugins/inspect/plugin-mpegtsmux.xml b/docs/plugins/inspect/plugin-mpegtsmux.xml
index 621dcd0..303bd9b 100644
--- a/docs/plugins/inspect/plugin-mpegtsmux.xml
+++ b/docs/plugins/inspect/plugin-mpegtsmux.xml
@@ -3,10 +3,10 @@
   <description>MPEG-TS muxer</description>
   <filename>../../gst/mpegtsmux/.libs/libgstmpegtsmux.so</filename>
   <basename>libgstmpegtsmux.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mpegvideoparse.xml b/docs/plugins/inspect/plugin-mpegvideoparse.xml
index 10f45a2..873316b 100644
--- a/docs/plugins/inspect/plugin-mpegvideoparse.xml
+++ b/docs/plugins/inspect/plugin-mpegvideoparse.xml
@@ -3,10 +3,10 @@
   <description>MPEG-1 and MPEG-2 video parser</description>
   <filename>../../gst/mpegvideoparse/.libs/libgstmpegvideoparse.so</filename>
   <basename>libgstmpegvideoparse.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mplex.xml b/docs/plugins/inspect/plugin-mplex.xml
index 1a5cc81..a961843 100644
--- a/docs/plugins/inspect/plugin-mplex.xml
+++ b/docs/plugins/inspect/plugin-mplex.xml
@@ -3,10 +3,10 @@
   <description>High-quality MPEG/DVD/SVCD/VCD video/audio multiplexer</description>
   <filename>../../ext/mplex/.libs/libgstmplex.so</filename>
   <basename>libgstmplex.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>GPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-musepack.xml b/docs/plugins/inspect/plugin-musepack.xml
index abb804a..7d05a48 100644
--- a/docs/plugins/inspect/plugin-musepack.xml
+++ b/docs/plugins/inspect/plugin-musepack.xml
@@ -3,10 +3,10 @@
   <description>Musepack decoder</description>
   <filename>../../ext/musepack/.libs/libgstmusepack.so</filename>
   <basename>libgstmusepack.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-musicbrainz.xml b/docs/plugins/inspect/plugin-musicbrainz.xml
index b494d33..1a5fc05 100644
--- a/docs/plugins/inspect/plugin-musicbrainz.xml
+++ b/docs/plugins/inspect/plugin-musicbrainz.xml
@@ -3,10 +3,10 @@
   <description>A TRM signature producer based on libmusicbrainz</description>
   <filename>../../ext/musicbrainz/.libs/libgsttrm.so</filename>
   <basename>libgsttrm.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mve.xml b/docs/plugins/inspect/plugin-mve.xml
index 1a0bfc6..74fcea7 100644
--- a/docs/plugins/inspect/plugin-mve.xml
+++ b/docs/plugins/inspect/plugin-mve.xml
@@ -3,10 +3,10 @@
   <description>Interplay MVE movie format manipulation</description>
   <filename>../../gst/mve/.libs/libgstmve.so</filename>
   <basename>libgstmve.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mxf.xml b/docs/plugins/inspect/plugin-mxf.xml
index 6be7427..4394d08 100644
--- a/docs/plugins/inspect/plugin-mxf.xml
+++ b/docs/plugins/inspect/plugin-mxf.xml
@@ -3,10 +3,10 @@
   <description>MXF plugin library</description>
   <filename>../../gst/mxf/.libs/libgstmxf.so</filename>
   <basename>libgstmxf.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-mythtv.xml b/docs/plugins/inspect/plugin-mythtv.xml
index 99b33f4..231c9dc 100644
--- a/docs/plugins/inspect/plugin-mythtv.xml
+++ b/docs/plugins/inspect/plugin-mythtv.xml
@@ -3,10 +3,10 @@
   <description>lib MythTV src</description>
   <filename>../../ext/mythtv/.libs/libgstmythtvsrc.so</filename>
   <basename>libgstmythtvsrc.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-neon.xml b/docs/plugins/inspect/plugin-neon.xml
index 3bc1f14..12c4c7e 100644
--- a/docs/plugins/inspect/plugin-neon.xml
+++ b/docs/plugins/inspect/plugin-neon.xml
@@ -3,10 +3,10 @@
   <description>lib neon http client src</description>
   <filename>../../ext/neon/.libs/libgstneonhttpsrc.so</filename>
   <basename>libgstneonhttpsrc.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-nsf.xml b/docs/plugins/inspect/plugin-nsf.xml
index e9b9cad..7554379 100644
--- a/docs/plugins/inspect/plugin-nsf.xml
+++ b/docs/plugins/inspect/plugin-nsf.xml
@@ -3,10 +3,10 @@
   <description>Uses nosefart to decode .nsf files</description>
   <filename>../../gst/nsf/.libs/libgstnsf.so</filename>
   <basename>libgstnsf.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>GPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-nuvdemux.xml b/docs/plugins/inspect/plugin-nuvdemux.xml
index eaf0c4b..0d4e316 100644
--- a/docs/plugins/inspect/plugin-nuvdemux.xml
+++ b/docs/plugins/inspect/plugin-nuvdemux.xml
@@ -3,10 +3,10 @@
   <description>Demuxes MythTV NuppelVideo files</description>
   <filename>../../gst/nuvdemux/.libs/libgstnuvdemux.so</filename>
   <basename>libgstnuvdemux.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-ofa.xml b/docs/plugins/inspect/plugin-ofa.xml
index 8519340..73f348d 100644
--- a/docs/plugins/inspect/plugin-ofa.xml
+++ b/docs/plugins/inspect/plugin-ofa.xml
@@ -3,10 +3,10 @@
   <description>Calculate MusicIP fingerprint from audio files</description>
   <filename>../../ext/ofa/.libs/libgstofa.so</filename>
   <basename>libgstofa.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>GPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-patchdetect.xml b/docs/plugins/inspect/plugin-patchdetect.xml
index baf5ac7..5631d48 100644
--- a/docs/plugins/inspect/plugin-patchdetect.xml
+++ b/docs/plugins/inspect/plugin-patchdetect.xml
@@ -3,7 +3,7 @@
   <description>patchdetect element</description>
   <filename>../../gst/patchdetect/.libs/libgstpatchdetect.so</filename>
   <basename>libgstpatchdetect.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer Bad Plug-ins</package>
diff --git a/docs/plugins/inspect/plugin-pcapparse.xml b/docs/plugins/inspect/plugin-pcapparse.xml
index 9cff580..1818c62 100644
--- a/docs/plugins/inspect/plugin-pcapparse.xml
+++ b/docs/plugins/inspect/plugin-pcapparse.xml
@@ -3,7 +3,7 @@
   <description>Element parsing raw pcap streams</description>
   <filename>../../gst/pcapparse/.libs/libgstpcapparse.so</filename>
   <basename>libgstpcapparse.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer</package>
diff --git a/docs/plugins/inspect/plugin-pnm.xml b/docs/plugins/inspect/plugin-pnm.xml
index b48e8f7..e630147 100644
--- a/docs/plugins/inspect/plugin-pnm.xml
+++ b/docs/plugins/inspect/plugin-pnm.xml
@@ -3,10 +3,10 @@
   <description>PNM plugin</description>
   <filename>../../gst/pnm/.libs/libgstpnm.so</filename>
   <basename>libgstpnm.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-rawparse.xml b/docs/plugins/inspect/plugin-rawparse.xml
index d9ce953..6248994 100644
--- a/docs/plugins/inspect/plugin-rawparse.xml
+++ b/docs/plugins/inspect/plugin-rawparse.xml
@@ -3,10 +3,10 @@
   <description>Parses byte streams into raw frames</description>
   <filename>../../gst/rawparse/.libs/libgstrawparse.so</filename>
   <basename>libgstrawparse.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-real.xml b/docs/plugins/inspect/plugin-real.xml
index d781465..3806dc3 100644
--- a/docs/plugins/inspect/plugin-real.xml
+++ b/docs/plugins/inspect/plugin-real.xml
@@ -3,10 +3,10 @@
   <description>Decode REAL streams</description>
   <filename>../../gst/real/.libs/libgstreal.so</filename>
   <basename>libgstreal.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-removesilence.xml b/docs/plugins/inspect/plugin-removesilence.xml
index 3003873..00e3bce 100644
--- a/docs/plugins/inspect/plugin-removesilence.xml
+++ b/docs/plugins/inspect/plugin-removesilence.xml
@@ -3,10 +3,10 @@
   <description>Removes silence from an audio stream</description>
   <filename>../../gst/removesilence/.libs/libgstremovesilence.so</filename>
   <basename>libgstremovesilence.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-resindvd.xml b/docs/plugins/inspect/plugin-resindvd.xml
index 13efc61..61848db 100644
--- a/docs/plugins/inspect/plugin-resindvd.xml
+++ b/docs/plugins/inspect/plugin-resindvd.xml
@@ -3,7 +3,7 @@
   <description>Resin DVD playback elements</description>
   <filename>../../ext/resindvd/.libs/libresindvd.so</filename>
   <basename>libresindvd.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>GPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer</package>
diff --git a/docs/plugins/inspect/plugin-rfbsrc.xml b/docs/plugins/inspect/plugin-rfbsrc.xml
index 2068035..97b501a 100644
--- a/docs/plugins/inspect/plugin-rfbsrc.xml
+++ b/docs/plugins/inspect/plugin-rfbsrc.xml
@@ -3,10 +3,10 @@
   <description>Connects to a VNC server and decodes RFB stream</description>
   <filename>../../gst/librfb/.libs/libgstrfbsrc.so</filename>
   <basename>libgstrfbsrc.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-rsvg.xml b/docs/plugins/inspect/plugin-rsvg.xml
index 8c9e329..94c31f3 100644
--- a/docs/plugins/inspect/plugin-rsvg.xml
+++ b/docs/plugins/inspect/plugin-rsvg.xml
@@ -3,10 +3,10 @@
   <description>RSVG plugin library</description>
   <filename>../../ext/rsvg/.libs/libgstrsvg.so</filename>
   <basename>libgstrsvg.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-rtmp.xml b/docs/plugins/inspect/plugin-rtmp.xml
index ca6c8e4..446cc4c 100644
--- a/docs/plugins/inspect/plugin-rtmp.xml
+++ b/docs/plugins/inspect/plugin-rtmp.xml
@@ -3,10 +3,10 @@
   <description>RTMP source and sink</description>
   <filename>../../ext/rtmp/.libs/libgstrtmp.so</filename>
   <basename>libgstrtmp.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-rtpmux.xml b/docs/plugins/inspect/plugin-rtpmux.xml
index b6b295d..c4fe730 100644
--- a/docs/plugins/inspect/plugin-rtpmux.xml
+++ b/docs/plugins/inspect/plugin-rtpmux.xml
@@ -3,10 +3,10 @@
   <description>RTP Muxer plugins</description>
   <filename>../../gst/rtpmux/.libs/libgstrtpmux.so</filename>
   <basename>libgstrtpmux.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-rtpvp8.xml b/docs/plugins/inspect/plugin-rtpvp8.xml
index 94a7d35..52a7545 100644
--- a/docs/plugins/inspect/plugin-rtpvp8.xml
+++ b/docs/plugins/inspect/plugin-rtpvp8.xml
@@ -3,10 +3,10 @@
   <description>rtpvp8</description>
   <filename>../../gst/rtpvp8/.libs/libgstrtpvp8.so</filename>
   <basename>libgstrtpvp8.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-scaletempo.xml b/docs/plugins/inspect/plugin-scaletempo.xml
index 55437ce..cbecfc8 100644
--- a/docs/plugins/inspect/plugin-scaletempo.xml
+++ b/docs/plugins/inspect/plugin-scaletempo.xml
@@ -3,7 +3,7 @@
   <description>Scale audio tempo in sync with playback rate</description>
   <filename>../../gst/scaletempo/.libs/libgstscaletempoplugin.so</filename>
   <basename>libgstscaletempoplugin.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer</package>
diff --git a/docs/plugins/inspect/plugin-schro.xml b/docs/plugins/inspect/plugin-schro.xml
index c2425b6..9112897 100644
--- a/docs/plugins/inspect/plugin-schro.xml
+++ b/docs/plugins/inspect/plugin-schro.xml
@@ -3,10 +3,10 @@
   <description>Schroedinger plugin</description>
   <filename>../../ext/schroedinger/.libs/libgstschro.so</filename>
   <basename>libgstschro.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -26,7 +26,7 @@
           <name>src</name>
           <direction>source</direction>
           <presence>always</presence>
-          <details>video/x-raw-yuv, format=(fourcc){ I420, YUY2, AYUV }, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
+          <details>video/x-raw-yuv, format=(fourcc){ I420, YV12, YUY2, UYVY, AYUV, Y42B, Y444, v216, v210, AY64 }, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]; video/x-raw-rgb, bpp=(int)32, depth=(int)32, endianness=(int)4321, red_mask=(int)16711680, green_mask=(int)65280, blue_mask=(int)255, alpha_mask=(int)-16777216, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
         </caps>
       </pads>
     </element>
@@ -41,7 +41,7 @@
           <name>sink</name>
           <direction>sink</direction>
           <presence>always</presence>
-          <details>video/x-raw-yuv, format=(fourcc){ I420, YV12, YUY2, UYVY, AYUV }, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
+          <details>video/x-raw-yuv, format=(fourcc){ I420, YV12, YUY2, UYVY, AYUV, Y42B, Y444, v216, v210, AY64 }, width=(int)[ 1, 2147483647 ], height=(int)[ 1, 2147483647 ], framerate=(fraction)[ 0/1, 2147483647/1 ]</details>
         </caps>
         <caps>
           <name>src</name>
diff --git a/docs/plugins/inspect/plugin-sdi.xml b/docs/plugins/inspect/plugin-sdi.xml
index 8b941fe..43e8d6b 100644
--- a/docs/plugins/inspect/plugin-sdi.xml
+++ b/docs/plugins/inspect/plugin-sdi.xml
@@ -3,7 +3,7 @@
   <description>SDI elements</description>
   <filename>../../gst/sdi/.libs/libgstsdi.so</filename>
   <basename>libgstsdi.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer Bad Plug-ins</package>
diff --git a/docs/plugins/inspect/plugin-sdp.xml b/docs/plugins/inspect/plugin-sdp.xml
index 832c160..4b2b42a 100644
--- a/docs/plugins/inspect/plugin-sdp.xml
+++ b/docs/plugins/inspect/plugin-sdp.xml
@@ -3,10 +3,10 @@
   <description>configure streaming sessions using SDP</description>
   <filename>../../gst/sdp/.libs/libgstsdpelem.so</filename>
   <basename>libgstsdpelem.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-segmentclip.xml b/docs/plugins/inspect/plugin-segmentclip.xml
index d8d7e06..1af2ccb 100644
--- a/docs/plugins/inspect/plugin-segmentclip.xml
+++ b/docs/plugins/inspect/plugin-segmentclip.xml
@@ -3,10 +3,10 @@
   <description>Segment clip elements</description>
   <filename>../../gst/segmentclip/.libs/libgstsegmentclip.so</filename>
   <basename>libgstsegmentclip.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-shm.xml b/docs/plugins/inspect/plugin-shm.xml
index c7fa7b4..6e83daa 100644
--- a/docs/plugins/inspect/plugin-shm.xml
+++ b/docs/plugins/inspect/plugin-shm.xml
@@ -3,10 +3,10 @@
   <description>shared memory sink source</description>
   <filename>../../sys/shm/.libs/libgstshm.so</filename>
   <basename>libgstshm.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-smooth.xml b/docs/plugins/inspect/plugin-smooth.xml
index 81586c7..85dcdb2 100644
--- a/docs/plugins/inspect/plugin-smooth.xml
+++ b/docs/plugins/inspect/plugin-smooth.xml
@@ -3,10 +3,10 @@
   <description>Apply a smooth filter to an image</description>
   <filename>../../gst/smooth/.libs/libgstsmooth.so</filename>
   <basename>libgstsmooth.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-sndfile.xml b/docs/plugins/inspect/plugin-sndfile.xml
index 36d3076..10d0607 100644
--- a/docs/plugins/inspect/plugin-sndfile.xml
+++ b/docs/plugins/inspect/plugin-sndfile.xml
@@ -3,10 +3,10 @@
   <description>use libsndfile to read and write audio from and to files</description>
   <filename>../../ext/sndfile/.libs/libgstsndfile.so</filename>
   <basename>libgstsndfile.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-soundtouch.xml b/docs/plugins/inspect/plugin-soundtouch.xml
index 60c9c87..626347f 100644
--- a/docs/plugins/inspect/plugin-soundtouch.xml
+++ b/docs/plugins/inspect/plugin-soundtouch.xml
@@ -3,10 +3,10 @@
   <description>Audio Pitch Controller &amp; BPM Detection</description>
   <filename>../../ext/soundtouch/.libs/libgstsoundtouch.so</filename>
   <basename>libgstsoundtouch.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-speed.xml b/docs/plugins/inspect/plugin-speed.xml
index f680f0e..502b5e4 100644
--- a/docs/plugins/inspect/plugin-speed.xml
+++ b/docs/plugins/inspect/plugin-speed.xml
@@ -3,10 +3,10 @@
   <description>Set speed/pitch on audio/raw streams (resampler)</description>
   <filename>../../gst/speed/.libs/libgstspeed.so</filename>
   <basename>libgstspeed.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-stereo.xml b/docs/plugins/inspect/plugin-stereo.xml
index ebde5c5..cf2a342 100644
--- a/docs/plugins/inspect/plugin-stereo.xml
+++ b/docs/plugins/inspect/plugin-stereo.xml
@@ -3,10 +3,10 @@
   <description>Muck with the stereo signal, enhance it&apos;s &apos;stereo-ness&apos;</description>
   <filename>../../gst/stereo/.libs/libgststereo.so</filename>
   <basename>libgststereo.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-subenc.xml b/docs/plugins/inspect/plugin-subenc.xml
index 0bcc413..1aff047 100644
--- a/docs/plugins/inspect/plugin-subenc.xml
+++ b/docs/plugins/inspect/plugin-subenc.xml
@@ -3,10 +3,10 @@
   <description>subtitle encoders</description>
   <filename>../../gst/subenc/.libs/libgstsubenc.so</filename>
   <basename>libgstsubenc.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-tta.xml b/docs/plugins/inspect/plugin-tta.xml
index 98fdd3a..8b09489 100644
--- a/docs/plugins/inspect/plugin-tta.xml
+++ b/docs/plugins/inspect/plugin-tta.xml
@@ -3,10 +3,10 @@
   <description>TTA lossless audio format handling</description>
   <filename>../../gst/tta/.libs/libgsttta.so</filename>
   <basename>libgsttta.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-vcdsrc.xml b/docs/plugins/inspect/plugin-vcdsrc.xml
index 23e05f3..beefe2c 100644
--- a/docs/plugins/inspect/plugin-vcdsrc.xml
+++ b/docs/plugins/inspect/plugin-vcdsrc.xml
@@ -3,10 +3,10 @@
   <description>Asynchronous read from VCD disk</description>
   <filename>../../sys/vcd/.libs/libgstvcdsrc.so</filename>
   <basename>libgstvcdsrc.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-vdpau.xml b/docs/plugins/inspect/plugin-vdpau.xml
index f32c0d6..3758f6d 100644
--- a/docs/plugins/inspect/plugin-vdpau.xml
+++ b/docs/plugins/inspect/plugin-vdpau.xml
@@ -3,7 +3,7 @@
   <description>Various elements utilizing VDPAU</description>
   <filename>../../sys/vdpau/.libs/libgstvdpau.so</filename>
   <basename>libgstvdpau.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer</package>
diff --git a/docs/plugins/inspect/plugin-videofiltersbad.xml b/docs/plugins/inspect/plugin-videofiltersbad.xml
index bafc8f9..629306f 100644
--- a/docs/plugins/inspect/plugin-videofiltersbad.xml
+++ b/docs/plugins/inspect/plugin-videofiltersbad.xml
@@ -3,7 +3,7 @@
   <description>Video filters in gst-plugins-bad</description>
   <filename>../../gst/videofilters/.libs/libgstvideofiltersbad.so</filename>
   <basename>libgstvideofiltersbad.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer Bad Plug-ins</package>
diff --git a/docs/plugins/inspect/plugin-videomaxrate.xml b/docs/plugins/inspect/plugin-videomaxrate.xml
index 7d532d0..4db9f45 100644
--- a/docs/plugins/inspect/plugin-videomaxrate.xml
+++ b/docs/plugins/inspect/plugin-videomaxrate.xml
@@ -3,10 +3,10 @@
   <description>Drop extra frames</description>
   <filename>../../gst/videomaxrate/.libs/libgstvideomaxrate.so</filename>
   <basename>libgstvideomaxrate.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-videomeasure.xml b/docs/plugins/inspect/plugin-videomeasure.xml
index c2751e4..2efa462 100644
--- a/docs/plugins/inspect/plugin-videomeasure.xml
+++ b/docs/plugins/inspect/plugin-videomeasure.xml
@@ -3,10 +3,10 @@
   <description>Various video measurers</description>
   <filename>../../gst/videomeasure/.libs/libgstvideomeasure.so</filename>
   <basename>libgstvideomeasure.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-videoparsersbad.xml b/docs/plugins/inspect/plugin-videoparsersbad.xml
index e4cf6e8..a6cdb36 100644
--- a/docs/plugins/inspect/plugin-videoparsersbad.xml
+++ b/docs/plugins/inspect/plugin-videoparsersbad.xml
@@ -3,10 +3,10 @@
   <description>videoparsers</description>
   <filename>../../gst/videoparsers/.libs/libgstvideoparsersbad.so</filename>
   <basename>libgstvideoparsersbad.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-videosignal.xml b/docs/plugins/inspect/plugin-videosignal.xml
index f105c2b..39ee3ab 100644
--- a/docs/plugins/inspect/plugin-videosignal.xml
+++ b/docs/plugins/inspect/plugin-videosignal.xml
@@ -3,10 +3,10 @@
   <description>Various video signal analysers</description>
   <filename>../../gst/videosignal/.libs/libgstvideosignal.so</filename>
   <basename>libgstvideosignal.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-vmnc.xml b/docs/plugins/inspect/plugin-vmnc.xml
index be3caf9..088c562 100644
--- a/docs/plugins/inspect/plugin-vmnc.xml
+++ b/docs/plugins/inspect/plugin-vmnc.xml
@@ -3,10 +3,10 @@
   <description>VmWare Video Codec plugins</description>
   <filename>../../gst/vmnc/.libs/libgstvmnc.so</filename>
   <basename>libgstvmnc.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-vp8.xml b/docs/plugins/inspect/plugin-vp8.xml
index 4aa642a..e8e1a0b 100644
--- a/docs/plugins/inspect/plugin-vp8.xml
+++ b/docs/plugins/inspect/plugin-vp8.xml
@@ -3,10 +3,10 @@
   <description>VP8 plugin</description>
   <filename>../../ext/vp8/.libs/libgstvp8.so</filename>
   <basename>libgstvp8.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-wildmidi.xml b/docs/plugins/inspect/plugin-wildmidi.xml
index 27fc4a0..233d339 100644
--- a/docs/plugins/inspect/plugin-wildmidi.xml
+++ b/docs/plugins/inspect/plugin-wildmidi.xml
@@ -3,10 +3,10 @@
   <description>Wildmidi Plugin</description>
   <filename>../../ext/timidity/.libs/libgstwildmidi.so</filename>
   <basename>libgstwildmidi.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>GPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-xvid.xml b/docs/plugins/inspect/plugin-xvid.xml
index 00ba1f8..26de3c0 100644
--- a/docs/plugins/inspect/plugin-xvid.xml
+++ b/docs/plugins/inspect/plugin-xvid.xml
@@ -3,10 +3,10 @@
   <description>XviD plugin library</description>
   <filename>../../ext/xvid/.libs/libgstxvid.so</filename>
   <basename>libgstxvid.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>GPL</license>
   <source>gst-plugins-bad</source>
-  <package>GStreamer Bad Plug-ins source release</package>
+  <package>GStreamer Bad Plug-ins git</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
diff --git a/docs/plugins/inspect/plugin-y4mdec.xml b/docs/plugins/inspect/plugin-y4mdec.xml
index 14907e3..40670cb 100644
--- a/docs/plugins/inspect/plugin-y4mdec.xml
+++ b/docs/plugins/inspect/plugin-y4mdec.xml
@@ -3,7 +3,7 @@
   <description>Demuxes/decodes YUV4MPEG streams</description>
   <filename>../../gst/y4m/.libs/libgsty4mdec.so</filename>
   <basename>libgsty4mdec.so</basename>
-  <version>0.10.23</version>
+  <version>0.10.23.1</version>
   <license>LGPL</license>
   <source>gst-plugins-bad</source>
   <package>GStreamer Bad Plug-ins</package>
diff --git a/ext/Makefile.am b/ext/Makefile.am
index dc62386..0d57dc3 100644
--- a/ext/Makefile.am
+++ b/ext/Makefile.am
@@ -58,6 +58,12 @@ else
 CELT_DIR=
 endif
 
+if USE_CHROMAPRINT
+CHROMAPRINT_DIR=chromaprint
+else
+CHROMAPRINT_DIR=
+endif
+
 if USE_COG
 COG_DIR=cog
 else
@@ -88,6 +94,12 @@ else
 DIRECTFB_DIR=
 endif
 
+if USE_WAYLAND
+WAYLAND_DIR=wayland
+else
+WAYLAND_DIR=
+endif
+
 if USE_DIVX
 DIVX_DIR=divx
 else
@@ -397,11 +409,13 @@ SUBDIRS=\
 	$(BZ2_DIR) \
 	$(CDAUDIO_DIR) \
 	$(CELT_DIR) \
+	$(CHROMAPRINT_DIR) \
 	$(COG_DIR) \
 	$(CURL_DIR) \
 	$(DC1394_DIR) \
 	$(DIRAC_DIR) \
 	$(DIRECTFB_DIR) \
+	$(WAYLAND_DIR) \
 	$(DIVX_DIR) \
 	$(DTS_DIR) \
 	$(RESINDVD_DIR) \
@@ -456,11 +470,13 @@ DIST_SUBDIRS = \
 	bz2 \
 	cdaudio \
 	celt \
+	chromaprint \
 	cog \
 	curl \
 	dc1394 \
 	dirac \
 	directfb \
+        wayland \
 	faac \
 	faad \
 	flite \
diff --git a/ext/assrender/gstassrender.c b/ext/assrender/gstassrender.c
index b71e8e4..a184a33 100644
--- a/ext/assrender/gstassrender.c
+++ b/ext/assrender/gstassrender.c
@@ -31,6 +31,9 @@
  * </refsect2>
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
 
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
diff --git a/ext/celt/gstceltdec.c b/ext/celt/gstceltdec.c
index 84b2d20..e8899c4 100644
--- a/ext/celt/gstceltdec.c
+++ b/ext/celt/gstceltdec.c
@@ -298,8 +298,8 @@ gst_celt_dec_parse_comments (GstCeltDec * dec, GstBuffer * buf)
 
   GST_INFO_OBJECT (dec, "tags: %" GST_PTR_FORMAT, list);
 
-  gst_element_found_tags_for_pad (GST_ELEMENT (dec),
-      GST_AUDIO_DECODER_SRC_PAD (dec), list);
+  gst_audio_decoder_merge_tags (GST_AUDIO_DECODER (dec), list,
+      GST_TAG_MERGE_REPLACE);
 
   g_free (encoder);
   g_free (ver);
diff --git a/ext/chromaprint/Makefile.am b/ext/chromaprint/Makefile.am
new file mode 100644
index 0000000..115d8c2
--- /dev/null
+++ b/ext/chromaprint/Makefile.am
@@ -0,0 +1,14 @@
+plugin_LTLIBRARIES = libgstchromaprint.la
+
+libgstchromaprint_la_SOURCES = gstchromaprint.c gstchromaprint.h
+
+libgstchromaprint_la_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) \
+	$(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS) \
+	$(CHROMAPRINT_CFLAGS)
+libgstchromaprint_la_LIBADD = \
+	$(GST_PLUGINS_BASE_LIBS) -lgstaudio-$(GST_MAJORMINOR) $(GST_LIBS) \
+	$(CHROMAPRINT_LIBS)
+libgstchromaprint_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstchromaprint_la_LIBTOOLFLAGS = --tag=disable-static
+
+noinst_HEADERS = gstchromaprint.h
diff --git a/ext/chromaprint/gstchromaprint.c b/ext/chromaprint/gstchromaprint.c
new file mode 100644
index 0000000..66347d9
--- /dev/null
+++ b/ext/chromaprint/gstchromaprint.c
@@ -0,0 +1,317 @@
+/* GStreamer chromaprint audio fingerprinting element
+ * Copyright (C) 2006 M. Derezynski
+ * Copyright (C) 2008 Eric Buehl
+ * Copyright (C) 2008 Sebastian Dröge <slomo@circular-chaos.org>
+ * Copyright (C) 2011 Lukáš Lalinský <lalinsky@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:element-chromaprint
+ *
+ * The chromaprint element calculates an acoustic fingerprint for an
+ * audio stream which can be used to identify a song and look up
+ * further metadata from the <ulink url="http://acoustid.org/">Acoustid</ulink>
+ * and Musicbrainz databases.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch -m uridecodebin uri=file:///path/to/song.ogg ! audioconvert ! chromaprint ! fakesink
+ * ]|
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gstchromaprint.h"
+
+#define DEFAULT_MAX_DURATION 120
+
+#define PAD_CAPS \
+	"audio/x-raw-int, " \
+        "rate = (int) [ 1, MAX ], " \
+        "channels = (int) [ 1, 2 ], " \
+        "endianness = (int) { BYTE_ORDER  }, " \
+        "width = (int) { 16 }, " \
+        "depth = (int) { 16 }, " \
+	"signed = (boolean) true"
+
+GST_DEBUG_CATEGORY_STATIC (gst_chromaprint_debug);
+#define GST_CAT_DEFAULT gst_chromaprint_debug
+
+enum
+{
+  PROP_0,
+  PROP_FINGERPRINT,
+  PROP_MAX_DURATION
+};
+
+
+GST_BOILERPLATE (GstChromaprint, gst_chromaprint, GstAudioFilter,
+    GST_TYPE_AUDIO_FILTER);
+
+static void gst_chromaprint_finalize (GObject * object);
+static void gst_chromaprint_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_chromaprint_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+static GstFlowReturn gst_chromaprint_transform_ip (GstBaseTransform * trans,
+    GstBuffer * buf);
+static gboolean gst_chromaprint_event (GstBaseTransform * trans,
+    GstEvent * event);
+
+static void
+gst_chromaprint_base_init (gpointer g_class)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+  GstAudioFilterClass *audio_filter_class = (GstAudioFilterClass *) g_class;
+  GstCaps *caps;
+
+  gst_element_class_set_details_simple (element_class,
+      "Chromaprint fingerprinting element",
+      "Filter/Analyzer/Audio",
+      "Find an audio fingerprint using the Chromaprint library",
+      "Lukáš Lalinský <lalinsky@gmail.com>");
+
+  caps = gst_caps_from_string (PAD_CAPS);
+  gst_audio_filter_class_add_pad_templates (audio_filter_class, caps);
+  gst_caps_unref (caps);
+}
+
+static void
+gst_chromaprint_class_init (GstChromaprintClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstBaseTransformClass *gstbasetrans_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstbasetrans_class = GST_BASE_TRANSFORM_CLASS (klass);
+
+  gobject_class->set_property = gst_chromaprint_set_property;
+  gobject_class->get_property = gst_chromaprint_get_property;
+
+  /* FIXME: do we need this in addition to the tag message ? */
+  g_object_class_install_property (gobject_class, PROP_FINGERPRINT,
+      g_param_spec_string ("fingerprint", "Resulting fingerprint",
+          "Resulting fingerprint", NULL, G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class, PROP_MAX_DURATION,
+      g_param_spec_uint ("duration", "Duration limit",
+          "Number of seconds of audio to use for fingerprinting",
+          0, G_MAXUINT, DEFAULT_MAX_DURATION,
+          G_PARAM_READABLE | G_PARAM_WRITABLE));
+
+  gobject_class->finalize = GST_DEBUG_FUNCPTR (gst_chromaprint_finalize);
+
+  gstbasetrans_class->transform_ip =
+      GST_DEBUG_FUNCPTR (gst_chromaprint_transform_ip);
+  gstbasetrans_class->event = GST_DEBUG_FUNCPTR (gst_chromaprint_event);
+  gstbasetrans_class->passthrough_on_same_caps = TRUE;
+}
+
+static void
+gst_chromaprint_reset (GstChromaprint * chromaprint)
+{
+  if (chromaprint->fingerprint) {
+    chromaprint_dealloc (chromaprint->fingerprint);
+    chromaprint->fingerprint = NULL;
+  }
+
+  chromaprint->nsamples = 0;
+  chromaprint->duration = 0;
+  chromaprint->record = TRUE;
+}
+
+static void
+gst_chromaprint_create_fingerprint (GstChromaprint * chromaprint)
+{
+  GstTagList *tags;
+
+  if (chromaprint->duration <= 3)
+    return;
+
+  GST_DEBUG_OBJECT (chromaprint,
+      "Generating fingerprint based on %d seconds of audio",
+      chromaprint->duration);
+
+  chromaprint_finish (chromaprint->context);
+  chromaprint_get_fingerprint (chromaprint->context, &chromaprint->fingerprint);
+  chromaprint->record = FALSE;
+
+  tags = gst_tag_list_new_full (GST_TAG_CHROMAPRINT_FINGERPRINT,
+      chromaprint->fingerprint, NULL);
+
+  gst_element_found_tags (GST_ELEMENT (chromaprint), tags);
+}
+
+static void
+gst_chromaprint_init (GstChromaprint * chromaprint,
+    GstChromaprintClass * gclass)
+{
+  gst_base_transform_set_passthrough (GST_BASE_TRANSFORM (chromaprint), TRUE);
+
+  chromaprint->context = chromaprint_new (CHROMAPRINT_ALGORITHM_DEFAULT);
+  chromaprint->fingerprint = NULL;
+  chromaprint->max_duration = DEFAULT_MAX_DURATION;
+  gst_chromaprint_reset (chromaprint);
+}
+
+static void
+gst_chromaprint_finalize (GObject * object)
+{
+  GstChromaprint *chromaprint = GST_CHROMAPRINT (object);
+
+  chromaprint->record = FALSE;
+
+  if (chromaprint->context) {
+    chromaprint_free (chromaprint->context);
+    chromaprint->context = NULL;
+  }
+
+  if (chromaprint->fingerprint) {
+    chromaprint_dealloc (chromaprint->fingerprint);
+    chromaprint->fingerprint = NULL;
+  }
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static GstFlowReturn
+gst_chromaprint_transform_ip (GstBaseTransform * trans, GstBuffer * buf)
+{
+  GstChromaprint *chromaprint = GST_CHROMAPRINT (trans);
+  gint rate = GST_AUDIO_FILTER (chromaprint)->format.rate;
+  gint channels = GST_AUDIO_FILTER (chromaprint)->format.channels;
+  guint nsamples;
+
+  if (G_UNLIKELY (rate <= 0 || channels <= 0))
+    return GST_FLOW_NOT_NEGOTIATED;
+
+  if (!chromaprint->record)
+    return GST_FLOW_OK;
+
+  nsamples = GST_BUFFER_SIZE (buf) / (channels * 2);
+
+  if (nsamples == 0)
+    return GST_FLOW_OK;
+
+  if (chromaprint->nsamples == 0) {
+    chromaprint_start (chromaprint->context, rate, channels);
+  }
+  chromaprint->nsamples += nsamples;
+  chromaprint->duration = chromaprint->nsamples / rate;
+
+  chromaprint_feed (chromaprint->context, GST_BUFFER_DATA (buf),
+      GST_BUFFER_SIZE (buf) / 2);
+
+  if (chromaprint->duration >= chromaprint->max_duration
+      && !chromaprint->fingerprint) {
+    gst_chromaprint_create_fingerprint (chromaprint);
+  }
+
+  return GST_FLOW_OK;
+}
+
+static gboolean
+gst_chromaprint_event (GstBaseTransform * trans, GstEvent * event)
+{
+  GstChromaprint *chromaprint = GST_CHROMAPRINT (trans);
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_STOP:
+    case GST_EVENT_NEWSEGMENT:
+      GST_DEBUG_OBJECT (trans, "Got %s event, clearing buffer",
+          GST_EVENT_TYPE_NAME (event));
+      gst_chromaprint_reset (chromaprint);
+      break;
+    case GST_EVENT_EOS:
+      if (!chromaprint->fingerprint) {
+        gst_chromaprint_create_fingerprint (chromaprint);
+      }
+      break;
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+static void
+gst_chromaprint_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstChromaprint *chromaprint = GST_CHROMAPRINT (object);
+
+  switch (prop_id) {
+    case PROP_MAX_DURATION:
+      chromaprint->max_duration = g_value_get_uint (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_chromaprint_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstChromaprint *chromaprint = GST_CHROMAPRINT (object);
+
+  switch (prop_id) {
+    case PROP_FINGERPRINT:
+      g_value_set_string (value, chromaprint->fingerprint);
+      break;
+    case PROP_MAX_DURATION:
+      g_value_set_uint (value, chromaprint->max_duration);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  gboolean ret;
+
+  GST_DEBUG_CATEGORY_INIT (gst_chromaprint_debug, "chromaprint",
+      0, "chromaprint element");
+
+  GST_INFO ("libchromaprint %s", chromaprint_get_version ());
+
+  ret = gst_element_register (plugin, "chromaprint", GST_RANK_NONE,
+      GST_TYPE_CHROMAPRINT);
+
+  if (ret) {
+    gst_tag_register (GST_TAG_CHROMAPRINT_FINGERPRINT, GST_TAG_FLAG_META,
+        G_TYPE_STRING, "chromaprint fingerprint", "Chromaprint fingerprint",
+        NULL);
+  }
+
+  return ret;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "chromaprint",
+    "Calculate Chromaprint fingerprint from audio files",
+    plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/ext/chromaprint/gstchromaprint.h b/ext/chromaprint/gstchromaprint.h
new file mode 100644
index 0000000..12bad8a
--- /dev/null
+++ b/ext/chromaprint/gstchromaprint.h
@@ -0,0 +1,77 @@
+/* GStreamer chromaprint audio fingerprinting element
+ * Copyright (C) 2006 M. Derezynski
+ * Copyright (C) 2008 Eric Buehl
+ * Copyright (C) 2008 Sebastian Dröge <slomo@circular-chaos.org>
+ * Copyright (C) 2011 Lukáš Lalinský <<user@hostname.org>>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_CHROMAPRINT_H__
+#define __GST_CHROMAPRINT_H__
+
+#include <gst/gst.h>
+#include <gst/base/gstadapter.h>
+#include <gst/audio/gstaudiofilter.h>
+#include <gst/audio/audio.h>
+#include <chromaprint.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_CHROMAPRINT \
+  (gst_chromaprint_get_type())
+#define GST_CHROMAPRINT(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CHROMAPRINT,GstChromaprint))
+#define GST_CHROMAPRINT_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CHROMAPRINT,GstChromaprintClass))
+#define GST_IS_CHROMAPRINT(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CHROMAPRINT))
+#define GST_IS_CHROMAPRINT_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CHROMAPRINT))
+
+#define GST_TAG_CHROMAPRINT_FINGERPRINT "chromaprint-fingerprint"
+
+typedef struct _GstChromaprint      GstChromaprint;
+typedef struct _GstChromaprintClass GstChromaprintClass;
+
+/**
+ * GstChromaprint:
+ *
+ * Opaque #GstChromaprint element structure
+ */
+struct _GstChromaprint
+{
+  GstAudioFilter element;
+
+  /*< private >*/
+  ChromaprintContext * context;
+  char               * fingerprint;
+  gboolean             record;
+  guint64              nsamples;
+  guint                duration;
+  guint                max_duration;
+};
+
+struct _GstChromaprintClass
+{
+  GstAudioFilterClass parent_class;
+};
+
+GType gst_chromaprint_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_CHROMAPRINT_H__ */
diff --git a/ext/cog/Makefile.am b/ext/cog/Makefile.am
index 81e0f15..bbed6fe 100644
--- a/ext/cog/Makefile.am
+++ b/ext/cog/Makefile.am
@@ -5,6 +5,7 @@ include $(top_srcdir)/common/orc.mak
 
 libgstcog_la_CFLAGS = \
 	-DCOG_ENABLE_UNSTABLE_API \
+	$(GST_PLUGINS_BAD_CFLAGS) \
 	-I$(srcdir)/.. \
 	$(GST_PLUGINS_BASE_CFLAGS) \
 	$(GST_CFLAGS) \
diff --git a/ext/cog/gstcogcolorspace.c b/ext/cog/gstcogcolorspace.c
index 3c84c32..d849f36 100644
--- a/ext/cog/gstcogcolorspace.c
+++ b/ext/cog/gstcogcolorspace.c
@@ -372,7 +372,7 @@ gst_cogcolorspace_caps_get_chroma_site (GstCaps * caps)
   s = gst_video_parse_caps_chroma_site (caps);
 
   if (s == NULL)
-    return COG_COLOR_MATRIX_SDTV;
+    return COG_CHROMA_SITE_MPEG2;
 
   if (strcmp (s, "jpeg") == 0) {
     return COG_CHROMA_SITE_JPEG;
diff --git a/ext/cog/gstcogmse.c b/ext/cog/gstcogmse.c
index f85c873..af29087 100644
--- a/ext/cog/gstcogmse.c
+++ b/ext/cog/gstcogmse.c
@@ -23,6 +23,7 @@
 #endif
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <gst/video/video.h>
 #include <string.h>
 #include <cog/cogframe.h>
diff --git a/ext/cog/gstcogorc-dist.c b/ext/cog/gstcogorc-dist.c
index d4daee6..e752c55 100644
--- a/ext/cog/gstcogorc-dist.c
+++ b/ext/cog/gstcogorc-dist.c
@@ -406,7 +406,7 @@ cogorc_memcpy_2d (orc_uint8 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -510,7 +510,7 @@ cogorc_downsample_horiz_cosite_1tap (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint16 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -723,7 +723,7 @@ cogorc_downsample_horiz_cosite_3tap (orc_uint8 * ORC_RESTRICT d1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -941,7 +941,7 @@ cogorc_downsample_420_jpeg (orc_uint8 * ORC_RESTRICT d1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1066,7 +1066,7 @@ cogorc_downsample_vert_halfsite_2tap (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s1, const orc_uint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1243,7 +1243,7 @@ cogorc_downsample_vert_cosite_3tap (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1476,7 +1476,7 @@ cogorc_downsample_vert_halfsite_4tap (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s3, const orc_uint8 * ORC_RESTRICT s4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1620,7 +1620,7 @@ cogorc_upsample_horiz_cosite_1tap (guint8 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1748,7 +1748,7 @@ cogorc_upsample_horiz_cosite (guint8 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s1, const orc_uint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1858,7 +1858,7 @@ cogorc_upsample_vert_avgub (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s1, const orc_uint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1960,7 +1960,7 @@ orc_unpack_yuyv_y (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint16 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2074,7 +2074,7 @@ orc_unpack_yuyv_u (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint32 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2191,7 +2191,7 @@ orc_unpack_yuyv_v (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint32 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2382,7 +2382,7 @@ orc_pack_yuyv (orc_uint32 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const orc_uint8 * ORC_RESTRICT s2, const orc_uint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2501,7 +2501,7 @@ orc_unpack_uyvy_y (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint16 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2615,7 +2615,7 @@ orc_unpack_uyvy_u (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint32 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2732,7 +2732,7 @@ orc_unpack_uyvy_v (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint32 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2923,7 +2923,7 @@ orc_pack_uyvy (orc_uint32 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const orc_uint8 * ORC_RESTRICT s2, const orc_uint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3046,7 +3046,7 @@ orc_addc_convert_u8_s16 (orc_uint8 * ORC_RESTRICT d1,
     const gint16 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3154,7 +3154,7 @@ orc_subc_convert_s16_u8 (gint16 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3244,7 +3244,7 @@ void
 orc_splat_u8_ns (orc_uint8 * ORC_RESTRICT d1, int p1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3330,7 +3330,7 @@ void
 orc_splat_s16_ns (gint16 * ORC_RESTRICT d1, int p1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3492,7 +3492,7 @@ orc_matrix2_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, int p1, int p2, int p3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3715,7 +3715,7 @@ orc_matrix2_11_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, int p1, int p2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3954,7 +3954,7 @@ orc_matrix2_12_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, int p1, int p2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -4189,7 +4189,7 @@ orc_matrix3_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int p2, int p3, int p4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -4464,7 +4464,7 @@ orc_matrix3_100_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int p2, int p3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -4714,7 +4714,7 @@ orc_matrix3_100_offset_u8 (guint8 * ORC_RESTRICT d1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -4951,7 +4951,7 @@ orc_matrix3_000_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int p2, int p3, int p4, int p5, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -5149,7 +5149,7 @@ orc_pack_123x (guint32 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1,
     int p1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -5323,7 +5323,7 @@ orc_pack_x123 (guint32 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1,
     int p1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -5487,7 +5487,7 @@ cogorc_combine2_u8 (orc_uint8 * ORC_RESTRICT d1,
     int p1, int p2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -5742,7 +5742,7 @@ cogorc_combine4_u8 (orc_uint8 * ORC_RESTRICT d1,
     int p1, int p2, int p3, int p4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -5900,7 +5900,7 @@ cogorc_unpack_axyz_0 (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint32 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6017,7 +6017,7 @@ cogorc_unpack_axyz_1 (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint32 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6134,7 +6134,7 @@ cogorc_unpack_axyz_2 (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint32 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6251,7 +6251,7 @@ cogorc_unpack_axyz_3 (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint32 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6340,7 +6340,7 @@ cogorc_resample_horiz_1tap (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s1, int p1, int p2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6440,7 +6440,7 @@ cogorc_resample_horiz_2tap (orc_uint8 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s1, int p1, int p2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6644,7 +6644,7 @@ cogorc_convert_I420_UYVY (orc_uint32 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6857,7 +6857,7 @@ cogorc_convert_I420_YUY2 (orc_uint32 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7090,7 +7090,7 @@ cogorc_convert_I420_AYUV (orc_uint32 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7325,7 +7325,7 @@ cogorc_convert_YUY2_I420 (orc_uint16 * ORC_RESTRICT d1,
     const orc_uint32 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7447,7 +7447,7 @@ cogorc_convert_UYVY_YUY2 (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint32 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7572,7 +7572,7 @@ cogorc_planar_chroma_420_422 (orc_uint8 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7690,7 +7690,7 @@ cogorc_planar_chroma_420_444 (orc_uint16 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7801,7 +7801,7 @@ cogorc_planar_chroma_422_444 (orc_uint16 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7925,7 +7925,7 @@ cogorc_planar_chroma_444_422 (orc_uint8 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint16 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -8074,7 +8074,7 @@ cogorc_planar_chroma_444_420 (orc_uint8 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint16 * ORC_RESTRICT s2, int s2_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -8199,7 +8199,7 @@ cogorc_planar_chroma_422_420 (orc_uint8 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint8 * ORC_RESTRICT s2, int s2_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -8409,7 +8409,7 @@ cogorc_convert_YUY2_AYUV (orc_uint64 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint32 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -8627,7 +8627,7 @@ cogorc_convert_UYVY_AYUV (orc_uint64 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint32 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -8803,7 +8803,7 @@ cogorc_convert_YUY2_Y42B (orc_uint16 * ORC_RESTRICT d1, int d1_stride,
     int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -8977,7 +8977,7 @@ cogorc_convert_UYVY_Y42B (orc_uint16 * ORC_RESTRICT d1, int d1_stride,
     int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -9163,7 +9163,7 @@ cogorc_convert_YUY2_Y444 (orc_uint16 * ORC_RESTRICT d1, int d1_stride,
     int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -9355,7 +9355,7 @@ cogorc_convert_UYVY_Y444 (orc_uint16 * ORC_RESTRICT d1, int d1_stride,
     int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -9584,7 +9584,7 @@ cogorc_convert_UYVY_I420 (orc_uint16 * ORC_RESTRICT d1,
     const orc_uint32 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -9944,7 +9944,7 @@ cogorc_convert_AYUV_I420 (orc_uint16 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint64 * ORC_RESTRICT s2, int s2_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -10191,7 +10191,7 @@ cogorc_convert_AYUV_YUY2 (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint64 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -10413,7 +10413,7 @@ cogorc_convert_AYUV_UYVY (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint64 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -10645,7 +10645,7 @@ cogorc_convert_AYUV_Y42B (orc_uint16 * ORC_RESTRICT d1, int d1_stride,
     int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -10830,7 +10830,7 @@ cogorc_convert_AYUV_Y444 (orc_uint8 * ORC_RESTRICT d1, int d1_stride,
     int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -11007,7 +11007,7 @@ cogorc_convert_Y42B_YUY2 (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint8 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -11181,7 +11181,7 @@ cogorc_convert_Y42B_UYVY (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint8 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -11407,7 +11407,7 @@ cogorc_convert_Y42B_AYUV (orc_uint64 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint8 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -11631,7 +11631,7 @@ cogorc_convert_Y444_YUY2 (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint16 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -11854,7 +11854,7 @@ cogorc_convert_Y444_UYVY (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint16 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -12045,7 +12045,7 @@ cogorc_convert_Y444_AYUV (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint8 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -12491,7 +12491,7 @@ cogorc_convert_AYUV_ARGB (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint32 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -13013,7 +13013,7 @@ cogorc_convert_AYUV_BGRA (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint32 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -13535,7 +13535,7 @@ cogorc_convert_AYUV_ABGR (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint32 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -14057,7 +14057,7 @@ cogorc_convert_AYUV_RGBA (orc_uint32 * ORC_RESTRICT d1, int d1_stride,
     const orc_uint32 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -14566,7 +14566,7 @@ cogorc_convert_I420_BGRA (orc_uint32 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -15117,7 +15117,7 @@ cogorc_convert_I420_BGRA_avg (orc_uint32 * ORC_RESTRICT d1,
     const orc_uint8 * ORC_RESTRICT s5, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
diff --git a/ext/curl/Makefile.am b/ext/curl/Makefile.am
index 77b2373..42fbe31 100644
--- a/ext/curl/Makefile.am
+++ b/ext/curl/Makefile.am
@@ -2,6 +2,7 @@ plugin_LTLIBRARIES = libgstcurl.la
 
 libgstcurl_la_SOURCES = gstcurl.c gstcurlsink.c
 libgstcurl_la_CFLAGS = \
+	$(GST_PLUGINS_BAD_CFLAGS) \
 	$(GST_BASE_CFLAGS) \
 	$(GST_CFLAGS) \
 	$(CURL_CFLAGS)
diff --git a/ext/curl/gstcurlsink.c b/ext/curl/gstcurlsink.c
index 75b459c..7bf9b43 100644
--- a/ext/curl/gstcurlsink.c
+++ b/ext/curl/gstcurlsink.c
@@ -57,6 +57,8 @@
 
 #include "gstcurlsink.h"
 
+#include "gst/glib-compat-private.h"
+
 /* Default values */
 #define GST_CAT_DEFAULT                gst_curl_sink_debug
 #define DEFAULT_URL                    "localhost:5555"
@@ -847,7 +849,7 @@ gst_curl_sink_handle_transfer (GstCurlSink * sink)
     if (!proxy_conn_established && (resp_proxy != RESPONSE_CONNECT_PROXY)
         && proxy_auth) {
       curl_easy_getinfo (sink->curl, CURLINFO_HTTP_CONNECTCODE, &resp_proxy);
-      if ((resp_proxy == RESPONSE_CONNECT_PROXY)) {
+      if (resp_proxy == RESPONSE_CONNECT_PROXY) {
         GST_LOG ("received HTTP/1.0 200 Connection Established");
         /* Workaround: redefine HTTP headers before connecting to HTTP server.
          * When talking to proxy, the Content-Length: 0 is send with the request.
diff --git a/ext/directfb/dfbvideosink.c b/ext/directfb/dfbvideosink.c
index c3417a5..737096b 100644
--- a/ext/directfb/dfbvideosink.c
+++ b/ext/directfb/dfbvideosink.c
@@ -1613,7 +1613,7 @@ gst_dfbvideosink_show_frame (GstBaseSink * bsink, GstBuffer * buf)
 
     res = dest->Unlock (dest);
 
-    res = dest->Release (dest);
+    dest->Release (dest);
 
     if (dfbvideosink->backbuffer) {
       if (dfbvideosink->vsync) {
diff --git a/ext/dts/gstdtsdec.c b/ext/dts/gstdtsdec.c
index 4a304f8..0455ab0 100644
--- a/ext/dts/gstdtsdec.c
+++ b/ext/dts/gstdtsdec.c
@@ -137,8 +137,6 @@ static gboolean gst_dtsdec_parse (GstAudioDecoder * dec, GstAdapter * adapter,
     gint * offset, gint * length);
 static GstFlowReturn gst_dtsdec_handle_frame (GstAudioDecoder * dec,
     GstBuffer * buffer);
-static GstFlowReturn gst_dtsdec_pre_push (GstAudioDecoder * bdec,
-    GstBuffer ** buffer);
 
 static GstFlowReturn gst_dtsdec_chain (GstPad * pad, GstBuffer * buf);
 
@@ -182,7 +180,6 @@ gst_dtsdec_class_init (GstDtsDecClass * klass)
   gstbase_class->set_format = GST_DEBUG_FUNCPTR (gst_dtsdec_set_format);
   gstbase_class->parse = GST_DEBUG_FUNCPTR (gst_dtsdec_parse);
   gstbase_class->handle_frame = GST_DEBUG_FUNCPTR (gst_dtsdec_handle_frame);
-  gstbase_class->pre_push = GST_DEBUG_FUNCPTR (gst_dtsdec_pre_push);
 
   /**
    * GstDtsDec::drc
@@ -266,10 +263,6 @@ gst_dtsdec_stop (GstAudioDecoder * dec)
     dca_free (dts->state);
     dts->state = NULL;
   }
-  if (dts->pending_tags) {
-    gst_tag_list_free (dts->pending_tags);
-    dts->pending_tags = NULL;
-  }
 
   return TRUE;
 }
@@ -293,7 +286,7 @@ gst_dtsdec_parse (GstAudioDecoder * bdec, GstAdapter * adapter,
   bit_rate = dts->bit_rate;
   sample_rate = dts->sample_rate;
   flags = 0;
-  while (av >= 7) {
+  while (size >= 7) {
     length = dca_syncinfo (dts->state, data, &flags,
         &sample_rate, &bit_rate, &frame_length);
 
@@ -459,28 +452,9 @@ gst_dtsdec_update_streaminfo (GstDtsDec * dts)
     /* 1 => open bitrate, 2 => variable bitrate, 3 => lossless */
     gst_tag_list_add (taglist, GST_TAG_MERGE_APPEND, GST_TAG_BITRATE,
         (guint) dts->bit_rate, NULL);
-
-    if (dts->pending_tags) {
-      gst_tag_list_free (dts->pending_tags);
-      dts->pending_tags = NULL;
-    }
-
-    dts->pending_tags = taglist;
-  }
-}
-
-static GstFlowReturn
-gst_dtsdec_pre_push (GstAudioDecoder * bdec, GstBuffer ** buffer)
-{
-  GstDtsDec *dts = GST_DTSDEC (bdec);
-
-  if (G_UNLIKELY (dts->pending_tags)) {
-    gst_element_found_tags_for_pad (GST_ELEMENT (dts),
-        GST_AUDIO_DECODER_SRC_PAD (dts), dts->pending_tags);
-    dts->pending_tags = NULL;
+    gst_audio_decoder_merge_tags (GST_AUDIO_DECODER (dts), taglist,
+        GST_TAG_MERGE_REPLACE);
   }
-
-  return GST_FLOW_OK;
 }
 
 static GstFlowReturn
diff --git a/ext/dts/gstdtsdec.h b/ext/dts/gstdtsdec.h
index be6005a..172473a 100644
--- a/ext/dts/gstdtsdec.h
+++ b/ext/dts/gstdtsdec.h
@@ -66,8 +66,6 @@ struct _GstDtsDec {
 #else
   dts_state_t 	*state;
 #endif
-
-  GstTagList    *pending_tags;
 };
 
 struct _GstDtsDecClass {
diff --git a/ext/faac/gstfaac.c b/ext/faac/gstfaac.c
index f811cd1..68c1e01 100644
--- a/ext/faac/gstfaac.c
+++ b/ext/faac/gstfaac.c
@@ -379,9 +379,8 @@ static gboolean
 gst_faac_set_format (GstAudioEncoder * enc, GstAudioInfo * info)
 {
   GstFaac *faac = GST_FAAC (enc);
-  faacEncHandle *handle;
   gint channels, samplerate, width;
-  gulong samples, bytes, fmt = 0, bps = 0;
+  gulong fmt = 0, bps = 0;
   gboolean result = FALSE;
 
   /* base class takes care */
@@ -408,41 +407,24 @@ gst_faac_set_format (GstAudioEncoder * enc, GstAudioInfo * info)
     bps = 4;
   }
 
-  /* clean up in case of re-configure */
-  gst_faac_close_encoder (faac);
-
-  if (!(handle = faacEncOpen (samplerate, channels, &samples, &bytes)))
-    goto setup_failed;
-
-  /* mind channel count */
-  samples /= channels;
-
   /* ok, record and set up */
   faac->format = fmt;
   faac->bps = bps;
-  faac->handle = handle;
-  faac->bytes = bytes;
-  faac->samples = samples;
   faac->channels = channels;
   faac->samplerate = samplerate;
 
   /* finish up */
   result = gst_faac_configure_source_pad (faac);
+  if (!result)
+    goto done;
 
   /* report needs to base class */
-  gst_audio_encoder_set_frame_samples_min (enc, samples);
-  gst_audio_encoder_set_frame_samples_max (enc, samples);
+  gst_audio_encoder_set_frame_samples_min (enc, faac->samples);
+  gst_audio_encoder_set_frame_samples_max (enc, faac->samples);
   gst_audio_encoder_set_frame_max (enc, 1);
 
 done:
   return result;
-
-  /* ERRORS */
-setup_failed:
-  {
-    GST_ELEMENT_ERROR (faac, LIBRARY, SETTINGS, (NULL), (NULL));
-    goto done;
-  }
 }
 
 /* check downstream caps to configure format */
@@ -504,15 +486,32 @@ gst_faac_negotiate (GstFaac * faac)
 }
 
 static gboolean
-gst_faac_configure_source_pad (GstFaac * faac)
+gst_faac_open_encoder (GstFaac * faac)
 {
-  GstCaps *srccaps;
-  gboolean ret = FALSE;
+  faacEncHandle *handle;
   faacEncConfiguration *conf;
   guint maxbitrate;
+  gulong samples, bytes;
 
-  /* negotiate stream format */
-  gst_faac_negotiate (faac);
+  g_return_val_if_fail (faac->samplerate != 0 && faac->channels != 0, FALSE);
+
+  /* clean up in case of re-configure */
+  gst_faac_close_encoder (faac);
+
+  if (!(handle = faacEncOpen (faac->samplerate, faac->channels,
+              &samples, &bytes)))
+    goto setup_failed;
+
+  /* mind channel count */
+  samples /= faac->channels;
+
+  /* record */
+  faac->handle = handle;
+  faac->samples = samples;
+  faac->bytes = bytes;
+
+  GST_DEBUG_OBJECT (faac, "faac needs samples %d, output size %d",
+      faac->samples, faac->bytes);
 
   /* we negotiated caps update current configuration */
   conf = faacEncGetCurrentConfiguration (faac->handle);
@@ -549,7 +548,7 @@ gst_faac_configure_source_pad (GstFaac * faac)
   conf->bandWidth = 0;
 
   if (!faacEncSetConfiguration (faac->handle, conf))
-    goto set_failed;
+    goto setup_failed;
 
   /* let's see what really happened,
    * note that this may not really match desired rate */
@@ -558,6 +557,28 @@ gst_faac_configure_source_pad (GstFaac * faac)
   GST_DEBUG_OBJECT (faac, "quantization quality: %ld", conf->quantqual);
   GST_DEBUG_OBJECT (faac, "bandwidth: %d Hz", conf->bandWidth);
 
+  return TRUE;
+
+  /* ERRORS */
+setup_failed:
+  {
+    GST_ELEMENT_ERROR (faac, LIBRARY, SETTINGS, (NULL), (NULL));
+    return FALSE;
+  }
+}
+
+static gboolean
+gst_faac_configure_source_pad (GstFaac * faac)
+{
+  GstCaps *srccaps;
+  gboolean ret;
+
+  /* negotiate stream format */
+  gst_faac_negotiate (faac);
+
+  if (!gst_faac_open_encoder (faac))
+    goto set_failed;
+
   /* now create a caps for it all */
   srccaps = gst_caps_new_simple ("audio/mpeg",
       "mpegversion", G_TYPE_INT, faac->mpegversion,
@@ -670,6 +691,13 @@ gst_faac_handle_frame (GstAudioEncoder * enc, GstBuffer * in_buf)
     ret = gst_audio_encoder_finish_frame (enc, out_buf, faac->samples);
   } else {
     gst_buffer_unref (out_buf);
+    /* re-create encoder after final flush */
+    if (!in_buf) {
+      GST_DEBUG_OBJECT (faac, "flushed; recreating encoder");
+      gst_faac_close_encoder (faac);
+      if (!gst_faac_open_encoder (faac))
+        ret = GST_FLOW_ERROR;
+    }
   }
 
   return ret;
diff --git a/ext/faac/gstfaac.h b/ext/faac/gstfaac.h
index 5bd0574..029e4fd 100644
--- a/ext/faac/gstfaac.h
+++ b/ext/faac/gstfaac.h
@@ -51,9 +51,9 @@ struct _GstFaac {
        bps;
 
   /* input frame size */
-  gulong samples;
+  gint samples;
   /* required output buffer size */
-  gulong bytes;
+  gint bytes;
 
   /* negotiated */
   gint mpegversion, outputformat;
diff --git a/ext/faad/gstfaad.c b/ext/faad/gstfaad.c
index 4dd73eb..3fee59e 100644
--- a/ext/faad/gstfaad.c
+++ b/ext/faad/gstfaad.c
@@ -806,6 +806,8 @@ decode_failed:
   {
     GST_AUDIO_DECODER_ERROR (faad, 1, STREAM, DECODE, (NULL),
         ("decoding error: %s", faacDecGetErrorMessage (info.error)), ret);
+    if (ret == GST_FLOW_OK)
+      gst_audio_decoder_finish_frame (dec, NULL, 1);
     goto out;
   }
 negotiation_failed:
diff --git a/ext/flite/gstflite.c b/ext/flite/gstflite.c
index 2995d9f..d75bd2f 100644
--- a/ext/flite/gstflite.c
+++ b/ext/flite/gstflite.c
@@ -24,7 +24,6 @@
 #include <gst/gst.h>
 #include <flite/flite.h>
 
-GType gst_flite_synth_get_type (void);
 GType gst_flite_test_src_get_type (void);
 
 
@@ -33,8 +32,6 @@ plugin_init (GstPlugin * plugin)
 {
   flite_init ();
 
-//  gst_element_register (plugin, "flitesynth", GST_RANK_NONE,
-//      gst_flite_synth_get_type ());
   gst_element_register (plugin, "flitetestsrc", GST_RANK_NONE,
       gst_flite_test_src_get_type ());
 
diff --git a/ext/flite/gstflitetestsrc.c b/ext/flite/gstflitetestsrc.c
index a8e595c..97c2acf 100644
--- a/ext/flite/gstflitetestsrc.c
+++ b/ext/flite/gstflitetestsrc.c
@@ -298,10 +298,9 @@ gst_flite_test_src_get_times (GstBaseSrc * basesrc, GstBuffer * buffer,
 }
 #endif
 
+/* there is no header for libflite_cmu_us_kal */
 cst_voice *register_cmu_us_kal ();
 
-
-
 static gboolean
 gst_flite_test_src_start (GstBaseSrc * basesrc)
 {
diff --git a/ext/gme/gstgme.c b/ext/gme/gstgme.c
index f8a387d..00ad589 100644
--- a/ext/gme/gstgme.c
+++ b/ext/gme/gstgme.c
@@ -18,6 +18,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/ext/gsettings/Makefile.am b/ext/gsettings/Makefile.am
index 64801df..6cef006 100644
--- a/ext/gsettings/Makefile.am
+++ b/ext/gsettings/Makefile.am
@@ -18,7 +18,7 @@ libgstgsettingselements_la_SOURCES = \
         gstswitchsrc.c \
 	plugin.c
 
-libgstgsettingselements_la_CFLAGS = $(GST_CFLAGS) $(GSETTINGS_CFLAGS) $(DIR_CFLAGS) \
+libgstgsettingselements_la_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_CFLAGS) $(GSETTINGS_CFLAGS) $(DIR_CFLAGS) \
 	-DGstSwitchSrc=GstGSettingsSwitchSrc \
 	-DGstSwitchSrcClass=GstGSettingsSwitchSrcClass \
 	-DGstSwitchSink=GstGSettingsSwitchSink \
diff --git a/ext/gsettings/gstgsettingsaudiosink.c b/ext/gsettings/gstgsettingsaudiosink.c
index 7e115c9..12d8489 100644
--- a/ext/gsettings/gstgsettingsaudiosink.c
+++ b/ext/gsettings/gstgsettingsaudiosink.c
@@ -35,6 +35,7 @@
 #endif
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <string.h>
 
 #include "gstgsettingsaudiosink.h"
@@ -159,8 +160,9 @@ static void
 on_changed (GSettings * settings, gchar * key, GstGSettingsAudioSink * sink)
 {
   gboolean changed = FALSE;
-  if (!g_str_has_suffix (key, "audiosink"));
-  return;
+
+  if (!g_str_has_suffix (key, "audiosink"))
+    return;
 
   GST_OBJECT_LOCK (sink);
   if ((sink->profile == GST_GSETTINGS_AUDIOSINK_PROFILE_SOUNDS &&
diff --git a/ext/gsettings/gstgsettingsaudiosrc.c b/ext/gsettings/gstgsettingsaudiosrc.c
index 844c8eb..c30f122 100644
--- a/ext/gsettings/gstgsettingsaudiosrc.c
+++ b/ext/gsettings/gstgsettingsaudiosrc.c
@@ -35,6 +35,7 @@
 #endif
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <string.h>
 
 #include "gstgsettingsaudiosrc.h"
@@ -103,8 +104,8 @@ fail:
 static void
 on_changed (GSettings * settings, gchar * key, GstGSettingsAudioSrc * src)
 {
-  if (!g_str_equal (key, "audiosrc"));
-  return;
+  if (!g_str_equal (key, "audiosrc"))
+    return;
 
   gst_gsettings_audio_src_change_child (src);
 }
diff --git a/ext/gsettings/gstgsettingsvideosink.c b/ext/gsettings/gstgsettingsvideosink.c
index 2444c7c..e225ec1 100644
--- a/ext/gsettings/gstgsettingsvideosink.c
+++ b/ext/gsettings/gstgsettingsvideosink.c
@@ -35,6 +35,7 @@
 #endif
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <string.h>
 
 #include "gstgsettingsvideosink.h"
@@ -103,8 +104,8 @@ fail:
 static void
 on_changed (GSettings * settings, gchar * key, GstGSettingsVideoSink * sink)
 {
-  if (!g_str_has_suffix (key, "videosink"));
-  return;
+  if (!g_str_has_suffix (key, "videosink"))
+    return;
 
   gst_gsettings_video_sink_change_child (sink);
 }
diff --git a/ext/gsettings/gstgsettingsvideosrc.c b/ext/gsettings/gstgsettingsvideosrc.c
index 42ee5fe..6c2a5b0 100644
--- a/ext/gsettings/gstgsettingsvideosrc.c
+++ b/ext/gsettings/gstgsettingsvideosrc.c
@@ -35,6 +35,7 @@
 #endif
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <string.h>
 
 #include "gstgsettingsvideosrc.h"
@@ -103,8 +104,8 @@ fail:
 static void
 on_changed (GSettings * settings, gchar * key, GstGSettingsVideoSrc * src)
 {
-  if (!g_str_equal (key, "videosrc"));
-  return;
+  if (!g_str_equal (key, "videosrc"))
+    return;
 
   gst_gsettings_video_src_change_child (src);
 }
diff --git a/ext/gsm/gstgsmdec.c b/ext/gsm/gstgsmdec.c
index 65d3275..b9c019d 100644
--- a/ext/gsm/gstgsmdec.c
+++ b/ext/gsm/gstgsmdec.c
@@ -43,43 +43,16 @@ enum
   ARG_0
 };
 
-static void gst_gsmdec_base_init (gpointer g_class);
-static void gst_gsmdec_class_init (GstGSMDec * klass);
-static void gst_gsmdec_init (GstGSMDec * gsmdec);
-static void gst_gsmdec_finalize (GObject * object);
-
-static gboolean gst_gsmdec_sink_setcaps (GstPad * pad, GstCaps * caps);
-static gboolean gst_gsmdec_sink_event (GstPad * pad, GstEvent * event);
-static GstFlowReturn gst_gsmdec_chain (GstPad * pad, GstBuffer * buf);
-
-static GstElementClass *parent_class = NULL;
+static gboolean gst_gsmdec_start (GstAudioDecoder * dec);
+static gboolean gst_gsmdec_stop (GstAudioDecoder * dec);
+static gboolean gst_gsmdec_set_format (GstAudioDecoder * dec, GstCaps * caps);
+static GstFlowReturn gst_gsmdec_parse (GstAudioDecoder * dec,
+    GstAdapter * adapter, gint * offset, gint * length);
+static GstFlowReturn gst_gsmdec_handle_frame (GstAudioDecoder * dec,
+    GstBuffer * in_buf);
 
 /*static guint gst_gsmdec_signals[LAST_SIGNAL] = { 0 }; */
 
-GType
-gst_gsmdec_get_type (void)
-{
-  static GType gsmdec_type = 0;
-
-  if (!gsmdec_type) {
-    static const GTypeInfo gsmdec_info = {
-      sizeof (GstGSMDecClass),
-      gst_gsmdec_base_init,
-      NULL,
-      (GClassInitFunc) gst_gsmdec_class_init,
-      NULL,
-      NULL,
-      sizeof (GstGSMDec),
-      0,
-      (GInstanceInitFunc) gst_gsmdec_init,
-    };
-
-    gsmdec_type =
-        g_type_register_static (GST_TYPE_ELEMENT, "GstGSMDec", &gsmdec_info, 0);
-  }
-  return gsmdec_type;
-}
-
 #define ENCODED_SAMPLES	160
 
 static GstStaticPadTemplate gsmdec_sink_template =
@@ -101,6 +74,9 @@ GST_STATIC_PAD_TEMPLATE ("src",
         "depth = (int) 16, " "rate = (int) [1, MAX], " "channels = (int) 1")
     );
 
+GST_BOILERPLATE (GstGSMDec, gst_gsmdec, GstAudioDecoder,
+    GST_TYPE_AUDIO_DECODER);
+
 static void
 gst_gsmdec_base_init (gpointer g_class)
 {
@@ -116,63 +92,60 @@ gst_gsmdec_base_init (gpointer g_class)
 }
 
 static void
-gst_gsmdec_class_init (GstGSMDec * klass)
+gst_gsmdec_class_init (GstGSMDecClass * klass)
 {
-  GObjectClass *gobject_class;
+  GstAudioDecoderClass *base_class;
 
-  gobject_class = (GObjectClass *) klass;
+  base_class = (GstAudioDecoderClass *) klass;
 
-  parent_class = g_type_class_peek_parent (klass);
-
-  gobject_class->finalize = gst_gsmdec_finalize;
+  base_class->start = GST_DEBUG_FUNCPTR (gst_gsmdec_start);
+  base_class->stop = GST_DEBUG_FUNCPTR (gst_gsmdec_stop);
+  base_class->set_format = GST_DEBUG_FUNCPTR (gst_gsmdec_set_format);
+  base_class->parse = GST_DEBUG_FUNCPTR (gst_gsmdec_parse);
+  base_class->handle_frame = GST_DEBUG_FUNCPTR (gst_gsmdec_handle_frame);
 
   GST_DEBUG_CATEGORY_INIT (gsmdec_debug, "gsmdec", 0, "GSM Decoder");
 }
 
 static void
-gst_gsmdec_init (GstGSMDec * gsmdec)
+gst_gsmdec_init (GstGSMDec * gsmdec, GstGSMDecClass * klass)
 {
-  /* create the sink and src pads */
-  gsmdec->sinkpad =
-      gst_pad_new_from_static_template (&gsmdec_sink_template, "sink");
-  gst_pad_set_setcaps_function (gsmdec->sinkpad, gst_gsmdec_sink_setcaps);
-  gst_pad_set_event_function (gsmdec->sinkpad, gst_gsmdec_sink_event);
-  gst_pad_set_chain_function (gsmdec->sinkpad, gst_gsmdec_chain);
-  gst_element_add_pad (GST_ELEMENT (gsmdec), gsmdec->sinkpad);
-
-  gsmdec->srcpad =
-      gst_pad_new_from_static_template (&gsmdec_src_template, "src");
-  gst_element_add_pad (GST_ELEMENT (gsmdec), gsmdec->srcpad);
+}
+
+static gboolean
+gst_gsmdec_start (GstAudioDecoder * dec)
+{
+  GstGSMDec *gsmdec = GST_GSMDEC (dec);
+
+  GST_DEBUG_OBJECT (dec, "start");
 
   gsmdec->state = gsm_create ();
 
-  gsmdec->adapter = gst_adapter_new ();
-  gsmdec->next_of = 0;
-  gsmdec->next_ts = 0;
+  return TRUE;
 }
 
-static void
-gst_gsmdec_finalize (GObject * object)
+static gboolean
+gst_gsmdec_stop (GstAudioDecoder * dec)
 {
-  GstGSMDec *gsmdec;
+  GstGSMDec *gsmdec = GST_GSMDEC (dec);
 
-  gsmdec = GST_GSMDEC (object);
+  GST_DEBUG_OBJECT (dec, "stop");
 
-  g_object_unref (gsmdec->adapter);
   gsm_destroy (gsmdec->state);
 
-  G_OBJECT_CLASS (parent_class)->finalize (object);
+  return TRUE;
 }
 
 static gboolean
-gst_gsmdec_sink_setcaps (GstPad * pad, GstCaps * caps)
+gst_gsmdec_set_format (GstAudioDecoder * dec, GstCaps * caps)
 {
   GstGSMDec *gsmdec;
   GstCaps *srccaps;
   GstStructure *s;
   gboolean ret = FALSE;
+  gint rate;
 
-  gsmdec = GST_GSMDEC (gst_pad_get_parent (pad));
+  gsmdec = GST_GSMDEC (dec);
 
   s = gst_caps_get_structure (caps, 0);
   if (s == NULL)
@@ -186,7 +159,9 @@ gst_gsmdec_sink_setcaps (GstPad * pad, GstCaps * caps)
   else
     goto wrong_caps;
 
-  if (!gst_structure_get_int (s, "rate", &gsmdec->rate)) {
+  gsmdec->needed = 33;
+
+  if (!gst_structure_get_int (s, "rate", &rate)) {
     GST_WARNING_OBJECT (gsmdec, "missing sample rate parameter from sink caps");
     goto beach;
   }
@@ -194,21 +169,16 @@ gst_gsmdec_sink_setcaps (GstPad * pad, GstCaps * caps)
   /* MSGSM needs different framing */
   gsm_option (gsmdec->state, GSM_OPT_WAV49, &gsmdec->use_wav49);
 
-  gsmdec->duration = gst_util_uint64_scale (ENCODED_SAMPLES,
-      GST_SECOND, gsmdec->rate);
-
   /* Setting up src caps based on the input sample rate. */
   srccaps = gst_caps_new_simple ("audio/x-raw-int",
       "endianness", G_TYPE_INT, G_BYTE_ORDER,
       "signed", G_TYPE_BOOLEAN, TRUE,
       "width", G_TYPE_INT, 16,
       "depth", G_TYPE_INT, 16,
-      "rate", G_TYPE_INT, gsmdec->rate, "channels", G_TYPE_INT, 1, NULL);
-
-  ret = gst_pad_set_caps (gsmdec->srcpad, srccaps);
+      "rate", G_TYPE_INT, rate, "channels", G_TYPE_INT, 1, NULL);
 
+  ret = gst_pad_set_caps (GST_AUDIO_DECODER_SRC_PAD (dec), srccaps);
   gst_caps_unref (srccaps);
-  gst_object_unref (gsmdec);
 
   return ret;
 
@@ -218,127 +188,66 @@ wrong_caps:
   GST_ERROR_OBJECT (gsmdec, "invalid caps received");
 
 beach:
-  gst_object_unref (gsmdec);
 
   return ret;
 }
 
-static gboolean
-gst_gsmdec_sink_event (GstPad * pad, GstEvent * event)
+static GstFlowReturn
+gst_gsmdec_parse (GstAudioDecoder * dec, GstAdapter * adapter,
+    gint * offset, gint * length)
 {
-  gboolean res;
-  GstGSMDec *gsmdec;
+  GstGSMDec *gsmdec = GST_GSMDEC (dec);
+  guint size;
+
+  size = gst_adapter_available (adapter);
+  g_return_val_if_fail (size > 0, GST_FLOW_ERROR);
 
-  gsmdec = GST_GSMDEC (gst_pad_get_parent (pad));
-
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_FLUSH_START:
-      res = gst_pad_push_event (gsmdec->srcpad, event);
-      break;
-    case GST_EVENT_FLUSH_STOP:
-      gst_segment_init (&gsmdec->segment, GST_FORMAT_UNDEFINED);
-      res = gst_pad_push_event (gsmdec->srcpad, event);
-      break;
-    case GST_EVENT_NEWSEGMENT:
-    {
-      gboolean update;
-      GstFormat format;
-      gdouble rate, arate;
-      gint64 start, stop, time;
-
-      gst_event_parse_new_segment_full (event, &update, &rate, &arate, &format,
-          &start, &stop, &time);
-
-      /* now configure the values */
-      gst_segment_set_newsegment_full (&gsmdec->segment, update,
-          rate, arate, format, start, stop, time);
-
-      /* and forward */
-      res = gst_pad_push_event (gsmdec->srcpad, event);
-      break;
-    }
-    case GST_EVENT_EOS:
-    default:
-      res = gst_pad_push_event (gsmdec->srcpad, event);
-      break;
+  /* WAV49 requires alternating 33 and 32 bytes of input */
+  if (gsmdec->use_wav49) {
+    gsmdec->needed = (gsmdec->needed == 33 ? 32 : 33);
   }
 
-  gst_object_unref (gsmdec);
+  if (size < gsmdec->needed)
+    return GST_FLOW_UNEXPECTED;
 
-  return res;
+  *offset = 0;
+  *length = gsmdec->needed;
+
+  return GST_FLOW_OK;
 }
 
 static GstFlowReturn
-gst_gsmdec_chain (GstPad * pad, GstBuffer * buf)
+gst_gsmdec_handle_frame (GstAudioDecoder * dec, GstBuffer * buffer)
 {
   GstGSMDec *gsmdec;
   gsm_byte *data;
   GstFlowReturn ret = GST_FLOW_OK;
-  GstClockTime timestamp;
-  gint needed;
-
-  gsmdec = GST_GSMDEC (gst_pad_get_parent (pad));
-
-  timestamp = GST_BUFFER_TIMESTAMP (buf);
-
-  if (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT)) {
-    gst_adapter_clear (gsmdec->adapter);
-    gsmdec->next_ts = GST_CLOCK_TIME_NONE;
-    /* FIXME, do some good offset */
-    gsmdec->next_of = 0;
-  }
-  gst_adapter_push (gsmdec->adapter, buf);
-
-  needed = 33;
-  /* do we have enough bytes to read a frame */
-  while (gst_adapter_available (gsmdec->adapter) >= needed) {
-    GstBuffer *outbuf;
-
-    /* always the same amount of output samples */
-    outbuf = gst_buffer_new_and_alloc (ENCODED_SAMPLES * sizeof (gsm_signal));
-
-    /* If we are not given any timestamp, interpolate from last seen
-     * timestamp (if any). */
-    if (timestamp == GST_CLOCK_TIME_NONE)
-      timestamp = gsmdec->next_ts;
-
-    GST_BUFFER_TIMESTAMP (outbuf) = timestamp;
-
-    /* interpolate in the next run */
-    if (timestamp != GST_CLOCK_TIME_NONE)
-      gsmdec->next_ts = timestamp + gsmdec->duration;
-    timestamp = GST_CLOCK_TIME_NONE;
-
-    GST_BUFFER_DURATION (outbuf) = gsmdec->duration;
-    GST_BUFFER_OFFSET (outbuf) = gsmdec->next_of;
-    if (gsmdec->next_of != -1)
-      gsmdec->next_of += ENCODED_SAMPLES;
-    GST_BUFFER_OFFSET_END (outbuf) = gsmdec->next_of;
-
-    gst_buffer_set_caps (outbuf, GST_PAD_CAPS (gsmdec->srcpad));
-
-    /* now encode frame into the output buffer */
-    data = (gsm_byte *) gst_adapter_peek (gsmdec->adapter, needed);
-    if (gsm_decode (gsmdec->state, data,
-            (gsm_signal *) GST_BUFFER_DATA (outbuf)) < 0) {
-      /* invalid frame */
-      GST_WARNING_OBJECT (gsmdec, "tried to decode an invalid frame, skipping");
-    }
-    gst_adapter_flush (gsmdec->adapter, needed);
-
-    /* WAV49 requires alternating 33 and 32 bytes of input */
-    if (gsmdec->use_wav49)
-      needed = (needed == 33 ? 32 : 33);
-
-    GST_DEBUG_OBJECT (gsmdec, "Pushing buffer of size %d ts %" GST_TIME_FORMAT,
-        GST_BUFFER_SIZE (outbuf),
-        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (outbuf)));
-
-    /* push */
-    ret = gst_pad_push (gsmdec->srcpad, outbuf);
+  GstBuffer *outbuf;
+
+  /* no fancy draining */
+  if (G_UNLIKELY (!buffer))
+    return GST_FLOW_OK;
+
+  gsmdec = GST_GSMDEC (dec);
+
+  /* always the same amount of output samples */
+  outbuf = gst_buffer_new_and_alloc (ENCODED_SAMPLES * sizeof (gsm_signal));
+
+  /* now encode frame into the output buffer */
+  data = (gsm_byte *) GST_BUFFER_DATA (buffer);
+  if (gsm_decode (gsmdec->state, data,
+          (gsm_signal *) GST_BUFFER_DATA (outbuf)) < 0) {
+    /* invalid frame */
+    GST_AUDIO_DECODER_ERROR (gsmdec, 1, STREAM, DECODE, (NULL),
+        ("tried to decode an invalid frame"), ret);
+    if (ret != GST_FLOW_OK)
+      goto exit;
+    gst_buffer_unref (outbuf);
+    outbuf = NULL;
   }
 
-  gst_object_unref (gsmdec);
+  gst_audio_decoder_finish_frame (dec, outbuf, 1);
 
+exit:
   return ret;
 }
diff --git a/ext/gsm/gstgsmdec.h b/ext/gsm/gstgsmdec.h
index 0013aa4..d3ddec6 100644
--- a/ext/gsm/gstgsmdec.h
+++ b/ext/gsm/gstgsmdec.h
@@ -21,7 +21,7 @@
 #define __GST_GSMDEC_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstadapter.h>
+#include <gst/audio/gstaudiodecoder.h>
 
 #ifdef GSM_HEADER_IN_SUBDIR
 #include <gsm/gsm.h>
@@ -47,28 +47,16 @@ typedef struct _GstGSMDecClass GstGSMDecClass;
 
 struct _GstGSMDec
 {
-  GstElement element;
-
-  /* pads */
-  GstPad *sinkpad, *srcpad;
+  GstAudioDecoder element;
 
   gsm state;
   gint use_wav49;
-  gint64 next_of;
-  GstClockTime next_ts;
-
-  GstAdapter *adapter;
-
-  GstSegment segment;
-
-  gint rate;
-
-  GstClockTime duration;
+  gint needed;
 };
 
 struct _GstGSMDecClass
 {
-  GstElementClass parent_class;
+  GstAudioDecoderClass parent_class;
 };
 
 GType gst_gsmdec_get_type (void);
diff --git a/ext/gsm/gstgsmenc.c b/ext/gsm/gstgsmenc.c
index 52d0b55..d95968c 100644
--- a/ext/gsm/gstgsmenc.c
+++ b/ext/gsm/gstgsmenc.c
@@ -43,39 +43,12 @@ enum
   ARG_0
 };
 
-static void gst_gsmenc_base_init (gpointer g_class);
-static void gst_gsmenc_class_init (GstGSMEnc * klass);
-static void gst_gsmenc_init (GstGSMEnc * gsmenc);
-static void gst_gsmenc_finalize (GObject * object);
-
-static gboolean gst_gsmenc_setcaps (GstPad * pad, GstCaps * caps);
-static GstFlowReturn gst_gsmenc_chain (GstPad * pad, GstBuffer * buf);
-
-static GstElementClass *parent_class = NULL;
-
-GType
-gst_gsmenc_get_type (void)
-{
-  static GType gsmenc_type = 0;
-
-  if (!gsmenc_type) {
-    static const GTypeInfo gsmenc_info = {
-      sizeof (GstGSMEncClass),
-      gst_gsmenc_base_init,
-      NULL,
-      (GClassInitFunc) gst_gsmenc_class_init,
-      NULL,
-      NULL,
-      sizeof (GstGSMEnc),
-      0,
-      (GInstanceInitFunc) gst_gsmenc_init,
-    };
-
-    gsmenc_type =
-        g_type_register_static (GST_TYPE_ELEMENT, "GstGSMEnc", &gsmenc_info, 0);
-  }
-  return gsmenc_type;
-}
+static gboolean gst_gsmenc_start (GstAudioEncoder * enc);
+static gboolean gst_gsmenc_stop (GstAudioEncoder * enc);
+static gboolean gst_gsmenc_set_format (GstAudioEncoder * enc,
+    GstAudioInfo * info);
+static GstFlowReturn gst_gsmenc_handle_frame (GstAudioEncoder * enc,
+    GstBuffer * in_buf);
 
 static GstStaticPadTemplate gsmenc_src_template =
 GST_STATIC_PAD_TEMPLATE ("src",
@@ -95,6 +68,9 @@ GST_STATIC_PAD_TEMPLATE ("sink",
         "depth = (int) 16, " "rate = (int) 8000, " "channels = (int) 1")
     );
 
+GST_BOILERPLATE (GstGSMEnc, gst_gsmenc, GstAudioEncoder,
+    GST_TYPE_AUDIO_ENCODER);
+
 static void
 gst_gsmenc_base_init (gpointer g_class)
 {
@@ -110,34 +86,32 @@ gst_gsmenc_base_init (gpointer g_class)
 }
 
 static void
-gst_gsmenc_class_init (GstGSMEnc * klass)
+gst_gsmenc_class_init (GstGSMEncClass * klass)
 {
-  GObjectClass *gobject_class;
+  GstAudioEncoderClass *base_class;
 
-  gobject_class = (GObjectClass *) klass;
+  base_class = (GstAudioEncoderClass *) klass;
 
-  parent_class = g_type_class_peek_parent (klass);
-
-  gobject_class->finalize = gst_gsmenc_finalize;
+  base_class->start = GST_DEBUG_FUNCPTR (gst_gsmenc_start);
+  base_class->stop = GST_DEBUG_FUNCPTR (gst_gsmenc_stop);
+  base_class->set_format = GST_DEBUG_FUNCPTR (gst_gsmenc_set_format);
+  base_class->handle_frame = GST_DEBUG_FUNCPTR (gst_gsmenc_handle_frame);
 
   GST_DEBUG_CATEGORY_INIT (gsmenc_debug, "gsmenc", 0, "GSM Encoder");
 }
 
 static void
-gst_gsmenc_init (GstGSMEnc * gsmenc)
+gst_gsmenc_init (GstGSMEnc * gsmenc, GstGSMEncClass * klass)
 {
-  gint use_wav49;
+}
 
-  /* create the sink and src pads */
-  gsmenc->sinkpad =
-      gst_pad_new_from_static_template (&gsmenc_sink_template, "sink");
-  gst_pad_set_chain_function (gsmenc->sinkpad, gst_gsmenc_chain);
-  gst_pad_set_setcaps_function (gsmenc->sinkpad, gst_gsmenc_setcaps);
-  gst_element_add_pad (GST_ELEMENT (gsmenc), gsmenc->sinkpad);
+static gboolean
+gst_gsmenc_start (GstAudioEncoder * enc)
+{
+  GstGSMEnc *gsmenc = GST_GSMENC (enc);
+  gint use_wav49;
 
-  gsmenc->srcpad =
-      gst_pad_new_from_static_template (&gsmenc_src_template, "src");
-  gst_element_add_pad (GST_ELEMENT (gsmenc), gsmenc->srcpad);
+  GST_DEBUG_OBJECT (enc, "start");
 
   gsmenc->state = gsm_create ();
 
@@ -145,78 +119,69 @@ gst_gsmenc_init (GstGSMEnc * gsmenc)
   use_wav49 = 0;
   gsm_option (gsmenc->state, GSM_OPT_WAV49, &use_wav49);
 
-  gsmenc->adapter = gst_adapter_new ();
-  gsmenc->next_ts = 0;
+  return TRUE;
 }
 
-static void
-gst_gsmenc_finalize (GObject * object)
+static gboolean
+gst_gsmenc_stop (GstAudioEncoder * enc)
 {
-  GstGSMEnc *gsmenc;
-
-  gsmenc = GST_GSMENC (object);
+  GstGSMEnc *gsmenc = GST_GSMENC (enc);
 
-  g_object_unref (gsmenc->adapter);
+  GST_DEBUG_OBJECT (enc, "stop");
   gsm_destroy (gsmenc->state);
 
-  G_OBJECT_CLASS (parent_class)->finalize (object);
+  return TRUE;
 }
 
 static gboolean
-gst_gsmenc_setcaps (GstPad * pad, GstCaps * caps)
+gst_gsmenc_set_format (GstAudioEncoder * benc, GstAudioInfo * info)
 {
-  GstGSMEnc *gsmenc;
   GstCaps *srccaps;
 
-  gsmenc = GST_GSMENC (gst_pad_get_parent (pad));
-
   srccaps = gst_static_pad_template_get_caps (&gsmenc_src_template);
+  gst_pad_set_caps (GST_AUDIO_ENCODER_SRC_PAD (benc), srccaps);
 
-  gst_pad_set_caps (gsmenc->srcpad, srccaps);
-
-  gst_object_unref (gsmenc);
+  /* report needs to base class */
+  gst_audio_encoder_set_frame_samples_min (benc, 160);
+  gst_audio_encoder_set_frame_samples_max (benc, 160);
+  gst_audio_encoder_set_frame_max (benc, 1);
 
   return TRUE;
 }
 
-
 static GstFlowReturn
-gst_gsmenc_chain (GstPad * pad, GstBuffer * buf)
+gst_gsmenc_handle_frame (GstAudioEncoder * benc, GstBuffer * buffer)
 {
   GstGSMEnc *gsmenc;
   gsm_signal *data;
   GstFlowReturn ret = GST_FLOW_OK;
+  GstBuffer *outbuf;
 
-  gsmenc = GST_GSMENC (gst_pad_get_parent (pad));
+  gsmenc = GST_GSMENC (benc);
 
-  if (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT)) {
-    gst_adapter_clear (gsmenc->adapter);
+  /* we don't deal with squeezing remnants, so simply discard those */
+  if (G_UNLIKELY (buffer == NULL)) {
+    GST_DEBUG_OBJECT (gsmenc, "no data");
+    goto done;
   }
-  gst_adapter_push (gsmenc->adapter, buf);
-
-  while (gst_adapter_available (gsmenc->adapter) >= 320) {
-    GstBuffer *outbuf;
-
-    outbuf = gst_buffer_new_and_alloc (33 * sizeof (gsm_byte));
 
-    GST_BUFFER_TIMESTAMP (outbuf) = gsmenc->next_ts;
-    GST_BUFFER_DURATION (outbuf) = 20 * GST_MSECOND;
-    gsmenc->next_ts += 20 * GST_MSECOND;
-
-    /* encode 160 16-bit samples into 33 bytes */
-    data = (gsm_signal *) gst_adapter_peek (gsmenc->adapter, 320);
-    gsm_encode (gsmenc->state, data, (gsm_byte *) GST_BUFFER_DATA (outbuf));
-    gst_adapter_flush (gsmenc->adapter, 320);
+  if (G_UNLIKELY (GST_BUFFER_SIZE (buffer) < 320)) {
+    GST_DEBUG_OBJECT (gsmenc, "discarding trailing data %d",
+        GST_BUFFER_SIZE (buffer));
+    ret = gst_audio_encoder_finish_frame (benc, NULL, -1);
+    goto done;
+  }
 
-    gst_buffer_set_caps (outbuf, GST_PAD_CAPS (gsmenc->srcpad));
+  outbuf = gst_buffer_new_and_alloc (33 * sizeof (gsm_byte));
 
-    GST_DEBUG_OBJECT (gsmenc, "Pushing buffer of size %d",
-        GST_BUFFER_SIZE (outbuf));
+  /* encode 160 16-bit samples into 33 bytes */
+  data = (gsm_signal *) GST_BUFFER_DATA (buffer);
+  gsm_encode (gsmenc->state, data, (gsm_byte *) GST_BUFFER_DATA (outbuf));
 
-    ret = gst_pad_push (gsmenc->srcpad, outbuf);
-  }
+  GST_LOG_OBJECT (gsmenc, "encoded to %d bytes", GST_BUFFER_SIZE (outbuf));
 
-  gst_object_unref (gsmenc);
+  ret = gst_audio_encoder_finish_frame (benc, outbuf, 160);
 
+done:
   return ret;
 }
diff --git a/ext/gsm/gstgsmenc.h b/ext/gsm/gstgsmenc.h
index ba3b089..28b8e2e 100644
--- a/ext/gsm/gstgsmenc.h
+++ b/ext/gsm/gstgsmenc.h
@@ -21,7 +21,7 @@
 #define __GST_GSMENC_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstadapter.h>
+#include <gst/audio/gstaudioencoder.h>
 
 #ifdef GSM_HEADER_IN_SUBDIR
 #include <gsm/gsm.h>
@@ -47,20 +47,14 @@ typedef struct _GstGSMEncClass GstGSMEncClass;
 
 struct _GstGSMEnc
 {
-  GstElement element;
-
-  /* pads */
-  GstPad *sinkpad, *srcpad;
-  GstAdapter *adapter;
+  GstAudioEncoder element;
 
   gsm state;
-  GstClockTime next_ts;
-  gboolean firstBuf;
 };
 
 struct _GstGSMEncClass
 {
-  GstElementClass parent_class;
+  GstAudioEncoderClass parent_class;
 };
 
 GType gst_gsmenc_get_type (void);
diff --git a/ext/kate/Makefile.am b/ext/kate/Makefile.am
index fd7d6ce..4e310d9 100644
--- a/ext/kate/Makefile.am
+++ b/ext/kate/Makefile.am
@@ -9,7 +9,7 @@ libgstkate_la_SOURCES += gstkatetiger.c
 endif
 
 # flags used to compile this plugin
-libgstkate_la_CFLAGS = $(GST_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(TIGER_CFLAGS) $(KATE_CFLAGS)
+libgstkate_la_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS) $(TIGER_CFLAGS) $(KATE_CFLAGS)
 libgstkate_la_LIBADD = $(GST_PLUGINS_BASE_LIBS) -lgstvideo-$(GST_MAJORMINOR) -lgsttag-$(GST_MAJORMINOR) $(GST_LIBS) $(TIGER_LIBS) $(KATE_LIBS)
 libgstkate_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstkate_la_LIBTOOLFLAGS = --tag=disable-static
diff --git a/ext/kate/gstkatetiger.c b/ext/kate/gstkatetiger.c
index be21bb8..d6e25a9 100644
--- a/ext/kate/gstkatetiger.c
+++ b/ext/kate/gstkatetiger.c
@@ -3,7 +3,6 @@
  * Copyright 2005 Thomas Vander Stichele <thomas@apestaart.org>
  * Copyright 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
  * Copyright 2008 Vincent Penquerc'h <ogg.k.ogg.k@googlemail.com>
- * Copyright (C) <2009> Young-Ho Cha <ganadist@gmail.com>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -81,6 +80,7 @@
 #include <string.h>
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <gst/video/video.h>
 
 #include "gstkate.h"
@@ -126,39 +126,6 @@ enum
   ARG_SILENT
 };
 
-/* RGB -> YUV blitting routines taken from textoverlay,
-   original code from Young-Ho Cha <ganadist@gmail.com> */
-
-#define COMP_Y(ret, r, g, b) \
-{ \
-   ret = (int) (((19595 * r) >> 16) + ((38470 * g) >> 16) + ((7471 * b) >> 16)); \
-   ret = CLAMP (ret, 0, 255); \
-}
-
-#define COMP_U(ret, r, g, b) \
-{ \
-   ret = (int) (-((11059 * r) >> 16) - ((21709 * g) >> 16) + ((32768 * b) >> 16) + 128); \
-   ret = CLAMP (ret, 0, 255); \
-}
-
-#define COMP_V(ret, r, g, b) \
-{ \
-   ret = (int) (((32768 * r) >> 16) - ((27439 * g) >> 16) - ((5329 * b) >> 16) + 128); \
-   ret = CLAMP (ret, 0, 255); \
-}
-
-#define BLEND(ret, alpha, v0, v1) \
-{ \
-	ret = (v0 * alpha + v1 * (255 - alpha)) / 255; \
-}
-
-#define OVER(ret, alphaA, Ca, alphaB, Cb, alphaNew)	\
-{ \
-    gint _tmp; \
-    _tmp = (Ca * alphaA + Cb * alphaB * (255 - alphaA) / 255) / alphaNew; \
-    ret = CLAMP (_tmp, 0, 255); \
-}
-
 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
 # define TIGER_ARGB_A 3
 # define TIGER_ARGB_R 2
@@ -187,11 +154,16 @@ static GstStaticPadTemplate kate_sink_factory =
 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
 #define TIGER_VIDEO_CAPS \
     GST_VIDEO_CAPS_xRGB ";" GST_VIDEO_CAPS_BGRx ";" \
-    GST_VIDEO_CAPS_YUV ("{AYUV, I420, YV12, UYVY, NV12, NV21}")
+    GST_VIDEO_CAPS_YUV ("{I420, YV12, AYUV, YUY2, UYVY, v308, v210," \
+        " v216, Y41B, Y42B, Y444, Y800, Y16, NV12, NV21, UYVP, A420," \
+        " YUV9, IYU1}")
+
 #else
 #define TIGER_VIDEO_CAPS \
     GST_VIDEO_CAPS_BGRx ";" GST_VIDEO_CAPS_xRGB ";" \
-    GST_VIDEO_CAPS_YUV ("{AYUV, I420, YV12, UYVY, NV12, NV21}")
+    GST_VIDEO_CAPS_YUV ("{I420, YV12, AYUV, YUY2, UYVY, v308, v210," \
+        " v216, Y41B, Y42B, Y444, Y800, Y16, NV12, NV21, UYVP, A420," \
+        " YUV9, IYU1}")
 #endif
 
 static GstStaticPadTemplate video_sink_factory =
@@ -415,6 +387,8 @@ gst_kate_tiger_init (GstKateTiger * tiger, GstKateTigerClass * gclass)
   tiger->video_width = 0;
   tiger->video_height = 0;
 
+  tiger->composition = NULL;
+
   tiger->seen_header = FALSE;
 }
 
@@ -430,8 +404,10 @@ gst_kate_tiger_dispose (GObject * object)
     tiger->default_font_desc = NULL;
   }
 
-  g_free (tiger->render_buffer);
-  tiger->render_buffer = NULL;
+  if (tiger->render_buffer) {
+    gst_buffer_unref (tiger->render_buffer);
+    tiger->render_buffer = NULL;
+  }
 
   g_cond_free (tiger->cond);
   tiger->cond = NULL;
@@ -439,6 +415,11 @@ gst_kate_tiger_dispose (GObject * object)
   g_mutex_free (tiger->mutex);
   tiger->mutex = NULL;
 
+  if (tiger->composition) {
+    gst_video_overlay_composition_unref (tiger->composition);
+    tiger->composition = NULL;
+  }
+
   GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
 }
 
@@ -788,397 +769,24 @@ gst_kate_tiger_get_time (GstKateTiger * tiger)
 }
 
 static inline void
-gst_kate_tiger_blit_1 (GstKateTiger * tiger, guchar * dest, gint xpos,
-    gint ypos, const guint8 * image, gint image_width, gint image_height,
-    guint dest_stride)
+gst_kate_tiger_set_composition (GstKateTiger * tiger)
 {
-  gint i, j = 0;
-  gint x, y;
-  guchar r, g, b, a;
-  const guint8 *pimage;
-  guchar *py;
-  gint width = image_width;
-  gint height = image_height;
-
-  if (xpos < 0) {
-    xpos = 0;
-  }
-
-  if (xpos + width > tiger->video_width) {
-    width = tiger->video_width - xpos;
-  }
-
-  if (ypos + height > tiger->video_height) {
-    height = tiger->video_height - ypos;
-  }
-
-  dest += (ypos / 1) * dest_stride;
-
-  for (i = 0; i < height; i++) {
-    pimage = image + 4 * (i * image_width);
-    py = dest + i * dest_stride + xpos;
-    for (j = 0; j < width; j++) {
-      b = pimage[TIGER_ARGB_B];
-      g = pimage[TIGER_ARGB_G];
-      r = pimage[TIGER_ARGB_R];
-      a = pimage[TIGER_ARGB_A];
-      TIGER_UNPREMULTIPLY (a, r, g, b);
-
-      pimage += 4;
-      if (a == 0) {
-        py++;
-        continue;
-      }
-      COMP_Y (y, r, g, b);
-      x = *py;
-      BLEND (*py++, a, y, x);
-    }
-  }
-}
-
-static inline void
-gst_kate_tiger_blit_sub2x2cbcr (GstKateTiger * tiger,
-    guchar * destcb, guchar * destcr, gint xpos, gint ypos,
-    const guint8 * image, gint image_width, gint image_height,
-    guint destcb_stride, guint destcr_stride, guint pix_stride)
-{
-  gint i, j;
-  gint x, cb, cr;
-  gushort r, g, b, a;
-  gushort r1, g1, b1, a1;
-  const guint8 *pimage1, *pimage2;
-  guchar *pcb, *pcr;
-  gint width = image_width - 2;
-  gint height = image_height - 2;
-
-  xpos *= pix_stride;
-
-  if (xpos < 0) {
-    xpos = 0;
-  }
-
-  if (xpos + width > tiger->video_width) {
-    width = tiger->video_width - xpos;
-  }
-
-  if (ypos + height > tiger->video_height) {
-    height = tiger->video_height - ypos;
-  }
-
-  destcb += (ypos / 2) * destcb_stride;
-  destcr += (ypos / 2) * destcr_stride;
-
-  for (i = 0; i < height; i += 2) {
-    pimage1 = image + 4 * (i * image_width);
-    pimage2 = pimage1 + 4 * image_width;
-    pcb = destcb + (i / 2) * destcb_stride + xpos / 2;
-    pcr = destcr + (i / 2) * destcr_stride + xpos / 2;
-    for (j = 0; j < width; j += 2) {
-      b = pimage1[TIGER_ARGB_B];
-      g = pimage1[TIGER_ARGB_G];
-      r = pimage1[TIGER_ARGB_R];
-      a = pimage1[TIGER_ARGB_A];
-      TIGER_UNPREMULTIPLY (a, r, g, b);
-      pimage1 += 4;
-
-      b1 = pimage1[TIGER_ARGB_B];
-      g1 = pimage1[TIGER_ARGB_G];
-      r1 = pimage1[TIGER_ARGB_R];
-      a1 = pimage1[TIGER_ARGB_A];
-      TIGER_UNPREMULTIPLY (a1, r1, g1, b1);
-      b += b1;
-      g += g1;
-      r += r1;
-      a += a1;
-      pimage1 += 4;
-
-      b1 = pimage2[TIGER_ARGB_B];
-      g1 = pimage2[TIGER_ARGB_G];
-      r1 = pimage2[TIGER_ARGB_R];
-      a1 = pimage2[TIGER_ARGB_A];
-      TIGER_UNPREMULTIPLY (a1, r1, g1, b1);
-      b += b1;
-      g += g1;
-      r += r1;
-      a += a1;
-      pimage2 += 4;
-
-      /* + 2 for rounding */
-      b1 = pimage2[TIGER_ARGB_B];
-      g1 = pimage2[TIGER_ARGB_G];
-      r1 = pimage2[TIGER_ARGB_R];
-      a1 = pimage2[TIGER_ARGB_A];
-      TIGER_UNPREMULTIPLY (a1, r1, g1, b1);
-      b += b1 + 2;
-      g += g1 + 2;
-      r += r1 + 2;
-      a += a1 + 2;
-      pimage2 += 4;
-
-      b /= 4;
-      g /= 4;
-      r /= 4;
-      a /= 4;
-
-      if (a == 0) {
-        pcb += pix_stride;
-        pcr += pix_stride;
-        continue;
-      }
-      COMP_U (cb, r, g, b);
-      COMP_V (cr, r, g, b);
-
-      x = *pcb;
-      BLEND (*pcb, a, cb, x);
-      x = *pcr;
-      BLEND (*pcr, a, cr, x);
-
-      pcb += pix_stride;
-      pcr += pix_stride;
-    }
-  }
-}
-
-/* FIXME:
- *  - use proper strides and offset for I420
- */
-
-static inline void
-gst_kate_tiger_blit_NV12_NV21 (GstKateTiger * tiger,
-    guint8 * yuv_pixels, gint xpos, gint ypos, const guint8 * image,
-    gint image_width, gint image_height)
-{
-  int y_stride, uv_stride;
-  int u_offset, v_offset;
-  int h, w;
-
-  /* because U/V is 2x2 subsampled, we need to round, either up or down,
-   * to a boundary of integer number of U/V pixels:
-   */
-  xpos = GST_ROUND_UP_2 (xpos);
-  ypos = GST_ROUND_UP_2 (ypos);
-
-  w = tiger->video_width;
-  h = tiger->video_height;
-
-  y_stride = gst_video_format_get_row_stride (tiger->video_format, 0, w);
-  uv_stride = gst_video_format_get_row_stride (tiger->video_format, 1, w);
-  u_offset =
-      gst_video_format_get_component_offset (tiger->video_format, 1, w, h);
-  v_offset =
-      gst_video_format_get_component_offset (tiger->video_format, 2, w, h);
-
-  gst_kate_tiger_blit_1 (tiger, yuv_pixels, xpos, ypos, image, image_width,
-      image_height, y_stride);
-  gst_kate_tiger_blit_sub2x2cbcr (tiger, yuv_pixels + u_offset,
-      yuv_pixels + v_offset, xpos, ypos, image, image_width, image_height,
-      uv_stride, uv_stride, 2);
-}
-
-static inline void
-gst_kate_tiger_blit_I420_YV12 (GstKateTiger * tiger,
-    guint8 * yuv_pixels, gint xpos, gint ypos, const guint8 * image,
-    gint image_width, gint image_height)
-{
-  int y_stride, u_stride, v_stride;
-  int u_offset, v_offset;
-  int h, w;
-
-  /* because U/V is 2x2 subsampled, we need to round, either up or down,
-   * to a boundary of integer number of U/V pixels:
-   */
-  xpos = GST_ROUND_UP_2 (xpos);
-  ypos = GST_ROUND_UP_2 (ypos);
-
-  w = tiger->video_width;
-  h = tiger->video_height;
-
-  y_stride = gst_video_format_get_row_stride (tiger->video_format, 0, w);
-  u_stride = gst_video_format_get_row_stride (tiger->video_format, 1, w);
-  v_stride = gst_video_format_get_row_stride (tiger->video_format, 2, w);
-  u_offset =
-      gst_video_format_get_component_offset (tiger->video_format, 1, w, h);
-  v_offset =
-      gst_video_format_get_component_offset (tiger->video_format, 2, w, h);
-
-  gst_kate_tiger_blit_1 (tiger, yuv_pixels, xpos, ypos, image, image_width,
-      image_height, y_stride);
-  gst_kate_tiger_blit_sub2x2cbcr (tiger, yuv_pixels + u_offset,
-      yuv_pixels + v_offset, xpos, ypos, image, image_width, image_height,
-      u_stride, v_stride, 1);
-}
-
-static inline void
-gst_kate_tiger_blit_UYVY (GstKateTiger * tiger,
-    guint8 * yuv_pixels, gint xpos, gint ypos, const guint8 * image,
-    gint image_width, gint image_height)
-{
-  int a0, r0, g0, b0;
-  int a1, r1, g1, b1;
-  int y0, y1, u, v;
-  int i, j;
-  int h, w;
-  const guint8 *pimage;
-  guchar *dest;
-
-  /* because U/V is 2x horizontally subsampled, we need to round to a
-   * boundary of integer number of U/V pixels in x dimension:
-   */
-  xpos = GST_ROUND_UP_2 (xpos);
-
-  w = image_width - 2;
-  h = image_height - 2;
-
-  if (xpos < 0) {
-    xpos = 0;
-  }
-
-  if (xpos + w > tiger->video_width) {
-    w = tiger->video_width - xpos;
-  }
-
-  if (ypos + h > tiger->video_height) {
-    h = tiger->video_height - ypos;
-  }
-
-  for (i = 0; i < h; i++) {
-    pimage = image + i * image_width * 4;
-    dest = yuv_pixels + (i + ypos) * tiger->video_width * 2 + xpos * 2;
-    for (j = 0; j < w; j += 2) {
-      b0 = pimage[TIGER_ARGB_B];
-      g0 = pimage[TIGER_ARGB_G];
-      r0 = pimage[TIGER_ARGB_R];
-      a0 = pimage[TIGER_ARGB_A];
-      TIGER_UNPREMULTIPLY (a0, r0, g0, b0);
-      pimage += 4;
-
-      b1 = pimage[TIGER_ARGB_B];
-      g1 = pimage[TIGER_ARGB_G];
-      r1 = pimage[TIGER_ARGB_R];
-      a1 = pimage[TIGER_ARGB_A];
-      TIGER_UNPREMULTIPLY (a1, r1, g1, b1);
-      pimage += 4;
-
-      a0 += a1 + 2;
-      a0 /= 2;
-      if (a0 == 0) {
-        dest += 4;
-        continue;
-      }
-
-      COMP_Y (y0, r0, g0, b0);
-      COMP_Y (y1, r1, g1, b1);
-
-      b0 += b1 + 2;
-      g0 += g1 + 2;
-      r0 += r1 + 2;
-
-      b0 /= 2;
-      g0 /= 2;
-      r0 /= 2;
-
-      COMP_U (u, r0, g0, b0);
-      COMP_V (v, r0, g0, b0);
-
-      BLEND (*dest, a0, u, *dest);
-      dest++;
-      BLEND (*dest, a0, y0, *dest);
-      dest++;
-      BLEND (*dest, a0, v, *dest);
-      dest++;
-      BLEND (*dest, a0, y1, *dest);
-      dest++;
-    }
-  }
-}
-
-static inline void
-gst_kate_tiger_blit_AYUV (GstKateTiger * tiger,
-    guint8 * rgb_pixels, gint xpos, gint ypos, const guint8 * image,
-    gint image_width, gint image_height)
-{
-  int a, r, g, b, a1;
-  int y, u, v;
-  int i, j;
-  int h, w;
-  const guint8 *pimage;
-  guchar *dest;
-
-  w = image_width;
-  h = image_height;
-
-  if (xpos < 0) {
-    xpos = 0;
-  }
-
-  if (xpos + w > tiger->video_width) {
-    w = tiger->video_width - xpos;
-  }
-
-  if (ypos + h > tiger->video_height) {
-    h = tiger->video_height - ypos;
-  }
-
-  for (i = 0; i < h; i++) {
-    pimage = image + i * image_width * 4;
-    dest = rgb_pixels + (i + ypos) * 4 * tiger->video_width + xpos * 4;
-    for (j = 0; j < w; j++) {
-      a = pimage[TIGER_ARGB_A];
-      b = pimage[TIGER_ARGB_B];
-      g = pimage[TIGER_ARGB_G];
-      r = pimage[TIGER_ARGB_R];
-
-      TIGER_UNPREMULTIPLY (a, r, g, b);
-
-      // convert background to yuv
-      COMP_Y (y, r, g, b);
-      COMP_U (u, r, g, b);
-      COMP_V (v, r, g, b);
-
-      // preform text "OVER" background alpha compositing
-      a1 = a + (dest[0] * (255 - a)) / 255 + 1; // add 1 to prevent divide by 0
-      OVER (dest[1], a, y, dest[0], dest[1], a1);
-      OVER (dest[2], a, u, dest[0], dest[2], a1);
-      OVER (dest[3], a, v, dest[0], dest[3], a1);
-      dest[0] = a1 - 1;         // remove the temporary 1 we added
-
-      pimage += 4;
-      dest += 4;
-    }
-  }
-}
-
-static void
-gst_kate_tiger_blend_yuv (GstKateTiger * tiger, GstBuffer * video_frame,
-    const guint8 * image, gint image_width, gint image_height)
-{
-  gint xpos = 0, ypos = 0;
-
-  switch (tiger->video_format) {
-    case GST_VIDEO_FORMAT_I420:
-    case GST_VIDEO_FORMAT_YV12:
-      gst_kate_tiger_blit_I420_YV12 (tiger,
-          GST_BUFFER_DATA (video_frame), xpos, ypos, image, image_width,
-          image_height);
-      break;
-    case GST_VIDEO_FORMAT_NV12:
-    case GST_VIDEO_FORMAT_NV21:
-      gst_kate_tiger_blit_NV12_NV21 (tiger,
-          GST_BUFFER_DATA (video_frame), xpos, ypos, image, image_width,
-          image_height);
-      break;
-    case GST_VIDEO_FORMAT_UYVY:
-      gst_kate_tiger_blit_UYVY (tiger,
-          GST_BUFFER_DATA (video_frame), xpos, ypos, image, image_width,
-          image_height);
-      break;
-    case GST_VIDEO_FORMAT_AYUV:
-      gst_kate_tiger_blit_AYUV (tiger,
-          GST_BUFFER_DATA (video_frame), xpos, ypos, image, image_width,
-          image_height);
-      break;
-    default:
-      g_assert_not_reached ();
+  GstVideoOverlayRectangle *rectangle;
+
+  if (tiger->render_buffer) {
+    rectangle = gst_video_overlay_rectangle_new_argb (tiger->render_buffer,
+        tiger->video_width, tiger->video_height, 4 * tiger->video_width,
+        0, 0, tiger->video_width, tiger->video_height,
+        GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA);
+
+    if (tiger->composition)
+      gst_video_overlay_composition_unref (tiger->composition);
+    tiger->composition = gst_video_overlay_composition_new (rectangle);
+    gst_video_overlay_rectangle_unref (rectangle);
+
+  } else if (tiger->composition) {
+    gst_video_overlay_composition_unref (tiger->composition);
+    tiger->composition = NULL;
   }
 }
 
@@ -1246,14 +854,12 @@ gst_kate_tiger_video_chain (GstPad * pad, GstBuffer * buf)
 
   /* and setup that buffer before rendering */
   if (gst_video_format_is_yuv (tiger->video_format)) {
-    guint8 *tmp = g_realloc (tiger->render_buffer,
-        tiger->video_width * tiger->video_height * 4);
-    if (!tmp) {
-      GST_WARNING_OBJECT (tiger, "Failed to allocate render buffer");
-      goto pass;
+    if (!tiger->render_buffer) {
+      tiger->render_buffer =
+          gst_buffer_new_and_alloc (tiger->video_width * tiger->video_height *
+          4);
     }
-    tiger->render_buffer = tmp;
-    ptr = tiger->render_buffer;
+    ptr = GST_BUFFER_DATA (tiger->render_buffer);
     tiger_renderer_set_surface_clear_color (tiger->tr, 1, 0.0, 0.0, 0.0, 0.0);
   } else {
     ptr = GST_BUFFER_DATA (buf);
@@ -1277,8 +883,9 @@ gst_kate_tiger_video_chain (GstPad * pad, GstBuffer * buf)
   }
 
   if (gst_video_format_is_yuv (tiger->video_format)) {
-    gst_kate_tiger_blend_yuv (tiger, buf, tiger->render_buffer,
-        tiger->video_width, tiger->video_height);
+    gst_kate_tiger_set_composition (tiger);
+    if (tiger->composition)
+      gst_video_overlay_composition_blend (tiger->composition, buf);
   }
 
 pass:
diff --git a/ext/kate/gstkatetiger.h b/ext/kate/gstkatetiger.h
index f966cbf..ad7cb14 100644
--- a/ext/kate/gstkatetiger.h
+++ b/ext/kate/gstkatetiger.h
@@ -50,6 +50,7 @@
 #include <tiger/tiger.h>
 #include <gst/gst.h>
 #include <gst/video/video.h>
+#include <gst/video/video-overlay-composition.h>
 #include "gstkateutil.h"
 
 G_BEGIN_DECLS
@@ -95,7 +96,8 @@ struct _GstKateTiger
   gint video_width;
   gint video_height;
   gboolean swap_rgb;
-  guint8 *render_buffer;
+  GstBuffer *render_buffer;
+  GstVideoOverlayComposition *composition;
 
   GMutex *mutex;
   GCond *cond;
diff --git a/ext/modplug/gstmodplug.cc b/ext/modplug/gstmodplug.cc
index 09836a9..3468099 100644
--- a/ext/modplug/gstmodplug.cc
+++ b/ext/modplug/gstmodplug.cc
@@ -43,6 +43,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 /* Required to not get an undefined warning
  * https://bugzilla.gnome.org/show_bug.cgi?id=613795
  */
@@ -463,6 +467,8 @@ static void
 gst_modplug_fixate (GstPad * pad, GstCaps * caps)
 {
   GstStructure *structure;
+  
+  GST_DEBUG_OBJECT (pad, "Fixating caps: %"GST_PTR_FORMAT, caps);
 
   structure = gst_caps_get_structure (caps, 0);
   if (!gst_structure_fixate_field_nearest_int (structure, "rate", 44100))
@@ -496,6 +502,10 @@ gst_modplug_load_song (GstModPlug * modplug)
   gst_structure_get_int (structure, "depth", &modplug->bits);
   gst_structure_get_int (structure, "channels", &modplug->channel);
   gst_structure_get_int (structure, "rate", &modplug->frequency);
+  
+  GST_DEBUG_OBJECT (modplug, 
+      "Audio settings: %d bits, %d channel(s), %d Hz sampling rate",
+      modplug->bits, modplug->channel, modplug->frequency);
 
   gst_pad_set_caps (modplug->srcpad, newcaps);
   gst_caps_unref (newcaps);
@@ -636,7 +646,8 @@ gst_modplug_loop (GstModPlug * modplug)
       GstEvent *newsegment;
       GstTagList *tags;
       gboolean ok;
-      gchar comment[16384];
+      #define COMMENT_SIZE 16384
+      gchar comment[COMMENT_SIZE];
 
       ok = gst_modplug_load_song (modplug);
       gst_buffer_unref (modplug->buffer);
@@ -658,12 +669,13 @@ gst_modplug_loop (GstModPlug * modplug)
           GST_TAG_BEATS_PER_MINUTE,
           (gdouble) modplug->mSoundFile->GetMusicTempo (), NULL);
 
-      if (modplug->mSoundFile->GetSongComments ((gchar *) & comment, 16384, 32)) {
+      if (modplug->mSoundFile->GetSongComments ((gchar *) & comment,
+          COMMENT_SIZE, 32)) {
+        comment[COMMENT_SIZE - 1] = '\0';
         gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,
             GST_TAG_COMMENT, comment, NULL);
       }
 
-
       gst_element_found_tags (GST_ELEMENT (modplug), tags);
     } else {
       /* not fully loaded yet */
@@ -678,7 +690,7 @@ gst_modplug_loop (GstModPlug * modplug)
     gfloat temp;
 
     temp = (gfloat) modplug->song_length / modplug->seek_at;
-    seek_to_pos = (int) (modplug->mSoundFile->GetMaxPosition () / temp);
+    seek_to_pos = (gint) (modplug->mSoundFile->GetMaxPosition () / temp);
 
     GST_DEBUG_OBJECT (modplug, "Seeking to row %d", seek_to_pos);
 
@@ -687,9 +699,12 @@ gst_modplug_loop (GstModPlug * modplug)
   }
 
   /* read and output a buffer */
+  GST_LOG_OBJECT (modplug, "Read %d bytes", (gint)modplug->read_bytes);
+  /* libmodplug 0.8.7 trashes memory */
   flow = gst_pad_alloc_buffer_and_set_caps (modplug->srcpad,
-      GST_BUFFER_OFFSET_NONE, modplug->read_bytes,
+      GST_BUFFER_OFFSET_NONE, modplug->read_bytes * 2,
       GST_PAD_CAPS (modplug->srcpad), &out);
+  GST_BUFFER_SIZE (out) = modplug->read_bytes;
 
   if (flow != GST_FLOW_OK) {
     GST_LOG_OBJECT (modplug, "pad alloc flow: %s", gst_flow_get_name (flow));
@@ -765,6 +780,7 @@ gst_modplug_change_state (GstElement * element, GstStateChange transition)
       }
       if (modplug->mSoundFile) {
         modplug->mSoundFile->Destroy ();
+        delete modplug->mSoundFile;
         modplug->mSoundFile = NULL;
       }
       break;
diff --git a/ext/mpeg2enc/Makefile.am b/ext/mpeg2enc/Makefile.am
index 1e3d944..ae78a55 100644
--- a/ext/mpeg2enc/Makefile.am
+++ b/ext/mpeg2enc/Makefile.am
@@ -8,7 +8,7 @@ libgstmpeg2enc_la_SOURCES = \
 	gstmpeg2encpicturereader.cc
 
 libgstmpeg2enc_la_CXXFLAGS = \
-	$(GST_PLUGINS_BASE_CFLAGS) $(GST_CXXFLAGS) $(MPEG2ENC_CFLAGS)
+	$(GST_PLUGINS_BAD_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GST_CXXFLAGS) $(MPEG2ENC_CFLAGS)
 libgstmpeg2enc_la_LIBADD = \
 	$(GST_PLUGINS_BASE_LIBS) $(GST_LIBS) $(MPEG2ENC_LIBS)
 libgstmpeg2enc_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
diff --git a/ext/mpeg2enc/gstmpeg2enc.cc b/ext/mpeg2enc/gstmpeg2enc.cc
index 1987103..e437b34 100644
--- a/ext/mpeg2enc/gstmpeg2enc.cc
+++ b/ext/mpeg2enc/gstmpeg2enc.cc
@@ -57,6 +57,7 @@
 #include "config.h"
 #endif
 
+#include <gst/glib-compat-private.h>
 #include "gstmpeg2enc.hh"
 
 GST_DEBUG_CATEGORY (mpeg2enc_debug);
diff --git a/ext/mplex/Makefile.am b/ext/mplex/Makefile.am
index 86ff2f2..741b0d8 100644
--- a/ext/mplex/Makefile.am
+++ b/ext/mplex/Makefile.am
@@ -7,7 +7,7 @@ libgstmplex_la_SOURCES = \
 	gstmplexoutputstream.cc
 
 libgstmplex_la_CXXFLAGS = \
-	$(GST_PLUGINS_BASE_CFLAGS) $(GST_CXXFLAGS) $(MPLEX_CFLAGS)
+	$(GST_PLUGINS_BAD_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GST_CXXFLAGS) $(MPLEX_CFLAGS)
 libgstmplex_la_LIBADD = \
 	$(GST_PLUGINS_BASE_LIBS) $(GST_BASE_LIBS) $(GST_LIBS) $(MPLEX_LIBS)
 libgstmplex_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS) $(MPLEX_LDFLAGS)
diff --git a/ext/mplex/gstmplex.cc b/ext/mplex/gstmplex.cc
index ac94e7c..31de91e 100644
--- a/ext/mplex/gstmplex.cc
+++ b/ext/mplex/gstmplex.cc
@@ -53,6 +53,7 @@
 
 #include <string.h>
 
+#include <gst/glib-compat-private.h>
 #include "gstmplex.hh"
 #include "gstmplexoutputstream.hh"
 #include "gstmplexibitstream.hh"
diff --git a/ext/musepack/gstmusepackdec.c b/ext/musepack/gstmusepackdec.c
index 1d6380c..899a4c2 100644
--- a/ext/musepack/gstmusepackdec.c
+++ b/ext/musepack/gstmusepackdec.c
@@ -19,6 +19,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/ext/openal/gstopenalsink.c b/ext/openal/gstopenalsink.c
index a169d9e..9e6bf9a 100644
--- a/ext/openal/gstopenalsink.c
+++ b/ext/openal/gstopenalsink.c
@@ -20,6 +20,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 /**
  * SECTION:element-openalsink
  *
diff --git a/ext/opencv/MotionCells.cpp b/ext/opencv/MotionCells.cpp
index 5223bc7..6d18a99 100644
--- a/ext/opencv/MotionCells.cpp
+++ b/ext/opencv/MotionCells.cpp
@@ -42,6 +42,13 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* This breaks the build for reasons that aren't entirely clear to me yet */
+#if 0
+//#ifdef HAVE_CONFIG_H
+//#include "config.h"
+//#endif
+#endif
+
 #include <cstdlib>
 #include <errno.h>
 #include <math.h>
diff --git a/ext/opencv/MotionCells.h b/ext/opencv/MotionCells.h
index ee84fd6..68a2fec 100644
--- a/ext/opencv/MotionCells.h
+++ b/ext/opencv/MotionCells.h
@@ -46,7 +46,12 @@
 #define MOTIONCELLS_H_
 
 #include <cv.h>                 // includes OpenCV definitions
+#ifdef HAVE_HIGHGUI_H
 #include <highgui.h>            // includes highGUI definitions
+#endif
+#ifdef HAVE_OPENCV2_HIGHGUI_HIGHGUI_C_H
+#include <opencv2/highgui/highgui_c.h>            // includes highGUI definitions
+#endif
 #include <iostream>
 #include <fstream>
 #include <vector>
diff --git a/ext/opencv/gstfaceblur.c b/ext/opencv/gstfaceblur.c
index 2f9dcf5..7b801c1 100644
--- a/ext/opencv/gstfaceblur.c
+++ b/ext/opencv/gstfaceblur.c
@@ -68,7 +68,8 @@
 GST_DEBUG_CATEGORY_STATIC (gst_face_blur_debug);
 #define GST_CAT_DEFAULT gst_face_blur_debug
 
-#define DEFAULT_PROFILE "/usr/share/opencv/haarcascades/haarcascade_frontalface_default.xml"
+#define HAAR_CASCADES_DIR OPENCV_PREFIX "/share/opencv/haarcascades/"
+#define DEFAULT_PROFILE HAAR_CASCADES_DIR "haarcascade_frontalface_default.xml"
 
 /* Filter signals and args */
 enum
diff --git a/ext/opencv/gstfacedetect.c b/ext/opencv/gstfacedetect.c
index 0112671..e51eb52 100644
--- a/ext/opencv/gstfacedetect.c
+++ b/ext/opencv/gstfacedetect.c
@@ -82,10 +82,11 @@
 GST_DEBUG_CATEGORY_STATIC (gst_face_detect_debug);
 #define GST_CAT_DEFAULT gst_face_detect_debug
 
-#define DEFAULT_FACE_PROFILE "/usr/share/opencv/haarcascades/haarcascade_frontalface_default.xml"
-#define DEFAULT_NOSE_PROFILE "/usr/share/opencv/haarcascades/haarcascade_mcs_nose.xml"
-#define DEFAULT_MOUTH_PROFILE "/usr/share/opencv/haarcascades/haarcascade_mcs_mouth.xml"
-#define DEFAULT_EYES_PROFILE "/usr/share/opencv/haarcascades/haarcascade_mcs_eyepair_small.xml"
+#define HAAR_CASCADES_DIR OPENCV_PREFIX "/share/opencv/haarcascades/"
+#define DEFAULT_FACE_PROFILE HAAR_CASCADES_DIR "haarcascade_frontalface_default.xml"
+#define DEFAULT_NOSE_PROFILE HAAR_CASCADES_DIR "haarcascade_mcs_nose.xml"
+#define DEFAULT_MOUTH_PROFILE HAAR_CASCADES_DIR "haarcascade_mcs_mouth.xml"
+#define DEFAULT_EYES_PROFILE HAAR_CASCADES_DIR "haarcascade_mcs_eyepair_small.xml"
 #define DEFAULT_SCALE_FACTOR 1.1
 #define DEFAULT_FLAGS 0
 #define DEFAULT_MIN_NEIGHBORS 3
@@ -469,6 +470,19 @@ gst_face_detect_message_new (GstFaceDetect * filter, GstBuffer * buf)
   return gst_message_new_element (GST_OBJECT (filter), s);
 }
 
+static CvSeq *
+gst_face_detect_run_detector (GstFaceDetect * filter,
+    CvHaarClassifierCascade * detector, gint min_size_width,
+    gint min_size_height)
+{
+  return cvHaarDetectObjects (filter->cvGray, detector,
+      filter->cvStorage, filter->scale_factor, filter->min_neighbors,
+      filter->flags, cvSize (min_size_width, min_size_height)
+#if (CV_MAJOR_VERSION >= 2) && (CV_MINOR_VERSION >= 2)
+      , cvSize (min_size_width + 2, min_size_height + 2)
+#endif
+      );
+}
 
 /* 
  * Performs the face detection
@@ -481,9 +495,11 @@ gst_face_detect_transform_ip (GstOpencvVideoFilter * base, GstBuffer * buf,
 
   if (filter->cvFaceDetect) {
     GstMessage *msg = NULL;
+    GstStructure *s;
     GValue facelist = { 0 };
+    GValue facedata = { 0 };
     CvSeq *faces;
-    CvSeq *mouth, *nose, *eyes;
+    CvSeq *mouth = NULL, *nose = NULL, *eyes = NULL;
     gint i;
     gboolean do_display = FALSE;
 
@@ -498,96 +514,77 @@ gst_face_detect_transform_ip (GstOpencvVideoFilter * base, GstBuffer * buf,
     cvCvtColor (img, filter->cvGray, CV_RGB2GRAY);
     cvClearMemStorage (filter->cvStorage);
 
-    faces =
-        cvHaarDetectObjects (filter->cvGray, filter->cvFaceDetect,
-        filter->cvStorage, filter->scale_factor, filter->min_neighbors,
-        filter->flags, cvSize (filter->min_size_width, filter->min_size_height)
-#if (CV_MAJOR_VERSION >= 2) && (CV_MINOR_VERSION >= 2)
-        , cvSize (filter->min_size_width + 2, filter->min_size_height + 2)
-#endif
-        );
+    faces = gst_face_detect_run_detector (filter, filter->cvFaceDetect,
+        filter->min_size_width, filter->min_size_height);
 
-    if (faces && faces->total > 0) {
-      msg = gst_face_detect_message_new (filter, buf);
-      g_value_init (&facelist, GST_TYPE_LIST);
-    }
+    msg = gst_face_detect_message_new (filter, buf);
+    g_value_init (&facelist, GST_TYPE_LIST);
 
     for (i = 0; i < (faces ? faces->total : 0); i++) {
       CvRect *r = (CvRect *) cvGetSeqElem (faces, i);
-      GValue value = { 0 };
-      GstStructure *s;
       guint mw = filter->min_size_width / 8;
       guint mh = filter->min_size_height / 8;
-      guint rnx, rny, rnw, rnh;
-      guint rmx, rmy, rmw, rmh;
-      guint rex, rey, rew, reh;
+      guint rnx = 0, rny = 0, rnw, rnh;
+      guint rmx = 0, rmy = 0, rmw, rmh;
+      guint rex = 0, rey = 0, rew, reh;
       gboolean have_nose, have_mouth, have_eyes;
 
       /* detect face features */
 
-      rnx = r->x + r->width / 4;
-      rny = r->y + r->height / 4;
-      rnw = r->width / 2;
-      rnh = r->height / 2;
-      cvSetImageROI (filter->cvGray, cvRect (rnx, rny, rnw, rnh));
-      nose =
-          cvHaarDetectObjects (filter->cvGray, filter->cvNoseDetect,
-          filter->cvStorage, filter->scale_factor, filter->min_neighbors,
-          filter->flags, cvSize (mw, mh)
-#if (CV_MAJOR_VERSION >= 2) && (CV_MINOR_VERSION >= 2)
-          , cvSize (mw + 2, mh + 2)
-#endif
-          );
-      have_nose = (nose && nose->total);
-      cvResetImageROI (filter->cvGray);
-
-      rmx = r->x;
-      rmy = r->y + r->height / 2;
-      rmw = r->width;
-      rmh = r->height / 2;
-      cvSetImageROI (filter->cvGray, cvRect (rmx, rmy, rmw, rmh));
-      mouth =
-          cvHaarDetectObjects (filter->cvGray, filter->cvMouthDetect,
-          filter->cvStorage, filter->scale_factor, filter->min_neighbors,
-          filter->flags, cvSize (mw, mh)
-#if (CV_MAJOR_VERSION >= 2) && (CV_MINOR_VERSION >= 2)
-          , cvSize (mw + 2, mh + 2)
-#endif
-          );
-      have_mouth = (mouth && mouth->total);
-      cvResetImageROI (filter->cvGray);
-
-      rex = r->x;
-      rey = r->y;
-      rew = r->width;
-      reh = r->height / 2;
-      cvSetImageROI (filter->cvGray, cvRect (rex, rey, rew, reh));
-      eyes =
-          cvHaarDetectObjects (filter->cvGray, filter->cvEyesDetect,
-          filter->cvStorage, filter->scale_factor, filter->min_neighbors,
-          filter->flags, cvSize (mw, mh)
-#if (CV_MAJOR_VERSION >= 2) && (CV_MINOR_VERSION >= 2)
-          , cvSize (mw + 2, mh + 2)
-#endif
-          );
-      have_eyes = (eyes && eyes->total);
-      cvResetImageROI (filter->cvGray);
+      if (filter->cvNoseDetect) {
+        rnx = r->x + r->width / 4;
+        rny = r->y + r->height / 4;
+        rnw = r->width / 2;
+        rnh = r->height / 2;
+        cvSetImageROI (filter->cvGray, cvRect (rnx, rny, rnw, rnh));
+        nose =
+            gst_face_detect_run_detector (filter, filter->cvNoseDetect, mw, mh);
+        have_nose = (nose && nose->total);
+        cvResetImageROI (filter->cvGray);
+      } else {
+        have_nose = FALSE;
+      }
+
+      if (filter->cvMouthDetect) {
+        rmx = r->x;
+        rmy = r->y + r->height / 2;
+        rmw = r->width;
+        rmh = r->height / 2;
+        cvSetImageROI (filter->cvGray, cvRect (rmx, rmy, rmw, rmh));
+        mouth =
+            gst_face_detect_run_detector (filter, filter->cvMouthDetect, mw,
+            mh);
+        have_mouth = (mouth && mouth->total);
+        cvResetImageROI (filter->cvGray);
+      } else {
+        have_mouth = FALSE;
+      }
+
+      if (filter->cvEyesDetect) {
+        rex = r->x;
+        rey = r->y;
+        rew = r->width;
+        reh = r->height / 2;
+        cvSetImageROI (filter->cvGray, cvRect (rex, rey, rew, reh));
+        eyes =
+            gst_face_detect_run_detector (filter, filter->cvEyesDetect, mw, mh);
+        have_eyes = (eyes && eyes->total);
+        cvResetImageROI (filter->cvGray);
+      } else {
+        have_eyes = FALSE;
+      }
 
       GST_LOG_OBJECT (filter,
           "%2d/%2d: x,y = %4u,%4u: w.h = %4u,%4u : features(e,n,m) = %d,%d,%d",
           i, faces->total, r->x, r->y, r->width, r->height,
           have_eyes, have_nose, have_mouth);
 
-      /* ignore 'face' where we don't fix mount/nose/eyes ? */
-      if (!(have_eyes && have_nose && have_mouth))
-        continue;
-
       s = gst_structure_new ("face",
           "x", G_TYPE_UINT, r->x,
           "y", G_TYPE_UINT, r->y,
           "width", G_TYPE_UINT, r->width,
           "height", G_TYPE_UINT, r->height, NULL);
-      if (nose && nose->total) {
+      if (have_nose) {
         CvRect *sr = (CvRect *) cvGetSeqElem (nose, 0);
         GST_LOG_OBJECT (filter, "nose/%d: x,y = %4u,%4u: w.h = %4u,%4u",
             nose->total, rnx + sr->x, rny + sr->y, sr->width, sr->height);
@@ -597,7 +594,7 @@ gst_face_detect_transform_ip (GstOpencvVideoFilter * base, GstBuffer * buf,
             "nose->width", G_TYPE_UINT, sr->width,
             "nose->height", G_TYPE_UINT, sr->height, NULL);
       }
-      if (mouth && mouth->total) {
+      if (have_mouth) {
         CvRect *sr = (CvRect *) cvGetSeqElem (mouth, 0);
         GST_LOG_OBJECT (filter, "mouth/%d: x,y = %4u,%4u: w.h = %4u,%4u",
             mouth->total, rmx + sr->x, rmy + sr->y, sr->width, sr->height);
@@ -607,7 +604,7 @@ gst_face_detect_transform_ip (GstOpencvVideoFilter * base, GstBuffer * buf,
             "mouth->width", G_TYPE_UINT, sr->width,
             "mouth->height", G_TYPE_UINT, sr->height, NULL);
       }
-      if (eyes && eyes->total) {
+      if (have_eyes) {
         CvRect *sr = (CvRect *) cvGetSeqElem (eyes, 0);
         GST_LOG_OBJECT (filter, "eyes/%d: x,y = %4u,%4u: w.h = %4u,%4u",
             eyes->total, rex + sr->x, rey + sr->y, sr->width, sr->height);
@@ -618,10 +615,11 @@ gst_face_detect_transform_ip (GstOpencvVideoFilter * base, GstBuffer * buf,
             "eyes->height", G_TYPE_UINT, sr->height, NULL);
       }
 
-      g_value_init (&value, GST_TYPE_STRUCTURE);
-      gst_value_set_structure (&value, s);
-      gst_value_list_append_value (&facelist, &value);
-      g_value_unset (&value);
+      g_value_init (&facedata, GST_TYPE_STRUCTURE);
+      g_value_take_boxed (&facedata, s);
+      gst_value_list_append_value (&facelist, &facedata);
+      g_value_unset (&facedata);
+      s = NULL;
 
       if (do_display) {
         CvPoint center;
@@ -640,7 +638,7 @@ gst_face_detect_transform_ip (GstOpencvVideoFilter * base, GstBuffer * buf,
         cvEllipse (img, center, axes, 0.0, 0.0, 360.0, CV_RGB (cr, cg, cb),
             3, 8, 0);
 
-        if (nose && nose->total) {
+        if (have_nose) {
           CvRect *sr = (CvRect *) cvGetSeqElem (nose, 0);
 
           w = sr->width / 2;
@@ -652,7 +650,7 @@ gst_face_detect_transform_ip (GstOpencvVideoFilter * base, GstBuffer * buf,
           cvEllipse (img, center, axes, 0.0, 0.0, 360.0, CV_RGB (cr, cg, cb),
               1, 8, 0);
         }
-        if (mouth && mouth->total) {
+        if (have_mouth) {
           CvRect *sr = (CvRect *) cvGetSeqElem (mouth, 0);
 
           w = sr->width / 2;
@@ -664,7 +662,7 @@ gst_face_detect_transform_ip (GstOpencvVideoFilter * base, GstBuffer * buf,
           cvEllipse (img, center, axes, 0.0, 0.0, 360.0, CV_RGB (cr, cg, cb),
               1, 8, 0);
         }
-        if (eyes && eyes->total) {
+        if (have_eyes) {
           CvRect *sr = (CvRect *) cvGetSeqElem (eyes, 0);
 
           w = sr->width / 2;
@@ -679,11 +677,9 @@ gst_face_detect_transform_ip (GstOpencvVideoFilter * base, GstBuffer * buf,
       }
     }
 
-    if (msg) {
-      gst_structure_set_value (msg->structure, "faces", &facelist);
-      g_value_unset (&facelist);
-      gst_element_post_message (GST_ELEMENT (filter), msg);
-    }
+    gst_structure_set_value (msg->structure, "faces", &facelist);
+    g_value_unset (&facelist);
+    gst_element_post_message (GST_ELEMENT (filter), msg);
   }
 
   return GST_FLOW_OK;
diff --git a/ext/opencv/gstopencvutils.c b/ext/opencv/gstopencvutils.c
index dc42f90..8c72257 100644
--- a/ext/opencv/gstopencvutils.c
+++ b/ext/opencv/gstopencvutils.c
@@ -19,6 +19,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "gstopencvutils.h"
 
 static gboolean
diff --git a/ext/opencv/gstopencvvideofilter.c b/ext/opencv/gstopencvvideofilter.c
index 7c42b19..dcb98c0 100644
--- a/ext/opencv/gstopencvvideofilter.c
+++ b/ext/opencv/gstopencvvideofilter.c
@@ -122,6 +122,8 @@ gst_opencv_video_filter_finalize (GObject * obj)
 
   if (transform->cvImage)
     cvReleaseImage (&transform->cvImage);
+  if (transform->out_cvImage)
+    cvReleaseImage (&transform->out_cvImage);
 
   G_OBJECT_CLASS (parent_class)->finalize (obj);
 }
diff --git a/ext/opencv/gsttemplatematch.h b/ext/opencv/gsttemplatematch.h
index 7b4b388..8d99f98 100644
--- a/ext/opencv/gsttemplatematch.h
+++ b/ext/opencv/gsttemplatematch.h
@@ -48,7 +48,12 @@
 
 #include <gst/gst.h>
 #include <cv.h>
-#include <highgui.h>
+#ifdef HAVE_HIGHGUI_H
+#include <highgui.h>            // includes highGUI definitions
+#endif
+#ifdef HAVE_OPENCV2_HIGHGUI_HIGHGUI_C_H
+#include <opencv2/highgui/highgui_c.h>            // includes highGUI definitions
+#endif
 
 G_BEGIN_DECLS
 /* #defines don't like whitespacey bits */
diff --git a/ext/opencv/motioncells_wrapper.cpp b/ext/opencv/motioncells_wrapper.cpp
index d509686..f55802b 100644
--- a/ext/opencv/motioncells_wrapper.cpp
+++ b/ext/opencv/motioncells_wrapper.cpp
@@ -42,6 +42,13 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* This breaks the build for reasons that aren't entirely clear to me yet */
+#if 0
+//#ifdef HAVE_CONFIG_H
+//#include "config.h"
+//#endif
+#endif
+
 #include <stdio.h>
 #include <limits.h>
 #include "motioncells_wrapper.h"
diff --git a/ext/opus/Makefile.am b/ext/opus/Makefile.am
index cdf3c30..48a7ead 100644
--- a/ext/opus/Makefile.am
+++ b/ext/opus/Makefile.am
@@ -3,13 +3,13 @@ plugin_LTLIBRARIES = libgstopus.la
 libgstopus_la_SOURCES = gstopus.c gstopusdec.c gstopusenc.c gstopusparse.c gstopusheader.c gstopuscommon.c gstrtpopuspay.c gstrtpopusdepay.c
 libgstopus_la_CFLAGS = \
         -DGST_USE_UNSTABLE_API \
+	$(GST_PLUGINS_BAD_CFLAGS) \
 	$(GST_PLUGINS_BASE_CFLAGS) \
 	$(GST_CFLAGS) \
 	$(OPUS_CFLAGS)
 libgstopus_la_LIBADD = \
-	-lgstaudio-$(GST_MAJORMINOR) \
-	$(GST_PLUGINS_BASE_LIBS) -lgsttag-$(GST_MAJORMINOR) \
-    -lgstrtp-@GST_MAJORMINOR@ \
+	$(GST_PLUGINS_BASE_LIBS) -lgstaudio-$(GST_MAJORMINOR) \
+	-lgsttag-$(GST_MAJORMINOR) -lgstrtp-$(GST_MAJORMINOR) \
 	$(GST_BASE_LIBS) \
 	$(GST_LIBS) \
 	$(OPUS_LIBS)
diff --git a/ext/opus/gstopusenc.c b/ext/opus/gstopusenc.c
index 9b475cf..6a19ffd 100644
--- a/ext/opus/gstopusenc.c
+++ b/ext/opus/gstopusenc.c
@@ -48,6 +48,7 @@
 
 #include <gst/gsttagsetter.h>
 #include <gst/audio/audio.h>
+#include <gst/glib-compat-private.h>
 #include "gstopusheader.h"
 #include "gstopuscommon.h"
 #include "gstopusenc.h"
@@ -381,11 +382,9 @@ gst_opus_enc_setup_base_class (GstOpusEnc * enc, GstAudioEncoder * benc)
 {
   gst_audio_encoder_set_latency (benc,
       gst_opus_enc_get_latency (enc), gst_opus_enc_get_latency (enc));
-  gst_audio_encoder_set_frame_samples_min (benc,
-      enc->frame_samples * enc->n_channels * 2);
-  gst_audio_encoder_set_frame_samples_max (benc,
-      enc->frame_samples * enc->n_channels * 2);
-  gst_audio_encoder_set_frame_max (benc, 0);
+  gst_audio_encoder_set_frame_samples_min (benc, enc->frame_samples);
+  gst_audio_encoder_set_frame_samples_max (benc, enc->frame_samples);
+  gst_audio_encoder_set_frame_max (benc, 1);
 }
 
 static gint
@@ -793,6 +792,8 @@ gst_opus_enc_encode (GstOpusEnc * enc, GstBuffer * buf)
   gsize bsize, size;
   gsize bytes;
   gint ret = GST_FLOW_OK;
+  gint outsize;
+  GstBuffer *outbuf;
 
   g_mutex_lock (enc->property_lock);
 
@@ -817,51 +818,41 @@ gst_opus_enc_encode (GstOpusEnc * enc, GstBuffer * buf)
     goto done;
   }
 
+  g_assert (size == bytes);
 
-  while (size) {
-    gint outsize;
-    GstBuffer *outbuf;
+  ret = gst_pad_alloc_buffer_and_set_caps (GST_AUDIO_ENCODER_SRC_PAD (enc),
+      GST_BUFFER_OFFSET_NONE, enc->max_payload_size * enc->n_channels,
+      GST_PAD_CAPS (GST_AUDIO_ENCODER_SRC_PAD (enc)), &outbuf);
 
-    ret = gst_pad_alloc_buffer_and_set_caps (GST_AUDIO_ENCODER_SRC_PAD (enc),
-        GST_BUFFER_OFFSET_NONE, enc->max_payload_size * enc->n_channels,
-        GST_PAD_CAPS (GST_AUDIO_ENCODER_SRC_PAD (enc)), &outbuf);
-
-    if (GST_FLOW_OK != ret)
-      goto done;
-
-    GST_DEBUG_OBJECT (enc, "encoding %d samples (%d bytes)",
-        enc->frame_samples, (int) bytes);
-
-    outsize =
-        opus_multistream_encode (enc->state, (const gint16 *) data,
-        enc->frame_samples, GST_BUFFER_DATA (outbuf),
-        enc->max_payload_size * enc->n_channels);
+  if (GST_FLOW_OK != ret)
+    goto done;
 
-    if (outsize < 0) {
-      GST_ERROR_OBJECT (enc, "Encoding failed: %d", outsize);
-      ret = GST_FLOW_ERROR;
-      goto done;
-    } else if (outsize > enc->max_payload_size) {
-      GST_WARNING_OBJECT (enc,
-          "Encoded size %d is higher than max payload size (%d bytes)",
-          outsize, enc->max_payload_size);
-      ret = GST_FLOW_ERROR;
-      goto done;
-    }
+  GST_DEBUG_OBJECT (enc, "encoding %d samples (%d bytes)",
+      enc->frame_samples, (int) bytes);
 
-    GST_DEBUG_OBJECT (enc, "Output packet is %u bytes", outsize);
-    GST_BUFFER_SIZE (outbuf) = outsize;
+  outsize =
+      opus_multistream_encode (enc->state, (const gint16 *) data,
+      enc->frame_samples, GST_BUFFER_DATA (outbuf),
+      enc->max_payload_size * enc->n_channels);
 
-    ret =
-        gst_audio_encoder_finish_frame (GST_AUDIO_ENCODER (enc), outbuf,
-        enc->frame_samples);
+  if (outsize < 0) {
+    GST_ERROR_OBJECT (enc, "Encoding failed: %d", outsize);
+    ret = GST_FLOW_ERROR;
+    goto done;
+  } else if (outsize > enc->max_payload_size) {
+    GST_WARNING_OBJECT (enc,
+        "Encoded size %d is higher than max payload size (%d bytes)",
+        outsize, enc->max_payload_size);
+    ret = GST_FLOW_ERROR;
+    goto done;
+  }
 
-    if ((GST_FLOW_OK != ret) && (GST_FLOW_NOT_LINKED != ret))
-      goto done;
+  GST_DEBUG_OBJECT (enc, "Output packet is %u bytes", outsize);
+  GST_BUFFER_SIZE (outbuf) = outsize;
 
-    data += bytes;
-    size -= bytes;
-  }
+  ret =
+      gst_audio_encoder_finish_frame (GST_AUDIO_ENCODER (enc), outbuf,
+      enc->frame_samples);
 
 done:
 
diff --git a/ext/resindvd/resindvdbin.c b/ext/resindvd/resindvdbin.c
index c1a29eb..c8102e8 100644
--- a/ext/resindvd/resindvdbin.c
+++ b/ext/resindvd/resindvdbin.c
@@ -24,6 +24,7 @@
 #include <string.h>
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <gst/pbutils/missing-plugins.h>
 
 #include "resindvdbin.h"
diff --git a/ext/resindvd/resindvdsrc.c b/ext/resindvd/resindvdsrc.c
index 3179219..9847369 100644
--- a/ext/resindvd/resindvdsrc.c
+++ b/ext/resindvd/resindvdsrc.c
@@ -25,6 +25,7 @@
 #include <string.h>
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <gst/gst-i18n-plugin.h>
 #include <gst/interfaces/navigation.h>
 #include <gst/video/video.h>
@@ -1035,6 +1036,7 @@ rsn_dvdsrc_step (resinDvdSrc * src, gboolean have_dvd_lock)
       break;
     case DVDNAV_CELL_CHANGE:{
       dvdnav_cell_change_event_t *event = (dvdnav_cell_change_event_t *) data;
+      GstMessage *message;
 
       src->pgc_duration = MPEGTIME_TO_GSTTIME (event->pgc_length);
       /* event->cell_start has the wrong time - it doesn't handle
@@ -1048,6 +1050,10 @@ rsn_dvdsrc_step (resinDvdSrc * src, gboolean have_dvd_lock)
           GST_TIME_FORMAT, GST_TIME_ARGS (src->pgc_duration),
           GST_TIME_ARGS (src->cur_position));
 
+      message = gst_message_new_duration (GST_OBJECT (src), GST_FORMAT_TIME,
+          src->pgc_duration);
+      gst_element_post_message (GST_ELEMENT (src), message);
+
       rsn_dvdsrc_prepare_streamsinfo_event (src);
       src->need_tag_update = TRUE;
 
@@ -2421,6 +2427,53 @@ rsn_dvdsrc_src_event (GstBaseSrc * basesrc, GstEvent * event)
   return res;
 }
 
+static void
+rsn_dvdsrc_post_title_info (GstElement * element)
+{
+  resinDvdSrc *src = RESINDVDSRC (element);
+  GstMessage *message;
+  GstStructure *s;
+  int32_t n, ntitles;
+  int res;
+  GValue array = { 0 };
+
+  res = dvdnav_get_number_of_titles (src->dvdnav, &ntitles);
+  if (res != DVDNAV_STATUS_OK) {
+    GST_WARNING_OBJECT (src, "Failed to get number of titles: %d", res);
+    return;
+  }
+
+  g_value_init (&array, GST_TYPE_ARRAY);
+
+  s = gst_structure_new ("application/x-gst-dvd", "event",
+      G_TYPE_STRING, "dvd-title-info", NULL);
+
+  for (n = 0; n < ntitles; ++n) {
+    uint64_t *times, duration;
+    uint32_t nchapters;
+    GValue item = { 0 };
+
+    g_value_init (&item, G_TYPE_UINT64);
+
+    nchapters =
+        dvdnav_describe_title_chapters (src->dvdnav, n, &times, &duration);
+    if (nchapters == 0) {
+      GST_WARNING_OBJECT (src, "Failed to get title %d info", n);
+      g_value_set_uint64 (&item, GST_CLOCK_TIME_NONE);
+    } else {
+      g_value_set_uint64 (&item, gst_util_uint64_scale (duration, GST_SECOND,
+              90000));
+    }
+    gst_value_array_append_value (&array, &item);
+    g_value_unset (&item);
+  }
+  gst_structure_set_value (s, "title-durations", &array);
+  g_value_unset (&array);
+
+  message = gst_message_new_element (GST_OBJECT (src), s);
+  gst_element_post_message (GST_ELEMENT_CAST (src), message);
+}
+
 static GstStateChangeReturn
 rsn_dvdsrc_change_state (GstElement * element, GstStateChange transition)
 {
@@ -2457,6 +2510,9 @@ rsn_dvdsrc_change_state (GstElement * element, GstStateChange transition)
       rsn_dvdsrc_check_nav_blocks (src);
       g_mutex_unlock (src->dvd_lock);
       break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      rsn_dvdsrc_post_title_info (element);
+      break;
     default:
       break;
   }
@@ -2484,6 +2540,9 @@ rsn_dvdsrc_src_query (GstBaseSrc * basesrc, GstQuery * query)
       if (format == GST_FORMAT_TIME) {
         if (src->pgc_duration != GST_CLOCK_TIME_NONE) {
           val = src->pgc_duration;
+
+          GST_DEBUG_OBJECT (src, "duration : %" GST_TIME_FORMAT,
+              GST_TIME_ARGS (val));
           gst_query_set_duration (query, format, val);
           res = TRUE;
         }
diff --git a/ext/resindvd/rsnparsetter.c b/ext/resindvd/rsnparsetter.c
index baaea2b..ffa5ab5 100644
--- a/ext/resindvd/rsnparsetter.c
+++ b/ext/resindvd/rsnparsetter.c
@@ -7,6 +7,7 @@
 #endif
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <gst/video/video.h>
 #include <string.h>
 
diff --git a/ext/rsvg/gstrsvgoverlay.c b/ext/rsvg/gstrsvgoverlay.c
index 42de199..1673829 100644
--- a/ext/rsvg/gstrsvgoverlay.c
+++ b/ext/rsvg/gstrsvgoverlay.c
@@ -72,7 +72,7 @@ enum
 {
   PROP_0,
   PROP_DATA,
-  PROP_FILENAME,
+  PROP_LOCATION,
   PROP_FIT_TO_FRAME,
   PROP_X,
   PROP_Y,
@@ -164,6 +164,8 @@ gst_rsvg_overlay_set_svg_data (GstRsvgOverlay * overlay, const gchar * data,
         overlay->svg_width = svg_dimension.width;
         overlay->svg_height = svg_dimension.height;
         gst_base_transform_set_passthrough (btrans, FALSE);
+        GST_INFO_OBJECT (overlay, "updated SVG, %d x %d", overlay->svg_width,
+            overlay->svg_height);
       }
     }
   }
@@ -184,7 +186,7 @@ gst_rsvg_overlay_set_property (GObject * object, guint prop_id,
           FALSE);
       break;
     }
-    case PROP_FILENAME:
+    case PROP_LOCATION:
     {
       gst_rsvg_overlay_set_svg_data (overlay, g_value_get_string (value), TRUE);
       break;
@@ -336,7 +338,7 @@ gst_rsvg_overlay_data_sink_event (GstPad * pad, GstEvent * event)
       GST_RSVG_UNLOCK (overlay);
     }
 
-    case GST_EVENT_FLUSH_START:
+    case GST_EVENT_FLUSH_STOP:
       gst_adapter_clear (overlay->adapter);
       break;
 
@@ -436,10 +438,11 @@ gst_rsvg_overlay_stop (GstBaseTransform * btrans)
 
   if (overlay->handle) {
     g_object_unref (overlay->handle);
-    g_object_unref (overlay->adapter);
     overlay->handle = NULL;
   }
 
+  gst_adapter_clear (overlay->adapter);
+
   return TRUE;
 }
 
@@ -473,7 +476,7 @@ gst_rsvg_overlay_class_init (GstRsvgOverlayClass * klass)
   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_DATA,
       g_param_spec_string ("data", "data", "SVG data.", "",
           G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
-  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_FILENAME,
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_LOCATION,
       g_param_spec_string ("location", "location", "SVG file location.", "",
           G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_FIT_TO_FRAME,
diff --git a/ext/schroedinger/gstschrodec.c b/ext/schroedinger/gstschrodec.c
index bbff0eb..c8a6315 100644
--- a/ext/schroedinger/gstschrodec.c
+++ b/ext/schroedinger/gstschrodec.c
@@ -99,10 +99,11 @@ GST_STATIC_PAD_TEMPLATE ("sink",
     );
 
 static GstStaticPadTemplate gst_schro_dec_src_template =
-GST_STATIC_PAD_TEMPLATE ("src",
+    GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("{ I420, YUY2, AYUV }"))
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV (GST_SCHRO_YUV_LIST) ";"
+        GST_VIDEO_CAPS_ARGB)
     );
 
 GST_BOILERPLATE (GstSchroDec, gst_schro_dec, GstBaseVideoDecoder,
@@ -313,12 +314,35 @@ parse_sequence_header (GstSchroDec * schro_dec, guint8 * data, int size)
   ret = schro_parse_decode_sequence_header (data + 13, size - 13,
       &video_format);
   if (ret) {
-    if (video_format.chroma_format == SCHRO_CHROMA_444) {
-      state->format = GST_VIDEO_FORMAT_AYUV;
-    } else if (video_format.chroma_format == SCHRO_CHROMA_422) {
-      state->format = GST_VIDEO_FORMAT_YUY2;
-    } else if (video_format.chroma_format == SCHRO_CHROMA_420) {
-      state->format = GST_VIDEO_FORMAT_I420;
+    int bit_depth;
+
+#if SCHRO_CHECK_VERSION(1,0,11)
+    bit_depth = schro_video_format_get_bit_depth (&video_format);
+#else
+    bit_depth = 8;
+#endif
+
+    if (bit_depth == 8) {
+      if (video_format.chroma_format == SCHRO_CHROMA_444) {
+        state->format = GST_VIDEO_FORMAT_AYUV;
+      } else if (video_format.chroma_format == SCHRO_CHROMA_422) {
+        state->format = GST_VIDEO_FORMAT_UYVY;
+      } else if (video_format.chroma_format == SCHRO_CHROMA_420) {
+        state->format = GST_VIDEO_FORMAT_I420;
+      }
+#if SCHRO_CHECK_VERSION(1,0,11)
+    } else if (bit_depth <= 10) {
+      if (video_format.colour_matrix == SCHRO_COLOUR_MATRIX_REVERSIBLE) {
+        state->format = GST_VIDEO_FORMAT_ARGB;
+      } else {
+        state->format = GST_VIDEO_FORMAT_v210;
+      }
+    } else if (bit_depth <= 16) {
+      state->format = GST_VIDEO_FORMAT_AYUV64;
+    } else {
+      GST_ERROR ("bit depth too large (%d > 16)", bit_depth);
+      state->format = GST_VIDEO_FORMAT_AYUV64;
+#endif
     }
     state->fps_n = video_format.frame_rate_numerator;
     state->fps_d = video_format.frame_rate_denominator;
diff --git a/ext/schroedinger/gstschroenc.c b/ext/schroedinger/gstschroenc.c
index d1eb498..4ca8799 100644
--- a/ext/schroedinger/gstschroenc.c
+++ b/ext/schroedinger/gstschroenc.c
@@ -103,11 +103,16 @@ static GstFlowReturn gst_schro_enc_shape_output (GstBaseVideoEncoder *
     base_video_encoder, GstVideoFrame * frame);
 static void gst_schro_enc_finalize (GObject * object);
 
+#if SCHRO_CHECK_VERSION(1,0,12)
+#define ARGB_CAPS ";" GST_VIDEO_CAPS_ARGB
+#else
+#define ARGB_CAPS
+#endif
 static GstStaticPadTemplate gst_schro_enc_sink_template =
 GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("{ I420, YV12, YUY2, UYVY, AYUV }"))
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV (GST_SCHRO_YUV_LIST) ARGB_CAPS)
     );
 
 static GstStaticPadTemplate gst_schro_enc_src_template =
@@ -271,17 +276,28 @@ gst_schro_enc_set_format (GstBaseVideoEncoder * base_video_encoder,
   switch (state->format) {
     case GST_VIDEO_FORMAT_I420:
     case GST_VIDEO_FORMAT_YV12:
+#if SCHRO_CHECK_VERSION(1,0,11)
+    case GST_VIDEO_FORMAT_Y42B:
+#endif
       schro_enc->video_format->chroma_format = SCHRO_CHROMA_420;
       break;
     case GST_VIDEO_FORMAT_YUY2:
     case GST_VIDEO_FORMAT_UYVY:
+#if SCHRO_CHECK_VERSION(1,0,11)
+    case GST_VIDEO_FORMAT_v216:
+    case GST_VIDEO_FORMAT_v210:
+#endif
       schro_enc->video_format->chroma_format = SCHRO_CHROMA_422;
       break;
     case GST_VIDEO_FORMAT_AYUV:
-      schro_enc->video_format->chroma_format = SCHRO_CHROMA_444;
-      break;
+#if SCHRO_CHECK_VERSION(1,0,12)
     case GST_VIDEO_FORMAT_ARGB:
-      schro_enc->video_format->chroma_format = SCHRO_CHROMA_420;
+#endif
+#if SCHRO_CHECK_VERSION(1,0,11)
+    case GST_VIDEO_FORMAT_Y444:
+    case GST_VIDEO_FORMAT_AYUV64:
+#endif
+      schro_enc->video_format->chroma_format = SCHRO_CHROMA_444;
       break;
     default:
       g_assert_not_reached ();
@@ -300,8 +316,34 @@ gst_schro_enc_set_format (GstBaseVideoEncoder * base_video_encoder,
   schro_enc->video_format->aspect_ratio_numerator = state->par_n;
   schro_enc->video_format->aspect_ratio_denominator = state->par_d;
 
-  schro_video_format_set_std_signal_range (schro_enc->video_format,
-      SCHRO_SIGNAL_RANGE_8BIT_VIDEO);
+  switch (state->format) {
+    default:
+      schro_video_format_set_std_signal_range (schro_enc->video_format,
+          SCHRO_SIGNAL_RANGE_8BIT_VIDEO);
+      break;
+#if SCHRO_CHECK_VERSION(1,0,11)
+    case GST_VIDEO_FORMAT_v210:
+      schro_video_format_set_std_signal_range (schro_enc->video_format,
+          SCHRO_SIGNAL_RANGE_10BIT_VIDEO);
+      break;
+    case GST_VIDEO_FORMAT_v216:
+    case GST_VIDEO_FORMAT_AYUV64:
+      schro_enc->video_format->luma_offset = 64 << 8;
+      schro_enc->video_format->luma_excursion = 219 << 8;
+      schro_enc->video_format->chroma_offset = 128 << 8;
+      schro_enc->video_format->chroma_excursion = 224 << 8;
+      break;
+#endif
+#if SCHRO_CHECK_VERSION(1,0,12)
+    case GST_VIDEO_FORMAT_ARGB:
+      schro_enc->video_format->luma_offset = 256;
+      schro_enc->video_format->luma_excursion = 511;
+      schro_enc->video_format->chroma_offset = 256;
+      schro_enc->video_format->chroma_excursion = 511;
+      break;
+#endif
+  }
+
   schro_video_format_set_std_colour_spec (schro_enc->video_format,
       SCHRO_COLOUR_SPEC_HDTV);
 
diff --git a/ext/schroedinger/gstschroutils.c b/ext/schroedinger/gstschroutils.c
index 66514a3..f23abf7 100644
--- a/ext/schroedinger/gstschroutils.c
+++ b/ext/schroedinger/gstschroutils.c
@@ -72,25 +72,32 @@ gst_schro_buffer_wrap (GstBuffer * buf, GstVideoFormat format, int width,
       frame =
           schro_frame_new_from_data_AYUV (GST_BUFFER_DATA (buf), width, height);
       break;
-#if 0
+#if SCHRO_CHECK_VERSION(1,0,12)
     case GST_VIDEO_FORMAT_ARGB:
-    {
-      SchroFrame *rgbframe =
-          schro_frame_new_from_data_AYUV (GST_BUFFER_DATA (buf), width, height);
-      SchroFrame *vframe1;
-      SchroFrame *vframe2;
-      SchroFrame *vframe3;
-
-      vframe1 = schro_virt_frame_new_unpack (rgbframe);
-      vframe2 = schro_virt_frame_new_color_matrix (vframe1);
-      vframe3 =
-          schro_virt_frame_new_subsample (vframe2, SCHRO_FRAME_FORMAT_U8_420);
-
-      frame = schro_frame_new_and_alloc (NULL, SCHRO_FRAME_FORMAT_U8_420,
-          width, height);
-      schro_virt_frame_render (vframe3, frame);
-      schro_frame_unref (vframe3);
-    }
+      frame =
+          schro_frame_new_from_data_ARGB (GST_BUFFER_DATA (buf), width, height);
+      break;
+#endif
+#if SCHRO_CHECK_VERSION(1,0,11)
+    case GST_VIDEO_FORMAT_Y42B:
+      frame =
+          schro_frame_new_from_data_Y42B (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_Y444:
+      frame =
+          schro_frame_new_from_data_Y444 (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_v210:
+      frame =
+          schro_frame_new_from_data_v210 (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_v216:
+      frame =
+          schro_frame_new_from_data_v216 (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_AYUV64:
+      frame =
+          schro_frame_new_from_data_AY64 (GST_BUFFER_DATA (buf), width, height);
       break;
 #endif
     default:
diff --git a/ext/schroedinger/gstschroutils.h b/ext/schroedinger/gstschroutils.h
index 4e8ca2d..c1d06c5 100644
--- a/ext/schroedinger/gstschroutils.h
+++ b/ext/schroedinger/gstschroutils.h
@@ -24,6 +24,12 @@
 #include <gst/video/video.h>
 #include <schroedinger/schro.h>
 
+#if SCHRO_CHECK_VERSION(1,0,11)
+#define GST_SCHRO_YUV_LIST "{ I420, YV12, YUY2, UYVY, AYUV, Y42B, Y444, v216, v210, AY64 }"
+#else
+#define GST_SCHRO_YUV_LIST "{ I420, YV12, YUY2, UYVY, AYUV }"
+#endif
+
 SchroFrame *
 gst_schro_buffer_wrap (GstBuffer *buf, GstVideoFormat format, int width,
     int height);
diff --git a/ext/sdl/Makefile.am b/ext/sdl/Makefile.am
index 7f29981..6bc4264 100644
--- a/ext/sdl/Makefile.am
+++ b/ext/sdl/Makefile.am
@@ -5,7 +5,7 @@ libgstsdl_la_SOURCES = \
 	sdlvideosink.c \
 	sdlaudiosink.c
 
-libgstsdl_la_CFLAGS =  $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS) $(SDL_CFLAGS)
+libgstsdl_la_CFLAGS =  $(GST_PLUGINS_BAD_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS) $(SDL_CFLAGS)
 libgstsdl_la_LIBADD =  $(GST_PLUGINS_BASE_LIBS) \
 				-lgstvideo-$(GST_MAJORMINOR) \
 				-lgstaudio-$(GST_MAJORMINOR) \
diff --git a/ext/sdl/sdlaudiosink.c b/ext/sdl/sdlaudiosink.c
index 98f5bb7..62c975c 100644
--- a/ext/sdl/sdlaudiosink.c
+++ b/ext/sdl/sdlaudiosink.c
@@ -23,6 +23,8 @@
 
 #include <unistd.h>
 
+#include <gst/glib-compat-private.h>
+
 GST_DEBUG_CATEGORY_EXTERN (sdl_debug);
 #define GST_CAT_DEFAULT sdl_debug
 
diff --git a/ext/sdl/sdlvideosink.c b/ext/sdl/sdlvideosink.c
index fe155a4..0b89805 100644
--- a/ext/sdl/sdlvideosink.c
+++ b/ext/sdl/sdlvideosink.c
@@ -30,6 +30,7 @@
 #endif
 #include <stdlib.h>
 
+#include <gst/glib-compat-private.h>
 #include <gst/interfaces/xoverlay.h>
 #include <gst/interfaces/navigation.h>
 
diff --git a/ext/timidity/gstwildmidi.c b/ext/timidity/gstwildmidi.c
index e78ecc1..287ff54 100644
--- a/ext/timidity/gstwildmidi.c
+++ b/ext/timidity/gstwildmidi.c
@@ -38,6 +38,10 @@
  * </refsect2>
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
diff --git a/ext/voaacenc/gstvoaacenc.c b/ext/voaacenc/gstvoaacenc.c
index ed01f3c..c3f3363 100644
--- a/ext/voaacenc/gstvoaacenc.c
+++ b/ext/voaacenc/gstvoaacenc.c
@@ -456,9 +456,6 @@ gst_voaacenc_handle_frame (GstAudioEncoder * benc, GstBuffer * buf)
 
   g_return_val_if_fail (voaacenc->handle, GST_FLOW_NOT_NEGOTIATED);
 
-  if (voaacenc->rate == 0 || voaacenc->channels == 0)
-    goto not_negotiated;
-
   /* we don't deal with squeezing remnants, so simply discard those */
   if (G_UNLIKELY (buf == NULL)) {
     GST_DEBUG_OBJECT (benc, "no data");
@@ -510,13 +507,6 @@ exit:
   return ret;
 
   /* ERRORS */
-not_negotiated:
-  {
-    GST_ELEMENT_ERROR (voaacenc, STREAM, TYPE_NOT_FOUND,
-        (NULL), ("unknown type"));
-    ret = GST_FLOW_NOT_NEGOTIATED;
-    goto exit;
-  }
 encode_failed:
   {
     GST_ELEMENT_ERROR (voaacenc, STREAM, ENCODE, (NULL), ("encode failed"));
diff --git a/ext/voamrwbenc/gstvoamrwbenc.c b/ext/voamrwbenc/gstvoamrwbenc.c
index b0680ea..f29e71e 100644
--- a/ext/voamrwbenc/gstvoamrwbenc.c
+++ b/ext/voamrwbenc/gstvoamrwbenc.c
@@ -283,11 +283,6 @@ gst_voamrwbenc_handle_frame (GstAudioEncoder * benc, GstBuffer * buffer)
 
   g_return_val_if_fail (amrwbenc->handle, GST_FLOW_NOT_NEGOTIATED);
 
-  if (amrwbenc->rate == 0 || amrwbenc->channels == 0) {
-    ret = GST_FLOW_NOT_NEGOTIATED;
-    goto done;
-  }
-
   /* we don't deal with squeezing remnants, so simply discard those */
   if (G_UNLIKELY (buffer == NULL)) {
     GST_DEBUG_OBJECT (amrwbenc, "no data");
diff --git a/ext/vp8/GstVP8Enc.prs b/ext/vp8/GstVP8Enc.prs
new file mode 100644
index 0000000..6e1d13d
--- /dev/null
+++ b/ext/vp8/GstVP8Enc.prs
@@ -0,0 +1,7 @@
+[_presets_]
+version=0.10
+element-name=GstVP8Enc
+
+[Profile Realtime]
+max-latency=1
+speed=2
diff --git a/ext/vp8/Makefile.am b/ext/vp8/Makefile.am
index d839666..312966c 100644
--- a/ext/vp8/Makefile.am
+++ b/ext/vp8/Makefile.am
@@ -24,3 +24,8 @@ noinst_HEADERS = \
 	gstvp8dec.h \
 	gstvp8enc.h \
 	gstvp8utils.h
+
+presetdir = $(datadir)/gstreamer-$(GST_MAJORMINOR)/presets
+preset_DATA = GstVP8Enc.prs
+
+EXTRA_DIST = $(preset_DATA)
diff --git a/ext/vp8/gstvp8dec.c b/ext/vp8/gstvp8dec.c
index e3a2fd9..68abfec 100644
--- a/ext/vp8/gstvp8dec.c
+++ b/ext/vp8/gstvp8dec.c
@@ -495,6 +495,7 @@ gst_vp8_dec_handle_frame (GstBaseVideoDecoder * decoder, GstVideoFrame * frame)
     }
   } else {
     /* Invisible frame */
+    frame->decode_only = 1;
     gst_base_video_decoder_finish_frame (decoder, frame);
   }
 
diff --git a/ext/vp8/gstvp8enc.c b/ext/vp8/gstvp8enc.c
index b1f06e0..9dadd51 100644
--- a/ext/vp8/gstvp8enc.c
+++ b/ext/vp8/gstvp8enc.c
@@ -843,7 +843,7 @@ gst_vp8_enc_set_format (GstBaseVideoEncoder * base_video_encoder,
 
   /* prepare cached image buffer setup */
   image = &encoder->image;
-  memset (image, 0, sizeof (image));
+  memset (image, 0, sizeof (*image));
 
   image->fmt = VPX_IMG_FMT_I420;
   image->bps = 12;
diff --git a/ext/wayland/Makefile.am b/ext/wayland/Makefile.am
new file mode 100644
index 0000000..122e8f0
--- /dev/null
+++ b/ext/wayland/Makefile.am
@@ -0,0 +1,13 @@
+plugin_LTLIBRARIES = libgstwaylandsink.la
+
+libgstwaylandsink_la_SOURCES =  gstwaylandsink.c
+libgstwaylandsink_la_CFLAGS = $(GST_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) \
+                               $(WAYLAND_CFLAGS)
+libgstwaylandsink_la_LIBADD = $(GST_PLUGINS_BASE_LIBS) \
+                               -lgstvideo-$(GST_MAJORMINOR) \
+                               -lgstinterfaces-$(GST_MAJORMINOR) \
+                               $(WAYLAND_LIBS) $(LIBOIL_LIBS)
+libgstwaylandsink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstwaylandsink_la_LIBTOOLFLAGS = --tag=disable-static
+
+noinst_HEADERS = gstwaylandsink.h
diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
new file mode 100644
index 0000000..ecc026d
--- /dev/null
+++ b/ext/wayland/gstwaylandsink.c
@@ -0,0 +1,681 @@
+/*
+ * GStreamer Wayland video sink
+ *
+ * Copyright (C) 2011 Intel Corporation
+ * Copyright (C) 2011 Sreerenj Balachandran <sreerenj.balachandran@intel.com>
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/**
+ * SECTION:element-waylandsink
+ *
+ *  The waylandsink is creating its own window and render the decoded video frames to that.
+ *  Setup the Wayland environment as described in
+ *  <ulink url="http://wayland.freedesktop.org/building.html">Wayland</ulink> home page.
+ *  The current implementaion is based on weston compositor. 
+ *
+ * <refsect2>
+ * <title>Example pipelines</title>
+ * |[
+ * gst-launch -v videotestsrc ! waylandsink
+ * ]| test the video rendering in wayland
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gstwaylandsink.h"
+
+/* signals */
+enum
+{
+  SIGNAL_0,
+  SIGNAL_FRAME_READY,
+  LAST_SIGNAL
+};
+
+/* Properties */
+enum
+{
+  PROP_0,
+  PROP_WAYLAND_DISPLAY
+};
+
+GST_DEBUG_CATEGORY (gstwayland_debug);
+#define GST_CAT_DEFAULT gstwayland_debug
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-raw-rgb, "
+        "framerate = (fraction) [ 0, MAX ], "
+        "endianness = (int) 4321,"
+        "red_mask = (int) 65280, "
+        "green_mask = (int) 16711680, "
+        "blue_mask = (int) -16777216,"
+        "width = (int) [ 1, MAX ], " "height = (int) [ 1, MAX ] "));
+
+G_DEFINE_TYPE (GstWlBuffer, gst_wlbuffer, GST_TYPE_BUFFER);
+
+/*Fixme: Add more interfaces */
+GST_BOILERPLATE (GstWaylandSink, gst_wayland_sink, GstVideoSink,
+    GST_TYPE_VIDEO_SINK);
+
+static void gst_wlbuffer_finalize (GstWlBuffer * wbuffer);
+
+static void gst_wayland_sink_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec);
+static void gst_wayland_sink_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec);
+static void gst_wayland_sink_finalize (GObject * object);
+static GstCaps *gst_wayland_sink_get_caps (GstBaseSink * bsink);
+static gboolean gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps);
+static gboolean gst_wayland_sink_start (GstBaseSink * bsink);
+static gboolean gst_wayland_sink_stop (GstBaseSink * bsink);
+static GstFlowReturn
+gst_wayland_sink_buffer_alloc (GstBaseSink * bsink, guint64 offset,
+    guint size, GstCaps * caps, GstBuffer ** buf);
+static gboolean gst_wayland_sink_preroll (GstBaseSink * bsink,
+    GstBuffer * buffer);
+static gboolean gst_wayland_sink_render (GstBaseSink * bsink,
+    GstBuffer * buffer);
+static void gst_wayland_bufferpool_clear (GstWaylandSink * sink);
+static void
+gst_wayland_buffer_destroy (GstWaylandSink * sink, GstWlBuffer * buffer);
+
+static int event_mask_update (uint32_t mask, void *data);
+static struct display *create_display (void);
+static void display_handle_global (struct wl_display *display, uint32_t id,
+    const char *interface, uint32_t version, void *data);
+static void redraw (void *data, struct wl_callback *callback, uint32_t time);
+static void create_window (GstWaylandSink * sink, struct display *display,
+    int width, int height);
+
+static void
+gst_wlbuffer_init (GstWlBuffer * buffer)
+{
+  buffer->wbuffer = NULL;
+  buffer->wlsink = NULL;
+}
+
+static void
+gst_wlbuffer_class_init (GstWlBufferClass * klass)
+{
+  GstMiniObjectClass *mini_object_class = GST_MINI_OBJECT_CLASS (klass);
+
+  mini_object_class->finalize = (GstMiniObjectFinalizeFunction)
+      gst_wlbuffer_finalize;
+}
+
+static void
+gst_wlbuffer_finalize (GstWlBuffer * wbuffer)
+{
+  GstWaylandSink *sink = NULL;
+
+  g_return_if_fail (wbuffer != NULL);
+
+  GST_DEBUG_OBJECT (sink, "Finalizing the WlBuffer");
+  sink = wbuffer->wlsink;
+  if (!sink) {
+    GST_WARNING_OBJECT (wbuffer, "No sink..");
+    goto beach;
+  }
+
+  GST_DEBUG_OBJECT (sink, "recycling buffer %p in pool", wbuffer);
+  /* need to increment the refcount again to recycle */
+  gst_buffer_ref (GST_BUFFER (wbuffer));
+  g_mutex_lock (sink->pool_lock);
+  sink->buffer_pool = g_slist_prepend (sink->buffer_pool, wbuffer);
+  g_mutex_unlock (sink->pool_lock);
+
+beach:
+  return;
+}
+
+static void
+gst_wayland_sink_base_init (gpointer gclass)
+{
+
+  GstElementClass *element_class = GST_ELEMENT_CLASS (gclass);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&sink_template));
+
+  gst_element_class_set_details_simple (element_class,
+      "wayland video sink", "Sink/Video",
+      "Output to wayland surface",
+      "Sreerenj Balachandran <sreerenj.balachandran@intel.com>");
+}
+
+static void
+gst_wayland_sink_class_init (GstWaylandSinkClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstBaseSinkClass *gstbasesink_class;
+
+  gobject_class = (GObjectClass *) klass;
+  gstbasesink_class = (GstBaseSinkClass *) klass;
+
+  gobject_class->set_property = gst_wayland_sink_set_property;
+  gobject_class->get_property = gst_wayland_sink_get_property;
+  gobject_class->finalize = GST_DEBUG_FUNCPTR (gst_wayland_sink_finalize);
+
+  gstbasesink_class->get_caps = GST_DEBUG_FUNCPTR (gst_wayland_sink_get_caps);
+  gstbasesink_class->set_caps = GST_DEBUG_FUNCPTR (gst_wayland_sink_set_caps);
+  gstbasesink_class->start = GST_DEBUG_FUNCPTR (gst_wayland_sink_start);
+  gstbasesink_class->buffer_alloc =
+      GST_DEBUG_FUNCPTR (gst_wayland_sink_buffer_alloc);
+  gstbasesink_class->stop = GST_DEBUG_FUNCPTR (gst_wayland_sink_stop);
+  gstbasesink_class->preroll = GST_DEBUG_FUNCPTR (gst_wayland_sink_preroll);
+  gstbasesink_class->render = GST_DEBUG_FUNCPTR (gst_wayland_sink_render);
+
+  g_object_class_install_property (gobject_class, PROP_WAYLAND_DISPLAY,
+      g_param_spec_pointer ("wayland-display", "Wayland Display",
+          "Wayland  Display handle created by the application ",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  parent_class = g_type_class_peek_parent (klass);
+}
+
+static void
+gst_wayland_sink_init (GstWaylandSink * sink,
+    GstWaylandSinkClass * wayland_sink_class)
+{
+
+  sink->caps = NULL;
+  sink->render_finish = TRUE;
+  sink->display = NULL;
+  sink->window = NULL;
+
+  sink->pool_lock = g_mutex_new ();
+  sink->buffer_pool = NULL;
+
+  sink->wayland_lock = g_mutex_new ();
+}
+
+static void
+gst_wayland_sink_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstWaylandSink *sink = GST_WAYLAND_SINK (object);
+
+  switch (prop_id) {
+    case PROP_WAYLAND_DISPLAY:
+      g_value_set_pointer (value, sink->display);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_wayland_sink_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstWaylandSink *sink = GST_WAYLAND_SINK (object);
+
+  switch (prop_id) {
+    case PROP_WAYLAND_DISPLAY:
+      sink->display = g_value_get_pointer (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+destroy_display (struct display *display)
+{
+  if (display->shm)
+    wl_shm_destroy (display->shm);
+
+  if (display->shell)
+    wl_shell_destroy (display->shell);
+
+  if (display->compositor)
+    wl_compositor_destroy (display->compositor);
+
+  wl_display_flush (display->display);
+  wl_display_destroy (display->display);
+  free (display);
+}
+
+static void
+destroy_window (struct window *window)
+{
+  if (window->shell_surface)
+    wl_shell_surface_destroy (window->shell_surface);
+  if (window->surface)
+    wl_surface_destroy (window->surface);
+  free (window);
+}
+
+static void
+gst_wayland_sink_finalize (GObject * object)
+{
+  GstWaylandSink *sink = GST_WAYLAND_SINK (object);
+
+  GST_DEBUG_OBJECT (sink, "Finalizing the sink..");
+
+  if (sink->window)
+    destroy_window (sink->window);
+  if (sink->display)
+    destroy_display (sink->display);
+
+  if (sink->pool_lock) {
+    g_mutex_free (sink->pool_lock);
+    sink->pool_lock = NULL;
+  }
+
+  if (sink->buffer_pool) {
+    gst_wayland_bufferpool_clear (sink);
+  }
+
+  g_mutex_free (sink->wayland_lock);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static GstCaps *
+gst_wayland_sink_get_caps (GstBaseSink * bsink)
+{
+  return gst_caps_copy (gst_static_pad_template_get_caps (&sink_template));
+}
+
+static int
+event_mask_update (uint32_t mask, void *data)
+{
+  struct display *d = data;
+
+  d->mask = mask;
+
+  return 0;
+}
+
+static void
+shm_format (void *data, struct wl_shm *wl_shm, uint32_t format)
+{
+  struct display *d = data;
+
+  d->formats |= (1 << format);
+}
+
+struct wl_shm_listener shm_listenter = {
+  shm_format
+};
+
+static void
+display_handle_global (struct wl_display *display, uint32_t id,
+    const char *interface, uint32_t version, void *data)
+{
+  struct display *d = data;
+
+  if (strcmp (interface, "wl_compositor") == 0) {
+    d->compositor = wl_display_bind (display, id, &wl_compositor_interface);
+  } else if (strcmp (interface, "wl_shell") == 0) {
+    d->shell = wl_display_bind (display, id, &wl_shell_interface);
+  } else if (strcmp (interface, "wl_shm") == 0) {
+    d->shm = wl_display_bind (display, id, &wl_shm_interface);
+    wl_shm_add_listener (d->shm, &shm_listenter, d);
+  }
+
+}
+
+static struct display *
+create_display (void)
+{
+  struct display *display;
+
+  display = malloc (sizeof *display);
+  display->display = wl_display_connect (NULL);
+  assert (display->display);
+
+  wl_display_add_global_listener (display->display,
+      display_handle_global, display);
+
+  wl_display_iterate (display->display, WL_DISPLAY_READABLE);
+  wl_display_roundtrip (display->display);
+
+  if (!(display->formats & (1 << WL_SHM_FORMAT_XRGB8888))) {
+    GST_ERROR ("WL_SHM_FORMAT_XRGB32 not available");
+    return NULL;
+  }
+
+  wl_display_get_fd (display->display, event_mask_update, display);
+
+  return display;
+}
+
+static GstWlBuffer *
+wayland_buffer_create (GstWaylandSink * sink)
+{
+  char filename[1024];
+  int fd, size, stride;
+  static void *data;
+  static int init = 0;
+  GstWlBuffer *wbuffer;
+
+  GST_DEBUG_OBJECT (sink, "Creating wayland-shm buffers");
+
+  wbuffer = (GstWlBuffer *) gst_mini_object_new (GST_TYPE_WLBUFFER);
+  wbuffer->wlsink = gst_object_ref (sink);
+
+  snprintf (filename, 256, "%s-%d-%s", "/tmp/wayland-shm", init++, "XXXXXX");
+
+  fd = mkstemp (filename);
+  if (fd < 0) {
+    GST_ERROR_OBJECT (sink, "open %s failed:", filename);
+    exit (0);
+  }
+
+  stride = sink->video_width * 4;
+  size = stride * sink->video_height;
+
+  if (ftruncate (fd, size) < 0) {
+    GST_ERROR_OBJECT (sink, "ftruncate failed:");
+    close (fd);
+    exit (0);
+  }
+
+  data = mmap (NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+  unlink (filename);
+  if (data == MAP_FAILED) {
+    GST_ELEMENT_ERROR (sink, LIBRARY, SHUTDOWN, (NULL),
+        ("mmap() failed: %s", strerror (errno)));
+    close (fd);
+    exit (0);
+  }
+
+  wbuffer->wbuffer = wl_shm_create_buffer (sink->display->shm, fd,
+      sink->video_width, sink->video_height, stride, WL_SHM_FORMAT_XRGB8888);
+
+  close (fd);
+
+  GST_BUFFER_DATA (wbuffer) = data;
+  GST_BUFFER_SIZE (wbuffer) = size;
+
+  return wbuffer;
+}
+
+static void
+gst_wayland_buffer_destroy (GstWaylandSink * sink, GstWlBuffer * buffer)
+{
+  if (buffer->wlsink) {
+    buffer->wlsink = NULL;
+    gst_object_unref (sink);
+  }
+
+  GST_MINI_OBJECT_CLASS (gst_wlbuffer_parent_class)->finalize (GST_MINI_OBJECT
+      (buffer));
+}
+
+static void
+gst_wayland_bufferpool_clear (GstWaylandSink * sink)
+{
+  g_mutex_lock (sink->pool_lock);
+  while (sink->buffer_pool) {
+    GstWlBuffer *buffer = sink->buffer_pool->data;
+
+    sink->buffer_pool = g_slist_delete_link (sink->buffer_pool,
+        sink->buffer_pool);
+    gst_wayland_buffer_destroy (sink, buffer);
+  }
+  g_mutex_unlock (sink->pool_lock);
+}
+
+static GstFlowReturn
+gst_wayland_sink_buffer_alloc (GstBaseSink * bsink, guint64 offset, guint size,
+    GstCaps * caps, GstBuffer ** buf)
+{
+  GstWaylandSink *sink = GST_WAYLAND_SINK (bsink);
+  GstWlBuffer *buffer = NULL;
+  GstFlowReturn ret = GST_FLOW_OK;
+  GstStructure *structure = NULL;
+  GstCaps *desired_caps = NULL;
+
+  GST_LOG_OBJECT (sink, "a buffer of %u bytes was requested with caps "
+      "%" GST_PTR_FORMAT " and offset %" G_GUINT64_FORMAT, size, caps, offset);
+
+  desired_caps = gst_caps_copy (caps);
+  structure = gst_caps_get_structure (desired_caps, 0);
+
+  if (gst_structure_get_int (structure, "width", &sink->video_width) &&
+      gst_structure_get_int (structure, "height", &sink->video_height)) {
+    sink->bpp = size / sink->video_width / sink->video_height;
+  }
+
+  g_mutex_lock (sink->pool_lock);
+  while (sink->buffer_pool) {
+    buffer = (GstWlBuffer *) sink->buffer_pool->data;
+
+    if (buffer) {
+      sink->buffer_pool =
+          g_slist_delete_link (sink->buffer_pool, sink->buffer_pool);
+    } else {
+      break;
+    }
+  }
+
+  g_mutex_unlock (sink->pool_lock);
+
+  if (!buffer)
+    buffer = wayland_buffer_create (sink);
+
+  if (buffer)
+    gst_buffer_set_caps (GST_BUFFER (buffer), caps);
+
+  *buf = GST_BUFFER (buffer);
+
+  gst_caps_unref (desired_caps);
+
+  return ret;
+}
+
+static gboolean
+gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
+{
+  GstWaylandSink *sink = GST_WAYLAND_SINK (bsink);
+  const GstStructure *structure;
+  GstCaps *allowed_caps;
+  gboolean ret = TRUE;
+
+  GST_LOG_OBJECT (sink, "set caps %" GST_PTR_FORMAT, caps);
+
+  allowed_caps = gst_pad_get_caps (GST_BASE_SINK_PAD (bsink));
+
+  if (!gst_caps_can_intersect (allowed_caps, caps))
+    return FALSE;
+
+  structure = gst_caps_get_structure (caps, 0);
+
+  ret &= gst_structure_get_int (structure, "width", &sink->video_width);
+  ret &= gst_structure_get_int (structure, "height", &sink->video_height);
+
+  if (!ret)
+    return FALSE;
+
+  gst_caps_replace (&sink->caps, caps);
+
+  return TRUE;
+}
+
+static const struct wl_callback_listener frame_listener;
+
+static void
+redraw (void *data, struct wl_callback *callback, uint32_t time)
+{
+
+  GstWaylandSink *sink = (GstWaylandSink *) data;
+
+  sink->render_finish = TRUE;
+}
+
+static void
+create_window (GstWaylandSink * sink, struct display *display, int width,
+    int height)
+{
+  struct window *window;
+
+  if (sink->window)
+    return;
+
+  g_mutex_lock (sink->wayland_lock);
+
+  window = malloc (sizeof *window);
+  window->display = display;
+  window->width = width;
+  window->height = height;
+  window->surface = wl_compositor_create_surface (display->compositor);
+
+  window->shell_surface = wl_shell_get_shell_surface (display->shell,
+      window->surface);
+  /* wl_shell_surface_set_toplevel (window->shell_surface); */
+  wl_shell_surface_set_fullscreen (window->shell_surface,
+      WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT, 0, NULL);
+
+  sink->window = window;
+
+  g_mutex_unlock (sink->wayland_lock);
+}
+
+static gboolean
+gst_wayland_sink_start (GstBaseSink * bsink)
+{
+  GstWaylandSink *sink = (GstWaylandSink *) bsink;
+  gboolean result = TRUE;
+
+  GST_DEBUG_OBJECT (sink, "start");
+
+  if (!sink->display)
+    sink->display = create_display ();
+
+  return result;
+}
+
+static gboolean
+gst_wayland_sink_stop (GstBaseSink * bsink)
+{
+  GstWaylandSink *sink = (GstWaylandSink *) bsink;
+
+  GST_DEBUG_OBJECT (sink, "stop");
+
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_wayland_sink_preroll (GstBaseSink * bsink, GstBuffer * buffer)
+{
+  GST_DEBUG_OBJECT (bsink, "preroll buffer %p, data = %p", buffer,
+      GST_BUFFER_DATA (buffer));
+  return gst_wayland_sink_render (bsink, buffer);
+}
+
+static GstFlowReturn
+gst_wayland_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
+{
+  GstWaylandSink *sink = GST_WAYLAND_SINK (bsink);
+  gboolean mem_cpy = TRUE;
+  GstVideoRectangle src, dst, res;
+
+  GST_LOG_OBJECT (sink,
+      "render buffer %p, data = %p, timestamp = %" GST_TIME_FORMAT, buffer,
+      GST_BUFFER_DATA (buffer), GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)));
+
+  if (!sink->window)
+    create_window (sink, sink->display, sink->video_width, sink->video_height);
+
+  if (sink->render_finish) {
+    if (GST_IS_WLBUFFER (buffer)) {
+      GstWlBuffer *tmp_buffer = (GstWlBuffer *) buffer;
+
+      /* Does it have a waylandbuffer ? */
+      if (tmp_buffer->wbuffer) {
+        mem_cpy = FALSE;
+        GST_DEBUG_OBJECT (sink, "we have a buffer (%p) we allocated "
+            "ourselves and it has a wayland buffer, no memcpy then", buffer);
+        sink->window->buffer = tmp_buffer->wbuffer;
+      } else {
+        /* No wayland buffer, that's a malloc */
+        GST_DEBUG_OBJECT (sink, "we have a buffer (%p) we allocated "
+            "ourselves but it does not hold a wayland buffer", buffer);
+      }
+    } else {
+      /* Not our baby! */
+      GST_DEBUG_OBJECT (sink, "we have a buffer (%p) we did not allocate",
+          buffer);
+    }
+
+    if (mem_cpy) {
+
+      GstWlBuffer *wlbuf = wayland_buffer_create (sink);
+
+      memcpy (GST_BUFFER_DATA (wlbuf), GST_BUFFER_DATA (buffer),
+          GST_BUFFER_SIZE (buffer));
+      sink->window->buffer = wlbuf->wbuffer;
+    }
+
+    src.w = sink->video_width;
+    src.h = sink->video_height;
+    dst.w = sink->window->width;
+    dst.h = sink->window->height;
+
+    gst_video_sink_center_rect (src, dst, &res, FALSE);
+
+    sink->render_finish = FALSE;
+
+    wl_buffer_damage (sink->window->buffer, 0, 0, res.w, res.h);
+
+    wl_surface_attach (sink->window->surface, sink->window->buffer, 0, 0);
+
+    wl_surface_damage (sink->window->surface, 0, 0, res.w, res.h);
+
+    if (sink->callback)
+      wl_callback_destroy (sink->callback);
+
+    sink->callback = wl_surface_frame (sink->window->surface);
+    wl_callback_add_listener (sink->callback, &frame_listener, sink);
+    wl_display_iterate (sink->display->display, sink->display->mask);
+
+  } else
+    GST_LOG_OBJECT (sink,
+        "Waiting to get the signal from compositor to render the next frame..");
+
+  return GST_FLOW_OK;
+}
+
+static const struct wl_callback_listener frame_listener = {
+  redraw
+};
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  GST_DEBUG_CATEGORY_INIT (gstwayland_debug, "waylandsink", 0,
+      " wayland video sink");
+
+  return gst_element_register (plugin, "waylandsink", GST_RANK_MARGINAL,
+      GST_TYPE_WAYLAND_SINK);
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "waylandsink",
+    "Wayland Video Sink", plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME,
+    GST_PACKAGE_ORIGIN)
diff --git a/ext/wayland/gstwaylandsink.h b/ext/wayland/gstwaylandsink.h
new file mode 100644
index 0000000..f9c1ca8
--- /dev/null
+++ b/ext/wayland/gstwaylandsink.h
@@ -0,0 +1,131 @@
+/*
+ * GStreamer Wayland video sink
+ * Copyright (C) 2011 Intel Corporation
+ * Copyright (C) 2011 Sreerenj Balachandran <sreerenj.balachandran@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __GST_WAYLAND_VIDEO_SINK_H__
+#define __GST_WAYLAND_VIDEO_SINK_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <assert.h>
+#include <unistd.h>
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/video/gstvideosink.h>
+
+#include <wayland-client.h>
+
+#define GST_TYPE_WAYLAND_SINK \
+	    (gst_wayland_sink_get_type())
+#define GST_WAYLAND_SINK(obj) \
+	    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WAYLAND_SINK,GstWaylandSink))
+#define GST_WAYLAND_SINK_CLASS(klass) \
+	    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WAYLAND_SINK,GstWaylandSinkClass))
+#define GST_IS_WAYLAND_SINK(obj) \
+	    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WAYLAND_SINK))
+#define GST_IS_WAYLAND_SINK_CLASS(klass) \
+	    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WAYLAND_SINK))
+#define GST_WAYLAND_SINK_GET_CLASS(inst) \
+        (G_TYPE_INSTANCE_GET_CLASS ((inst), GST_TYPE_WAYLAND_SINK, GstWaylandSinkClass))
+
+struct  display
+{
+  struct wl_display *display;
+  struct wl_compositor *compositor;
+  struct wl_shell *shell;
+  struct wl_shm *shm;
+  uint32_t formats;
+  uint32_t mask;
+};
+
+struct window
+{
+  struct display *display;
+  int width, height;
+  struct wl_surface *surface;
+  struct wl_shell_surface *shell_surface;
+  struct wl_buffer *buffer;
+};
+
+typedef struct _GstWaylandSink GstWaylandSink;
+typedef struct _GstWaylandSinkClass GstWaylandSinkClass;
+
+#define GST_TYPE_WLBUFFER (gst_wlbuffer_get_type())
+#define GST_IS_WLBUFFER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WLBUFFER))
+#define GST_WLBUFFER (obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WLBUFFER, GstWlBuffer))
+
+typedef struct _GstWlBuffer GstWlBuffer;
+typedef struct _GstWlBufferClass GstWlBufferClass;
+
+struct _GstWlBuffer {
+  GstBuffer buffer; /* Extending GstBuffer */
+  
+  struct wl_buffer *wbuffer;
+  
+  GstWaylandSink *wlsink;
+};
+
+struct _GstWlBufferClass
+{
+  GstBufferClass parent_class;
+};
+
+struct _GstWaylandSink
+{
+
+  GstVideoSink parent;
+
+  GstCaps *caps;
+  
+  struct display *display;
+  struct window *window;
+  struct wl_callback *callback;
+
+  GMutex *pool_lock;
+  GSList *buffer_pool;
+
+  GMutex *wayland_lock;
+
+  gint video_width;
+  gint video_height;
+  guint bpp;
+
+  gboolean render_finish;
+
+};
+
+struct _GstWaylandSinkClass
+{
+  GstVideoSinkClass parent; 
+};
+
+GType gst_wayland_sink_get_type (void) G_GNUC_CONST;
+GType gst_wlbuffer_get_type (void);
+
+G_END_DECLS
+#endif /* __GST_WAYLAND_VIDEO_SINK_H__ */
diff --git a/gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.c b/gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.c
index 09995b8..99838ad 100644
--- a/gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.c
+++ b/gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.c
@@ -54,6 +54,7 @@
 #  include <config.h>
 #endif
 
+#include <gst/glib-compat-private.h>
 #include "gstbasecamerasrc.h"
 
 enum
diff --git a/gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.c b/gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.c
index 4273c71..b1ab9c7 100644
--- a/gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.c
+++ b/gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.c
@@ -28,6 +28,7 @@
  */
 #include <gst/app/gstappsrc.h>
 #include <gst/app/gstappsink.h>
+#include <gst/glib-compat-private.h>
 #include "gstcamerabinpreview.h"
 #include "gstbasecamerasrc.h"
 
diff --git a/gst-libs/gst/codecparsers/gsth264parser.c b/gst-libs/gst/codecparsers/gsth264parser.c
index 572a28d..00c1517 100644
--- a/gst-libs/gst/codecparsers/gsth264parser.c
+++ b/gst-libs/gst/codecparsers/gsth264parser.c
@@ -167,6 +167,7 @@ typedef struct
   const guint8 *data;
   guint size;
 
+  guint n_epb;                  /* Number of emulation prevention bytes */
   guint byte;                   /* Byte position */
   guint bits_in_cache;          /* bitpos in the cache of next bit */
   guint8 first_byte;
@@ -178,6 +179,7 @@ nal_reader_init (NalReader * nr, const guint8 * data, guint size)
 {
   nr->data = data;
   nr->size = size;
+  nr->n_epb = 0;
 
   nr->byte = 0;
   nr->bits_in_cache = 0;
@@ -211,6 +213,7 @@ nal_reader_read (NalReader * nr, guint nbits)
         ((nr->cache & 0xff) == 0)) {
       /* next byte goes unconditionally to the cache, even if it's 0x03 */
       check_three_byte = FALSE;
+      nr->n_epb++;
       goto next_byte;
     }
     nr->cache = (nr->cache << 8) | nr->first_byte;
@@ -263,6 +266,12 @@ nal_reader_get_remaining (const NalReader * nr)
   return (nr->size - nr->byte) * 8 + nr->bits_in_cache;
 }
 
+static inline guint
+nal_reader_get_epb_count (const NalReader * nr)
+{
+  return nr->n_epb;
+}
+
 #define GST_NAL_READER_READ_BITS(bits) \
 static gboolean \
 nal_reader_get_bits_uint##bits (NalReader *nr, guint##bits *val, guint nbits) \
@@ -1300,7 +1309,8 @@ gst_h264_parser_identify_nalu_avc (GstH264NalParser * nalparser,
   size = size - offset;
   gst_bit_reader_init (&br, data + offset, size);
 
-  gst_bit_reader_get_bits_uint32 (&br, &nalu->size, nal_length_size * 8);
+  nalu->size = gst_bit_reader_get_bits_uint32_unchecked (&br,
+      nal_length_size * 8);
   nalu->sc_offset = offset;
   nalu->offset = offset + nal_length_size;
 
@@ -1882,6 +1892,7 @@ gst_h264_parser_parse_slice_hdr (GstH264NalParser * nalparser,
   }
 
   slice->header_size = nal_reader_get_pos (&nr);
+  slice->n_emulation_prevention_bytes = nal_reader_get_epb_count (&nr);
 
   return GST_H264_PARSER_OK;
 
diff --git a/gst-libs/gst/codecparsers/gsth264parser.h b/gst-libs/gst/codecparsers/gsth264parser.h
index 3c22156..2e570c8 100644
--- a/gst-libs/gst/codecparsers/gsth264parser.h
+++ b/gst-libs/gst/codecparsers/gsth264parser.h
@@ -599,6 +599,9 @@ struct _GstH264SliceHdr
 
   /* Size of the slice_header() in bits */
   guint header_size;
+
+  /* Number of emulation prevention bytes (EPB) in this slice_header() */
+  guint n_emulation_prevention_bytes;
 };
 
 
diff --git a/gst-libs/gst/codecparsers/gstmpeg4parser.c b/gst-libs/gst/codecparsers/gstmpeg4parser.c
index 4b0acb6..1166b87 100644
--- a/gst-libs/gst/codecparsers/gstmpeg4parser.c
+++ b/gst-libs/gst/codecparsers/gstmpeg4parser.c
@@ -277,7 +277,7 @@ find_psc (GstByteReader * br)
       psc_pos = gst_byte_reader_get_pos (br);
       break;
     } else
-      gst_byte_reader_skip (br, 1);
+      gst_byte_reader_skip_unchecked (br, 1);
   }
 
 failed:
@@ -543,7 +543,7 @@ gst_h263_parse (GstMpeg4Packet * packet,
   packet->offset = off1 + offset;
   packet->data = data;
 
-  gst_byte_reader_skip (&br, 3);
+  gst_byte_reader_skip_unchecked (&br, 3);
   off2 = find_psc (&br);
 
   if (off2 == -1) {
diff --git a/gst-libs/gst/codecparsers/gstmpegvideoparser.c b/gst-libs/gst/codecparsers/gstmpegvideoparser.c
index b725d9d..ec8c934 100644
--- a/gst-libs/gst/codecparsers/gstmpegvideoparser.c
+++ b/gst-libs/gst/codecparsers/gstmpegvideoparser.c
@@ -97,9 +97,8 @@ find_start_code (GstBitReader * b)
   while (gst_bit_reader_peek_bits_uint32 (b, &bits, 32)) {
     if (bits >> 8 == 0x1) {
       return TRUE;
-    } else {
-      gst_bit_reader_skip (b, 8);
-    }
+    } else if (gst_bit_reader_skip (b, 8) == FALSE)
+      break;
   }
 
   return FALSE;
@@ -324,21 +323,24 @@ gst_mpeg_video_parse (const guint8 * data, gsize size, guint offset)
   while (off >= 0 && off + 3 < size) {
     GstMpegVideoTypeOffsetSize *codoffsize;
 
-    gst_byte_reader_skip (&br, off + 3);
+
+    if (gst_byte_reader_skip (&br, off + 3) == FALSE)
+      goto failed;
 
     codoffsize = g_malloc (sizeof (GstMpegVideoTypeOffsetSize));
-    gst_byte_reader_get_uint8 (&br, &codoffsize->type);
+    if (gst_byte_reader_get_uint8 (&br, &codoffsize->type) == FALSE)
+      goto failed;
 
     codoffsize->offset = gst_byte_reader_get_pos (&br) + offset;
 
     rsize = gst_byte_reader_get_remaining (&br);
-    if (rsize <= 0) {
-      g_free (codoffsize);
-      break;
+    if (rsize == 0) {
+      /* if there are no more bytes after the start code set the size to -1 */
+      off = -1;
+    } else {
+      off = scan_for_start_codes (&br, 0, rsize);
     }
 
-    off = scan_for_start_codes (&br, 0, rsize);
-
     codoffsize->size = off;
 
     ret = g_list_prepend (ret, codoffsize);
@@ -346,6 +348,12 @@ gst_mpeg_video_parse (const guint8 * data, gsize size, guint offset)
   }
 
   return g_list_reverse (ret);
+
+failed:
+  {
+    GST_WARNING ("Failed to parse");
+    return g_list_reverse (ret);
+  }
 }
 
 /**
diff --git a/gst-libs/gst/codecparsers/gstvc1parser.c b/gst-libs/gst/codecparsers/gstvc1parser.c
index 8f2937f..a82e46e 100644
--- a/gst-libs/gst/codecparsers/gstvc1parser.c
+++ b/gst-libs/gst/codecparsers/gstvc1parser.c
@@ -692,7 +692,7 @@ get_unary (GstBitReader * br, gint stop, gint len)
   guint8 current = 0xff;
 
   for (i = 0; i < len; i++) {
-    gst_bit_reader_get_bits_uint8 (br, &current, 1);
+    current = gst_bit_reader_get_bits_uint8_unchecked (br, 1);
     if (current == stop)
       return i;
   }
diff --git a/gst-libs/gst/glib-compat-private.h b/gst-libs/gst/glib-compat-private.h
new file mode 100644
index 0000000..9d54e92
--- /dev/null
+++ b/gst-libs/gst/glib-compat-private.h
@@ -0,0 +1,148 @@
+/*
+ * glib-compat.c
+ * Functions copied from glib 2.10
+ *
+ * Copyright 2005 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GLIB_COMPAT_PRIVATE_H__
+#define __GLIB_COMPAT_PRIVATE_H__
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+#if !GLIB_CHECK_VERSION(2,25,0)
+
+#if defined (_MSC_VER) && !defined(_WIN64)
+typedef struct _stat32 GStatBuf;
+#else
+typedef struct stat GStatBuf;
+#endif
+
+#endif
+
+#if GLIB_CHECK_VERSION(2,26,0)
+#define GLIB_HAS_GDATETIME
+#endif
+
+/* See bug #651514 */
+#if GLIB_CHECK_VERSION(2,29,5)
+#define G_ATOMIC_POINTER_COMPARE_AND_EXCHANGE(a,b,c) \
+    g_atomic_pointer_compare_and_exchange ((a),(b),(c))
+#define G_ATOMIC_INT_COMPARE_AND_EXCHANGE(a,b,c) \
+    g_atomic_int_compare_and_exchange ((a),(b),(c))
+#else
+#define G_ATOMIC_POINTER_COMPARE_AND_EXCHANGE(a,b,c) \
+    g_atomic_pointer_compare_and_exchange ((volatile gpointer *)(a),(b),(c))
+#define G_ATOMIC_INT_COMPARE_AND_EXCHANGE(a,b,c) \
+    g_atomic_int_compare_and_exchange ((volatile int *)(a),(b),(c))
+#endif
+
+/* See bug #651514 */
+#if GLIB_CHECK_VERSION(2,29,5)
+#define G_ATOMIC_INT_ADD(a,b) g_atomic_int_add ((a),(b))
+#else
+#define G_ATOMIC_INT_ADD(a,b) g_atomic_int_exchange_and_add ((a),(b))
+#endif
+
+/* copies */
+
+#if GLIB_CHECK_VERSION (2, 31, 0)
+#define g_mutex_new gst_g_mutex_new
+static inline GMutex *
+gst_g_mutex_new (void)
+{
+  GMutex *mutex = g_slice_new (GMutex);
+  g_mutex_init (mutex);
+  return mutex;
+}
+#define g_mutex_free gst_g_mutex_free
+static inline void
+gst_g_mutex_free (GMutex *mutex)
+{
+  g_mutex_clear (mutex);
+  g_slice_free (GMutex, mutex);
+}
+#define g_static_rec_mutex_init gst_g_static_rec_mutex_init
+static inline void
+gst_g_static_rec_mutex_init (GStaticRecMutex *mutex)
+{
+  static const GStaticRecMutex init_mutex = G_STATIC_REC_MUTEX_INIT;
+
+  *mutex = init_mutex;
+}
+#define g_cond_new gst_g_cond_new
+static inline GCond *
+gst_g_cond_new (void)
+{
+  GCond *cond = g_slice_new (GCond);
+  g_cond_init (cond);
+  return cond;
+}
+#define g_cond_free gst_g_cond_free
+static inline void
+gst_g_cond_free (GCond *cond)
+{
+  g_cond_clear (cond);
+  g_slice_free (GCond, cond);
+}
+#define g_cond_timed_wait gst_g_cond_timed_wait
+static inline gboolean
+gst_g_cond_timed_wait (GCond *cond, GMutex *mutex, GTimeVal *abs_time)
+{
+  gint64 end_time;
+
+  if (abs_time == NULL) {
+    g_cond_wait (cond, mutex);
+    return TRUE;
+  }
+
+  end_time = abs_time->tv_sec;
+  end_time *= 1000000;
+  end_time += abs_time->tv_usec;
+
+  /* would be nice if we had clock_rtoffset, but that didn't seem to
+   * make it into the kernel yet...
+   */
+  /* if CLOCK_MONOTONIC is not defined then g_get_montonic_time() and
+   * g_get_real_time() are returning the same clock and we'd add ~0
+   */
+  end_time += g_get_monotonic_time () - g_get_real_time ();
+  return g_cond_wait_until (cond, mutex, end_time);
+}
+#endif /* GLIB_CHECK_VERSION (2, 31, 0) */
+
+#if GLIB_CHECK_VERSION (2, 31, 0)
+#define g_thread_create gst_g_thread_create
+static inline GThread *
+gst_g_thread_create (GThreadFunc func, gpointer data, gboolean joinable,
+    GError **error)
+{
+  GThread *thread = g_thread_try_new ("gst-check", func, data, error);
+  if (!joinable)
+    g_thread_unref (thread);
+  return thread;
+}
+#endif /* GLIB_CHECK_VERSION (2, 31, 0) */
+
+/* adaptations */
+
+G_END_DECLS
+
+#endif
diff --git a/gst-libs/gst/video/gstbasevideocodec.c b/gst-libs/gst/video/gstbasevideocodec.c
index ee162be..cae94ab 100644
--- a/gst-libs/gst/video/gstbasevideocodec.c
+++ b/gst-libs/gst/video/gstbasevideocodec.c
@@ -21,6 +21,16 @@
 #include "config.h"
 #endif
 
+/**
+ * SECTION:gstbasevideocodec
+ * @short_description: Base class for video codecs
+ * @see_also: #GstBaseVideoDecoder , #GstBaseVideoEncoder
+ */
+
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include "gstbasevideocodec.h"
 
 #include <string.h>
@@ -45,6 +55,21 @@ static void gst_base_video_codec_finalize (GObject * object);
 static GstStateChangeReturn gst_base_video_codec_change_state (GstElement *
     element, GstStateChange transition);
 
+GType
+gst_video_frame_get_type (void)
+{
+  static volatile gsize type = 0;
+
+  if (g_once_init_enter (&type)) {
+    GType _type;
+
+    _type = g_boxed_type_register_static ("GstVideoFrame",
+        (GBoxedCopyFunc) gst_video_frame_ref,
+        (GBoxedFreeFunc) gst_video_frame_unref);
+    g_once_init_leave (&type, _type);
+  }
+  return (GType) type;
+}
 
 GST_BOILERPLATE (GstBaseVideoCodec, gst_base_video_codec, GstElement,
     GST_TYPE_ELEMENT);
@@ -109,7 +134,7 @@ gst_base_video_codec_reset (GstBaseVideoCodec * base_video_codec)
 
   GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_codec);
   for (g = base_video_codec->frames; g; g = g_list_next (g)) {
-    gst_base_video_codec_free_frame ((GstVideoFrame *) g->data);
+    gst_video_frame_unref ((GstVideoFrame *) g->data);
   }
   g_list_free (base_video_codec->frames);
   base_video_codec->frames = NULL;
@@ -170,6 +195,14 @@ gst_base_video_codec_change_state (GstElement * element,
   return ret;
 }
 
+/**
+ * gst_base_video_codec_new_frame:
+ * @base_video_codec: a #GstBaseVideoCodec
+ *
+ * Create a new blank #GstVideoFrame.
+ * 
+ * Returns: (transfer full): a new #GstVideoFrame
+ */
 GstVideoFrame *
 gst_base_video_codec_new_frame (GstBaseVideoCodec * base_video_codec)
 {
@@ -177,16 +210,21 @@ gst_base_video_codec_new_frame (GstBaseVideoCodec * base_video_codec)
 
   frame = g_slice_new0 (GstVideoFrame);
 
+  frame->ref_count = 1;
+
   GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_codec);
   frame->system_frame_number = base_video_codec->system_frame_number;
   base_video_codec->system_frame_number++;
   GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_codec);
 
+  GST_LOG_OBJECT (base_video_codec, "Created new frame %p (sfn:%d)",
+      frame, frame->system_frame_number);
+
   return frame;
 }
 
-void
-gst_base_video_codec_free_frame (GstVideoFrame * frame)
+static void
+_gst_video_frame_free (GstVideoFrame * frame)
 {
   g_return_if_fail (frame != NULL);
 
@@ -206,3 +244,39 @@ gst_base_video_codec_free_frame (GstVideoFrame * frame)
 
   g_slice_free (GstVideoFrame, frame);
 }
+
+/**
+ * gst_video_frame_ref:
+ * @frame: a #GstVideoFrame
+ *
+ * Increases the refcount of the given frame by one.
+ *
+ * Returns: @buf
+ */
+GstVideoFrame *
+gst_video_frame_ref (GstVideoFrame * frame)
+{
+  g_return_val_if_fail (frame != NULL, NULL);
+
+  g_atomic_int_inc (&frame->ref_count);
+
+  return frame;
+}
+
+/**
+ * gst_video_frame_unref:
+ * @frame: a #GstVideoFrame
+ *
+ * Decreases the refcount of the frame. If the refcount reaches 0, the frame
+ * will be freed.
+ */
+void
+gst_video_frame_unref (GstVideoFrame * frame)
+{
+  g_return_if_fail (frame != NULL);
+  g_return_if_fail (frame->ref_count > 0);
+
+  if (g_atomic_int_dec_and_test (&frame->ref_count)) {
+    _gst_video_frame_free (frame);
+  }
+}
diff --git a/gst-libs/gst/video/gstbasevideocodec.h b/gst-libs/gst/video/gstbasevideocodec.h
index 074537a..de5d3fe 100644
--- a/gst-libs/gst/video/gstbasevideocodec.h
+++ b/gst-libs/gst/video/gstbasevideocodec.h
@@ -76,10 +76,27 @@ G_BEGIN_DECLS
 /**
  * GST_BASE_VIDEO_CODEC_FLOW_NEED_DATA:
  *
+ * Returned while parsing to indicate more data is needed.
  */
 #define GST_BASE_VIDEO_CODEC_FLOW_NEED_DATA GST_FLOW_CUSTOM_SUCCESS
 
+/**
+ * GST_BASE_VIDEO_CODEC_STREAM_LOCK:
+ * @codec: video codec instance
+ *
+ * Obtain a lock to protect the codec function from concurrent access.
+ *
+ * Since: 0.10.22
+ */
 #define GST_BASE_VIDEO_CODEC_STREAM_LOCK(codec) g_static_rec_mutex_lock (&GST_BASE_VIDEO_CODEC (codec)->stream_lock)
+/**
+ * GST_BASE_VIDEO_CODEC_STREAM_UNLOCK:
+ * @codec: video codec instance
+ *
+ * Release the lock that protects the codec function from concurrent access.
+ *
+ * Since: 0.10.22
+ */
 #define GST_BASE_VIDEO_CODEC_STREAM_UNLOCK(codec) g_static_rec_mutex_unlock (&GST_BASE_VIDEO_CODEC (codec)->stream_lock)
 
 typedef struct _GstVideoState GstVideoState;
@@ -87,6 +104,10 @@ typedef struct _GstVideoFrame GstVideoFrame;
 typedef struct _GstBaseVideoCodec GstBaseVideoCodec;
 typedef struct _GstBaseVideoCodecClass GstBaseVideoCodecClass;
 
+/**
+ * GstVideoState:
+ * @caps: The caps 
+ */
 struct _GstVideoState
 {
   GstCaps *caps;
@@ -110,6 +131,8 @@ struct _GstVideoState
 
 struct _GstVideoFrame
 {
+  gint ref_count;
+
   GstClockTime decode_timestamp;
   GstClockTime presentation_timestamp;
   GstClockTime presentation_duration;
@@ -122,6 +145,10 @@ struct _GstVideoFrame
   gboolean is_sync_point;
   gboolean is_eos;
 
+  /* Frames that should not be pushed downstream and are
+   * not meant for display */
+  gboolean decode_only;
+
   GstBuffer *sink_buffer;
   GstBuffer *src_buffer;
 
@@ -141,48 +168,64 @@ struct _GstVideoFrame
   GList *events;
 };
 
+/**
+ * GstBaseVideoCodec:
+ *
+ * The opaque #GstBaseVideoCodec data structure.
+ */
 struct _GstBaseVideoCodec
 {
-  GstElement element;
-
   /*< private >*/
-  GstPad *sinkpad;
-  GstPad *srcpad;
+  GstElement      element;
+
+  /*< protected >*/
+  GstPad         *sinkpad;
+  GstPad         *srcpad;
 
   /* protects all data processing, i.e. is locked
    * in the chain function, finish_frame and when
    * processing serialized events */
   GStaticRecMutex stream_lock;
 
-  guint64 system_frame_number;
+  guint64         system_frame_number;
 
-  GList *frames;  /* Protected with OBJECT_LOCK */
-  GstVideoState state;
-  GstSegment segment;
+  GList          *frames;  /* Protected with OBJECT_LOCK */
+  GstVideoState   state;
+  GstSegment      segment;
 
-  gdouble proportion;
-  GstClockTime earliest_time;
-  gboolean discont;
+  /* QoS properties */
+  gdouble         proportion;
+  GstClockTime    earliest_time;
+  gboolean        discont;
 
-  gint64 bytes;
-  gint64 time;
+  gint64          bytes;
+  gint64          time;
 
   /* FIXME before moving to base */
-  void *padding[GST_PADDING_LARGE];
+  void           *padding[GST_PADDING_LARGE];
 };
 
+/**
+ * GstBaseVideoCodecClass:
+ *
+ * The opaque #GstBaseVideoCodecClass data structure.
+ */
 struct _GstBaseVideoCodecClass
 {
+  /*< private >*/
   GstElementClass element_class;
 
   /* FIXME before moving to base */
   void *padding[GST_PADDING_LARGE];
 };
 
+GType gst_video_frame_get_type (void);
 GType gst_base_video_codec_get_type (void);
 
 GstVideoFrame * gst_base_video_codec_new_frame (GstBaseVideoCodec *base_video_codec);
-void gst_base_video_codec_free_frame (GstVideoFrame *frame);
+
+GstVideoFrame * gst_video_frame_ref (GstVideoFrame * frame);
+void            gst_video_frame_unref (GstVideoFrame * frame);
 
 G_END_DECLS
 
diff --git a/gst-libs/gst/video/gstbasevideodecoder.c b/gst-libs/gst/video/gstbasevideodecoder.c
index f396ca0..dc45498 100644
--- a/gst-libs/gst/video/gstbasevideodecoder.c
+++ b/gst-libs/gst/video/gstbasevideodecoder.c
@@ -127,6 +127,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include "gstbasevideodecoder.h"
 #include "gstbasevideoutils.h"
 
@@ -922,16 +926,19 @@ gst_base_video_decoder_clear_queues (GstBaseVideoDecoder * dec)
   g_list_foreach (dec->gather, (GFunc) gst_mini_object_unref, NULL);
   g_list_free (dec->gather);
   dec->gather = NULL;
-  g_list_foreach (dec->decode, (GFunc) gst_base_video_codec_free_frame, NULL);
+  g_list_foreach (dec->decode, (GFunc) gst_video_frame_unref, NULL);
   g_list_free (dec->decode);
   dec->decode = NULL;
   g_list_foreach (dec->parse, (GFunc) gst_mini_object_unref, NULL);
   g_list_free (dec->parse);
   dec->parse = NULL;
-  g_list_foreach (dec->parse_gather, (GFunc) gst_base_video_codec_free_frame,
-      NULL);
+  g_list_foreach (dec->parse_gather, (GFunc) gst_video_frame_unref, NULL);
   g_list_free (dec->parse_gather);
   dec->parse_gather = NULL;
+  g_list_foreach (GST_BASE_VIDEO_CODEC (dec)->frames,
+      (GFunc) gst_video_frame_unref, NULL);
+  g_list_free (GST_BASE_VIDEO_CODEC (dec)->frames);
+  GST_BASE_VIDEO_CODEC (dec)->frames = NULL;
 }
 
 static void
@@ -965,7 +972,7 @@ gst_base_video_decoder_reset (GstBaseVideoDecoder * base_video_decoder,
   base_video_decoder->timestamps = NULL;
 
   if (base_video_decoder->current_frame) {
-    gst_base_video_codec_free_frame (base_video_decoder->current_frame);
+    gst_video_frame_unref (base_video_decoder->current_frame);
     base_video_decoder->current_frame = NULL;
   }
 
@@ -1094,8 +1101,10 @@ gst_base_video_decoder_flush_decode (GstBaseVideoDecoder * dec)
 
     next = g_list_next (walk);
     if (dec->current_frame)
-      gst_base_video_codec_free_frame (dec->current_frame);
+      gst_video_frame_unref (dec->current_frame);
     dec->current_frame = frame;
+    gst_video_frame_ref (dec->current_frame);
+
     /* decode buffer, resulting data prepended to queue */
     res = gst_base_video_decoder_have_frame_2 (dec);
 
@@ -1406,6 +1415,11 @@ gst_base_video_decoder_prepare_finish_frame (GstBaseVideoDecoder *
   }
   g_list_free (events);
 
+  /* Check if the data should not be displayed. For example altref/invisible
+   * frame in vp8. In this case we should not update the timestamps. */
+  if (frame->decode_only)
+    return;
+
   if (GST_CLOCK_TIME_IS_VALID (frame->presentation_timestamp)) {
     if (frame->presentation_timestamp != base_video_decoder->timestamp_offset) {
       GST_DEBUG_OBJECT (base_video_decoder,
@@ -1471,10 +1485,7 @@ gst_base_video_decoder_do_finish_frame (GstBaseVideoDecoder * dec,
   GST_BASE_VIDEO_CODEC (dec)->frames =
       g_list_remove (GST_BASE_VIDEO_CODEC (dec)->frames, frame);
 
-  if (frame->src_buffer)
-    gst_buffer_unref (frame->src_buffer);
-
-  gst_base_video_codec_free_frame (frame);
+  gst_video_frame_unref (frame);
 }
 
 /**
@@ -1562,7 +1573,7 @@ gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
   base_video_decoder->processed++;
 
   /* no buffer data means this frame is skipped */
-  if (!frame->src_buffer) {
+  if (!frame->src_buffer || frame->decode_only) {
     GST_DEBUG_OBJECT (base_video_decoder, "skipping frame %" GST_TIME_FORMAT,
         GST_TIME_ARGS (frame->presentation_timestamp));
     goto done;
@@ -1679,7 +1690,7 @@ done:
 }
 
 /**
- * gst_base_video_decoder_finish_frame:
+ * gst_base_video_decoder_add_to_frame:
  * @base_video_decoder: a #GstBaseVideoDecoder
  * @n_bytes: an encoded #GstVideoFrame
  *
@@ -1861,6 +1872,9 @@ gst_base_video_decoder_have_frame_2 (GstBaseVideoDecoder * base_video_decoder)
   }
 
 exit:
+  /* current frame has either been added to parse_gather or sent to
+     handle frame so there is no need to unref it */
+
   /* create new frame */
   base_video_decoder->current_frame =
       gst_base_video_decoder_new_frame (base_video_decoder);
@@ -1872,11 +1886,15 @@ exit:
  * gst_base_video_decoder_get_state:
  * @base_video_decoder: a #GstBaseVideoDecoder
  *
+ * Get the current #GstVideoState
+ *
  * Returns: #GstVideoState describing format of video data.
  */
 GstVideoState *
 gst_base_video_decoder_get_state (GstBaseVideoDecoder * base_video_decoder)
 {
+  /* FIXME : Move to base codec class */
+
   return &GST_BASE_VIDEO_CODEC (base_video_decoder)->state;
 }
 
@@ -1925,6 +1943,8 @@ gst_base_video_decoder_set_sync_point (GstBaseVideoDecoder * base_video_decoder)
  * gst_base_video_decoder_get_oldest_frame:
  * @base_video_decoder: a #GstBaseVideoDecoder
  *
+ * Get the oldest pending unfinished #GstVideoFrame
+ *
  * Returns: oldest pending unfinished #GstVideoFrame.
  */
 GstVideoFrame *
@@ -1933,6 +1953,8 @@ gst_base_video_decoder_get_oldest_frame (GstBaseVideoDecoder *
 {
   GList *g;
 
+  /* FIXME : Move to base codec class */
+
   GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_decoder);
   g = g_list_first (GST_BASE_VIDEO_CODEC (base_video_decoder)->frames);
   GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
@@ -1947,6 +1969,8 @@ gst_base_video_decoder_get_oldest_frame (GstBaseVideoDecoder *
  * @base_video_decoder: a #GstBaseVideoDecoder
  * @frame_number: system_frame_number of a frame
  *
+ * Get a pending unfinished #GstVideoFrame
+ * 
  * Returns: pending unfinished #GstVideoFrame identified by @frame_number.
  */
 GstVideoFrame *
@@ -1977,6 +2001,7 @@ gst_base_video_decoder_get_frame (GstBaseVideoDecoder * base_video_decoder,
  *
  * Sets src pad caps according to currently configured #GstVideoState.
  *
+ * Returns: #TRUE if the caps were accepted downstream, else #FALSE.
  */
 gboolean
 gst_base_video_decoder_set_src_caps (GstBaseVideoDecoder * base_video_decoder)
@@ -2028,11 +2053,11 @@ gst_base_video_decoder_set_src_caps (GstBaseVideoDecoder * base_video_decoder)
  * gst_base_video_decoder_alloc_src_buffer:
  * @base_video_decoder: a #GstBaseVideoDecoder
  *
- * Helper function that uses gst_pad_alloc_buffer_and_set_caps
+ * Helper function that uses @gst_pad_alloc_buffer_and_set_caps()
  * to allocate a buffer to hold a video frame for @base_video_decoder's
  * current #GstVideoState.
  *
- * Returns: allocated buffer
+ * Returns: (transfer full): allocated buffer
  */
 GstBuffer *
 gst_base_video_decoder_alloc_src_buffer (GstBaseVideoDecoder *
@@ -2061,6 +2086,7 @@ gst_base_video_decoder_alloc_src_buffer (GstBaseVideoDecoder *
   }
 
   GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_decoder);
+
   return buffer;
 }
 
@@ -2069,7 +2095,7 @@ gst_base_video_decoder_alloc_src_buffer (GstBaseVideoDecoder *
  * @base_video_decoder: a #GstBaseVideoDecoder
  * @frame: a #GstVideoFrame
  *
- * Helper function that uses gst_pad_alloc_buffer_and_set_caps
+ * Helper function that uses @gst_pad_alloc_buffer_and_set_caps()
  * to allocate a buffer to hold a video frame for @base_video_decoder's
  * current #GstVideoState.  Subclass should already have configured video state
  * and set src pad caps.
@@ -2144,8 +2170,10 @@ gst_base_video_decoder_get_max_decode_time (GstBaseVideoDecoder *
 }
 
 /**
- * gst_base_video_decoder_get_oldest_frame:
+ * gst_base_video_decoder_class_set_capture_pattern:
  * @base_video_decoder_class: a #GstBaseVideoDecoderClass
+ * @mask: The mask used for scanning
+ * @pattern: The pattern used for matching
  *
  * Sets the mask and pattern that will be scanned for to obtain parse sync.
  * Note that a non-zero @mask implies that @scan_for_sync will be ignored.
diff --git a/gst-libs/gst/video/gstbasevideodecoder.h b/gst-libs/gst/video/gstbasevideodecoder.h
index a3b81fe..21d757a 100644
--- a/gst-libs/gst/video/gstbasevideodecoder.h
+++ b/gst-libs/gst/video/gstbasevideodecoder.h
@@ -95,7 +95,7 @@ GstFlowReturn _gst_base_video_decoder_error (GstBaseVideoDecoder *dec, gint weig
  *          enclosed in parentheses)
  * @ret:    variable to receive return value
  *
- * Utility function that audio decoder elements can use in case they encountered
+ * Utility function that video decoder elements can use in case they encountered
  * a data processing error that may be fatal for the current "data unit" but
  * need not prevent subsequent decoding.  Such errors are counted and if there
  * are too many, as configured in the context's max_errors, the pipeline will
@@ -104,7 +104,7 @@ GstFlowReturn _gst_base_video_decoder_error (GstBaseVideoDecoder *dec, gint weig
  * is logged. In either case, @ret is set to the proper value to
  * return to upstream/caller (indicating either GST_FLOW_ERROR or GST_FLOW_OK).
  */
-#define GST_BASE_AUDIO_DECODER_ERROR(el, w, domain, code, text, debug, ret) \
+#define GST_BASE_VIDEO_DECODER_ERROR(el, w, domain, code, text, debug, ret) \
 G_STMT_START {                                                              \
   gchar *__txt = _gst_element_error_printf text;                            \
   gchar *__dbg = _gst_element_error_printf debug;                           \
@@ -122,6 +122,7 @@ G_STMT_START {                                                              \
  */
 struct _GstBaseVideoDecoder
 {
+  /*< private >*/
   GstBaseVideoCodec base_video_codec;
 
   /*< protected >*/
@@ -220,8 +221,10 @@ struct _GstBaseVideoDecoder
  */
 struct _GstBaseVideoDecoderClass
 {
+  /*< private >*/
   GstBaseVideoCodecClass base_video_codec_class;
 
+  /*< public >*/
   gboolean      (*start)          (GstBaseVideoDecoder *coder);
 
   gboolean      (*stop)           (GstBaseVideoDecoder *coder);
@@ -248,12 +251,12 @@ struct _GstBaseVideoDecoderClass
   void         *padding[GST_PADDING_LARGE];
 };
 
-void             gst_base_video_decoder_class_set_capture_pattern (GstBaseVideoDecoderClass *klass,
+void             gst_base_video_decoder_class_set_capture_pattern (GstBaseVideoDecoderClass *base_video_decoder_class,
                                     guint32 mask, guint32 pattern);
 
-GstVideoFrame   *gst_base_video_decoder_get_frame (GstBaseVideoDecoder *coder,
+GstVideoFrame   *gst_base_video_decoder_get_frame (GstBaseVideoDecoder *base_video_decoder,
                                     int frame_number);
-GstVideoFrame   *gst_base_video_decoder_get_oldest_frame (GstBaseVideoDecoder *coder);
+GstVideoFrame   *gst_base_video_decoder_get_oldest_frame (GstBaseVideoDecoder *base_video_decoder);
 
 void             gst_base_video_decoder_add_to_frame (GstBaseVideoDecoder *base_video_decoder,
                                     int n_bytes);
diff --git a/gst-libs/gst/video/gstbasevideoencoder.c b/gst-libs/gst/video/gstbasevideoencoder.c
index 34d0956..50ed82a 100644
--- a/gst-libs/gst/video/gstbasevideoencoder.c
+++ b/gst-libs/gst/video/gstbasevideoencoder.c
@@ -105,6 +105,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include "gstbasevideoencoder.h"
 #include "gstbasevideoutils.h"
 
@@ -260,6 +264,13 @@ gst_base_video_encoder_init (GstBaseVideoEncoder * base_video_encoder,
   base_video_encoder->sink_clipping = TRUE;
 }
 
+/**
+ * gst_base_video_encoder_set_headers:
+ * @base_video_encoder: a #GstBaseVideoEncoder
+ * @headers: (transfer full): the #GstBuffer containing the codec header
+ *
+ * Set the codec headers to be sent downstream whenever requested.
+ */
 void
 gst_base_video_encoder_set_headers (GstBaseVideoEncoder * base_video_encoder,
     GstBuffer * headers)
@@ -292,14 +303,9 @@ gst_base_video_encoder_drain (GstBaseVideoEncoder * enc)
   /* everything should be away now */
   if (codec->frames) {
     /* not fatal/impossible though if subclass/codec eats stuff */
-    GST_WARNING_OBJECT (enc, "still %d frames left after draining",
-        g_list_length (codec->frames));
-#if 0
-    /* FIXME should do this, but subclass may come up with it later on ?
-     * and would then need refcounting or so on frames */
-    g_list_foreach (codec->frames,
-        (GFunc) gst_base_video_codec_free_frame, NULL);
-#endif
+    g_list_foreach (codec->frames, (GFunc) gst_video_frame_unref, NULL);
+    g_list_free (codec->frames);
+    codec->frames = NULL;
   }
 
   return ret;
@@ -1121,7 +1127,7 @@ done:
   GST_BASE_VIDEO_CODEC (base_video_encoder)->frames =
       g_list_remove (GST_BASE_VIDEO_CODEC (base_video_encoder)->frames, frame);
 
-  gst_base_video_codec_free_frame (frame);
+  gst_video_frame_unref (frame);
 
   GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_encoder);
 
@@ -1132,11 +1138,15 @@ done:
  * gst_base_video_encoder_get_state:
  * @base_video_encoder: a #GstBaseVideoEncoder
  *
+ * Get the current #GstVideoState
+ *
  * Returns: #GstVideoState describing format of video data.
  */
 const GstVideoState *
 gst_base_video_encoder_get_state (GstBaseVideoEncoder * base_video_encoder)
 {
+  /* FIXME : Move to base codec class */
+
   return &GST_BASE_VIDEO_CODEC (base_video_encoder)->state;
 }
 
@@ -1167,7 +1177,7 @@ gst_base_video_encoder_set_latency (GstBaseVideoEncoder * base_video_encoder,
 /**
  * gst_base_video_encoder_set_latency_fields:
  * @base_video_encoder: a #GstBaseVideoEncoder
- * @fields: latency in fields
+ * @n_fields: latency in fields
  *
  * Informs baseclass of encoding latency in terms of fields (both min
  * and max latency).
@@ -1194,6 +1204,8 @@ gst_base_video_encoder_set_latency_fields (GstBaseVideoEncoder *
  * gst_base_video_encoder_get_oldest_frame:
  * @base_video_encoder: a #GstBaseVideoEncoder
  *
+ * Get the oldest unfinished pending #GstVideoFrame
+ *
  * Returns: oldest unfinished pending #GstVideoFrame
  */
 GstVideoFrame *
@@ -1202,6 +1214,8 @@ gst_base_video_encoder_get_oldest_frame (GstBaseVideoEncoder *
 {
   GList *g;
 
+  /* FIXME : Move to base codec class */
+
   GST_BASE_VIDEO_CODEC_STREAM_LOCK (base_video_encoder);
   g = g_list_first (GST_BASE_VIDEO_CODEC (base_video_encoder)->frames);
   GST_BASE_VIDEO_CODEC_STREAM_UNLOCK (base_video_encoder);
diff --git a/gst-libs/gst/video/gstbasevideoencoder.h b/gst-libs/gst/video/gstbasevideoencoder.h
index 6e2aa70..4fad71b 100644
--- a/gst-libs/gst/video/gstbasevideoencoder.h
+++ b/gst-libs/gst/video/gstbasevideoencoder.h
@@ -70,12 +70,12 @@ typedef struct _GstBaseVideoEncoderClass GstBaseVideoEncoderClass;
 
 /**
  * GstBaseVideoEncoder:
- * @element: the parent element.
  *
  * The opaque #GstBaseVideoEncoder data structure.
  */
 struct _GstBaseVideoEncoder
 {
+  /*< private >*/
   GstBaseVideoCodec base_video_codec;
 
   /*< protected >*/
@@ -115,6 +115,8 @@ struct _GstBaseVideoEncoder
  *                  GstVideoState fields have already been
  *                  set according to provided caps.
  * @handle_frame:   Provides input frame to subclass.
+ * @reset:          Optional.
+ *                  Allows subclass (codec) to perform post-seek semantics reset.
  * @finish:         Optional.
  *                  Called to request subclass to dispatch any pending remaining
  *                  data (e.g. at EOS).
@@ -133,6 +135,7 @@ struct _GstBaseVideoEncoder
  */
 struct _GstBaseVideoEncoderClass
 {
+  /*< private >*/
   GstBaseVideoCodecClass              base_video_codec_class;
 
   /*< public >*/
@@ -164,9 +167,9 @@ struct _GstBaseVideoEncoderClass
 
 GType                  gst_base_video_encoder_get_type (void);
 
-const GstVideoState*   gst_base_video_encoder_get_state (GstBaseVideoEncoder *coder);
+const GstVideoState*   gst_base_video_encoder_get_state (GstBaseVideoEncoder *base_video_encoder);
 
-GstVideoFrame*         gst_base_video_encoder_get_oldest_frame (GstBaseVideoEncoder *coder);
+GstVideoFrame*         gst_base_video_encoder_get_oldest_frame (GstBaseVideoEncoder *base_video_encoder);
 GstFlowReturn          gst_base_video_encoder_finish_frame (GstBaseVideoEncoder *base_video_encoder,
                                                             GstVideoFrame *frame);
 
@@ -175,7 +178,7 @@ void                   gst_base_video_encoder_set_latency (GstBaseVideoEncoder *
 void                   gst_base_video_encoder_set_latency_fields (GstBaseVideoEncoder *base_video_encoder,
                                                                   int n_fields);
 void                   gst_base_video_encoder_set_headers (GstBaseVideoEncoder *base_video_encoder,
-                                                                  GstBuffer *headers);
+							   GstBuffer *headers);
 G_END_DECLS
 
 #endif
diff --git a/gst-plugins-bad.doap b/gst-plugins-bad.doap
index c582f47..a4a3535 100644
--- a/gst-plugins-bad.doap
+++ b/gst-plugins-bad.doap
@@ -35,18 +35,6 @@ real live maintainer, or some actual wide use.
 
  <release>
   <Version>
-   <revision>0.10.23</revision>
-   <branch>0.10</branch>
-   <name>The Game Has Changed</name>
-   <created>2012-02-20</created>
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gst-plugins-bad/gst-plugins-bad-0.10.23.tar.bz2" />
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gst-plugins-bad/gst-plugins-bad-0.10.23.tar.gz" />
-   <file-release rdf:resource="http://gstreamer.freedesktop.org/src/gst-plugins-bad/gst-plugins-bad-0.10.23.tar.xz" />
-  </Version>
- </release>
-
- <release>
-  <Version>
    <revision>0.10.22</revision>
    <branch>0.10</branch>
    <name>Toy Piano</name>
diff --git a/gst/adpcmdec/Makefile.am b/gst/adpcmdec/Makefile.am
index 2521fe6..98f84e7 100644
--- a/gst/adpcmdec/Makefile.am
+++ b/gst/adpcmdec/Makefile.am
@@ -5,8 +5,10 @@ libgstadpcmdec_la_SOURCES = adpcmdec.c
 
 # flags used to compile this plugin
 # add other _CFLAGS and _LIBS as needed
-libgstadpcmdec_la_CFLAGS = $(GST_CFLAGS) $(GST_BASE_CFLAGS)
-libgstadpcmdec_la_LIBADD = $(GST_LIBS) $(GST_BASE_LIBS)
+libgstadpcmdec_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS)
+libgstadpcmdec_la_LIBADD = \
+	$(GST_PLUGINS_BASE_LIBS) -lgstaudio-@GST_MAJORMINOR@ \
+	$(GST_BASE_LIBS) $(GST_LIBS)
 libgstadpcmdec_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstadpcmdec_la_LIBTOOLFLAGS = --tag=disable-static
 
diff --git a/gst/adpcmdec/adpcmdec.c b/gst/adpcmdec/adpcmdec.c
index b97584c..4cfccb6 100644
--- a/gst/adpcmdec/adpcmdec.c
+++ b/gst/adpcmdec/adpcmdec.c
@@ -28,7 +28,7 @@
 #endif
 
 #include <gst/gst.h>
-#include <gst/base/gstadapter.h>
+#include <gst/audio/gstaudiodecoder.h>
 
 #define GST_TYPE_ADPCM_DEC \
     (adpcmdec_get_type ())
@@ -69,80 +69,29 @@ enum adpcm_layout
 
 typedef struct _ADPCMDecClass
 {
-  GstElementClass parent_class;
+  GstAudioDecoderClass parent_class;
 } ADPCMDecClass;
 
 typedef struct _ADPCMDec
 {
-  GstElement parent;
-
-  GstPad *sinkpad;
-  GstPad *srcpad;
-
-  GstCaps *output_caps;
+  GstAudioDecoder parent;
 
   enum adpcm_layout layout;
   int rate;
   int channels;
   int blocksize;
-
-  gboolean is_setup;
-
-  GstClockTime timestamp;
-  GstClockTime base_timestamp;
-
-  guint64 out_samples;
-
-  GstAdapter *adapter;
-
 } ADPCMDec;
 
 GType adpcmdec_get_type (void);
-GST_BOILERPLATE (ADPCMDec, adpcmdec, GstElement, GST_TYPE_ELEMENT);
-static gboolean
-adpcmdec_setup (ADPCMDec * dec)
-{
-  dec->output_caps = gst_caps_new_simple ("audio/x-raw-int",
-      "rate", G_TYPE_INT, dec->rate,
-      "channels", G_TYPE_INT, dec->channels,
-      "width", G_TYPE_INT, 16,
-      "depth", G_TYPE_INT, 16,
-      "endianness", G_TYPE_INT, G_BYTE_ORDER,
-      "signed", G_TYPE_BOOLEAN, TRUE, NULL);
-
-  if (dec->output_caps) {
-    gst_pad_set_caps (dec->srcpad, dec->output_caps);
-  }
-
-  dec->is_setup = TRUE;
-  dec->timestamp = GST_CLOCK_TIME_NONE;
-  dec->base_timestamp = GST_CLOCK_TIME_NONE;
-  dec->adapter = gst_adapter_new ();
-  dec->out_samples = 0;
-
-  return TRUE;
-}
-
-static void
-adpcmdec_teardown (ADPCMDec * dec)
-{
-  if (dec->output_caps) {
-    gst_caps_unref (dec->output_caps);
-    dec->output_caps = NULL;
-  }
-  if (dec->adapter) {
-    g_object_unref (dec->adapter);
-    dec->adapter = NULL;
-  }
-  dec->is_setup = FALSE;
-}
+GST_BOILERPLATE (ADPCMDec, adpcmdec, GstAudioDecoder, GST_TYPE_AUDIO_DECODER);
 
 static gboolean
-adpcmdec_sink_setcaps (GstPad * pad, GstCaps * caps)
+adpcmdec_set_format (GstAudioDecoder * bdec, GstCaps * in_caps)
 {
-  ADPCMDec *dec = (ADPCMDec *) gst_pad_get_parent (pad);
-  GstStructure *structure = gst_caps_get_structure (caps, 0);
+  ADPCMDec *dec = (ADPCMDec *) (bdec);
+  GstStructure *structure = gst_caps_get_structure (in_caps, 0);
   const gchar *layout;
+  GstCaps *caps;
 
   layout = gst_structure_get_string (structure, "layout");
   if (!layout)
@@ -163,9 +112,16 @@ adpcmdec_sink_setcaps (GstPad * pad, GstCaps * caps)
   if (!gst_structure_get_int (structure, "channels", &dec->channels))
     return FALSE;
 
-  if (dec->is_setup)
-    adpcmdec_teardown (dec);
-  gst_object_unref (dec);
+  caps = gst_caps_new_simple ("audio/x-raw-int",
+      "rate", G_TYPE_INT, dec->rate,
+      "channels", G_TYPE_INT, dec->channels,
+      "width", G_TYPE_INT, 16,
+      "depth", G_TYPE_INT, 16,
+      "endianness", G_TYPE_INT, G_BYTE_ORDER,
+      "signed", G_TYPE_BOOLEAN, TRUE, NULL);
+
+  gst_pad_set_caps (GST_AUDIO_DECODER_SRC_PAD (bdec), caps);
+  gst_caps_unref (caps);
 
   return TRUE;
 }
@@ -377,10 +333,10 @@ adpcmdec_decode_ima_block (ADPCMDec * dec, int n_samples, const guint8 * data,
   return TRUE;
 }
 
-static GstFlowReturn
+static GstBuffer *
 adpcmdec_decode_block (ADPCMDec * dec, const guint8 * data, int blocksize)
 {
-  gboolean res;
+  gboolean res = FALSE;
   GstBuffer *outbuf = NULL;
   int outsize;
   int samples;
@@ -390,7 +346,7 @@ adpcmdec_decode_block (ADPCMDec * dec, const guint8 * data, int blocksize)
        give two initial sample values per channel. Then the remainder gives
        two samples per byte */
     if (blocksize < 7 * dec->channels)
-      return GST_FLOW_ERROR;
+      goto exit;
     samples = (blocksize - 7 * dec->channels) * 2 + 2 * dec->channels;
     outsize = 2 * samples;
     outbuf = gst_buffer_new_and_alloc (outsize);
@@ -401,7 +357,7 @@ adpcmdec_decode_block (ADPCMDec * dec, const guint8 * data, int blocksize)
     /* Each block has a 4 byte header per channel, include an initial sample.
        Then the remainder gives two samples per byte */
     if (blocksize < 4 * dec->channels)
-      return GST_FLOW_ERROR;
+      goto exit;
     samples = (blocksize - 4 * dec->channels) * 2 + dec->channels;
     outsize = 2 * samples;
     outbuf = gst_buffer_new_and_alloc (outsize);
@@ -410,155 +366,114 @@ adpcmdec_decode_block (ADPCMDec * dec, const guint8 * data, int blocksize)
         (gint16 *) (GST_BUFFER_DATA (outbuf)));
   } else {
     GST_WARNING_OBJECT (dec, "Unknown layout");
-    return GST_FLOW_ERROR;
   }
 
   if (!res) {
-    gst_buffer_unref (outbuf);
+    if (outbuf)
+      gst_buffer_unref (outbuf);
+    outbuf = NULL;
     GST_WARNING_OBJECT (dec, "Decode of block failed");
-    return GST_FLOW_ERROR;
   }
 
-  gst_buffer_set_caps (outbuf, dec->output_caps);
-  GST_BUFFER_TIMESTAMP (outbuf) = dec->timestamp;
-  dec->out_samples += samples / dec->channels;
-  dec->timestamp = dec->base_timestamp +
-      gst_util_uint64_scale_int (dec->out_samples, GST_SECOND, dec->rate);
-  GST_BUFFER_DURATION (outbuf) = dec->timestamp - GST_BUFFER_TIMESTAMP (outbuf);
-
-  return gst_pad_push (dec->srcpad, outbuf);
+exit:
+  return outbuf;
 }
 
 static GstFlowReturn
-adpcmdec_chain (GstPad * pad, GstBuffer * buf)
+adpcmdec_parse (GstAudioDecoder * bdec, GstAdapter * adapter,
+    gint * offset, gint * length)
 {
-  ADPCMDec *dec = (ADPCMDec *) gst_pad_get_parent (pad);
-  GstFlowReturn ret = GST_FLOW_OK;
-  guint8 *data;
-  GstBuffer *databuf = NULL;
+  ADPCMDec *dec = (ADPCMDec *) (bdec);
+  guint size;
 
-  if (!dec->is_setup)
-    adpcmdec_setup (dec);
+  size = gst_adapter_available (adapter);
+  g_return_val_if_fail (size > 0, GST_FLOW_ERROR);
 
-  if (dec->base_timestamp == GST_CLOCK_TIME_NONE) {
-    dec->base_timestamp = GST_BUFFER_TIMESTAMP (buf);
-    if (dec->base_timestamp == GST_CLOCK_TIME_NONE)
-      dec->base_timestamp = 0;
-    dec->timestamp = dec->base_timestamp;
+  if (dec->blocksize < 0) {
+    /* No explicit blocksize; we just process one input buffer at a time */
+    *offset = 0;
+    *length = size;
+  } else {
+    if (size >= dec->blocksize) {
+      *offset = 0;
+      *length = dec->blocksize;
+    } else {
+      return GST_FLOW_UNEXPECTED;
+    }
   }
 
-  if (dec->blocksize > 0) {
-    gst_adapter_push (dec->adapter, buf);
+  return GST_FLOW_OK;
+}
 
-    while (gst_adapter_available (dec->adapter) >= dec->blocksize) {
-      databuf = gst_adapter_take_buffer (dec->adapter, dec->blocksize);
-      data = GST_BUFFER_DATA (databuf);
+static GstFlowReturn
+adpcmdec_handle_frame (GstAudioDecoder * bdec, GstBuffer * buffer)
+{
+  ADPCMDec *dec = (ADPCMDec *) (bdec);
+  GstFlowReturn ret = GST_FLOW_OK;
+  guint8 *data;
+  GstBuffer *outbuf = NULL;
 
-      ret = adpcmdec_decode_block (dec, data, dec->blocksize);
+  /* no fancy draining */
+  if (G_UNLIKELY (!buffer))
+    return GST_FLOW_OK;
 
-      /* Done with input data, free it */
-      gst_buffer_unref (databuf);
+  if (!dec->blocksize)
+    return GST_FLOW_NOT_NEGOTIATED;
 
-      if (ret != GST_FLOW_OK)
-        goto done;
-    }
-  } else {
-    /* No explicit blocksize; we just process one input buffer at a time */
-    ret = adpcmdec_decode_block (dec, GST_BUFFER_DATA (buf),
-        GST_BUFFER_SIZE (buf));
-    gst_buffer_unref (buf);
+  data = GST_BUFFER_DATA (buffer);
+  outbuf = adpcmdec_decode_block (dec, data, dec->blocksize);
+
+  if (outbuf == NULL) {
+    GST_AUDIO_DECODER_ERROR (bdec, 1, STREAM, DECODE, (NULL),
+        ("frame decode failed"), ret);
   }
 
-done:
-  gst_object_unref (dec);
+  if (ret == GST_FLOW_OK)
+    ret = gst_audio_decoder_finish_frame (bdec, outbuf, 1);
 
   return ret;
 }
 
 static gboolean
-adpcmdec_sink_event (GstPad * pad, GstEvent * event)
+adpcmdec_start (GstAudioDecoder * bdec)
 {
-  ADPCMDec *dec = (ADPCMDec *) gst_pad_get_parent (pad);
-  gboolean res;
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_FLUSH_STOP:
-      dec->out_samples = 0;
-      dec->timestamp = GST_CLOCK_TIME_NONE;
-      dec->base_timestamp = GST_CLOCK_TIME_NONE;
-      gst_adapter_clear (dec->adapter);
-      /* Fall through */
-    default:
-      res = gst_pad_push_event (dec->srcpad, event);
-      break;
-  }
-  gst_object_unref (dec);
-  return res;
-}
+  ADPCMDec *dec = (ADPCMDec *) bdec;
 
-static GstStateChangeReturn
-adpcmdec_change_state (GstElement * element, GstStateChange transition)
-{
-  GstStateChangeReturn ret;
-  ADPCMDec *dec = (ADPCMDec *) element;
-
-  switch (transition) {
-    case GST_STATE_CHANGE_NULL_TO_READY:
-      break;
-    case GST_STATE_CHANGE_READY_TO_PAUSED:
-      break;
-    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
-      break;
-    default:
-      break;
-  }
+  GST_DEBUG_OBJECT (dec, "start");
 
-  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
-      break;
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
-      adpcmdec_teardown (dec);
-      break;
-    case GST_STATE_CHANGE_READY_TO_NULL:
-      break;
-    default:
-      break;
-  }
-  return ret;
+  dec->blocksize = 0;
+  dec->rate = 0;
+  dec->channels = 0;
+
+  return TRUE;
 }
 
-static void
-adpcmdec_dispose (GObject * obj)
+static gboolean
+adpcmdec_stop (GstAudioDecoder * dec)
 {
-  G_OBJECT_CLASS (parent_class)->dispose (obj);
+  GST_DEBUG_OBJECT (dec, "stop");
+
+  return TRUE;
 }
 
 static void
 adpcmdec_init (ADPCMDec * dec, ADPCMDecClass * klass)
 {
-  dec->sinkpad =
-      gst_pad_new_from_static_template (&adpcmdec_sink_template, "sink");
-  gst_pad_set_setcaps_function (dec->sinkpad,
-      GST_DEBUG_FUNCPTR (adpcmdec_sink_setcaps));
-  gst_pad_set_chain_function (dec->sinkpad, GST_DEBUG_FUNCPTR (adpcmdec_chain));
-  gst_pad_set_event_function (dec->sinkpad,
-      GST_DEBUG_FUNCPTR (adpcmdec_sink_event));
-  gst_element_add_pad (GST_ELEMENT (dec), dec->sinkpad);
-  dec->srcpad =
-      gst_pad_new_from_static_template (&adpcmdec_src_template, "src");
-  gst_element_add_pad (GST_ELEMENT (dec), dec->srcpad);
 }
 
 static void
 adpcmdec_class_init (ADPCMDecClass * klass)
 {
-  GObjectClass *gobjectclass = (GObjectClass *) klass;
-  GstElementClass *gstelement_class = (GstElementClass *) klass;
-  gobjectclass->dispose = adpcmdec_dispose;
-  gstelement_class->change_state = adpcmdec_change_state;
-} static void
+  GstAudioDecoderClass *base_class = (GstAudioDecoderClass *) klass;
+
+  base_class->start = GST_DEBUG_FUNCPTR (adpcmdec_start);
+  base_class->stop = GST_DEBUG_FUNCPTR (adpcmdec_stop);
+  base_class->set_format = GST_DEBUG_FUNCPTR (adpcmdec_set_format);
+  base_class->parse = GST_DEBUG_FUNCPTR (adpcmdec_parse);
+  base_class->handle_frame = GST_DEBUG_FUNCPTR (adpcmdec_handle_frame);
+}
 
+static void
 adpcmdec_base_init (gpointer klass)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
diff --git a/gst/adpcmenc/Makefile.am b/gst/adpcmenc/Makefile.am
index 17b3ecd..bfd945d 100644
--- a/gst/adpcmenc/Makefile.am
+++ b/gst/adpcmenc/Makefile.am
@@ -5,8 +5,9 @@ libgstadpcmenc_la_SOURCES = adpcmenc.c
 
 # flags used to compile this plugin
 # add other _CFLAGS and _LIBS as needed
-libgstadpcmenc_la_CFLAGS = $(GST_CFLAGS) $(GST_BASE_CFLAGS)
-libgstadpcmenc_la_LIBADD = $(GST_LIBS) $(GST_BASE_LIBS)
+libgstadpcmenc_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS)
+libgstadpcmenc_la_LIBADD = $(GST_PLUGINS_BASE_LIBS) -lgstaudio-@GST_MAJORMINOR@ \
+	$(GST_LIBS)
 libgstadpcmenc_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstadpcmenc_la_LIBTOOLFLAGS = --tag=disable-static
 
diff --git a/gst/adpcmenc/adpcmenc.c b/gst/adpcmenc/adpcmenc.c
index d8ce1db..6f434e3 100644
--- a/gst/adpcmenc/adpcmenc.c
+++ b/gst/adpcmenc/adpcmenc.c
@@ -28,7 +28,7 @@
 #endif
 
 #include <gst/gst.h>
-#include <gst/base/gstadapter.h>
+#include <gst/audio/gstaudioencoder.h>
 
 #define GST_TYPE_ADPCM_ENC \
     (adpcmenc_get_type ())
@@ -113,17 +113,12 @@ adpcmenc_layout_get_type (void)
 
 typedef struct _ADPCMEncClass
 {
-  GstElementClass parent_class;
+  GstAudioEncoderClass parent_class;
 } ADPCMEncClass;
 
 typedef struct _ADPCMEnc
 {
-  GstElement parent;
-
-  GstPad *sinkpad;
-  GstPad *srcpad;
-
-  GstCaps *output_caps;
+  GstAudioEncoder parent;
 
   enum adpcm_layout layout;
   int rate;
@@ -133,19 +128,11 @@ typedef struct _ADPCMEnc
 
   guint8 step_index[2];
 
-  gboolean is_setup;
-
-  GstClockTime timestamp;
-  GstClockTime base_timestamp;
-
-  guint64 out_samples;
-
-  GstAdapter *adapter;
-
 } ADPCMEnc;
 
 GType adpcmenc_get_type (void);
-GST_BOILERPLATE (ADPCMEnc, adpcmenc, GstElement, GST_TYPE_ELEMENT);
+GST_BOILERPLATE (ADPCMEnc, adpcmenc, GstAudioEncoder, GST_TYPE_AUDIO_ENCODER);
+
 static gboolean
 adpcmenc_setup (ADPCMEnc * enc)
 {
@@ -153,6 +140,7 @@ adpcmenc_setup (ADPCMEnc * enc)
   const int ADPCM_SAMPLES_PER_BYTE = 2;
   guint64 sample_bytes;
   const char *layout;
+  GstCaps *caps;
 
   switch (enc->layout) {
     case LAYOUT_ADPCM_DVI:
@@ -168,21 +156,14 @@ adpcmenc_setup (ADPCMEnc * enc)
       return FALSE;
   }
 
-  enc->output_caps = gst_caps_new_simple ("audio/x-adpcm",
+  caps = gst_caps_new_simple ("audio/x-adpcm",
       "rate", G_TYPE_INT, enc->rate,
       "channels", G_TYPE_INT, enc->channels,
       "layout", G_TYPE_STRING, layout,
       "block_align", G_TYPE_INT, enc->blocksize, NULL);
 
-  if (enc->output_caps) {
-    gst_pad_set_caps (enc->srcpad, enc->output_caps);
-  }
-
-  enc->is_setup = TRUE;
-  enc->timestamp = GST_CLOCK_TIME_NONE;
-  enc->base_timestamp = GST_CLOCK_TIME_NONE;
-  enc->adapter = gst_adapter_new ();
-  enc->out_samples = 0;
+  gst_pad_set_caps (GST_AUDIO_ENCODER_SRC_PAD (enc), caps);
+  gst_caps_unref (caps);
 
   /* Step index state is carried between blocks. */
   enc->step_index[0] = 0;
@@ -191,37 +172,21 @@ adpcmenc_setup (ADPCMEnc * enc)
   return TRUE;
 }
 
-static void
-adpcmenc_teardown (ADPCMEnc * enc)
-{
-  if (enc->output_caps) {
-    gst_caps_unref (enc->output_caps);
-    enc->output_caps = NULL;
-  }
-  if (enc->adapter) {
-    g_object_unref (enc->adapter);
-    enc->adapter = NULL;
-  }
-  enc->is_setup = FALSE;
-}
-
 static gboolean
-adpcmenc_sink_setcaps (GstPad * pad, GstCaps * caps)
+adpcmenc_set_format (GstAudioEncoder * benc, GstAudioInfo * info)
 {
-  ADPCMEnc *enc = (ADPCMEnc *) gst_pad_get_parent (pad);
-  GstStructure *structure = gst_caps_get_structure (caps, 0);
+  ADPCMEnc *enc = (ADPCMEnc *) (benc);
 
-  if (!gst_structure_get_int (structure, "rate", &enc->rate))
-    return FALSE;
-  if (!gst_structure_get_int (structure, "channels", &enc->channels))
-    return FALSE;
+  enc->rate = GST_AUDIO_INFO_RATE (info);
+  enc->channels = GST_AUDIO_INFO_CHANNELS (info);
 
-  if (enc->is_setup) {
-    adpcmenc_teardown (enc);
-  }
-  adpcmenc_setup (enc);
+  if (!adpcmenc_setup (enc))
+    return FALSE;
 
-  gst_object_unref (enc);
+  /* report needs to base class */
+  gst_audio_encoder_set_frame_samples_min (benc, enc->samples_per_block);
+  gst_audio_encoder_set_frame_samples_max (benc, enc->samples_per_block);
+  gst_audio_encoder_set_frame_max (benc, 1);
 
   return TRUE;
 }
@@ -368,148 +333,86 @@ adpcmenc_encode_ima_block (ADPCMEnc * enc, const gint16 * samples,
   return TRUE;
 }
 
-static GstFlowReturn
+static GstBuffer *
 adpcmenc_encode_block (ADPCMEnc * enc, const gint16 * samples, int blocksize)
 {
-  gboolean res;
+  gboolean res = FALSE;
   GstBuffer *outbuf = NULL;
 
   if (enc->layout == LAYOUT_ADPCM_DVI) {
     outbuf = gst_buffer_new_and_alloc (enc->blocksize);
     res = adpcmenc_encode_ima_block (enc, samples, GST_BUFFER_DATA (outbuf));
   } else {
+    /* should not happen afaics */
+    g_assert_not_reached ();
     GST_WARNING_OBJECT (enc, "Unknown layout");
-    return GST_FLOW_ERROR;
+    res = FALSE;
   }
 
   if (!res) {
-    gst_buffer_unref (outbuf);
+    if (outbuf)
+      gst_buffer_unref (outbuf);
+    outbuf = NULL;
     GST_WARNING_OBJECT (enc, "Encode of block failed");
-    return GST_FLOW_ERROR;
   }
 
-  gst_buffer_set_caps (outbuf, enc->output_caps);
-  GST_BUFFER_TIMESTAMP (outbuf) = enc->timestamp;
-
-  enc->out_samples += enc->samples_per_block;
-  enc->timestamp = enc->base_timestamp +
-      gst_util_uint64_scale_int (enc->out_samples, GST_SECOND, enc->rate);
-  GST_BUFFER_DURATION (outbuf) = enc->timestamp - GST_BUFFER_TIMESTAMP (outbuf);
-
-  return gst_pad_push (enc->srcpad, outbuf);
+  return outbuf;
 }
 
 static GstFlowReturn
-adpcmenc_chain (GstPad * pad, GstBuffer * buf)
+adpcmenc_handle_frame (GstAudioEncoder * benc, GstBuffer * buffer)
 {
-  ADPCMEnc *enc = (ADPCMEnc *) gst_pad_get_parent (pad);
+  ADPCMEnc *enc = (ADPCMEnc *) (benc);
   GstFlowReturn ret = GST_FLOW_OK;
   gint16 *samples;
-  GstBuffer *databuf = NULL;
+  GstBuffer *outbuf;
   int input_bytes_per_block;
   const int BYTES_PER_SAMPLE = 2;
 
-  if (enc->base_timestamp == GST_CLOCK_TIME_NONE) {
-    enc->base_timestamp = GST_BUFFER_TIMESTAMP (buf);
-    if (enc->base_timestamp == GST_CLOCK_TIME_NONE)
-      enc->base_timestamp = 0;
-    enc->timestamp = enc->base_timestamp;
+  /* we don't deal with squeezing remnants, so simply discard those */
+  if (G_UNLIKELY (buffer == NULL)) {
+    GST_DEBUG_OBJECT (benc, "no data");
+    goto done;
   }
 
-  gst_adapter_push (enc->adapter, buf);
-
   input_bytes_per_block =
       enc->samples_per_block * BYTES_PER_SAMPLE * enc->channels;
 
-  while (gst_adapter_available (enc->adapter) >= input_bytes_per_block) {
-    databuf = gst_adapter_take_buffer (enc->adapter, input_bytes_per_block);
-    samples = (gint16 *) GST_BUFFER_DATA (databuf);
-    ret = adpcmenc_encode_block (enc, samples, enc->blocksize);
-    gst_buffer_unref (databuf);
-    if (ret != GST_FLOW_OK)
-      goto done;
+  if (G_UNLIKELY (GST_BUFFER_SIZE (buffer) < input_bytes_per_block)) {
+    GST_DEBUG_OBJECT (enc, "discarding trailing data %d",
+        GST_BUFFER_SIZE (buffer));
+    ret = gst_audio_encoder_finish_frame (benc, NULL, -1);
+    goto done;
   }
 
+  samples = (gint16 *) GST_BUFFER_DATA (buffer);
+  outbuf = adpcmenc_encode_block (enc, samples, enc->blocksize);
+
+  ret = gst_audio_encoder_finish_frame (benc, outbuf, enc->samples_per_block);
+
 done:
-  gst_object_unref (enc);
   return ret;
 }
 
 static gboolean
-adpcmenc_sink_event (GstPad * pad, GstEvent * event)
+adpcmenc_start (GstAudioEncoder * enc)
 {
-  ADPCMEnc *enc = (ADPCMEnc *) gst_pad_get_parent (pad);
-  gboolean res;
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_FLUSH_STOP:
-      enc->out_samples = 0;
-      enc->timestamp = GST_CLOCK_TIME_NONE;
-      enc->base_timestamp = GST_CLOCK_TIME_NONE;
-      gst_adapter_clear (enc->adapter);
-      /* Fall through */
-    default:
-      res = gst_pad_push_event (enc->srcpad, event);
-      break;
-  }
-  gst_object_unref (enc);
-  return res;
-}
-
-static GstStateChangeReturn
-adpcmenc_change_state (GstElement * element, GstStateChange transition)
-{
-  GstStateChangeReturn ret;
-  ADPCMEnc *enc = (ADPCMEnc *) element;
-
-  switch (transition) {
-    case GST_STATE_CHANGE_NULL_TO_READY:
-      break;
-    case GST_STATE_CHANGE_READY_TO_PAUSED:
-      break;
-    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
-      break;
-    default:
-      break;
-  }
-
-  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+  GST_DEBUG_OBJECT (enc, "start");
 
-  switch (transition) {
-    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
-      break;
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
-      adpcmenc_teardown (enc);
-      break;
-    case GST_STATE_CHANGE_READY_TO_NULL:
-      break;
-    default:
-      break;
-  }
-  return ret;
+  return TRUE;
 }
 
-static void
-adpcmenc_dispose (GObject * obj)
+static gboolean
+adpcmenc_stop (GstAudioEncoder * enc)
 {
-  G_OBJECT_CLASS (parent_class)->dispose (obj);
+  GST_DEBUG_OBJECT (enc, "stop");
+
+  return TRUE;
 }
 
 static void
 adpcmenc_init (ADPCMEnc * enc, ADPCMEncClass * klass)
 {
-  enc->sinkpad =
-      gst_pad_new_from_static_template (&adpcmenc_sink_template, "sink");
-  gst_pad_set_setcaps_function (enc->sinkpad,
-      GST_DEBUG_FUNCPTR (adpcmenc_sink_setcaps));
-  gst_pad_set_chain_function (enc->sinkpad, GST_DEBUG_FUNCPTR (adpcmenc_chain));
-  gst_pad_set_event_function (enc->sinkpad,
-      GST_DEBUG_FUNCPTR (adpcmenc_sink_event));
-  gst_element_add_pad (GST_ELEMENT (enc), enc->sinkpad);
-
-  enc->srcpad =
-      gst_pad_new_from_static_template (&adpcmenc_src_template, "src");
-  gst_element_add_pad (GST_ELEMENT (enc), enc->srcpad);
-
   /* Set defaults. */
   enc->blocksize = DEFAULT_ADPCM_BLOCK_SIZE;
   enc->layout = DEFAULT_ADPCM_LAYOUT;
@@ -519,11 +422,16 @@ static void
 adpcmenc_class_init (ADPCMEncClass * klass)
 {
   GObjectClass *gobjectclass = (GObjectClass *) klass;
-  GstElementClass *gstelement_class = (GstElementClass *) klass;
+  GstAudioEncoderClass *base_class = (GstAudioEncoderClass *) klass;
 
   gobjectclass->set_property = adpcmenc_set_property;
   gobjectclass->get_property = adpcmenc_get_property;
 
+  base_class->start = GST_DEBUG_FUNCPTR (adpcmenc_start);
+  base_class->stop = GST_DEBUG_FUNCPTR (adpcmenc_stop);
+  base_class->set_format = GST_DEBUG_FUNCPTR (adpcmenc_set_format);
+  base_class->handle_frame = GST_DEBUG_FUNCPTR (adpcmenc_handle_frame);
+
   g_object_class_install_property (gobjectclass, ARG_LAYOUT,
       g_param_spec_enum ("layout", "Layout",
           "Layout for output stream",
@@ -537,10 +445,9 @@ adpcmenc_class_init (ADPCMEncClass * klass)
           DEFAULT_ADPCM_BLOCK_SIZE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
-  gobjectclass->dispose = adpcmenc_dispose;
-  gstelement_class->change_state = adpcmenc_change_state;
-} static void
+}
 
+static void
 adpcmenc_base_init (gpointer klass)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
diff --git a/gst/aiff/aiffmux.c b/gst/aiff/aiffmux.c
index 0d2772a..565ea86 100644
--- a/gst/aiff/aiffmux.c
+++ b/gst/aiff/aiffmux.c
@@ -163,11 +163,14 @@ gst_aiff_mux_write_form_header (GstAiffMux * aiffmux, guint32 audio_data_size,
     GstByteWriter * writer)
 {
   /* ckID == 'FORM' */
-  gst_byte_writer_put_uint32_le (writer, GST_MAKE_FOURCC ('F', 'O', 'R', 'M'));
+  gst_byte_writer_put_uint32_le_unchecked (writer,
+      GST_MAKE_FOURCC ('F', 'O', 'R', 'M'));
   /* ckSize is currently bogus but we'll know what it is later */
-  gst_byte_writer_put_uint32_be (writer, audio_data_size + AIFF_HEADER_LEN - 8);
+  gst_byte_writer_put_uint32_be_unchecked (writer,
+      audio_data_size + AIFF_HEADER_LEN - 8);
   /* formType == 'AIFF' */
-  gst_byte_writer_put_uint32_le (writer, GST_MAKE_FOURCC ('A', 'I', 'F', 'F'));
+  gst_byte_writer_put_uint32_le_unchecked (writer,
+      GST_MAKE_FOURCC ('A', 'I', 'F', 'F'));
 }
 
 /*
@@ -218,8 +221,8 @@ gst_aiff_mux_write_ext (GstByteWriter * writer, double d)
   if (d < 0)
     ext.exponent[0] |= 0x80;
 
-  gst_byte_writer_put_data (writer, ext.exponent, 2);
-  gst_byte_writer_put_data (writer, ext.mantissa, 8);
+  gst_byte_writer_put_data_unchecked (writer, ext.exponent, 2);
+  gst_byte_writer_put_data_unchecked (writer, ext.mantissa, 8);
 }
 
 /*
@@ -230,13 +233,14 @@ static void
 gst_aiff_mux_write_comm_header (GstAiffMux * aiffmux, guint32 audio_data_size,
     GstByteWriter * writer)
 {
-  gst_byte_writer_put_uint32_le (writer, GST_MAKE_FOURCC ('C', 'O', 'M', 'M'));
-  gst_byte_writer_put_uint32_be (writer, 18);
-  gst_byte_writer_put_uint16_be (writer, aiffmux->channels);
+  gst_byte_writer_put_uint32_le_unchecked (writer,
+      GST_MAKE_FOURCC ('C', 'O', 'M', 'M'));
+  gst_byte_writer_put_uint32_be_unchecked (writer, 18);
+  gst_byte_writer_put_uint16_be_unchecked (writer, aiffmux->channels);
   /* numSampleFrames value will be overwritten when known */
-  gst_byte_writer_put_uint32_be (writer,
+  gst_byte_writer_put_uint32_be_unchecked (writer,
       audio_data_size / (aiffmux->width / 8 * aiffmux->channels));
-  gst_byte_writer_put_uint16_be (writer, aiffmux->depth);
+  gst_byte_writer_put_uint16_be_unchecked (writer, aiffmux->depth);
   gst_aiff_mux_write_ext (writer, aiffmux->rate);
 }
 
@@ -244,13 +248,14 @@ static void
 gst_aiff_mux_write_ssnd_header (GstAiffMux * aiffmux, guint32 audio_data_size,
     GstByteWriter * writer)
 {
-  gst_byte_writer_put_uint32_le (writer, GST_MAKE_FOURCC ('S', 'S', 'N', 'D'));
+  gst_byte_writer_put_uint32_le_unchecked (writer,
+      GST_MAKE_FOURCC ('S', 'S', 'N', 'D'));
   /* ckSize will be overwritten when known */
-  gst_byte_writer_put_uint32_be (writer,
+  gst_byte_writer_put_uint32_be_unchecked (writer,
       audio_data_size + AIFF_SSND_HEADER_LEN - 8);
   /* offset and blockSize are set to 0 as we don't support block-aligned sample data yet */
-  gst_byte_writer_put_uint32_be (writer, 0);
-  gst_byte_writer_put_uint32_be (writer, 0);
+  gst_byte_writer_put_uint32_be_unchecked (writer, 0);
+  gst_byte_writer_put_uint32_be_unchecked (writer, 0);
 }
 
 static GstFlowReturn
diff --git a/gst/aiff/aiffparse.c b/gst/aiff/aiffparse.c
index 6dbee68..176c679 100644
--- a/gst/aiff/aiffparse.c
+++ b/gst/aiff/aiffparse.c
@@ -52,6 +52,11 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 #include <math.h>
 
diff --git a/gst/asfmux/gstasfmux.c b/gst/asfmux/gstasfmux.c
index 8e6af1d..44f7f16 100644
--- a/gst/asfmux/gstasfmux.c
+++ b/gst/asfmux/gstasfmux.c
@@ -165,7 +165,7 @@ static GstStateChangeReturn gst_asf_mux_change_state (GstElement * element,
 static gboolean gst_asf_mux_sink_event (GstPad * pad, GstEvent * event);
 
 static void gst_asf_mux_pad_reset (GstAsfPad * data);
-static GstFlowReturn gst_asf_mux_collected (GstCollectPads * collect,
+static GstFlowReturn gst_asf_mux_collected (GstCollectPads2 * collect,
     gpointer data);
 
 static GstElementClass *parent_class = NULL;
@@ -334,9 +334,9 @@ gst_asf_mux_init (GstAsfMux * asfmux)
   gst_pad_use_fixed_caps (asfmux->srcpad);
   gst_element_add_pad (GST_ELEMENT (asfmux), asfmux->srcpad);
 
-  asfmux->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (asfmux->collect,
-      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (gst_asf_mux_collected),
+  asfmux->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (asfmux->collect,
+      (GstCollectPads2Function) GST_DEBUG_FUNCPTR (gst_asf_mux_collected),
       asfmux);
 
   asfmux->payloads = NULL;
@@ -1850,7 +1850,7 @@ gst_asf_mux_process_buffer (GstAsfMux * asfmux, GstAsfPad * pad,
   AsfPayload *payload;
 
   payload = g_malloc0 (sizeof (AsfPayload));
-  payload->pad = (GstCollectData *) pad;
+  payload->pad = (GstCollectData2 *) pad;
   payload->data = buf;
 
   GST_LOG_OBJECT (asfmux,
@@ -1910,7 +1910,7 @@ gst_asf_mux_process_buffer (GstAsfMux * asfmux, GstAsfPad * pad,
 }
 
 static GstFlowReturn
-gst_asf_mux_collected (GstCollectPads * collect, gpointer data)
+gst_asf_mux_collected (GstCollectPads2 * collect, gpointer data)
 {
   GstAsfMux *asfmux = GST_ASF_MUX_CAST (data);
   GstFlowReturn ret = GST_FLOW_OK;
@@ -1936,15 +1936,15 @@ gst_asf_mux_collected (GstCollectPads * collect, gpointer data)
   walk = asfmux->collect->data;
   while (walk) {
     GstAsfPad *pad;
-    GstCollectData *data;
+    GstCollectData2 *data;
     GstClockTime time;
 
-    data = (GstCollectData *) walk->data;
+    data = (GstCollectData2 *) walk->data;
     pad = (GstAsfPad *) data;
 
     walk = g_slist_next (walk);
 
-    buf = gst_collect_pads_peek (collect, data);
+    buf = gst_collect_pads2_peek (collect, data);
     if (buf == NULL) {
       GST_LOG_OBJECT (asfmux, "Pad %s has no buffers",
           GST_PAD_NAME (pad->collect.pad));
@@ -1979,7 +1979,7 @@ gst_asf_mux_collected (GstCollectPads * collect, gpointer data)
     /* we have data */
     GST_LOG_OBJECT (asfmux, "selected pad %s with time %" GST_TIME_FORMAT,
         GST_PAD_NAME (best_pad->collect.pad), GST_TIME_ARGS (best_time));
-    buf = gst_collect_pads_pop (collect, &best_pad->collect);
+    buf = gst_collect_pads2_pop (collect, &best_pad->collect);
     ret = gst_asf_mux_process_buffer (asfmux, best_pad, buf);
   } else {
     /* no data, let's finish it up */
@@ -2278,8 +2278,8 @@ gst_asf_mux_request_new_pad (GstElement * element,
     collect_size = sizeof (GstAsfVideoPad);
   }
   collect_pad = (GstAsfPad *)
-      gst_collect_pads_add_pad_full (asfmux->collect, newpad, collect_size,
-      (GstCollectDataDestroyNotify) (gst_asf_mux_pad_reset));
+      gst_collect_pads2_add_pad_full (asfmux->collect, newpad, collect_size,
+      (GstCollectData2DestroyNotify) (gst_asf_mux_pad_reset), TRUE);
 
   /* set up pad */
   collect_pad->is_audio = is_audio;
@@ -2293,7 +2293,7 @@ gst_asf_mux_request_new_pad (GstElement * element,
   collect_pad->stream_number = asfmux->stream_number;
 
   /* FIXME: hacked way to override/extend the event function of
-   * GstCollectPads; because it sets its own event function giving
+   * GstCollectPads2; because it sets its own event function giving
    * the element no access to events.
    */
   asfmux->collect_event = (GstPadEventFunction) GST_PAD_EVENTFUNC (newpad);
@@ -2390,12 +2390,12 @@ gst_asf_mux_change_state (GstElement * element, GstStateChange transition)
       asfmux->packet_size = asfmux->prop_packet_size;
       asfmux->preroll = asfmux->prop_preroll;
       asfmux->merge_stream_tags = asfmux->prop_merge_stream_tags;
-      gst_collect_pads_start (asfmux->collect);
+      gst_collect_pads2_start (asfmux->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_collect_pads_stop (asfmux->collect);
+      gst_collect_pads2_stop (asfmux->collect);
       asfmux->state = GST_ASF_MUX_STATE_NONE;
       break;
     default:
diff --git a/gst/asfmux/gstasfmux.h b/gst/asfmux/gstasfmux.h
index 4036aa1..49bd92d 100644
--- a/gst/asfmux/gstasfmux.h
+++ b/gst/asfmux/gstasfmux.h
@@ -23,7 +23,7 @@
 
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 #include <gst/riff/riff-media.h>
 
 #include "gstasfobjects.h"
@@ -57,7 +57,7 @@ enum _GstAsfMuxState
 
 struct _GstAsfPad
 {
-  GstCollectData collect;
+  GstCollectData2 collect;
 
   gboolean is_audio;
   guint8 stream_number;
@@ -143,7 +143,7 @@ struct _GstAsfMux
   /* pads */
   GstPad *srcpad;
 
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
   GstPadEventFunction collect_event;
 };
 
diff --git a/gst/asfmux/gstasfobjects.h b/gst/asfmux/gstasfobjects.h
index 2a91a4c..00546ff 100644
--- a/gst/asfmux/gstasfobjects.h
+++ b/gst/asfmux/gstasfobjects.h
@@ -22,7 +22,7 @@
 #include <glib.h>
 #include <gst/gst.h>
 #include <gst/base/gstbytereader.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 #define ASF_PAYLOAD_IS_KEYFRAME(pay) ((pay->stream_number & 0x80) != 0)
 #define ASF_MILI_TO_100NANO(v) (v * 10000)
@@ -75,7 +75,7 @@ typedef struct _AsfPayload
   guint32 presentation_time;
   GstBuffer *data;
 
-  GstCollectData *pad;
+  GstCollectData2 *pad;
 
   /* simple index info */
   gboolean has_packet_info;
diff --git a/gst/audiovisualizers/README b/gst/audiovisualizers/README
index be2491e..3c59f0e 100644
--- a/gst/audiovisualizers/README
+++ b/gst/audiovisualizers/README
@@ -58,6 +58,11 @@ xxxscope
 - element maker template
 - test for baseclass
 
+- actors
+  - we use the wave, filtered waves, balance and fft so far
+  - we could have narrow filters over harmonic frequencies
+  - we could use loudness like determined in level-meter
+
 - we probably want a VisBin like the gnome video effects
 - this way we can specify pipeline fragments
 - VisBin can use a videomixer to switch effects based on time or song
@@ -82,3 +87,5 @@ GST_PLUGIN_PATH=$GST_PLUGIN_PATH:$PWD gst-launch filesrc location=$HOME/Music/1.
 
 GST_PLUGIN_PATH=$GST_PLUGIN_PATH:$PWD gst-launch filesrc location=$HOME/Music/1.mp3 ! decodebin2 ! tee name=t ! queue ! audioconvert ! synaesthesia ! ximagesink t. ! queue ! synaescope shade-amount=0x00040404 ! colorspace ! ximagesink
 
+gst-launch filesrc location=$HOME/Music/1.mp3 ! decodebin2 ! tee name=t ! queue ! audioconvert ! wavescope style=color-lines shade-amount=0x00080402 ! alpha alpha=0.5 ! videomixer2 name=m background=black ! colorspace ! vertigotv ! ximagesink t. ! queue ! audioconvert ! spacescope style=color-lines shade-amount=0x00080402 ! alpha alpha=0.5 ! m. t. ! queue ! pulsesink
+
diff --git a/gst/audiovisualizers/gstbaseaudiovisualizer.c b/gst/audiovisualizers/gstbaseaudiovisualizer.c
index 6d42b7d..d7bd4d7 100644
--- a/gst/audiovisualizers/gstbaseaudiovisualizer.c
+++ b/gst/audiovisualizers/gstbaseaudiovisualizer.c
@@ -32,6 +32,11 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 #include <gst/controller/gstcontroller.h>
 
@@ -823,7 +828,7 @@ gst_base_audio_visualizer_chain (GstPad * pad, GstBuffer * buffer)
     /* we want to take less or more, depending on spf : req_spf */
     if (avail - sbpf >= sbpf) {
       gst_adapter_flush (scope->adapter, sbpf);
-    } else if (avail - sbpf >= 0) {
+    } else if (avail >= sbpf) {
       /* just flush a bit and stop */
       gst_adapter_flush (scope->adapter, (avail - sbpf));
       break;
diff --git a/gst/bayer/gstbayerorc-dist.c b/gst/bayer/gstbayerorc-dist.c
index de016e3..a8bc117 100644
--- a/gst/bayer/gstbayerorc-dist.c
+++ b/gst/bayer/gstbayerorc-dist.c
@@ -310,7 +310,7 @@ gst_bayer_horiz_upsample_unaligned (guint8 * ORC_RESTRICT d1,
     guint8 * ORC_RESTRICT d2, const guint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -535,7 +535,7 @@ gst_bayer_horiz_upsample (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     const guint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -854,7 +854,7 @@ gst_bayer_merge_bg_bgra (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s5, const guint8 * ORC_RESTRICT s6, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1181,7 +1181,7 @@ gst_bayer_merge_gr_bgra (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s5, const guint8 * ORC_RESTRICT s6, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1508,7 +1508,7 @@ gst_bayer_merge_bg_abgr (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s5, const guint8 * ORC_RESTRICT s6, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1835,7 +1835,7 @@ gst_bayer_merge_gr_abgr (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s5, const guint8 * ORC_RESTRICT s6, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2162,7 +2162,7 @@ gst_bayer_merge_bg_rgba (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s5, const guint8 * ORC_RESTRICT s6, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2489,7 +2489,7 @@ gst_bayer_merge_gr_rgba (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s5, const guint8 * ORC_RESTRICT s6, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2816,7 +2816,7 @@ gst_bayer_merge_bg_argb (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s5, const guint8 * ORC_RESTRICT s6, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3143,7 +3143,7 @@ gst_bayer_merge_gr_argb (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s5, const guint8 * ORC_RESTRICT s6, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
diff --git a/gst/camerabin/gstcamerabin.c b/gst/camerabin/gstcamerabin.c
index a17e02c..e3f4bf7 100644
--- a/gst/camerabin/gstcamerabin.c
+++ b/gst/camerabin/gstcamerabin.c
@@ -151,11 +151,16 @@
 #  include <config.h>
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 #include <stdlib.h>
 
 #include <gst/gst.h>
 #include <gst/tag/tag.h>
+#include <gst/glib-compat-private.h>
 /* FIXME: include #include <gst/gst-i18n-plugin.h> and use _(" ") */
 
 #include "gstcamerabin.h"
diff --git a/gst/camerabin/gstinputselector.c b/gst/camerabin/gstinputselector.c
index 62ee380..2f0c817 100644
--- a/gst/camerabin/gstinputselector.c
+++ b/gst/camerabin/gstinputselector.c
@@ -35,6 +35,7 @@
 
 #include <string.h>
 
+#include <gst/glib-compat-private.h>
 #include "gstinputselector.h"
 #include "gstcamerabin-marshal.h"
 
diff --git a/gst/camerabin2/gstcamerabin2.c b/gst/camerabin2/gstcamerabin2.c
index 7d5f8f4..54cffc8 100644
--- a/gst/camerabin2/gstcamerabin2.c
+++ b/gst/camerabin2/gstcamerabin2.c
@@ -165,6 +165,7 @@
 #include "gstcamerabin2.h"
 #include <gst/gst-i18n-plugin.h>
 #include <gst/pbutils/pbutils.h>
+#include <gst/glib-compat-private.h>
 
 #if GLIB_CHECK_VERSION(2,29,6)
 #define gst_camerabin2_atomic_int_add g_atomic_int_add
diff --git a/gst/camerabin2/gstwrappercamerabinsrc.c b/gst/camerabin2/gstwrappercamerabinsrc.c
index e1d481d..5185789 100644
--- a/gst/camerabin2/gstwrappercamerabinsrc.c
+++ b/gst/camerabin2/gstwrappercamerabinsrc.c
@@ -31,6 +31,10 @@
 #  include <config.h>
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/interfaces/photography.h>
 
 #include "gstwrappercamerabinsrc.h"
@@ -149,6 +153,18 @@ gst_wrapper_camera_bin_reset_video_src_caps (GstWrapperCameraBinSrc * self,
 
   GST_DEBUG_OBJECT (self, "Resetting src caps to %" GST_PTR_FORMAT, caps);
   if (self->src_vid_src) {
+    GstCaps *old_caps;
+
+    g_object_get (G_OBJECT (self->src_filter), "caps", &old_caps, NULL);
+    if (gst_caps_is_equal (caps, old_caps)) {
+      GST_DEBUG_OBJECT (self, "old and new caps are same, do not reset it");
+      if (old_caps)
+        gst_caps_unref (old_caps);
+      return;
+    }
+    if (old_caps)
+      gst_caps_unref (old_caps);
+
     clock = gst_element_get_clock (self->src_vid_src);
     base_time = gst_element_get_base_time (self->src_vid_src);
 
diff --git a/gst/cdxaparse/gstcdxaparse.c b/gst/cdxaparse/gstcdxaparse.c
index 1f997b7..7620fda 100644
--- a/gst/cdxaparse/gstcdxaparse.c
+++ b/gst/cdxaparse/gstcdxaparse.c
@@ -22,6 +22,11 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 
 #include "gstcdxaparse.h"
diff --git a/gst/coloreffects/gstchromahold.c b/gst/coloreffects/gstchromahold.c
index e6e7c40..9a6a695 100644
--- a/gst/coloreffects/gstchromahold.c
+++ b/gst/coloreffects/gstchromahold.c
@@ -40,6 +40,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include "gstchromahold.h"
 
 #include <stdlib.h>
diff --git a/gst/coloreffects/gstcoloreffects.c b/gst/coloreffects/gstcoloreffects.c
index 0941df1..35af8a2 100644
--- a/gst/coloreffects/gstcoloreffects.c
+++ b/gst/coloreffects/gstcoloreffects.c
@@ -86,6 +86,7 @@ gst_color_effects_preset_get_type (void)
     {GST_COLOR_EFFECTS_PRESET_XRAY, "Invert and slightly shade to blue",
         "xray"},
     {GST_COLOR_EFFECTS_PRESET_XPRO, "Cross processing toning", "xpro"},
+    {GST_COLOR_EFFECTS_PRESET_YELLOWBLUE, "Yellow foreground Blue background color filter", "yellowblue"},
     {0, NULL, NULL},
   };
 
@@ -253,6 +254,38 @@ static const guint8 xpro_table[768] =
     "\376\365\377\377\365\377\377\366\377\377\366\377\377\366\377\377\367\377"
     "\377\367\377\377\367\377\377\370";
 
+/*Used for a video magnifer emulator in gnome-video-effects*/
+static const guint8 yellowblue_table[768] =
+  "\0\0\377\1\1\376\2\2\375\3\3\374\4\4\373\5\5\372\6\6\371\7\7\370\10\10\367"
+  "\11\11\367\12\12\365\13\13\364\14\14\363\15\14\362\16\16\361\17\17\360\20"
+  "\20\357\20\21\356\22\22\355\23\23\354\24\24\354\24\25\352\26\26\351\27\27"
+  "\350\27\30\347\31\31\346\32\32\345\33\32\344\34\34\343\34\34\342\36\36\341"
+  "\37\36\340\40\40\337!!\336!!\335##\334$#\334%%\332&%\331'&\330((\327()\326"
+  "*)\325++\324,,\323--\322..\321//\320/0\31711\31722\31522\31444\31445\313"
+  "55\31276\31188\30799\3069:\305;;\305<<\304==\302>>\301>>\300@@\300@A\276"
+  "AB\275BC\274CD\273DE\272EE\272FF\270HH\270HI\266IJ\265KK\264KL\263MM\262"
+  "NN\262NN\261OO\257QP\256RQ\256RR\254TT\253UU\253VU\251VW\250XX\247XY\246"
+  "YZ\245[[\245[[\243]]\243^^\242^_\240_`\237`a\236aa\235bb\235dc\233de\233"
+  "ff\232gf\231hg\230hi\227ji\226kj\225lk\223lm\223nm\222nn\221op\217qq\216"
+  "rr\215ss\214st\213uu\213uu\211wv\210ww\207xx\207yz\205z{\205{{\204||\203"
+  "}}\202\177~\201\177\200\177\200\201\177\202\202~\203\202|\204\203|\204\204"
+  "{\205\206z\207\206x\207\207w\211\210w\211\211v\212\212u\213\214s\214\214"
+  "r\215\215r\216\217q\217\217p\221\220o\221\222n\223\222l\224\223k\224\224"
+  "k\225\225j\226\226i\227\227h\230\231f\231\231f\233\232e\233\233c\234\234"
+  "c\235\235b\236\236a\237\237`\241\240_\242\241^\242\242]\243\244\\\244\244"
+  "[\245\245Y\246\246Y\250\247X\250\250W\251\251V\252\252T\253\253T\254\255"
+  "S\256\255R\257\256Q\257\260P\260\261O\261\261N\262\262M\263\263L\264\265"
+  "K\265\265J\266\266I\267\270H\270\270G\271\271F\272\272E\273\273C\274\274"
+  "B\275\275B\276\276A\277\277@\300\300?\301\301>\302\302=\303\303<\304\304"
+  ";\305\305:\306\3069\307\3078\310\3107\311\3116\312\3125\313\3134\314\314"
+  "3\315\3152\316\3161\317\3170\320\320/\321\321.\322\322-\323\323,\323\324"
+  "+\325\325*\326\326)\327\327(\330\330'\331\331&\332\331%\333\332$\334\334"
+  "#\334\335\"\336\336!\337\337\40\340\340\37\341\341\36\342\342\35\343\343"
+  "\34\344\344\33\345\345\32\345\346\31\347\347\30\350\350\27\351\351\26\352"
+  "\352\25\353\353\24\354\354\23\354\355\22\356\356\21\357\357\20\360\360\17"
+  "\361\361\16\362\362\15\363\362\14\364\364\13\365\365\12\365\366\11\367\367"
+  "\11\370\370\7\371\371\6\372\371\5\373\373\4\374\374\4\375\375\3\375\376\1";
+
 static const int cog_ycbcr_to_rgb_matrix_8bit_sdtv[] = {
   298, 0, 409, -57068,
   298, -100, -208, 34707,
@@ -543,6 +576,10 @@ gst_color_effects_set_property (GObject * object, guint prop_id,
           filter->table = xpro_table;
           filter->map_luma = FALSE;
           break;
+	case GST_COLOR_EFFECTS_PRESET_YELLOWBLUE:
+	  filter->table = yellowblue_table;
+	  filter->map_luma = FALSE;
+	  break;
         default:
           g_assert_not_reached ();
 
diff --git a/gst/coloreffects/gstcoloreffects.h b/gst/coloreffects/gstcoloreffects.h
index 04e52a9..e2ae65f 100644
--- a/gst/coloreffects/gstcoloreffects.h
+++ b/gst/coloreffects/gstcoloreffects.h
@@ -45,6 +45,7 @@ typedef struct _GstColorEffectsClass GstColorEffectsClass;
  * @GST_CLUT_PRESET_SEPIA: Sepia toning filter
  * @GST_CLUT_PRESET_XRAY: Invert colors and slightly shade to cyan
  * @GST_CLUT_PRESET_XPRO: Cross Processing filter
+ * @GST_CLUT_PRESET_YELLOWBLUE: Visual magnifier high-contrast color filter. Since: 0.10.24
  *
  * The lookup table to use to convert input colors
  */
@@ -54,7 +55,8 @@ typedef enum
   GST_COLOR_EFFECTS_PRESET_HEAT,
   GST_COLOR_EFFECTS_PRESET_SEPIA,
   GST_COLOR_EFFECTS_PRESET_XRAY,
-  GST_COLOR_EFFECTS_PRESET_XPRO
+  GST_COLOR_EFFECTS_PRESET_XPRO,
+  GST_COLOR_EFFECTS_PRESET_YELLOWBLUE,
 } GstColorEffectsPreset;
 
 /**
diff --git a/gst/colorspace/colorspace.c b/gst/colorspace/colorspace.c
index 15b6caf..537da6d 100644
--- a/gst/colorspace/colorspace.c
+++ b/gst/colorspace/colorspace.c
@@ -412,7 +412,7 @@ putline_v210 (ColorspaceConvert * convert, guint8 * dest, const guint8 * src,
   int i;
   guint8 *destline = FRAME_GET_LINE (dest, 0, j);
 
-  for (i = 0; i < convert->width + 5; i += 6) {
+  for (i = 0; i < convert->width; i += 6) {
     guint32 a0, a1, a2, a3;
     guint16 y0, y1, y2, y3, y4, y5;
     guint16 u0, u1, u2;
@@ -518,7 +518,7 @@ putline16_v210 (ColorspaceConvert * convert, guint8 * dest, const guint16 * src,
   int i;
   guint8 *destline = FRAME_GET_LINE (dest, 0, j);
 
-  for (i = 0; i < convert->width + 5; i += 6) {
+  for (i = 0; i < convert->width; i += 6) {
     guint32 a0, a1, a2, a3;
     guint16 y0, y1, y2, y3, y4, y5;
     guint16 u0, u1, u2;
@@ -1540,6 +1540,28 @@ matrix_yuv_bt470_6_to_yuv_bt709 (ColorspaceConvert * convert)
 }
 
 static void
+matrix_yuv_jpeg_to_bt470_6 (ColorspaceConvert * convert)
+{
+  int i;
+  int y, u, v;
+  guint8 *tmpline = convert->tmpline;
+
+  for (i = 0; i < convert->width; i++) {
+    y = tmpline[i * 4 + 1];
+    u = tmpline[i * 4 + 2];
+    v = tmpline[i * 4 + 3];
+
+    y = (220 * y + 16 * 256 + 128) >> 8;
+    //u = (261 * u + 29 * v - 4367) >> 8;
+    //v = (19 * u + 262 * v - 3289) >> 8;
+
+    tmpline[i * 4 + 1] = CLAMP (y, 0, 255);
+    tmpline[i * 4 + 2] = CLAMP (u, 0, 255);
+    tmpline[i * 4 + 3] = CLAMP (v, 0, 255);
+  }
+}
+
+static void
 matrix_identity (ColorspaceConvert * convert)
 {
   /* do nothing */
@@ -1750,6 +1772,11 @@ colorspace_convert_lookup_getput (ColorspaceConvert * convert)
       && convert->to_spec == COLOR_SPEC_YUV_BT709) {
     convert->matrix = matrix_yuv_bt470_6_to_yuv_bt709;
     convert->matrix16 = matrix16_yuv_bt470_6_to_yuv_bt709;
+  } else if (convert->from_spec == COLOR_SPEC_YUV_JPEG
+      && convert->to_spec == COLOR_SPEC_YUV_BT470_6) {
+    convert->matrix = matrix_yuv_jpeg_to_bt470_6;
+    //convert->matrix16 = matrix16_yuv_jpeg_to_bt470_6;
+    convert->matrix16 = matrix16_identity;
   }
 }
 
@@ -1796,10 +1823,14 @@ colorspace_dither_verterr (ColorspaceConvert * convert, int j)
   int i;
   guint16 *tmpline = convert->tmpline16;
   guint16 *errline = convert->errline;
+  unsigned int mask = 0xff;
 
   for (i = 0; i < 4 * convert->width; i++) {
-    tmpline[i] += errline[i];
-    errline[i] = tmpline[i] & 0xff;
+    int x = tmpline[i] + errline[i];
+    if (x > 65535)
+      x = 65535;
+    tmpline[i] = x;
+    errline[i] = x & mask;
   }
 }
 
@@ -1820,7 +1851,11 @@ colorspace_dither_halftone (ColorspaceConvert * convert, int j)
   };
 
   for (i = 0; i < convert->width * 4; i++) {
-    tmpline[i] += halftone[(i >> 2) & 7][j & 7];
+    int x;
+    x = tmpline[i] + halftone[(i >> 2) & 7][j & 7];
+    if (x > 65535)
+      x = 65535;
+    tmpline[i] = x;
   }
 }
 
diff --git a/gst/colorspace/gstcolorspaceorc-dist.c b/gst/colorspace/gstcolorspaceorc-dist.c
index 70ca8d1..06d75b2 100644
--- a/gst/colorspace/gstcolorspaceorc-dist.c
+++ b/gst/colorspace/gstcolorspaceorc-dist.c
@@ -142,10 +142,10 @@ void orc_matrix3_000_u8 (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2,
     const guint8 * ORC_RESTRICT s3, int p1, int p2, int p3, int p4, int p5,
     int n);
-void orc_pack_123x (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
+void orc_pack_123x (guint32 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1,
     int n);
-void orc_pack_x123 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
+void orc_pack_x123 (guint32 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1,
     int n);
 void cogorc_combine2_u8 (guint8 * ORC_RESTRICT d1,
@@ -434,7 +434,7 @@ cogorc_memcpy_2d (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -538,7 +538,7 @@ cogorc_downsample_horiz_cosite_1tap (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -749,7 +749,7 @@ cogorc_downsample_horiz_cosite_3tap (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -965,7 +965,7 @@ cogorc_downsample_420_jpeg (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1090,7 +1090,7 @@ cogorc_downsample_vert_halfsite_2tap (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1267,7 +1267,7 @@ cogorc_downsample_vert_cosite_3tap (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1500,7 +1500,7 @@ cogorc_downsample_vert_halfsite_4tap (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s3, const guint8 * ORC_RESTRICT s4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1644,7 +1644,7 @@ cogorc_upsample_horiz_cosite_1tap (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1772,7 +1772,7 @@ cogorc_upsample_horiz_cosite (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1882,7 +1882,7 @@ cogorc_upsample_vert_avgub (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -1984,7 +1984,7 @@ orc_unpack_yuyv_y (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2098,7 +2098,7 @@ orc_unpack_yuyv_u (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2215,7 +2215,7 @@ orc_unpack_yuyv_v (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2406,7 +2406,7 @@ orc_pack_yuyv (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2525,7 +2525,7 @@ orc_unpack_uyvy_y (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2639,7 +2639,7 @@ orc_unpack_uyvy_u (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2756,7 +2756,7 @@ orc_unpack_uyvy_v (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -2947,7 +2947,7 @@ orc_pack_uyvy (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3128,7 +3128,7 @@ orc_matrix2_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, int p1, int p2, int p3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3351,7 +3351,7 @@ orc_matrix2_11_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, int p1, int p2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3590,7 +3590,7 @@ orc_matrix2_12_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, int p1, int p2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -3825,7 +3825,7 @@ orc_matrix3_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int p2, int p3, int p4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -4100,7 +4100,7 @@ orc_matrix3_100_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int p2, int p3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -4350,7 +4350,7 @@ orc_matrix3_100_offset_u8 (guint8 * ORC_RESTRICT d1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -4587,7 +4587,7 @@ orc_matrix3_000_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int p2, int p3, int p4, int p5, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -4660,7 +4660,7 @@ orc_matrix3_000_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
 /* orc_pack_123x */
 #ifdef DISABLE_ORC
 void
-orc_pack_123x (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
+orc_pack_123x (guint32 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1,
     int n)
 {
@@ -4780,12 +4780,12 @@ _backup_orc_pack_123x (OrcExecutor * ORC_RESTRICT ex)
 }
 
 void
-orc_pack_123x (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
+orc_pack_123x (guint32 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -4834,7 +4834,7 @@ orc_pack_123x (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
 /* orc_pack_x123 */
 #ifdef DISABLE_ORC
 void
-orc_pack_x123 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
+orc_pack_x123 (guint32 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1,
     int n)
 {
@@ -4954,12 +4954,12 @@ _backup_orc_pack_x123 (OrcExecutor * ORC_RESTRICT ex)
 }
 
 void
-orc_pack_x123 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
+orc_pack_x123 (guint32 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -5121,7 +5121,7 @@ cogorc_combine2_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, int p1, int p2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -5340,7 +5340,7 @@ cogorc_convert_I420_UYVY (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     const guint8 * ORC_RESTRICT s3, const guint8 * ORC_RESTRICT s4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -5551,7 +5551,7 @@ cogorc_convert_I420_YUY2 (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     const guint8 * ORC_RESTRICT s3, const guint8 * ORC_RESTRICT s4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -5782,7 +5782,7 @@ cogorc_convert_I420_AYUV (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     const guint8 * ORC_RESTRICT s3, const guint8 * ORC_RESTRICT s4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6015,7 +6015,7 @@ cogorc_convert_YUY2_I420 (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6137,7 +6137,7 @@ cogorc_convert_UYVY_YUY2 (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6262,7 +6262,7 @@ cogorc_planar_chroma_420_422 (guint8 * ORC_RESTRICT d1, int d1_stride,
     int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6380,7 +6380,7 @@ cogorc_planar_chroma_420_444 (guint8 * ORC_RESTRICT d1, int d1_stride,
     int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6491,7 +6491,7 @@ cogorc_planar_chroma_422_444 (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6615,7 +6615,7 @@ cogorc_planar_chroma_444_422 (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6764,7 +6764,7 @@ cogorc_planar_chroma_444_420 (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s2, int s2_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -6889,7 +6889,7 @@ cogorc_planar_chroma_422_420 (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s2, int s2_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7099,7 +7099,7 @@ cogorc_convert_YUY2_AYUV (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7317,7 +7317,7 @@ cogorc_convert_UYVY_AYUV (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7491,7 +7491,7 @@ cogorc_convert_YUY2_Y42B (guint8 * ORC_RESTRICT d1, int d1_stride,
     int d3_stride, const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7663,7 +7663,7 @@ cogorc_convert_UYVY_Y42B (guint8 * ORC_RESTRICT d1, int d1_stride,
     int d3_stride, const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -7847,7 +7847,7 @@ cogorc_convert_YUY2_Y444 (guint8 * ORC_RESTRICT d1, int d1_stride,
     int d3_stride, const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -8037,7 +8037,7 @@ cogorc_convert_UYVY_Y444 (guint8 * ORC_RESTRICT d1, int d1_stride,
     int d3_stride, const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -8264,7 +8264,7 @@ cogorc_convert_UYVY_I420 (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -8624,7 +8624,7 @@ cogorc_convert_AYUV_I420 (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s2, int s2_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -8871,7 +8871,7 @@ cogorc_convert_AYUV_YUY2 (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -9093,7 +9093,7 @@ cogorc_convert_AYUV_UYVY (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -9323,7 +9323,7 @@ cogorc_convert_AYUV_Y42B (guint8 * ORC_RESTRICT d1, int d1_stride,
     int d3_stride, const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -9506,7 +9506,7 @@ cogorc_convert_AYUV_Y444 (guint8 * ORC_RESTRICT d1, int d1_stride,
     int d3_stride, const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -9683,7 +9683,7 @@ cogorc_convert_Y42B_YUY2 (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -9857,7 +9857,7 @@ cogorc_convert_Y42B_UYVY (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -10083,7 +10083,7 @@ cogorc_convert_Y42B_AYUV (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -10307,7 +10307,7 @@ cogorc_convert_Y444_YUY2 (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -10530,7 +10530,7 @@ cogorc_convert_Y444_UYVY (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -10721,7 +10721,7 @@ cogorc_convert_Y444_AYUV (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s3, int s3_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -11167,7 +11167,7 @@ cogorc_convert_AYUV_ARGB (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -11689,7 +11689,7 @@ cogorc_convert_AYUV_BGRA (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -12211,7 +12211,7 @@ cogorc_convert_AYUV_ABGR (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -12733,7 +12733,7 @@ cogorc_convert_AYUV_RGBA (guint8 * ORC_RESTRICT d1, int d1_stride,
     const guint8 * ORC_RESTRICT s1, int s1_stride, int n, int m)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -13242,7 +13242,7 @@ cogorc_convert_I420_BGRA (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -13793,7 +13793,7 @@ cogorc_convert_I420_BGRA_avg (guint8 * ORC_RESTRICT d1,
     const guint8 * ORC_RESTRICT s5, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -14059,7 +14059,7 @@ cogorc_getline_I420 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -14278,7 +14278,7 @@ cogorc_getline_YUV9 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -14494,7 +14494,7 @@ cogorc_getline_YUY2 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -14701,7 +14701,7 @@ cogorc_getline_UYVY (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -14914,7 +14914,7 @@ cogorc_getline_YVYU (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -15129,7 +15129,7 @@ cogorc_getline_Y42B (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -15304,7 +15304,7 @@ cogorc_getline_Y444 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -15445,7 +15445,7 @@ cogorc_getline_Y800 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -15586,7 +15586,7 @@ cogorc_getline_Y16 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -15686,7 +15686,7 @@ cogorc_getline_BGRA (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -15874,7 +15874,7 @@ cogorc_getline_ABGR (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -16080,7 +16080,7 @@ cogorc_getline_RGBA (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -16280,7 +16280,7 @@ cogorc_getline_NV12 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -16471,7 +16471,7 @@ cogorc_getline_NV21 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s2, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -16649,7 +16649,7 @@ cogorc_getline_A420 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     const guint8 * ORC_RESTRICT s4, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -16901,7 +16901,7 @@ cogorc_putline_I420 (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     guint8 * ORC_RESTRICT d3, const guint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -17117,7 +17117,7 @@ cogorc_putline_YUY2 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -17330,7 +17330,7 @@ cogorc_putline_YVYU (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -17539,7 +17539,7 @@ cogorc_putline_UYVY (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -17752,7 +17752,7 @@ cogorc_putline_Y42B (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     guint8 * ORC_RESTRICT d3, const guint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -17920,7 +17920,7 @@ cogorc_putline_Y444 (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     guint8 * ORC_RESTRICT d3, const guint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -18044,7 +18044,7 @@ cogorc_putline_Y800 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -18173,7 +18173,7 @@ cogorc_putline_Y16 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -18274,7 +18274,7 @@ cogorc_putline_BGRA (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -18462,7 +18462,7 @@ cogorc_putline_ABGR (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -18668,7 +18668,7 @@ cogorc_putline_RGBA (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1,
     int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -18860,7 +18860,7 @@ cogorc_putline_NV12 (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     const guint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -19052,7 +19052,7 @@ cogorc_putline_NV21 (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     const guint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
@@ -19335,7 +19335,7 @@ cogorc_putline_A420 (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2,
     const guint8 * ORC_RESTRICT s1, int n)
 {
   OrcExecutor _ex, *ex = &_ex;
-  static volatile int p_inited = 0;
+  static int p_inited = 0;
   static OrcProgram *p = 0;
   void (*func) (OrcExecutor *);
 
diff --git a/gst/colorspace/gstcolorspaceorc-dist.h b/gst/colorspace/gstcolorspaceorc-dist.h
index ac4ea5b..2384b52 100644
--- a/gst/colorspace/gstcolorspaceorc-dist.h
+++ b/gst/colorspace/gstcolorspaceorc-dist.h
@@ -92,8 +92,8 @@ void orc_matrix3_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, c
 void orc_matrix3_100_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1, int p2, int p3, int n);
 void orc_matrix3_100_offset_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1, int p2, int p3, int p4, int p5, int n);
 void orc_matrix3_000_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1, int p2, int p3, int p4, int p5, int n);
-void orc_pack_123x (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1, int n);
-void orc_pack_x123 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1, int n);
+void orc_pack_123x (guint32 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1, int n);
+void orc_pack_x123 (guint32 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, int p1, int n);
 void cogorc_combine2_u8 (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, int p1, int p2, int n);
 void cogorc_convert_I420_UYVY (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2, const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, const guint8 * ORC_RESTRICT s4, int n);
 void cogorc_convert_I420_YUY2 (guint8 * ORC_RESTRICT d1, guint8 * ORC_RESTRICT d2, const guint8 * ORC_RESTRICT s1, const guint8 * ORC_RESTRICT s2, const guint8 * ORC_RESTRICT s3, const guint8 * ORC_RESTRICT s4, int n);
diff --git a/gst/dccp/gstdccp.c b/gst/dccp/gstdccp.c
index af652f2..cbe7c46 100644
--- a/gst/dccp/gstdccp.c
+++ b/gst/dccp/gstdccp.c
@@ -333,7 +333,7 @@ gst_dccp_socket_write (GstElement * element, int socket, const void *buf,
     size_t size, int packet_size)
 {
   size_t bytes_written = 0;
-  ssize_t wrote;
+  ssize_t wrote = 0;
 
 #ifndef G_OS_WIN32
   struct iovec iov;
@@ -362,11 +362,14 @@ gst_dccp_socket_write (GstElement * element, int socket, const void *buf,
     } while (wrote == SOCKET_ERROR && errorCode == EAGAIN);
 #endif
 
-    /* TODO print the send error */
-    bytes_written += wrote;
+    /* give up on error */
+    if (wrote >= 0)
+      bytes_written += wrote;
+    else
+      break;
   }
 
-  if (bytes_written < 0)
+  if (wrote < 0)
     GST_WARNING ("Error while writing.");
   else
     GST_LOG_OBJECT (element, "Wrote %" G_GSIZE_FORMAT " bytes succesfully.",
diff --git a/gst/debugutils/gstcompare.c b/gst/debugutils/gstcompare.c
index 92b8fa4..b20a8d0 100644
--- a/gst/debugutils/gstcompare.c
+++ b/gst/debugutils/gstcompare.c
@@ -26,7 +26,7 @@
 #include <string.h>
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 #include <gst/video/video.h>
 
 #include "gstcompare.h"
@@ -109,7 +109,7 @@ static void gst_compare_get_property (GObject * object,
 static void gst_compare_reset (GstCompare * overlay);
 
 static GstCaps *gst_compare_getcaps (GstPad * pad);
-static GstFlowReturn gst_compare_collect_pads (GstCollectPads * cpads,
+static GstFlowReturn gst_compare_collect_pads (GstCollectPads2 * cpads,
     GstCompare * comp);
 
 static GstStateChangeReturn gst_compare_change_state (GstElement * element,
@@ -187,9 +187,9 @@ gst_compare_class_init (GstCompareClass * klass)
 static void
 gst_compare_init (GstCompare * comp, GstCompareClass * klass)
 {
-  comp->cpads = gst_collect_pads_new ();
-  gst_collect_pads_set_function (comp->cpads,
-      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (gst_compare_collect_pads),
+  comp->cpads = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (comp->cpads,
+      (GstCollectPads2Function) GST_DEBUG_FUNCPTR (gst_compare_collect_pads),
       comp);
 
   comp->sinkpad = gst_pad_new_from_static_template (&sink_factory, "sink");
@@ -201,10 +201,10 @@ gst_compare_init (GstCompare * comp, GstCompareClass * klass)
   gst_pad_set_getcaps_function (comp->checkpad, gst_compare_getcaps);
   gst_element_add_pad (GST_ELEMENT (comp), comp->checkpad);
 
-  gst_collect_pads_add_pad_full (comp->cpads, comp->sinkpad,
-      sizeof (GstCollectData), NULL);
-  gst_collect_pads_add_pad_full (comp->cpads, comp->checkpad,
-      sizeof (GstCollectData), NULL);
+  gst_collect_pads2_add_pad_full (comp->cpads, comp->sinkpad,
+      sizeof (GstCollectData2), NULL, TRUE);
+  gst_collect_pads2_add_pad_full (comp->cpads, comp->checkpad,
+      sizeof (GstCollectData2), NULL, TRUE);
 
   comp->srcpad = gst_pad_new_from_static_template (&src_factory, "src");
   gst_pad_set_getcaps_function (comp->srcpad, gst_compare_getcaps);
@@ -537,14 +537,14 @@ gst_compare_buffers (GstCompare * comp, GstBuffer * buf1, GstBuffer * buf2)
 }
 
 static GstFlowReturn
-gst_compare_collect_pads (GstCollectPads * cpads, GstCompare * comp)
+gst_compare_collect_pads (GstCollectPads2 * cpads, GstCompare * comp)
 {
   GstBuffer *buf1, *buf2;
 
-  buf1 = gst_collect_pads_pop (comp->cpads,
+  buf1 = gst_collect_pads2_pop (comp->cpads,
       gst_pad_get_element_private (comp->sinkpad));
 
-  buf2 = gst_collect_pads_pop (comp->cpads,
+  buf2 = gst_collect_pads2_pop (comp->cpads,
       gst_pad_get_element_private (comp->checkpad));
 
   if (!buf1 && !buf2) {
@@ -636,10 +636,10 @@ gst_compare_change_state (GstElement * element, GstStateChange transition)
   switch (transition) {
     case GST_STATE_CHANGE_NULL_TO_READY:
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (comp->cpads);
+      gst_collect_pads2_start (comp->cpads);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_collect_pads_stop (comp->cpads);
+      gst_collect_pads2_stop (comp->cpads);
       break;
     default:
       break;
diff --git a/gst/debugutils/gstcompare.h b/gst/debugutils/gstcompare.h
index bee5108..65a9658 100644
--- a/gst/debugutils/gstcompare.h
+++ b/gst/debugutils/gstcompare.h
@@ -52,7 +52,7 @@ struct _GstCompare {
   GstPad *sinkpad;
   GstPad *checkpad;
 
-  GstCollectPads *cpads;
+  GstCollectPads2 *cpads;
 
   gint count;
 
diff --git a/gst/dvbsuboverlay/gstdvbsuboverlay.c b/gst/dvbsuboverlay/gstdvbsuboverlay.c
index 3c2cab3..5cd7a7f 100644
--- a/gst/dvbsuboverlay/gstdvbsuboverlay.c
+++ b/gst/dvbsuboverlay/gstdvbsuboverlay.c
@@ -38,6 +38,7 @@
 #  include <config.h>
 #endif
 
+#include <gst/glib-compat-private.h>
 #include "gstdvbsuboverlay.h"
 
 #include <string.h>
@@ -123,8 +124,7 @@ gst_dvbsub_overlay_base_init (gpointer gclass)
   gst_element_class_add_static_pad_template (element_class, &src_factory);
   gst_element_class_add_static_pad_template (element_class,
       &video_sink_factory);
-  gst_element_class_add_static_pad_template (element_class,
-      &text_sink_factory);
+  gst_element_class_add_static_pad_template (element_class, &text_sink_factory);
 
   gst_element_class_set_details_simple (element_class,
       "DVB Subtitles Overlay",
diff --git a/gst/dvdspu/gstdvdspu.c b/gst/dvdspu/gstdvdspu.c
index f57d3c2..94e69be 100644
--- a/gst/dvdspu/gstdvdspu.c
+++ b/gst/dvdspu/gstdvdspu.c
@@ -32,6 +32,10 @@
 #  include <config.h>
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/gst-i18n-plugin.h>
 #include <gst/video/video.h>
 
diff --git a/gst/faceoverlay/gstfaceoverlay.c b/gst/faceoverlay/gstfaceoverlay.c
index 209f656..b923c8f 100644
--- a/gst/faceoverlay/gstfaceoverlay.c
+++ b/gst/faceoverlay/gstfaceoverlay.c
@@ -1,5 +1,4 @@
-/*
- * GStreamer faceoverlay plugin
+/* GStreamer faceoverlay plugin
  * Copyright (C) 2011 Laura Lucas Alday <lauralucas@gmail.com>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -52,7 +51,6 @@
  * <title>Example launch line</title>
  * |[
  * gst-launch autovideosrc ! ffmpegcolorspace ! faceoverlay location=/path/to/gnome-video-effects/pixmaps/bow.svg x=-5 y=-15 w=0.3 h=0.1 ! ffmpegcolorspace ! autovideosink
-
  * ]|
  * </refsect2>
  */
@@ -70,19 +68,6 @@
 GST_DEBUG_CATEGORY_STATIC (gst_face_overlay_debug);
 #define GST_CAT_DEFAULT gst_face_overlay_debug
 
-#if G_BYTE_ORDER == G_LITTLE_ENDIAN
-#define GST_STR_VIDEO_CAPS GST_VIDEO_CAPS_BGRA
-#else
-#define GST_STR_VIDEO_CAPS GST_VIDEO_CAPS_ARGB
-#endif
-
-/* Filter signals and args */
-enum
-{
-  /* FILL ME */
-  LAST_SIGNAL
-};
-
 enum
 {
   PROP_0,
@@ -93,17 +78,16 @@ enum
   PROP_H
 };
 
-/* the capabilities of the inputs and outputs. */
 static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS (GST_STR_VIDEO_CAPS)
+    GST_STATIC_CAPS ("video/x-raw-rgb; video/x-raw-yuv")
     );
 
 static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS (GST_STR_VIDEO_CAPS)
+    GST_STATIC_CAPS ("video/x-raw-rgb; video/x-raw-yuv")
     );
 
 GST_BOILERPLATE (GstFaceOverlay, gst_face_overlay, GstBin, GST_TYPE_BIN);
@@ -117,121 +101,62 @@ static void gst_face_overlay_message_handler (GstBin * bin,
 static GstStateChangeReturn gst_face_overlay_change_state (GstElement * element,
     GstStateChange transition);
 static gboolean gst_face_overlay_create_children (GstFaceOverlay * filter);
-static gboolean gst_face_overlay_reset (GstFaceOverlay * filter);
-static gboolean gst_face_overlay_create_pad (GstFaceOverlay * filter,
-    GstPad * filter_pad, const char *pad_name, GstElement * child_element);
-static gboolean toggle_pads_link_state (GstPad * pad1, GstPad * pad2);
-
-
-static gboolean
-toggle_pads_link_state (GstPad * pad1, GstPad * pad2)
-{
-  gboolean ok = TRUE;
 
-  if (gst_pad_is_linked (pad1)) {
-    if (gst_pad_get_direction (pad1) == GST_PAD_SINK)
-      gst_pad_unlink (pad2, pad1);
-    else
-      gst_pad_unlink (pad1, pad2);
-  } else {
-    if (gst_pad_get_direction (pad1) == GST_PAD_SINK)
-      ok &= (gst_pad_link (pad2, pad1) == 0);
-    else
-      ok &= (gst_pad_link (pad1, pad2) == 0);
-  }
-
-  return ok;
-}
-
-/* Unlinks and removes the pad that was created in gst_face_overlay_init ()
- * and adds the internal element ghost pad instead  */
 static gboolean
-gst_face_overlay_create_pad (GstFaceOverlay * filter, GstPad * filter_pad,
-    const char *pad_name, GstElement * child_element)
+gst_face_overlay_create_children (GstFaceOverlay * filter)
 {
-  GstPad *peer = NULL;
-  GstPad *pad = NULL;
-  gboolean ok = TRUE;
+  GstElement *csp, *face_detect, *overlay;
+  GstPad *pad;
 
-  /* get the outside world pad connected to faceoverlay src/sink pad */
-  peer = gst_pad_get_peer (filter_pad);
+  csp = gst_element_factory_make ("ffmpegcolorspace", NULL);
+  face_detect = gst_element_factory_make ("facedetect", NULL);
+  overlay = gst_element_factory_make ("rsvgoverlay", NULL);
 
-  /* unlink and remove the faceoverlay src/sink pad */
-  toggle_pads_link_state (peer, filter_pad);
+  /* FIXME: post missing-plugin messages on NULL->READY if needed */
+  if (csp == NULL || face_detect == NULL || overlay == NULL)
+    goto missing_element;
 
-  gst_element_remove_pad (GST_ELEMENT (filter), filter_pad);
+  g_object_set (face_detect, "display", FALSE, NULL);
 
-  /* add a ghost pad pointing to the child element pad (facedetect sink or
-   * svg_overlay src depending on filter_pad direction) and add it to
-   * faceoverlay bin */
-  pad = gst_element_get_static_pad (child_element, pad_name);
-  filter_pad = gst_ghost_pad_new (pad_name, pad);
-  gst_object_unref (GST_OBJECT (pad));
+  gst_bin_add_many (GST_BIN (filter), face_detect, csp, overlay, NULL);
+  filter->svg_overlay = overlay;
 
-  gst_element_add_pad (GST_ELEMENT (filter), filter_pad);
+  if (!gst_element_link_many (face_detect, csp, overlay, NULL))
+    GST_ERROR_OBJECT (filter, "couldn't link elements");
 
-  /* link the child element pad to the outside world thru the ghost pad */
-  toggle_pads_link_state (peer, filter_pad);
+  pad = gst_element_get_static_pad (face_detect, "sink");
+  if (!gst_ghost_pad_set_target (GST_GHOST_PAD (filter->sinkpad), pad))
+    GST_ERROR_OBJECT (filter->sinkpad, "couldn't set sinkpad target");
+  gst_object_unref (pad);
 
-  g_object_unref (peer);
-
-  return ok;
-}
-
-static gboolean
-gst_face_overlay_reset (GstFaceOverlay * filter)
-{
-  gst_element_set_state (filter->face_detect, GST_STATE_NULL);
-  gst_bin_remove (GST_BIN (filter), filter->face_detect);
-  filter->face_detect = NULL;
-
-  gst_element_set_state (filter->svg_overlay, GST_STATE_NULL);
-  gst_bin_remove (GST_BIN (filter), filter->svg_overlay);
-  filter->svg_overlay = NULL;
-
-  gst_element_set_state (filter->colorspace, GST_STATE_NULL);
-  gst_bin_remove (GST_BIN (filter), filter->colorspace);
-  filter->colorspace = NULL;
+  pad = gst_element_get_static_pad (overlay, "src");
+  if (!gst_ghost_pad_set_target (GST_GHOST_PAD (filter->srcpad), pad))
+    GST_ERROR_OBJECT (filter->srcpad, "couldn't set srcpad target");
+  gst_object_unref (pad);
 
   return TRUE;
-}
 
-static gboolean
-gst_face_overlay_create_children (GstFaceOverlay * filter)
-{
-  gboolean ret = TRUE;
+/* ERRORS */
+missing_element:
+  {
+    /* clean up */
+    if (csp == NULL)
+      GST_ERROR_OBJECT (filter, "ffmpegcolorspace element not found");
+    else
+      gst_object_unref (csp);
 
-  if ((filter->colorspace = gst_element_factory_make ("ffmpegcolorspace",
-              NULL)) == NULL) {
-    return FALSE;
-  }
+    if (face_detect == NULL)
+      GST_ERROR_OBJECT (filter, "facedetect element not found (opencv plugin)");
+    else
+      gst_object_unref (face_detect);
 
-  if ((filter->face_detect = gst_element_factory_make ("facedetect",
-              NULL)) == NULL) {
-    return FALSE;
-  }
-  g_object_set (filter->face_detect, "display", 0, NULL);
+    if (overlay == NULL)
+      GST_ERROR_OBJECT (filter, "rsvgoverlay element not found (rsvg plugin)");
+    else
+      gst_object_unref (overlay);
 
-  if ((filter->svg_overlay = gst_element_factory_make ("rsvgoverlay",
-              NULL)) == NULL) {
     return FALSE;
   }
-
-  gst_bin_add_many (GST_BIN (filter),
-      filter->face_detect, filter->colorspace, filter->svg_overlay, NULL);
-
-  ret &= gst_element_link_pads (filter->face_detect, "src",
-      filter->colorspace, "sink");
-  ret &= gst_element_link_pads (filter->colorspace, "src",
-      filter->svg_overlay, "sink");
-
-  ret &= gst_face_overlay_create_pad (filter, filter->sinkpad, "sink",
-      filter->face_detect);
-  ret &= gst_face_overlay_create_pad (filter, filter->srcpad, "src",
-      filter->svg_overlay);
-
-  return ret;
-
 }
 
 static GstStateChangeReturn
@@ -242,8 +167,13 @@ gst_face_overlay_change_state (GstElement * element, GstStateChange transition)
 
   switch (transition) {
     case GST_STATE_CHANGE_NULL_TO_READY:
-      if (!gst_face_overlay_create_children (filter))
+      if (filter->svg_overlay == NULL) {
+        GST_ELEMENT_ERROR (filter, CORE, MISSING_PLUGIN, (NULL),
+            ("Some required plugins are missing, probably either the opencv "
+                "facedetect element or rsvgoverlay"));
         return GST_STATE_CHANGE_FAILURE;
+      }
+      filter->update_svg = TRUE;
       break;
     default:
       break;
@@ -252,9 +182,6 @@ gst_face_overlay_change_state (GstElement * element, GstStateChange transition)
   ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
 
   switch (transition) {
-    case GST_STATE_CHANGE_READY_TO_NULL:
-      gst_face_overlay_reset (filter);
-      break;
     default:
       break;
   }
@@ -263,65 +190,91 @@ gst_face_overlay_change_state (GstElement * element, GstStateChange transition)
 }
 
 static void
+gst_face_overlay_handle_faces (GstFaceOverlay * filter, const GstStructure * s)
+{
+  guint x, y, width, height;
+  gint svg_x, svg_y, svg_width, svg_height;
+  const GstStructure *face;
+  const GValue *faces_list, *face_val;
+  gchar *new_location = NULL;
+  gint face_count;
+
+#if 0
+  /* optionally draw the image once every two messages for better performance */
+  filter->process_message = !filter->process_message;
+  if (!filter->process_message)
+    return;
+#endif
+
+  faces_list = gst_structure_get_value (s, "faces");
+  face_count = gst_value_list_get_size (faces_list);
+  GST_LOG_OBJECT (filter, "face count: %d", face_count);
+
+  if (face_count == 0) {
+    GST_DEBUG_OBJECT (filter, "no face, clearing overlay");
+    g_object_set (filter->svg_overlay, "location", NULL, NULL);
+    GST_OBJECT_LOCK (filter);
+    filter->update_svg = TRUE;
+    GST_OBJECT_UNLOCK (filter);
+    return;
+  }
+
+  /* The last face in the list seems to be the right one, objects mistakenly
+   * detected as faces for a couple of frames seem to be in the list
+   * beginning. TODO: needs confirmation. */
+  face_val = gst_value_list_get_value (faces_list, face_count - 1);
+  face = gst_value_get_structure (face_val);
+  gst_structure_get_uint (face, "x", &x);
+  gst_structure_get_uint (face, "y", &y);
+  gst_structure_get_uint (face, "width", &width);
+  gst_structure_get_uint (face, "height", &height);
+
+  /* Apply x and y offsets relative to face position and size.
+   * Set image width and height as a fraction of face width and height.
+   * Cast to int since face position and size will never be bigger than
+   * G_MAX_INT and we may have negative values as svg_x or svg_y */
+
+  GST_OBJECT_LOCK (filter);
+
+  svg_x = (gint) x + (gint) (filter->x * width);
+  svg_y = (gint) y + (gint) (filter->y * height);
+
+  svg_width = (gint) (filter->w * width);
+  svg_height = (gint) (filter->h * height);
+
+  if (filter->update_svg) {
+    new_location = g_strdup (filter->location);
+    filter->update_svg = FALSE;
+  }
+  GST_OBJECT_UNLOCK (filter);
+
+  if (new_location != NULL) {
+    GST_DEBUG_OBJECT (filter, "set rsvgoverlay location=%s", new_location);
+    g_object_set (filter->svg_overlay, "location", new_location, NULL);
+    g_free (new_location);
+  }
+
+  GST_LOG_OBJECT (filter, "overlay dimensions: %d x %d @ %d,%d",
+      svg_width, svg_height, svg_x, svg_y);
+
+  g_object_set (filter->svg_overlay,
+      "x", svg_x, "y", svg_y, "width", svg_width, "height", svg_height, NULL);
+}
+
+static void
 gst_face_overlay_message_handler (GstBin * bin, GstMessage * message)
 {
-  if (GST_MESSAGE_TYPE (message) == GST_MESSAGE_ELEMENT &&
-      strcmp (gst_structure_get_name (message->structure), "facedetect") == 0) {
-    GstFaceOverlay *filter = GST_FACEOVERLAY (bin);
-
-    /* optionally draw the image once every two messages for better performance
-     * filter->process_message = !filter->process_message;
-     *  if(!filter->process_message)
-     *    return;
-     */
-
-    guint x, y, width, height;
-    int delta_x, delta_y, svg_x, svg_y, svg_width, svg_height;
-    const GstStructure *face;
-    int face_count;
-
-    face_count =
-        gst_value_list_get_size (gst_structure_get_value (message->structure,
-            "faces"));
-
-    /* The last face in the list seems to be the right one, objects mistakenly
-     * detected as faces for a couple of frames seem to be in the list
-     * beginning. TODO: needs confirmation. */
-    face =
-        gst_value_get_structure (gst_value_list_get_value
-        (gst_structure_get_value (message->structure, "faces"),
-            face_count - 1));
-    gst_structure_get_uint (face, "x", &x);
-    gst_structure_get_uint (face, "y", &y);
-    gst_structure_get_uint (face, "width", &width);
-    gst_structure_get_uint (face, "height", &height);
-
-    /* Apply x and y offsets relative to face position and size.
-     * Set image width and height as a fraction of face width and height.
-     * Cast to int since face position and size will never be bigger than
-     * G_MAX_INT and we may have negative values as svg_x or svg_y */
-
-    delta_x = (int) (filter->x * (int) width);
-    svg_x = (int) x + delta_x;
-
-    delta_y = (int) (filter->y * (int) height);
-    svg_y = (int) y + delta_y;
-
-    svg_width = (int) width *filter->w;
-    svg_height = (int) height *filter->h;
-
-    g_object_set (filter->svg_overlay,
-        "location", filter->location,
-        "x", svg_x, "y", svg_y, "width", svg_width, "height", svg_height, NULL);
+  if (GST_MESSAGE_TYPE (message) == GST_MESSAGE_ELEMENT) {
+    const GstStructure *s = gst_message_get_structure (message);
 
+    if (gst_structure_has_name (s, "facedetect")) {
+      gst_face_overlay_handle_faces (GST_FACEOVERLAY (bin), s);
+    }
   }
 
   GST_BIN_CLASS (parent_class)->handle_message (bin, message);
 }
 
-/* GObject vmethod implementations */
-/* the _base_init() function is meant to initialize class and child class
- * properties during each new child class creation */
 static void
 gst_face_overlay_base_init (gpointer gclass)
 {
@@ -337,10 +290,6 @@ gst_face_overlay_base_init (gpointer gclass)
   gst_element_class_add_static_pad_template (element_class, &sink_factory);
 }
 
-/* initialize the faceoverlay's class */
-/* the _class_init() function is used to initialise the class only once
- * (specifying what signals, arguments and virtual functions the class has and
- * setting up global state) */
 static void
 gst_face_overlay_class_init (GstFaceOverlayClass * klass)
 {
@@ -380,34 +329,32 @@ gst_face_overlay_class_init (GstFaceOverlayClass * klass)
       GST_DEBUG_FUNCPTR (gst_face_overlay_message_handler);
   gstelement_class->change_state =
       GST_DEBUG_FUNCPTR (gst_face_overlay_change_state);
-
 }
 
-/* initialize the new element
- * instantiate pads and add them to element
- * set pad calback functions
- * initialize instance structure
- * the _init() function is used to initialise a specific instance of this type.
- */
 static void
 gst_face_overlay_init (GstFaceOverlay * filter, GstFaceOverlayClass * gclass)
 {
+  GstPadTemplate *tmpl;
+
   filter->x = 0;
   filter->y = 0;
   filter->w = 1;
   filter->h = 1;
-  filter->colorspace = NULL;
   filter->svg_overlay = NULL;
-  filter->face_detect = NULL;
   filter->location = NULL;
   filter->process_message = TRUE;
 
-  filter->sinkpad = gst_pad_new_from_static_template (&sink_factory, "sink");
+  tmpl = gst_static_pad_template_get (&sink_factory);
+  filter->sinkpad = gst_ghost_pad_new_no_target_from_template ("sink", tmpl);
+  gst_object_unref (tmpl);
   gst_element_add_pad (GST_ELEMENT (filter), filter->sinkpad);
 
-  filter->srcpad = gst_pad_new_from_static_template (&src_factory, "src");
+  tmpl = gst_static_pad_template_get (&src_factory);
+  filter->srcpad = gst_ghost_pad_new_no_target_from_template ("src", tmpl);
+  gst_object_unref (tmpl);
   gst_element_add_pad (GST_ELEMENT (filter), filter->srcpad);
 
+  gst_face_overlay_create_children (filter);
 }
 
 static void
@@ -418,19 +365,31 @@ gst_face_overlay_set_property (GObject * object, guint prop_id,
 
   switch (prop_id) {
     case PROP_LOCATION:
+      GST_OBJECT_LOCK (filter);
+      g_free (filter->location);
       filter->location = g_value_dup_string (value);
+      filter->update_svg = TRUE;
+      GST_OBJECT_UNLOCK (filter);
       break;
     case PROP_X:
+      GST_OBJECT_LOCK (filter);
       filter->x = g_value_get_float (value);
+      GST_OBJECT_UNLOCK (filter);
       break;
     case PROP_Y:
+      GST_OBJECT_LOCK (filter);
       filter->y = g_value_get_float (value);
+      GST_OBJECT_UNLOCK (filter);
       break;
     case PROP_W:
+      GST_OBJECT_LOCK (filter);
       filter->w = g_value_get_float (value);
+      GST_OBJECT_UNLOCK (filter);
       break;
     case PROP_H:
+      GST_OBJECT_LOCK (filter);
       filter->h = g_value_get_float (value);
+      GST_OBJECT_UNLOCK (filter);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -446,19 +405,29 @@ gst_face_overlay_get_property (GObject * object, guint prop_id,
 
   switch (prop_id) {
     case PROP_LOCATION:
+      GST_OBJECT_LOCK (filter);
       g_value_set_string (value, filter->location);
+      GST_OBJECT_UNLOCK (filter);
       break;
     case PROP_X:
+      GST_OBJECT_LOCK (filter);
       g_value_set_float (value, filter->x);
+      GST_OBJECT_UNLOCK (filter);
       break;
     case PROP_Y:
+      GST_OBJECT_LOCK (filter);
       g_value_set_float (value, filter->y);
+      GST_OBJECT_UNLOCK (filter);
       break;
     case PROP_W:
+      GST_OBJECT_LOCK (filter);
       g_value_set_float (value, filter->w);
+      GST_OBJECT_UNLOCK (filter);
       break;
     case PROP_H:
+      GST_OBJECT_LOCK (filter);
       g_value_set_float (value, filter->h);
+      GST_OBJECT_UNLOCK (filter);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -466,14 +435,9 @@ gst_face_overlay_get_property (GObject * object, guint prop_id,
   }
 }
 
-/* entry point to initialize the plug-in
- * initialize the plug-in itself
- * register the element factories and other features
- */
 static gboolean
 faceoverlay_init (GstPlugin * faceoverlay)
 {
-  /* debug category for fltering log messages */
   GST_DEBUG_CATEGORY_INIT (gst_face_overlay_debug, "faceoverlay",
       0, "SVG Face Overlay");
 
@@ -481,18 +445,8 @@ faceoverlay_init (GstPlugin * faceoverlay)
       GST_TYPE_FACEOVERLAY);
 }
 
-/* PACKAGE: this is usually set by autotools depending on some _INIT macro
- * in configure.ac and then written into and defined in config.h, but we can
- * just set it ourselves here in case someone doesn't use autotools to
- * compile this code. GST_PLUGIN_DEFINE needs PACKAGE to be defined.
- */
-#ifndef PACKAGE
-#define PACKAGE "faceoverlay"
-#endif
-
-/* gstreamer looks for this structure to register plugins */
 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
     GST_VERSION_MINOR,
     "faceoverlay",
     "SVG Face Overlay",
-    faceoverlay_init, VERSION, "LGPL", "GStreamer", "http://gstreamer.net/")
+    faceoverlay_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/gst/faceoverlay/gstfaceoverlay.h b/gst/faceoverlay/gstfaceoverlay.h
index 7b8e50c..c21327b 100644
--- a/gst/faceoverlay/gstfaceoverlay.h
+++ b/gst/faceoverlay/gstfaceoverlay.h
@@ -1,5 +1,4 @@
-/*
- * GStreamer faceoverlay plugin
+/* GStreamer faceoverlay plugin
  * Copyright (C) 2011 Laura Lucas Alday <lauralucas@gmail.com>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -47,7 +46,7 @@
 #include <gst/gst.h>
 
 G_BEGIN_DECLS
-/* #defines don't like whitespacey bits */
+
 #define GST_TYPE_FACEOVERLAY \
   (gst_face_overlay_get_type())
 #define GST_FACEOVERLAY(obj) \
@@ -58,6 +57,7 @@ G_BEGIN_DECLS
   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FACEOVERLAY))
 #define GST_IS_FACEOVERLAY_CLASS(klass) \
   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FACEOVERLAY))
+
 typedef struct _GstFaceOverlay GstFaceOverlay;
 typedef struct _GstFaceOverlayClass GstFaceOverlayClass;
 
@@ -73,6 +73,8 @@ struct _GstFaceOverlay
 
   gboolean process_message;
 
+  gboolean update_svg;
+
   gchar *location;
   gfloat x;
   gfloat y;
@@ -88,4 +90,5 @@ struct _GstFaceOverlayClass
 GType gst_face_overlay_get_type (void);
 
 G_END_DECLS
+
 #endif /* __GST_FACEOVERLAY_H__ */
diff --git a/gst/frei0r/gstfrei0rmixer.c b/gst/frei0r/gstfrei0rmixer.c
index 3f0a77d..3b0bf2e 100644
--- a/gst/frei0r/gstfrei0rmixer.c
+++ b/gst/frei0r/gstfrei0rmixer.c
@@ -120,7 +120,7 @@ gst_frei0r_mixer_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_NULL_TO_READY:
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (self->collect);
+      gst_collect_pads2_start (self->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
@@ -129,11 +129,11 @@ gst_frei0r_mixer_change_state (GstElement * element, GstStateChange transition)
   }
 
   /* Stop before calling the parent's state change function as
-   * GstCollectPads might take locks and we would deadlock in that
+   * GstCollectPads2 might take locks and we would deadlock in that
    * case
    */
   if (transition == GST_STATE_CHANGE_PAUSED_TO_READY)
-    gst_collect_pads_stop (self->collect);
+    gst_collect_pads2_stop (self->collect);
 
   ret =
       GST_ELEMENT_CLASS (g_type_class_peek_parent (klass))->change_state
@@ -488,7 +488,7 @@ gst_frei0r_mixer_src_event (GstPad * pad, GstEvent * event)
       /* check if we are flushing */
       if (flags & GST_SEEK_FLAG_FLUSH) {
         /* make sure we accept nothing anymore and return WRONG_STATE */
-        gst_collect_pads_set_flushing (self->collect, TRUE);
+        gst_collect_pads2_set_flushing (self->collect, TRUE);
 
         /* flushing seek, start flush downstream, the flush will be done
          * when all pads received a FLUSH_STOP. */
@@ -532,7 +532,7 @@ gst_frei0r_mixer_sink0_event (GstPad * pad, GstEvent * event)
       break;
   }
 
-  /* now GstCollectPads can take care of the rest, e.g. EOS */
+  /* now GstCollectPads2 can take care of the rest, e.g. EOS */
   ret = self->collect_event (pad, event);
 
   gst_object_unref (self);
@@ -541,7 +541,7 @@ gst_frei0r_mixer_sink0_event (GstPad * pad, GstEvent * event)
 }
 
 static GstFlowReturn
-gst_frei0r_mixer_collected (GstCollectPads * pads, GstFrei0rMixer * self)
+gst_frei0r_mixer_collected (GstCollectPads2 * pads, GstFrei0rMixer * self)
 {
   GstBuffer *inbuf0 = NULL, *inbuf1 = NULL, *inbuf2 = NULL;
   GstBuffer *outbuf = NULL;
@@ -575,15 +575,15 @@ gst_frei0r_mixer_collected (GstCollectPads * pads, GstFrei0rMixer * self)
     return ret;
 
   for (l = pads->data; l; l = l->next) {
-    GstCollectData *cdata = l->data;
+    GstCollectData2 *cdata = l->data;
 
     if (cdata->pad == self->sink0) {
-      inbuf0 = gst_collect_pads_pop (pads, cdata);
+      inbuf0 = gst_collect_pads2_pop (pads, cdata);
       segment = &cdata->segment;
     } else if (cdata->pad == self->sink1) {
-      inbuf1 = gst_collect_pads_pop (pads, cdata);
+      inbuf1 = gst_collect_pads2_pop (pads, cdata);
     } else if (cdata->pad == self->sink2) {
-      inbuf2 = gst_collect_pads_pop (pads, cdata);
+      inbuf2 = gst_collect_pads2_pop (pads, cdata);
     }
   }
 
@@ -708,9 +708,9 @@ gst_frei0r_mixer_init (GstFrei0rMixer * self, GstFrei0rMixerClass * klass)
   self->property_cache =
       gst_frei0r_property_cache_init (klass->properties, klass->n_properties);
 
-  self->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (self->collect,
-      (GstCollectPadsFunction) gst_frei0r_mixer_collected, self);
+  self->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (self->collect,
+      (GstCollectPads2Function) gst_frei0r_mixer_collected, self);
 
   self->src =
       gst_pad_new_from_template (gst_element_class_get_pad_template
@@ -734,8 +734,8 @@ gst_frei0r_mixer_init (GstFrei0rMixer * self, GstFrei0rMixerClass * klass)
       GST_DEBUG_FUNCPTR (gst_frei0r_mixer_set_caps));
   gst_pad_set_query_function (self->sink0,
       GST_DEBUG_FUNCPTR (gst_frei0r_mixer_sink_query));
-  gst_collect_pads_add_pad (self->collect, self->sink0,
-      sizeof (GstCollectData));
+  gst_collect_pads2_add_pad (self->collect, self->sink0,
+      sizeof (GstCollectData2));
   self->collect_event = (GstPadEventFunction) GST_PAD_EVENTFUNC (self->sink0);
   gst_pad_set_event_function (self->sink0,
       GST_DEBUG_FUNCPTR (gst_frei0r_mixer_sink0_event));
@@ -750,8 +750,8 @@ gst_frei0r_mixer_init (GstFrei0rMixer * self, GstFrei0rMixerClass * klass)
       GST_DEBUG_FUNCPTR (gst_frei0r_mixer_set_caps));
   gst_pad_set_query_function (self->sink0,
       GST_DEBUG_FUNCPTR (gst_frei0r_mixer_sink_query));
-  gst_collect_pads_add_pad (self->collect, self->sink1,
-      sizeof (GstCollectData));
+  gst_collect_pads2_add_pad (self->collect, self->sink1,
+      sizeof (GstCollectData2));
   gst_element_add_pad (GST_ELEMENT_CAST (self), self->sink1);
 
   if (klass->info->plugin_type == F0R_PLUGIN_TYPE_MIXER3) {
@@ -764,8 +764,8 @@ gst_frei0r_mixer_init (GstFrei0rMixer * self, GstFrei0rMixerClass * klass)
         GST_DEBUG_FUNCPTR (gst_frei0r_mixer_set_caps));
     gst_pad_set_query_function (self->sink0,
         GST_DEBUG_FUNCPTR (gst_frei0r_mixer_sink_query));
-    gst_collect_pads_add_pad (self->collect, self->sink2,
-        sizeof (GstCollectData));
+    gst_collect_pads2_add_pad (self->collect, self->sink2,
+        sizeof (GstCollectData2));
     gst_element_add_pad (GST_ELEMENT_CAST (self), self->sink2);
   }
 
diff --git a/gst/frei0r/gstfrei0rmixer.h b/gst/frei0r/gstfrei0rmixer.h
index 7cb6600..19bb2d9 100644
--- a/gst/frei0r/gstfrei0rmixer.h
+++ b/gst/frei0r/gstfrei0rmixer.h
@@ -22,7 +22,7 @@
 
 #include <gst/gst.h>
 #include <gst/video/video.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 #include "frei0r.h"
 #include "gstfrei0r.h"
@@ -42,7 +42,7 @@ typedef struct _GstFrei0rMixerClass GstFrei0rMixerClass;
 struct _GstFrei0rMixer {
   GstElement parent;
 
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
   GstPad *src;
   GstPad *sink0, *sink1, *sink2;
 
diff --git a/gst/geometrictransform/gstgeometrictransform.c b/gst/geometrictransform/gstgeometrictransform.c
index 8e78de7..a1ec3ab 100644
--- a/gst/geometrictransform/gstgeometrictransform.c
+++ b/gst/geometrictransform/gstgeometrictransform.c
@@ -113,6 +113,8 @@ gst_geometric_transform_generate_map (GstGeometricTransform * gt)
   GstGeometricTransformClass *klass;
   gdouble *ptr;
 
+  GST_INFO_OBJECT (gt, "Generating new transform map");
+
   /* cleanup old map */
   g_free (gt->map);
   gt->map = NULL;
@@ -143,9 +145,11 @@ gst_geometric_transform_generate_map (GstGeometricTransform * gt)
   }
 
 end:
-  if (!ret)
+  if (!ret) {
+    GST_WARNING_OBJECT (gt, "Generating transform map failed");
     g_free (gt->map);
-  else
+    gt->map = NULL;
+  } else
     gt->needs_remap = FALSE;
   return ret;
 }
@@ -174,8 +178,8 @@ gst_geometric_transform_set_caps (GstBaseTransform * btrans, GstCaps * incaps,
 
     /* regenerate the map */
     GST_OBJECT_LOCK (gt);
-    if (old_width == 0 || old_height == 0 || gt->width != old_width ||
-        gt->height != old_height) {
+    if (gt->map == NULL || old_width == 0 || old_height == 0
+        || gt->width != old_width || gt->height != old_height) {
       if (klass->prepare_func)
         if (!klass->prepare_func (gt)) {
           GST_OBJECT_UNLOCK (gt);
@@ -347,7 +351,13 @@ gst_geometric_transform_stop (GstBaseTransform * trans)
 {
   GstGeometricTransform *gt = GST_GEOMETRIC_TRANSFORM_CAST (trans);
 
+  GST_INFO_OBJECT (gt, "Deleting transform map");
+
+  gt->width = 0;
+  gt->height = 0;
+
   g_free (gt->map);
+  gt->map = NULL;
 
   return TRUE;
 }
diff --git a/gst/h264parse/gsth264parse.c b/gst/h264parse/gsth264parse.c
index 8ae6075..0db2434 100644
--- a/gst/h264parse/gsth264parse.c
+++ b/gst/h264parse/gsth264parse.c
@@ -895,10 +895,8 @@ gst_h264_parse_base_init (gpointer g_class)
 {
   GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
 
-  gst_element_class_add_static_pad_template (gstelement_class,
-      &srctemplate);
-  gst_element_class_add_static_pad_template (gstelement_class,
-      &sinktemplate);
+  gst_element_class_add_static_pad_template (gstelement_class, &srctemplate);
+  gst_element_class_add_static_pad_template (gstelement_class, &sinktemplate);
   gst_element_class_set_details_simple (gstelement_class, "H264Parse",
       "Codec/Parser/Video",
       "Parses raw h264 stream",
@@ -1730,9 +1728,10 @@ gst_h264_parse_push_buffer (GstH264Parse * h264parse, GstBuffer * buf)
           /* insert config NALs into AU */
           GstByteWriter bw;
           GstBuffer *codec_nal, *new_buf;
+          gboolean ok;
 
           gst_byte_writer_init_with_size (&bw, GST_BUFFER_SIZE (buf), FALSE);
-          gst_byte_writer_put_data (&bw, GST_BUFFER_DATA (buf),
+          ok = gst_byte_writer_put_data (&bw, GST_BUFFER_DATA (buf),
               h264parse->idr_offset);
           GST_DEBUG_OBJECT (h264parse, "- inserting SPS/PPS");
           for (i = 0; i < MAX_SPS_COUNT; i++) {
@@ -1741,8 +1740,8 @@ gst_h264_parse_push_buffer (GstH264Parse * h264parse, GstBuffer * buf)
               codec_nal = gst_buffer_copy (h264parse->sps_nals[i]);
               codec_nal =
                   gst_h264_parse_write_nal_prefix (h264parse, codec_nal);
-              gst_byte_writer_put_data (&bw, GST_BUFFER_DATA (codec_nal),
-                  GST_BUFFER_SIZE (codec_nal));
+              ok &= gst_byte_writer_put_data (&bw,
+                  GST_BUFFER_DATA (codec_nal), GST_BUFFER_SIZE (codec_nal));
               h264parse->last_report = timestamp;
             }
           }
@@ -1752,12 +1751,12 @@ gst_h264_parse_push_buffer (GstH264Parse * h264parse, GstBuffer * buf)
               codec_nal = gst_buffer_copy (h264parse->pps_nals[i]);
               codec_nal =
                   gst_h264_parse_write_nal_prefix (h264parse, codec_nal);
-              gst_byte_writer_put_data (&bw, GST_BUFFER_DATA (codec_nal),
-                  GST_BUFFER_SIZE (codec_nal));
+              ok &= gst_byte_writer_put_data (&bw,
+                  GST_BUFFER_DATA (codec_nal), GST_BUFFER_SIZE (codec_nal));
               h264parse->last_report = timestamp;
             }
           }
-          gst_byte_writer_put_data (&bw,
+          ok &= gst_byte_writer_put_data (&bw,
               GST_BUFFER_DATA (buf) + h264parse->idr_offset,
               GST_BUFFER_SIZE (buf) - h264parse->idr_offset);
           /* collect result and push */
@@ -1765,6 +1764,10 @@ gst_h264_parse_push_buffer (GstH264Parse * h264parse, GstBuffer * buf)
           gst_buffer_copy_metadata (new_buf, buf, GST_BUFFER_COPY_ALL);
           gst_buffer_unref (buf);
           buf = new_buf;
+          /* some result checking seems to make some compilers happy */
+          if (G_UNLIKELY (!ok)) {
+            GST_ERROR_OBJECT (h264parse, "failed to insert SPS/PPS");
+          }
         }
       }
     }
diff --git a/gst/hls/Makefile.am b/gst/hls/Makefile.am
index 687b568..05f0ac8 100644
--- a/gst/hls/Makefile.am
+++ b/gst/hls/Makefile.am
@@ -4,17 +4,21 @@ plugin_LTLIBRARIES = libgstfragmented.la
 libgstfragmented_la_SOURCES =			\
 	m3u8.c					\
 	gsthlsdemux.c				\
+	gstfragment.c				\
+	gsturidownloader.c			\
 	gstfragmentedplugin.c
 
-libgstfragmented_la_CFLAGS = $(GST_CFLAGS) $(GST_BASE_CFLAGS) $(SOUP_CFLAGS)
-libgstfragmented_la_LIBADD = $(GST_LIBS) $(GST_BASE_LIBS) $(SOUP_LIBS)
+libgstfragmented_la_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_BASE_CFLAGS) $(GST_CFLAGS) $(SOUP_CFLAGS)
+libgstfragmented_la_LIBADD = $(GST_BASE_LIBS) $(GST_LIBS) $(SOUP_LIBS)
 libgstfragmented_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS) -no-undefined
 libgstfragmented_la_LIBTOOLFLAGS = --tag=disable-static
 
 # headers we need but don't want installed
 noinst_HEADERS = 			\
 	gstfragmented.h		\
+	gstfragment.h				\
 	gsthlsdemux.h			\
+	gsturidownloader.h			\
 	m3u8.h
 
 Android.mk: Makefile.am $(BUILT_SOURCES)
diff --git a/gst/hls/gstfragment.c b/gst/hls/gstfragment.c
new file mode 100644
index 0000000..00a3b4c
--- /dev/null
+++ b/gst/hls/gstfragment.c
@@ -0,0 +1,222 @@
+/* GStreamer
+ * Copyright (C) 2011 Andoni Morales Alastruey <ylatuya@gmail.com>
+ *
+ * gstfragment.c:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <glib.h>
+#include "gstfragmented.h"
+#include "gstfragment.h"
+
+#define GST_CAT_DEFAULT fragmented_debug
+
+#define GST_FRAGMENT_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_FRAGMENT, GstFragmentPrivate))
+
+enum
+{
+  PROP_0,
+  PROP_INDEX,
+  PROP_NAME,
+  PROP_DURATION,
+  PROP_DISCONTINOUS,
+  PROP_BUFFER_LIST,
+  PROP_LAST
+};
+
+struct _GstFragmentPrivate
+{
+  GstBufferList *buffer_list;
+  GstBufferListIterator *buffer_iterator;
+  gboolean headers_set;
+};
+
+G_DEFINE_TYPE (GstFragment, gst_fragment, G_TYPE_OBJECT);
+
+static void gst_fragment_dispose (GObject * object);
+static void gst_fragment_finalize (GObject * object);
+
+static void
+gst_fragment_get_property (GObject * object,
+    guint property_id, GValue * value, GParamSpec * pspec)
+{
+  GstFragment *fragment = GST_FRAGMENT (object);
+
+  switch (property_id) {
+    case PROP_INDEX:
+      g_value_set_uint (value, fragment->index);
+      break;
+
+    case PROP_NAME:
+      g_value_set_string (value, fragment->name);
+      break;
+
+    case PROP_DURATION:
+      g_value_set_uint64 (value, fragment->stop_time - fragment->start_time);
+      break;
+
+    case PROP_DISCONTINOUS:
+      g_value_set_boolean (value, fragment->discontinuous);
+      break;
+
+    case PROP_BUFFER_LIST:
+      g_value_set_object (value, gst_fragment_get_buffer_list (fragment));
+      break;
+
+    default:
+      /* We don't have any other property... */
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_fragment_class_init (GstFragmentClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GstFragmentPrivate));
+
+  gobject_class->get_property = gst_fragment_get_property;
+  gobject_class->dispose = gst_fragment_dispose;
+  gobject_class->finalize = gst_fragment_finalize;
+
+  g_object_class_install_property (gobject_class, PROP_INDEX,
+      g_param_spec_uint ("index", "Index", "Index of the fragment", 0,
+          G_MAXUINT, 0, G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class, PROP_NAME,
+      g_param_spec_string ("name", "Name",
+          "Name of the fragment (eg:fragment-12.ts)", NULL, G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class, PROP_DISCONTINOUS,
+      g_param_spec_boolean ("discontinuous", "Discontinous",
+          "Whether this fragment has a discontinuity or not",
+          FALSE, G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class, PROP_DURATION,
+      g_param_spec_uint64 ("duration", "Fragment duration",
+          "Duration of the fragment", 0, G_MAXUINT64, 0, G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class, PROP_BUFFER_LIST,
+      g_param_spec_object ("buffer-list", "Buffer List",
+          "A list with the fragment's buffers", GST_TYPE_FRAGMENT,
+          G_PARAM_READABLE));
+}
+
+static void
+gst_fragment_init (GstFragment * fragment)
+{
+  GstFragmentPrivate *priv;
+
+  fragment->priv = priv = GST_FRAGMENT_GET_PRIVATE (fragment);
+
+  priv->buffer_list = gst_buffer_list_new ();
+  priv->buffer_iterator = gst_buffer_list_iterate (priv->buffer_list);
+  gst_buffer_list_iterator_add_group (priv->buffer_iterator);
+  priv->headers_set = FALSE;
+  fragment->download_start_time = g_get_real_time ();
+  fragment->start_time = 0;
+  fragment->stop_time = 0;
+  fragment->index = 0;
+  fragment->name = g_strdup ("");
+  fragment->completed = FALSE;
+  fragment->discontinuous = FALSE;
+}
+
+GstFragment *
+gst_fragment_new (void)
+{
+  return GST_FRAGMENT (g_object_new (GST_TYPE_FRAGMENT, NULL));
+}
+
+static void
+gst_fragment_finalize (GObject * gobject)
+{
+  GstFragment *fragment = GST_FRAGMENT (gobject);
+
+  g_free (fragment->name);
+
+  G_OBJECT_CLASS (gst_fragment_parent_class)->finalize (gobject);
+}
+
+void
+gst_fragment_dispose (GObject * object)
+{
+  GstFragmentPrivate *priv = GST_FRAGMENT (object)->priv;
+
+  if (priv->buffer_list != NULL) {
+    gst_buffer_list_iterator_free (priv->buffer_iterator);
+    gst_buffer_list_unref (priv->buffer_list);
+    priv->buffer_list = NULL;
+  }
+
+  G_OBJECT_CLASS (gst_fragment_parent_class)->dispose (object);
+}
+
+GstBufferList *
+gst_fragment_get_buffer_list (GstFragment * fragment)
+{
+  g_return_val_if_fail (fragment != NULL, NULL);
+
+  if (!fragment->completed)
+    return NULL;
+
+  gst_buffer_list_ref (fragment->priv->buffer_list);
+  return fragment->priv->buffer_list;
+}
+
+gboolean
+gst_fragment_set_headers (GstFragment * fragment, GstBuffer ** buffer,
+    guint count)
+{
+  guint i;
+
+  g_return_val_if_fail (fragment != NULL, FALSE);
+  g_return_val_if_fail (buffer != NULL, FALSE);
+
+  if (fragment->priv->headers_set)
+    return FALSE;
+
+  for (i = 0; i < count; i++) {
+    /* We steal the buffers you pass in */
+    gst_buffer_list_iterator_add (fragment->priv->buffer_iterator, buffer[i]);
+    gst_buffer_list_iterator_add_group (fragment->priv->buffer_iterator);
+  }
+  return TRUE;
+}
+
+gboolean
+gst_fragment_add_buffer (GstFragment * fragment, GstBuffer * buffer)
+{
+  g_return_val_if_fail (fragment != NULL, FALSE);
+  g_return_val_if_fail (buffer != NULL, FALSE);
+
+  if (fragment->completed) {
+    GST_WARNING ("Fragment is completed, could not add more buffers");
+    return FALSE;
+  }
+
+  /* if this is the first buffer forbid setting the headers anymore */
+  if (G_UNLIKELY (fragment->priv->headers_set == FALSE))
+    fragment->priv->headers_set = TRUE;
+
+  GST_DEBUG ("Adding new buffer to the fragment");
+  /* We steal the buffers you pass in */
+  gst_buffer_list_iterator_add (fragment->priv->buffer_iterator, buffer);
+  return TRUE;
+}
diff --git a/gst/hls/gstfragment.h b/gst/hls/gstfragment.h
new file mode 100644
index 0000000..9ea0186
--- /dev/null
+++ b/gst/hls/gstfragment.h
@@ -0,0 +1,69 @@
+/* GStreamer
+ * Copyright (C) 2011 Andoni Morales Alastruey <ylatuya@gmail.com>
+ *
+ * gstfragment.h:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GSTFRAGMENT_H__
+#define __GSTFRAGMENT_H__
+
+#include <glib-object.h>
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_FRAGMENT (gst_fragment_get_type())
+#define GST_FRAGMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FRAGMENT,GstFragment))
+#define GST_FRAGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FRAGMENT,GstFragmentClass))
+#define GST_IS_FRAGMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FRAGMENT))
+#define GST_IS_FRAGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FRAGMENT))
+
+typedef struct _GstFragment GstFragment;
+typedef struct _GstFragmentPrivate GstFragmentPrivate;
+typedef struct _GstFragmentClass GstFragmentClass;
+
+struct _GstFragment
+{
+  GObject parent;
+
+  gchar * name;                 /* Name of the fragment */
+  gboolean completed;           /* Whether the fragment is complete or not */
+  guint64 download_start_time;  /* Epoch time when the download started */
+  guint64 download_stop_time;   /* Epoch time when the download finished */
+  guint64 start_time;           /* Start time of the fragment */
+  guint64 stop_time;            /* Stop time of the fragment */
+  gboolean index;               /* Index of the fragment */
+  gboolean discontinuous;       /* Whether this fragment is discontinuous or not */
+
+  GstFragmentPrivate *priv;
+};
+
+struct _GstFragmentClass
+{
+  GObjectClass parent_class;
+};
+
+GType gst_fragment_get_type (void);
+
+GstBufferList * gst_fragment_get_buffer_list (GstFragment *fragment);
+gboolean gst_fragment_set_headers (GstFragment *fragment, GstBuffer **buffer, guint count);
+gboolean gst_fragment_add_buffer (GstFragment *fragment, GstBuffer *buffer);
+GstFragment * gst_fragment_new (void);
+
+G_END_DECLS
+#endif /* __GSTFRAGMENT_H__ */
diff --git a/gst/hls/gsthlsdemux.c b/gst/hls/gsthlsdemux.c
index d840ae0..f0054bf 100644
--- a/gst/hls/gsthlsdemux.c
+++ b/gst/hls/gsthlsdemux.c
@@ -41,9 +41,13 @@
 #  include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
 
 #include <string.h>
 #include <gst/base/gsttypefindhelper.h>
+#include <gst/glib-compat-private.h>
 #include "gsthlsdemux.h"
 
 static GstStaticPadTemplate srctemplate = GST_STATIC_PAD_TEMPLATE ("src%d",
@@ -56,11 +60,6 @@ static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("application/x-hls"));
 
-static GstStaticPadTemplate fetchertemplate = GST_STATIC_PAD_TEMPLATE ("sink",
-    GST_PAD_SINK,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS_ANY);
-
 GST_DEBUG_CATEGORY_STATIC (gst_hls_demux_debug);
 #define GST_CAT_DEFAULT gst_hls_demux_debug
 
@@ -91,31 +90,23 @@ static GstStateChangeReturn
 gst_hls_demux_change_state (GstElement * element, GstStateChange transition);
 
 /* GstHLSDemux */
-static GstBusSyncReply gst_hls_demux_fetcher_bus_handler (GstBus * bus,
-    GstMessage * message, gpointer data);
 static GstFlowReturn gst_hls_demux_chain (GstPad * pad, GstBuffer * buf);
 static gboolean gst_hls_demux_sink_event (GstPad * pad, GstEvent * event);
 static gboolean gst_hls_demux_src_event (GstPad * pad, GstEvent * event);
 static gboolean gst_hls_demux_src_query (GstPad * pad, GstQuery * query);
-static GstFlowReturn gst_hls_demux_fetcher_chain (GstPad * pad,
-    GstBuffer * buf);
-static gboolean gst_hls_demux_fetcher_sink_event (GstPad * pad,
-    GstEvent * event);
-static void gst_hls_demux_loop (GstHLSDemux * demux);
+static void gst_hls_demux_stream_loop (GstHLSDemux * demux);
+static void gst_hls_demux_updates_loop (GstHLSDemux * demux);
 static void gst_hls_demux_stop (GstHLSDemux * demux);
-static void gst_hls_demux_stop_fetcher_locked (GstHLSDemux * demux,
-    gboolean cancelled);
-static void gst_hls_demux_stop_update (GstHLSDemux * demux);
-static gboolean gst_hls_demux_start_update (GstHLSDemux * demux);
 static gboolean gst_hls_demux_cache_fragments (GstHLSDemux * demux);
 static gboolean gst_hls_demux_schedule (GstHLSDemux * demux);
 static gboolean gst_hls_demux_switch_playlist (GstHLSDemux * demux);
-static gboolean gst_hls_demux_get_next_fragment (GstHLSDemux * demux);
+static gboolean gst_hls_demux_get_next_fragment (GstHLSDemux * demux,
+    gboolean caching);
 static gboolean gst_hls_demux_update_playlist (GstHLSDemux * demux);
 static void gst_hls_demux_reset (GstHLSDemux * demux, gboolean dispose);
 static gboolean gst_hls_demux_set_location (GstHLSDemux * demux,
     const gchar * uri);
-static gchar *gst_hls_src_buf_to_utf8_playlist (gchar * string, guint size);
+static gchar *gst_hls_src_buf_to_utf8_playlist (GstBuffer * buf);
 
 static void
 _do_init (GType type)
@@ -149,23 +140,37 @@ gst_hls_demux_dispose (GObject * obj)
 {
   GstHLSDemux *demux = GST_HLS_DEMUX (obj);
 
-  g_cond_free (demux->fetcher_cond);
-  g_mutex_free (demux->fetcher_lock);
-
-  g_cond_free (demux->thread_cond);
-  g_mutex_free (demux->thread_lock);
+  if (demux->stream_task) {
+    if (GST_TASK_STATE (demux->stream_task) != GST_TASK_STOPPED) {
+      GST_DEBUG_OBJECT (demux, "Leaving streaming task");
+      gst_task_stop (demux->stream_task);
+      gst_task_join (demux->stream_task);
+    }
+    gst_object_unref (demux->stream_task);
+    g_static_rec_mutex_free (&demux->stream_lock);
+    demux->stream_task = NULL;
+  }
 
-  gst_task_join (demux->task);
-  gst_object_unref (demux->task);
-  g_static_rec_mutex_free (&demux->task_lock);
+  if (demux->updates_task) {
+    if (GST_TASK_STATE (demux->updates_task) != GST_TASK_STOPPED) {
+      GST_DEBUG_OBJECT (demux, "Leaving updates task");
+      gst_task_stop (demux->updates_task);
+      gst_task_join (demux->updates_task);
+    }
+    gst_object_unref (demux->updates_task);
+    g_mutex_free (demux->updates_timed_lock);
+    g_static_rec_mutex_free (&demux->updates_lock);
+    demux->updates_task = NULL;
+  }
 
-  gst_object_unref (demux->fetcher_bus);
-  gst_object_unref (demux->fetcherpad);
+  if (demux->downloader != NULL) {
+    g_object_unref (demux->downloader);
+    demux->downloader = NULL;
+  }
 
   gst_hls_demux_reset (demux, TRUE);
 
   g_queue_free (demux->queue);
-  gst_object_unref (demux->download);
 
   G_OBJECT_CLASS (parent_class)->dispose (obj);
 }
@@ -212,15 +217,8 @@ gst_hls_demux_init (GstHLSDemux * demux, GstHLSDemuxClass * klass)
       GST_DEBUG_FUNCPTR (gst_hls_demux_sink_event));
   gst_element_add_pad (GST_ELEMENT (demux), demux->sinkpad);
 
-  /* fetcher pad */
-  demux->fetcherpad =
-      gst_pad_new_from_static_template (&fetchertemplate, "sink");
-  gst_pad_set_chain_function (demux->fetcherpad,
-      GST_DEBUG_FUNCPTR (gst_hls_demux_fetcher_chain));
-  gst_pad_set_event_function (demux->fetcherpad,
-      GST_DEBUG_FUNCPTR (gst_hls_demux_fetcher_sink_event));
-  gst_pad_set_element_private (demux->fetcherpad, demux);
-  gst_pad_activate_push (demux->fetcherpad, TRUE);
+  /* Downloader */
+  demux->downloader = gst_uri_downloader_new ();
 
   demux->do_typefind = TRUE;
 
@@ -228,19 +226,20 @@ gst_hls_demux_init (GstHLSDemux * demux, GstHLSDemuxClass * klass)
   demux->fragments_cache = DEFAULT_FRAGMENTS_CACHE;
   demux->bitrate_switch_tol = DEFAULT_BITRATE_SWITCH_TOLERANCE;
 
-  demux->download = gst_adapter_new ();
-  demux->fetcher_bus = gst_bus_new ();
-  gst_bus_set_sync_handler (demux->fetcher_bus,
-      gst_hls_demux_fetcher_bus_handler, demux);
-  demux->thread_cond = g_cond_new ();
-  demux->thread_lock = g_mutex_new ();
-  demux->fetcher_cond = g_cond_new ();
-  demux->fetcher_lock = g_mutex_new ();
   demux->queue = g_queue_new ();
-  g_static_rec_mutex_init (&demux->task_lock);
-  /* FIXME: This really should be a pad task instead */
-  demux->task = gst_task_create ((GstTaskFunction) gst_hls_demux_loop, demux);
-  gst_task_set_lock (demux->task, &demux->task_lock);
+
+  /* Updates task */
+  g_static_rec_mutex_init (&demux->updates_lock);
+  demux->updates_task =
+      gst_task_create ((GstTaskFunction) gst_hls_demux_updates_loop, demux);
+  gst_task_set_lock (demux->updates_task, &demux->updates_lock);
+  demux->updates_timed_lock = g_mutex_new ();
+
+  /* Streaming task */
+  g_static_rec_mutex_init (&demux->stream_lock);
+  demux->stream_task =
+      gst_task_create ((GstTaskFunction) gst_hls_demux_stream_loop, demux);
+  gst_task_set_lock (demux->stream_task, &demux->stream_lock);
 }
 
 static void
@@ -297,7 +296,7 @@ gst_hls_demux_change_state (GstElement * element, GstStateChange transition)
          state and we filled our queue with enough cached fragments
        */
       if (gst_m3u8_client_get_uri (demux->client)[0] != '\0')
-        gst_hls_demux_start_update (demux);
+        gst_task_start (demux->updates_task);
       break;
     default:
       break;
@@ -307,12 +306,12 @@ gst_hls_demux_change_state (GstElement * element, GstStateChange transition)
 
   switch (transition) {
     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
-      gst_hls_demux_stop_update (demux);
+      gst_task_stop (demux->updates_task);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
       demux->cancelled = TRUE;
       gst_hls_demux_stop (demux);
-      gst_task_join (demux->task);
+      gst_task_join (demux->stream_task);
       gst_hls_demux_reset (demux, FALSE);
       break;
     default:
@@ -337,9 +336,8 @@ gst_hls_demux_src_event (GstPad * pad, GstEvent * event)
       GstSeekType start_type, stop_type;
       gint64 start, stop;
       GList *walk;
-      gint current_pos;
+      GstClockTime current_pos, target_pos;
       gint current_sequence;
-      gint target_second;
       GstM3U8MediaFile *file;
 
       GST_INFO_OBJECT (demux, "Received GST_EVENT_SEEK");
@@ -363,14 +361,13 @@ gst_hls_demux_src_event (GstPad * pad, GstEvent * event)
       file = GST_M3U8_MEDIA_FILE (demux->client->current->files->data);
       current_sequence = file->sequence;
       current_pos = 0;
-      target_second = start / GST_SECOND;
-      GST_DEBUG_OBJECT (demux, "Target seek to %d", target_second);
+      target_pos = (GstClockTime) start;
       for (walk = demux->client->current->files; walk; walk = walk->next) {
         file = walk->data;
 
         current_sequence = file->sequence;
-        if (current_pos <= target_second
-            && target_second < current_pos + file->duration) {
+        if (current_pos <= target_pos
+            && target_pos < current_pos + file->duration) {
           break;
         }
         current_pos += file->duration;
@@ -388,23 +385,20 @@ gst_hls_demux_src_event (GstPad * pad, GstEvent * event)
       }
 
       demux->cancelled = TRUE;
-      gst_task_pause (demux->task);
-      g_mutex_lock (demux->fetcher_lock);
-      gst_hls_demux_stop_fetcher_locked (demux, TRUE);
-      g_mutex_unlock (demux->fetcher_lock);
-      gst_hls_demux_stop_update (demux);
-      gst_task_pause (demux->task);
+      gst_task_pause (demux->stream_task);
+      gst_uri_downloader_cancel (demux->downloader);
+      gst_task_stop (demux->updates_task);
+      gst_task_pause (demux->stream_task);
 
       /* wait for streaming to finish */
-      g_static_rec_mutex_lock (&demux->task_lock);
+      g_static_rec_mutex_lock (&demux->stream_lock);
 
       demux->need_cache = TRUE;
       while (!g_queue_is_empty (demux->queue)) {
-        GstBuffer *buf = g_queue_pop_head (demux->queue);
-        gst_buffer_unref (buf);
+        GstBufferList *buf_list = g_queue_pop_head (demux->queue);
+        gst_buffer_list_unref (buf_list);
       }
       g_queue_clear (demux->queue);
-      gst_adapter_clear (demux->download);
 
       GST_M3U8_CLIENT_LOCK (demux->client);
       GST_DEBUG_OBJECT (demux, "seeking to sequence %d", current_sequence);
@@ -421,8 +415,8 @@ gst_hls_demux_src_event (GstPad * pad, GstEvent * event)
       }
 
       demux->cancelled = FALSE;
-      gst_task_start (demux->task);
-      g_static_rec_mutex_unlock (&demux->task_lock);
+      gst_task_start (demux->stream_task);
+      g_static_rec_mutex_unlock (&demux->stream_lock);
 
       return TRUE;
     }
@@ -463,9 +457,7 @@ gst_hls_demux_sink_event (GstPad * pad, GstEvent * event)
       }
       gst_query_unref (query);
 
-      playlist = gst_hls_src_buf_to_utf8_playlist ((gchar *)
-          GST_BUFFER_DATA (demux->playlist), GST_BUFFER_SIZE (demux->playlist));
-      gst_buffer_unref (demux->playlist);
+      playlist = gst_hls_src_buf_to_utf8_playlist (demux->playlist);
       demux->playlist = NULL;
       if (playlist == NULL) {
         GST_WARNING_OBJECT (demux, "Error validating first playlist.");
@@ -485,7 +477,7 @@ gst_hls_demux_sink_event (GstPad * pad, GstEvent * event)
         return FALSE;
       }
 
-      gst_task_start (demux->task);
+      gst_task_start (demux->stream_task);
       gst_event_unref (event);
       return TRUE;
     }
@@ -568,27 +560,6 @@ gst_hls_demux_src_query (GstPad * pad, GstQuery * query)
   return ret;
 }
 
-static gboolean
-gst_hls_demux_fetcher_sink_event (GstPad * pad, GstEvent * event)
-{
-  GstHLSDemux *demux = GST_HLS_DEMUX (gst_pad_get_element_private (pad));
-
-  switch (event->type) {
-    case GST_EVENT_EOS:{
-      GST_DEBUG_OBJECT (demux, "Got EOS on the fetcher pad");
-      /* signal we have fetched the URI */
-      if (!demux->cancelled) {
-        g_cond_broadcast (demux->fetcher_cond);
-      }
-    }
-    default:
-      break;
-  }
-
-  gst_event_unref (event);
-  return FALSE;
-}
-
 static GstFlowReturn
 gst_hls_demux_chain (GstPad * pad, GstBuffer * buf)
 {
@@ -604,72 +575,19 @@ gst_hls_demux_chain (GstPad * pad, GstBuffer * buf)
   return GST_FLOW_OK;
 }
 
-static GstFlowReturn
-gst_hls_demux_fetcher_chain (GstPad * pad, GstBuffer * buf)
-{
-  GstHLSDemux *demux = GST_HLS_DEMUX (gst_pad_get_element_private (pad));
-
-  /* The source element can be an http source element. In case we get a 404,
-   * the html response will be sent downstream and the adapter
-   * will not be null, which might make us think that the request proceed
-   * successfully. But it will also post an error message in the bus that
-   * is handled synchronously and that will set demux->fetcher_error to TRUE,
-   * which is used to discard this buffer with the html response. */
-  if (demux->fetcher_error) {
-    goto done;
-  }
-
-  gst_adapter_push (demux->download, buf);
-
-done:
-  {
-    return GST_FLOW_OK;
-  }
-}
-
 static void
-gst_hls_demux_stop_fetcher_locked (GstHLSDemux * demux, gboolean cancelled)
+gst_hls_demux_stop (GstHLSDemux * demux)
 {
-  GstPad *pad;
-
-  /* When the fetcher is stopped while it's downloading, we will get an EOS that
-   * unblocks the fetcher thread and tries to stop it again from that thread.
-   * Here we check if the fetcher as already been stopped before continuing */
-  if (demux->fetcher == NULL || demux->stopping_fetcher)
-    return;
-
-  GST_DEBUG_OBJECT (demux, "Stopping fetcher.");
-  demux->stopping_fetcher = TRUE;
-  /* set the element state to NULL */
-  gst_element_set_state (demux->fetcher, GST_STATE_NULL);
-  gst_element_get_state (demux->fetcher, NULL, NULL, GST_CLOCK_TIME_NONE);
-  /* unlink it from the internal pad */
-  pad = gst_pad_get_peer (demux->fetcherpad);
-  if (pad) {
-    gst_pad_unlink (pad, demux->fetcherpad);
-    gst_object_unref (pad);
-  }
-  /* and finally unref it */
-  gst_object_unref (demux->fetcher);
-  demux->fetcher = NULL;
+  gst_uri_downloader_cancel (demux->downloader);
 
-  /* if we stopped it to cancell a download, free the cached buffer */
-  if (cancelled && gst_adapter_available (demux->download)) {
-    gst_adapter_clear (demux->download);
+  if (GST_TASK_STATE (demux->updates_task) != GST_TASK_STOPPED) {
+    demux->stop_stream_task = TRUE;
+    gst_task_stop (demux->updates_task);
+    GST_TASK_SIGNAL (demux->updates_task);
   }
-  /* signal the fetcher thread that the download has finished/cancelled */
-  if (cancelled)
-    g_cond_broadcast (demux->fetcher_cond);
-}
 
-static void
-gst_hls_demux_stop (GstHLSDemux * demux)
-{
-  g_mutex_lock (demux->fetcher_lock);
-  gst_hls_demux_stop_fetcher_locked (demux, TRUE);
-  g_mutex_unlock (demux->fetcher_lock);
-  gst_task_stop (demux->task);
-  gst_hls_demux_stop_update (demux);
+  if (GST_TASK_STATE (demux->stream_task) != GST_TASK_STOPPED)
+    gst_task_stop (demux->stream_task);
 }
 
 static void
@@ -677,7 +595,8 @@ switch_pads (GstHLSDemux * demux, GstCaps * newcaps)
 {
   GstPad *oldpad = demux->srcpad;
 
-  GST_DEBUG ("Switching pads (oldpad:%p)", oldpad);
+  GST_DEBUG ("Switching pads (oldpad:%p) with caps: %" GST_PTR_FORMAT, oldpad,
+      newcaps);
 
   /* FIXME: This is a workaround for a bug in playsink.
    * If we're switching from an audio-only or video-only fragment
@@ -713,8 +632,9 @@ switch_pads (GstHLSDemux * demux, GstCaps * newcaps)
 }
 
 static void
-gst_hls_demux_loop (GstHLSDemux * demux)
+gst_hls_demux_stream_loop (GstHLSDemux * demux)
 {
+  GstBufferList *buffer_list;
   GstBuffer *buf;
   GstFlowReturn ret;
 
@@ -730,7 +650,7 @@ gst_hls_demux_loop (GstHLSDemux * demux)
 
     /* we can start now the updates thread (only if on playing) */
     if (GST_STATE (demux) == GST_STATE_PLAYING)
-      gst_hls_demux_start_update (demux);
+      gst_task_start (demux->updates_task);
     GST_INFO_OBJECT (demux, "First fragments cached successfully");
   }
 
@@ -741,8 +661,9 @@ gst_hls_demux_loop (GstHLSDemux * demux)
     goto pause_task;
   }
 
-  buf = g_queue_pop_head (demux->queue);
-
+  buffer_list = g_queue_pop_head (demux->queue);
+  /* Work with the first buffer of the list */
+  buf = gst_buffer_list_get (buffer_list, 0, 0);
   /* Figure out if we need to create/switch pads */
   if (G_UNLIKELY (!demux->srcpad
           || GST_BUFFER_CAPS (buf) != GST_PAD_CAPS (demux->srcpad)
@@ -765,9 +686,9 @@ gst_hls_demux_loop (GstHLSDemux * demux)
   if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_DURATION (buf)))
     demux->position += GST_BUFFER_DURATION (buf);
 
-  ret = gst_pad_push (demux->srcpad, buf);
+  ret = gst_pad_push_list (demux->srcpad, buffer_list);
   if (ret != GST_FLOW_OK)
-    goto error;
+    goto error_pushing;
 
   return;
 
@@ -781,7 +702,7 @@ end_of_playlist:
 
 cache_error:
   {
-    gst_task_pause (demux->task);
+    gst_task_pause (demux->stream_task);
     if (!demux->cancelled) {
       GST_ELEMENT_ERROR (demux, RESOURCE, NOT_FOUND,
           ("Could not cache the first fragments"), (NULL));
@@ -790,71 +711,26 @@ cache_error:
     return;
   }
 
-error:
+error_pushing:
   {
     /* FIXME: handle error */
-    GST_DEBUG_OBJECT (demux, "error, stopping task");
+    GST_DEBUG_OBJECT (demux, "Error pushing buffer: %s... stopping task",
+        gst_flow_get_name (ret));
     gst_hls_demux_stop (demux);
     return;
   }
 
 pause_task:
   {
-    gst_task_pause (demux->task);
+    gst_task_pause (demux->stream_task);
     return;
   }
 }
 
-static GstBusSyncReply
-gst_hls_demux_fetcher_bus_handler (GstBus * bus,
-    GstMessage * message, gpointer data)
-{
-  GstHLSDemux *demux = GST_HLS_DEMUX (data);
-
-  if (GST_MESSAGE_TYPE (message) == GST_MESSAGE_ERROR) {
-    demux->fetcher_error = TRUE;
-    if (!demux->cancelled) {
-      g_mutex_lock (demux->fetcher_lock);
-      g_cond_broadcast (demux->fetcher_cond);
-      g_mutex_unlock (demux->fetcher_lock);
-    }
-  }
-
-  gst_message_unref (message);
-  return GST_BUS_DROP;
-}
-
-static gboolean
-gst_hls_demux_make_fetcher_locked (GstHLSDemux * demux, const gchar * uri)
-{
-  GstPad *pad;
-
-  if (!gst_uri_is_valid (uri))
-    return FALSE;
-
-  GST_DEBUG_OBJECT (demux, "Creating fetcher for the URI:%s", uri);
-  demux->fetcher = gst_element_make_from_uri (GST_URI_SRC, uri, NULL);
-  if (!demux->fetcher)
-    return FALSE;
-
-  demux->fetcher_error = FALSE;
-  demux->stopping_fetcher = FALSE;
-  gst_element_set_bus (GST_ELEMENT (demux->fetcher), demux->fetcher_bus);
-
-  g_object_set (G_OBJECT (demux->fetcher), "location", uri, NULL);
-  pad = gst_element_get_static_pad (demux->fetcher, "src");
-  if (pad) {
-    gst_pad_link (pad, demux->fetcherpad);
-    gst_object_unref (pad);
-  }
-  return TRUE;
-}
-
 static void
 gst_hls_demux_reset (GstHLSDemux * demux, gboolean dispose)
 {
   demux->need_cache = TRUE;
-  demux->thread_return = FALSE;
   demux->accumulated_delay = 0;
   demux->end_of_playlist = FALSE;
   demux->cancelled = FALSE;
@@ -870,8 +746,6 @@ gst_hls_demux_reset (GstHLSDemux * demux, gboolean dispose)
     demux->playlist = NULL;
   }
 
-  gst_adapter_clear (demux->download);
-
   if (demux->client) {
     gst_m3u8_client_free (demux->client);
     demux->client = NULL;
@@ -882,8 +756,8 @@ gst_hls_demux_reset (GstHLSDemux * demux, gboolean dispose)
   }
 
   while (!g_queue_is_empty (demux->queue)) {
-    GstBuffer *buf = g_queue_pop_head (demux->queue);
-    gst_buffer_unref (buf);
+    GstBufferList *buffer_list = g_queue_pop_head (demux->queue);
+    gst_buffer_list_unref (buffer_list);
   }
   g_queue_clear (demux->queue);
 
@@ -902,8 +776,8 @@ gst_hls_demux_set_location (GstHLSDemux * demux, const gchar * uri)
   return TRUE;
 }
 
-static gboolean
-gst_hls_demux_update_thread (GstHLSDemux * demux)
+void
+gst_hls_demux_updates_loop (GstHLSDemux * demux)
 {
   /* Loop for the updates. It's started when the first fragments are cached and
    * schedules the next update of the playlist (for lives sources) and the next
@@ -911,15 +785,14 @@ gst_hls_demux_update_thread (GstHLSDemux * demux)
    * download time with the next scheduled update to check if we can or should
    * switch to a different bitrate */
 
-  g_mutex_lock (demux->thread_lock);
-  GST_DEBUG_OBJECT (demux, "Started updates thread");
+  /* block until the next scheduled update or the signal to quit this thread */
+  g_mutex_lock (demux->updates_timed_lock);
+  GST_DEBUG_OBJECT (demux, "Started updates task");
   while (TRUE) {
-    /* block until the next scheduled update or the signal to quit this thread */
-    if (g_cond_timed_wait (demux->thread_cond, demux->thread_lock,
-            &demux->next_update)) {
+    if (g_cond_timed_wait (GST_TASK_GET_COND (demux->updates_task),
+            demux->updates_timed_lock, &demux->next_update)) {
       goto quit;
     }
-
     /* update the playlist for live sources */
     if (gst_m3u8_client_is_live (demux->client)) {
       if (!gst_hls_demux_update_playlist (demux)) {
@@ -952,7 +825,7 @@ gst_hls_demux_update_thread (GstHLSDemux * demux)
 
     /* fetch the next fragment */
     if (g_queue_is_empty (demux->queue)) {
-      if (!gst_hls_demux_get_next_fragment (demux)) {
+      if (!gst_hls_demux_get_next_fragment (demux, FALSE)) {
         if (!demux->end_of_playlist && !demux->cancelled) {
           demux->client->update_failed_count++;
           if (demux->client->update_failed_count < DEFAULT_FAILED_COUNT) {
@@ -975,39 +848,10 @@ gst_hls_demux_update_thread (GstHLSDemux * demux)
 
 quit:
   {
-    GST_DEBUG_OBJECT (demux, "Stopped updates thread");
-    demux->updates_thread = NULL;
-    g_mutex_unlock (demux->thread_lock);
-    return TRUE;
-  }
-}
-
-
-static void
-gst_hls_demux_stop_update (GstHLSDemux * demux)
-{
-  GST_DEBUG_OBJECT (demux, "Stopping updates thread");
-  while (demux->updates_thread) {
-    g_mutex_lock (demux->thread_lock);
-    g_cond_signal (demux->thread_cond);
-    g_mutex_unlock (demux->thread_lock);
-  }
-}
-
-static gboolean
-gst_hls_demux_start_update (GstHLSDemux * demux)
-{
-  GError *error;
-
-  /* creates a new thread for the updates */
-  g_mutex_lock (demux->thread_lock);
-  if (demux->updates_thread == NULL) {
-    GST_DEBUG_OBJECT (demux, "Starting updates thread");
-    demux->updates_thread = g_thread_create (
-        (GThreadFunc) gst_hls_demux_update_thread, demux, FALSE, &error);
+    GST_DEBUG_OBJECT (demux, "Stopped updates task");
+    gst_hls_demux_stop (demux);
+    g_mutex_unlock (demux->updates_timed_lock);
   }
-  g_mutex_unlock (demux->thread_lock);
-  return (error != NULL);
 }
 
 static gboolean
@@ -1062,7 +906,9 @@ gst_hls_demux_cache_fragments (GstHLSDemux * demux)
     g_time_val_add (&demux->next_update,
         gst_m3u8_client_get_target_duration (demux->client)
         / GST_SECOND * G_USEC_PER_SEC);
-    if (!gst_hls_demux_get_next_fragment (demux)) {
+    if (!gst_hls_demux_get_next_fragment (demux, TRUE)) {
+      if (demux->end_of_playlist)
+        break;
       if (!demux->cancelled)
         GST_ERROR_OBJECT (demux, "Error caching the first fragments");
       return FALSE;
@@ -1079,98 +925,58 @@ gst_hls_demux_cache_fragments (GstHLSDemux * demux)
 
   demux->need_cache = FALSE;
   return TRUE;
-}
-
-static gboolean
-gst_hls_demux_fetch_location (GstHLSDemux * demux, const gchar * uri)
-{
-  GstStateChangeReturn ret;
-  gboolean bret = FALSE;
-
-  g_mutex_lock (demux->fetcher_lock);
-
-  while (demux->fetcher)
-    g_cond_wait (demux->fetcher_cond, demux->fetcher_lock);
-
-  if (demux->cancelled)
-    goto quit;
-
-  if (!gst_hls_demux_make_fetcher_locked (demux, uri)) {
-    goto uri_error;
-  }
-
-  ret = gst_element_set_state (demux->fetcher, GST_STATE_PLAYING);
-  if (ret == GST_STATE_CHANGE_FAILURE)
-    goto state_change_error;
-
-  /* wait until we have fetched the uri */
-  GST_DEBUG_OBJECT (demux, "Waiting to fetch the URI");
-  g_cond_wait (demux->fetcher_cond, demux->fetcher_lock);
-
-  gst_hls_demux_stop_fetcher_locked (demux, FALSE);
-
-  if (!demux->fetcher_error && gst_adapter_available (demux->download)) {
-    GST_INFO_OBJECT (demux, "URI fetched successfully");
-    bret = TRUE;
-  }
-  goto quit;
 
-uri_error:
-  {
-    GST_ELEMENT_ERROR (demux, RESOURCE, OPEN_READ,
-        ("Could not create an element to fetch the given URI."), ("URI: \"%s\"",
-            uri));
-    bret = FALSE;
-    goto quit;
-  }
-
-state_change_error:
-  {
-    GST_ELEMENT_ERROR (demux, CORE, STATE_CHANGE,
-        ("Error changing state of the fetcher element."), (NULL));
-    bret = FALSE;
-    goto quit;
-  }
-
-quit:
-  {
-    /* Unlock any other fetcher that might be waiting */
-    g_cond_broadcast (demux->fetcher_cond);
-    g_mutex_unlock (demux->fetcher_lock);
-    return bret;
-  }
 }
 
 static gchar *
-gst_hls_src_buf_to_utf8_playlist (gchar * data, guint size)
+gst_hls_src_buf_to_utf8_playlist (GstBuffer * buf)
 {
+  gint size;
+  gchar *data;
   gchar *playlist;
 
+  data = (gchar *) GST_BUFFER_DATA (buf);
+  size = GST_BUFFER_SIZE (buf);
+
   if (!g_utf8_validate (data, size, NULL))
     return NULL;
 
   /* alloc size + 1 to end with a null character */
   playlist = g_malloc0 (size + 1);
   memcpy (playlist, data, size + 1);
+
+  gst_buffer_unref (buf);
   return playlist;
 }
 
 static gboolean
 gst_hls_demux_update_playlist (GstHLSDemux * demux)
 {
-  const guint8 *data;
+  GstFragment *download;
+  GstBufferListIterator *it;
+  GstBuffer *buf;
   gchar *playlist;
-  guint avail;
+
   const gchar *uri = gst_m3u8_client_get_current_uri (demux->client);
 
-  GST_INFO_OBJECT (demux, "Updating the playlist %s", uri);
-  if (!gst_hls_demux_fetch_location (demux, uri))
+  download = gst_uri_downloader_fetch_uri (demux->downloader, uri);
+
+  if (download == NULL)
     return FALSE;
 
-  avail = gst_adapter_available (demux->download);
-  data = gst_adapter_peek (demux->download, avail);
-  playlist = gst_hls_src_buf_to_utf8_playlist ((gchar *) data, avail);
-  gst_adapter_clear (demux->download);
+  /* Merge all the buffers in the list to build a unique buffer with the
+   * playlist */
+  it = gst_buffer_list_iterate (gst_fragment_get_buffer_list (download));
+
+  /* skip the first group, which contains the headers, which are not set in the
+   * demuxer*/
+  gst_buffer_list_iterator_next_group (it);
+  buf = gst_buffer_list_iterator_merge_group (it);
+
+  playlist = gst_hls_src_buf_to_utf8_playlist (buf);
+  gst_buffer_list_iterator_free (it);
+  g_object_unref (download);
+
   if (playlist == NULL) {
     GST_WARNING_OBJECT (demux, "Couldn't not validate playlist encoding");
     return FALSE;
@@ -1298,37 +1104,34 @@ gst_hls_demux_switch_playlist (GstHLSDemux * demux)
 }
 
 static gboolean
-gst_hls_demux_get_next_fragment (GstHLSDemux * demux)
+gst_hls_demux_get_next_fragment (GstHLSDemux * demux, gboolean caching)
 {
-  GstBuffer *buf;
-  guint avail;
+  GstFragment *download;
   const gchar *next_fragment_uri;
   GstClockTime duration;
   GstClockTime timestamp;
+  GstBufferList *buffer_list;
+  GstBuffer *buf;
   gboolean discont;
 
   if (!gst_m3u8_client_get_next_fragment (demux->client, &discont,
           &next_fragment_uri, &duration, &timestamp)) {
     GST_INFO_OBJECT (demux, "This playlist doesn't contain more fragments");
     demux->end_of_playlist = TRUE;
-    gst_task_start (demux->task);
+    gst_task_start (demux->stream_task);
     return FALSE;
   }
 
   GST_INFO_OBJECT (demux, "Fetching next fragment %s", next_fragment_uri);
 
-  if (!gst_hls_demux_fetch_location (demux, next_fragment_uri)) {
-    /* FIXME: The gst_m3u8_get_next_fragment increments the sequence number
-       but another thread might call get_next_fragment and this decrement
-       will not redownload the failed fragment, but might duplicate the
-       download of a succeeded fragment
-     */
-    g_atomic_int_add (&demux->client->sequence, -1);
-    return FALSE;
-  }
+  download = gst_uri_downloader_fetch_uri (demux->downloader,
+      next_fragment_uri);
+
+  if (download == NULL)
+    goto error;
 
-  avail = gst_adapter_available (demux->download);
-  buf = gst_adapter_take_buffer (demux->download, avail);
+  buffer_list = gst_fragment_get_buffer_list (download);
+  buf = gst_buffer_list_get (buffer_list, 0, 0);
   GST_BUFFER_DURATION (buf) = duration;
   GST_BUFFER_TIMESTAMP (buf) = timestamp;
 
@@ -1352,8 +1155,17 @@ gst_hls_demux_get_next_fragment (GstHLSDemux * demux)
     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
   }
 
-  g_queue_push_tail (demux->queue, buf);
-  gst_task_start (demux->task);
-  gst_adapter_clear (demux->download);
+  g_queue_push_tail (demux->queue, buffer_list);
+  g_object_unref (download);
+  if (!caching) {
+    GST_TASK_SIGNAL (demux->updates_task);
+  }
+
   return TRUE;
+
+error:
+  {
+    gst_hls_demux_stop (demux);
+    return FALSE;
+  }
 }
diff --git a/gst/hls/gsthlsdemux.h b/gst/hls/gsthlsdemux.h
index a09a88b..16c8677 100644
--- a/gst/hls/gsthlsdemux.h
+++ b/gst/hls/gsthlsdemux.h
@@ -27,6 +27,8 @@
 #include <gst/gst.h>
 #include <gst/base/gstadapter.h>
 #include "m3u8.h"
+#include "gstfragmented.h"
+#include "gsturidownloader.h"
 
 G_BEGIN_DECLS
 #define GST_TYPE_HLS_DEMUX \
@@ -51,12 +53,12 @@ struct _GstHLSDemux
 {
   GstElement parent;
 
-  GstTask *task;
-  GStaticRecMutex task_lock;
   GstPad *srcpad;
   GstPad *sinkpad;
+
   GstBuffer *playlist;
   GstCaps *input_caps;
+  GstUriDownloader *downloader;
   GstM3U8Client *client;        /* M3U8 client */
   GQueue *queue;                /* Queue storing the fetched fragments */
   gboolean need_cache;          /* Wheter we need to cache some fragments before starting to push data */
@@ -67,25 +69,18 @@ struct _GstHLSDemux
   guint fragments_cache;        /* number of fragments needed to be cached to start playing */
   gfloat bitrate_switch_tol;    /* tolerance with respect to the fragment duration to switch the bitarate*/
 
-  /* Updates thread */
-  GThread *updates_thread;      /* Thread handling the playlist and fragments updates */
-  GMutex *thread_lock;          /* Thread lock */
-  GCond *thread_cond;           /* Signals the thread to quit */
-  gboolean thread_return;       /* Instructs the thread to return after the thread_quit condition is meet */
+  /* Streaming task */
+  GstTask *stream_task;
+  GStaticRecMutex stream_lock;
+  gboolean stop_stream_task;
+
+  /* Updates task */
+  GstTask *updates_task;
+  GStaticRecMutex updates_lock;
+  GMutex *updates_timed_lock;
   GTimeVal next_update;         /* Time of the next update */
   gint64 accumulated_delay;     /* Delay accumulated fetching fragments, used to decide a playlist switch */
-
-  /* Fragments fetcher */
-  GstElement *fetcher;
-  GstBus *fetcher_bus;
-  GstPad *fetcherpad;
-  GMutex *fetcher_lock;
-  GCond *fetcher_cond;
-  GTimeVal *timeout;
-  gboolean fetcher_error;
-  gboolean stopping_fetcher;
   gboolean cancelled;
-  GstAdapter *download;
 
   /* Position in the stream */
   GstClockTime position;
diff --git a/gst/hls/gsturidownloader.c b/gst/hls/gsturidownloader.c
new file mode 100644
index 0000000..e208efe
--- /dev/null
+++ b/gst/hls/gsturidownloader.c
@@ -0,0 +1,347 @@
+/* GStreamer
+ * Copyright (C) 2011 Andoni Morales Alastruey <ylatuya@gmail.com>
+ *
+ * gstfragment.c:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <glib.h>
+#include "gstfragmented.h"
+#include "gstfragment.h"
+#include "gsturidownloader.h"
+
+GST_DEBUG_CATEGORY_STATIC (uridownloader_debug);
+#define GST_CAT_DEFAULT (uridownloader_debug)
+
+#define GST_URI_DOWNLOADER_GET_PRIVATE(obj)  \
+   (G_TYPE_INSTANCE_GET_PRIVATE ((obj), \
+    GST_TYPE_URI_DOWNLOADER, GstUriDownloaderPrivate))
+
+struct _GstUriDownloaderPrivate
+{
+  /* Fragments fetcher */
+  GstElement *urisrc;
+  GstBus *bus;
+  GstPad *pad;
+  GTimeVal *timeout;
+  GstFragment *download;
+  GMutex *lock;
+  GCond *cond;
+};
+
+static void gst_uri_downloader_finalize (GObject * object);
+static void gst_uri_downloader_dispose (GObject * object);
+
+static GstFlowReturn gst_uri_downloader_chain (GstPad * pad, GstBuffer * buf);
+static gboolean gst_uri_downloader_sink_event (GstPad * pad, GstEvent * event);
+static GstBusSyncReply gst_uri_downloader_bus_handler (GstBus * bus,
+    GstMessage * message, gpointer data);
+
+static GstStaticPadTemplate sinkpadtemplate = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+#define _do_init \
+{ \
+  GST_DEBUG_CATEGORY_INIT (uridownloader_debug, "uridownloader", 0, "URI downloader"); \
+}
+
+G_DEFINE_TYPE_WITH_CODE (GstUriDownloader, gst_uri_downloader, GST_TYPE_OBJECT,
+    _do_init);
+
+static void
+gst_uri_downloader_class_init (GstUriDownloaderClass * klass)
+{
+  GObjectClass *gobject_class;
+
+  gobject_class = (GObjectClass *) klass;
+
+  g_type_class_add_private (klass, sizeof (GstUriDownloaderPrivate));
+
+  gobject_class->dispose = gst_uri_downloader_dispose;
+  gobject_class->finalize = gst_uri_downloader_finalize;
+}
+
+static void
+gst_uri_downloader_init (GstUriDownloader * downloader)
+{
+  downloader->priv = GST_URI_DOWNLOADER_GET_PRIVATE (downloader);
+
+  /* Initialize the sink pad. This pad will be connected to the src pad of the
+   * element created with gst_element_make_from_uri and will handle the download */
+  downloader->priv->pad =
+      gst_pad_new_from_static_template (&sinkpadtemplate, "sink");
+  gst_pad_set_chain_function (downloader->priv->pad,
+      GST_DEBUG_FUNCPTR (gst_uri_downloader_chain));
+  gst_pad_set_event_function (downloader->priv->pad,
+      GST_DEBUG_FUNCPTR (gst_uri_downloader_sink_event));
+  gst_pad_set_element_private (downloader->priv->pad, downloader);
+  gst_pad_activate_push (downloader->priv->pad, TRUE);
+
+  /* Create a bus to handle error and warning message from the source element */
+  downloader->priv->bus = gst_bus_new ();
+
+  downloader->priv->lock = g_mutex_new ();
+  downloader->priv->cond = g_cond_new ();
+}
+
+static void
+gst_uri_downloader_dispose (GObject * object)
+{
+  GstUriDownloader *downloader = GST_URI_DOWNLOADER (object);
+
+  if (downloader->priv->urisrc != NULL) {
+    gst_object_unref (downloader->priv->urisrc);
+    downloader->priv->urisrc = NULL;
+  }
+
+  if (downloader->priv->bus != NULL) {
+    gst_object_unref (downloader->priv->bus);
+    downloader->priv->bus = NULL;
+  }
+
+  if (downloader->priv->pad) {
+    gst_object_unref (downloader->priv->pad);
+    downloader->priv->pad = NULL;
+  }
+
+  if (downloader->priv->download) {
+    g_object_unref (downloader->priv->download);
+    downloader->priv->download = NULL;
+  }
+
+  G_OBJECT_CLASS (gst_uri_downloader_parent_class)->dispose (object);
+}
+
+static void
+gst_uri_downloader_finalize (GObject * object)
+{
+  GstUriDownloader *downloader = GST_URI_DOWNLOADER (object);
+
+  g_mutex_free (downloader->priv->lock);
+  g_cond_free (downloader->priv->cond);
+
+  G_OBJECT_CLASS (gst_uri_downloader_parent_class)->finalize (object);
+}
+
+GstUriDownloader *
+gst_uri_downloader_new (void)
+{
+  return g_object_new (GST_TYPE_URI_DOWNLOADER, NULL);
+}
+
+static gboolean
+gst_uri_downloader_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstUriDownloader *downloader =
+      (GstUriDownloader *) (gst_pad_get_element_private (pad));
+
+  switch (event->type) {
+    case GST_EVENT_EOS:{
+      GST_OBJECT_LOCK (downloader);
+      GST_DEBUG_OBJECT (downloader, "Got EOS on the fetcher pad");
+      if (downloader->priv->download != NULL) {
+        /* signal we have fetched the URI */
+        downloader->priv->download->completed = TRUE;
+        downloader->priv->download->download_stop_time = g_get_real_time ();
+        GST_OBJECT_UNLOCK (downloader);
+        GST_DEBUG_OBJECT (downloader, "Signaling chain funtion");
+        g_cond_signal (downloader->priv->cond);
+
+      } else {
+        GST_OBJECT_UNLOCK (downloader);
+      }
+      break;
+    }
+    default:
+      break;
+  }
+
+  gst_event_unref (event);
+  return FALSE;
+}
+
+static GstBusSyncReply
+gst_uri_downloader_bus_handler (GstBus * bus,
+    GstMessage * message, gpointer data)
+{
+  GstUriDownloader *downloader = (GstUriDownloader *) (data);
+
+  if (GST_MESSAGE_TYPE (message) == GST_MESSAGE_ERROR ||
+      GST_MESSAGE_TYPE (message) == GST_MESSAGE_WARNING) {
+    GError *err = NULL;
+    gchar *dbg_info = NULL;
+
+    gst_message_parse_error (message, &err, &dbg_info);
+    GST_WARNING_OBJECT (downloader,
+        "Received error: %s from %s, the download will be cancelled",
+        GST_OBJECT_NAME (message->src), err->message);
+    GST_DEBUG ("Debugging info: %s\n", (dbg_info) ? dbg_info : "none");
+    g_error_free (err);
+    g_free (dbg_info);
+
+    /* remove the sync handler to avoid duplicated messages */
+    gst_bus_set_sync_handler (downloader->priv->bus, NULL, NULL);
+    gst_uri_downloader_cancel (downloader);
+  }
+
+  gst_message_unref (message);
+  return GST_BUS_DROP;
+}
+
+static GstFlowReturn
+gst_uri_downloader_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstUriDownloader *downloader =
+      (GstUriDownloader *) gst_pad_get_element_private (pad);
+
+  /* HTML errors (404, 500, etc...) are also pushed through this pad as
+   * response but the source element will also post a warning or error message
+   * in the bus, which is handled synchronously cancelling the download.
+   */
+  GST_OBJECT_LOCK (downloader);
+  if (downloader->priv->download == NULL) {
+    /* Download cancelled, quit */
+    GST_OBJECT_UNLOCK (downloader);
+    goto done;
+  }
+
+  GST_LOG_OBJECT (downloader, "The uri fetcher received a new buffer "
+      "of size %u", GST_BUFFER_SIZE (buf));
+  if (!gst_fragment_add_buffer (downloader->priv->download, buf))
+    GST_WARNING_OBJECT (downloader, "Could not add buffer to fragment");
+  GST_OBJECT_UNLOCK (downloader);
+
+done:
+  {
+    return GST_FLOW_OK;
+  }
+}
+
+static void
+gst_uri_downloader_stop (GstUriDownloader * downloader)
+{
+  GstPad *pad;
+
+  GST_DEBUG_OBJECT (downloader, "Stopping source element");
+
+  /* remove the bus' sync handler */
+  gst_bus_set_sync_handler (downloader->priv->bus, NULL, NULL);
+  /* unlink the source element from the internal pad */
+  pad = gst_pad_get_peer (downloader->priv->pad);
+  if (pad) {
+    gst_pad_unlink (pad, downloader->priv->pad);
+    gst_object_unref (pad);
+  }
+  /* set the element state to NULL */
+  gst_element_set_state (downloader->priv->urisrc, GST_STATE_NULL);
+  gst_element_get_state (downloader->priv->urisrc, NULL, NULL,
+      GST_CLOCK_TIME_NONE);
+}
+
+void
+gst_uri_downloader_cancel (GstUriDownloader * downloader)
+{
+  GST_OBJECT_LOCK (downloader);
+  if (downloader->priv->download != NULL) {
+    GST_DEBUG_OBJECT (downloader, "Cancelling download");
+    g_object_unref (downloader->priv->download);
+    downloader->priv->download = NULL;
+    GST_OBJECT_UNLOCK (downloader);
+    GST_DEBUG_OBJECT (downloader, "Signaling chain funtion");
+    g_cond_signal (downloader->priv->cond);
+  } else {
+    GST_OBJECT_UNLOCK (downloader);
+    GST_DEBUG_OBJECT (downloader,
+        "Trying to cancell a download that was alredy cancelled");
+  }
+}
+
+static gboolean
+gst_uri_downloader_set_uri (GstUriDownloader * downloader, const gchar * uri)
+{
+  GstPad *pad;
+
+  if (!gst_uri_is_valid (uri))
+    return FALSE;
+
+  GST_DEBUG_OBJECT (downloader, "Creating source element for the URI:%s", uri);
+  downloader->priv->urisrc = gst_element_make_from_uri (GST_URI_SRC, uri, NULL);
+  if (!downloader->priv->urisrc)
+    return FALSE;
+
+  /* add a sync handler for the bus messages to detect errors in the download */
+  gst_element_set_bus (GST_ELEMENT (downloader->priv->urisrc),
+      downloader->priv->bus);
+  gst_bus_set_sync_handler (downloader->priv->bus,
+      gst_uri_downloader_bus_handler, downloader);
+
+  pad = gst_element_get_static_pad (downloader->priv->urisrc, "src");
+  if (!pad)
+    return FALSE;
+  gst_pad_link (pad, downloader->priv->pad);
+  gst_object_unref (pad);
+  return TRUE;
+}
+
+GstFragment *
+gst_uri_downloader_fetch_uri (GstUriDownloader * downloader, const gchar * uri)
+{
+  GstStateChangeReturn ret;
+  GstFragment *download = NULL;
+
+  g_mutex_lock (downloader->priv->lock);
+
+  if (!gst_uri_downloader_set_uri (downloader, uri)) {
+    goto quit;
+  }
+
+  downloader->priv->download = gst_fragment_new ();
+
+  ret = gst_element_set_state (downloader->priv->urisrc, GST_STATE_PLAYING);
+  if (ret == GST_STATE_CHANGE_FAILURE) {
+    g_object_unref (downloader->priv->download);
+    downloader->priv->download = NULL;
+    goto quit;
+  }
+
+  /* wait until:
+   *   - the download succeed (EOS in the src pad)
+   *   - the download failed (Error message on the fetcher bus)
+   *   - the download was canceled
+   */
+  GST_DEBUG_OBJECT (downloader, "Waiting to fetch the URI");
+  g_cond_wait (downloader->priv->cond, downloader->priv->lock);
+
+  GST_OBJECT_LOCK (downloader);
+  download = downloader->priv->download;
+  downloader->priv->download = NULL;
+  GST_OBJECT_UNLOCK (downloader);
+
+  if (download != NULL)
+    GST_INFO_OBJECT (downloader, "URI fetched successfully");
+  else
+    GST_INFO_OBJECT (downloader, "Error fetching URI");
+
+quit:
+  {
+    gst_uri_downloader_stop (downloader);
+    g_mutex_unlock (downloader->priv->lock);
+    return download;
+  }
+}
diff --git a/gst/hls/gsturidownloader.h b/gst/hls/gsturidownloader.h
new file mode 100644
index 0000000..bfb5157
--- /dev/null
+++ b/gst/hls/gsturidownloader.h
@@ -0,0 +1,64 @@
+/* GStreamer
+ * Copyright (C) 2011 Andoni Morales Alastruey <ylatuya@gmail.com>
+ *
+ * gsturidownloader.h:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * Youshould have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GSTURI_DOWNLOADER_H__
+#define __GSTURI_DOWNLOADER_H__
+
+#include <glib-object.h>
+#include <gst/gst.h>
+#include "gstfragment.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_URI_DOWNLOADER (gst_uri_downloader_get_type())
+#define GST_URI_DOWNLOADER(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_URI_DOWNLOADER,GstUriDownloader))
+#define GST_URI_DOWNLOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_URI_DOWNLOADER,GstUriDownloaderClass))
+#define GST_IS_URI_DOWNLOADER(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_URI_DOWNLOADER))
+#define GST_IS_URI_DOWNLOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_URI_DOWNLOADER))
+
+typedef struct _GstUriDownloader GstUriDownloader;
+typedef struct _GstUriDownloaderPrivate GstUriDownloaderPrivate;
+typedef struct _GstUriDownloaderClass GstUriDownloaderClass;
+
+struct _GstUriDownloader
+{
+  GstObject parent;
+
+  GstUriDownloaderPrivate *priv;
+};
+
+struct _GstUriDownloaderClass
+{
+  GstObjectClass parent_class;
+
+  /*< private >*/
+  gpointer _gst_reserved[GST_PADDING];
+};
+
+GType gst_uri_downloader_get_type (void);
+
+GstUriDownloader * gst_uri_downloader_new (void);
+GstFragment * gst_uri_downloader_fetch_uri (GstUriDownloader * downloader, const gchar * uri);
+void gst_uri_downloader_cancel (GstUriDownloader *downloader);
+void gst_uri_downloader_free (GstUriDownloader *downloader);
+
+G_END_DECLS
+#endif /* __GSTURIDOWNLOADER_H__ */
diff --git a/gst/hls/m3u8.c b/gst/hls/m3u8.c
index 449b63e..eecb467 100644
--- a/gst/hls/m3u8.c
+++ b/gst/hls/m3u8.c
@@ -20,9 +20,11 @@
  */
 
 #include <stdlib.h>
+#include <math.h>
 #include <errno.h>
 #include <glib.h>
 
+#include <gst/glib-compat-private.h>
 #include "gstfragmented.h"
 #include "m3u8.h"
 
@@ -33,7 +35,7 @@ static void gst_m3u8_free (GstM3U8 * m3u8);
 static gboolean gst_m3u8_update (GstM3U8 * m3u8, gchar * data,
     gboolean * updated);
 static GstM3U8MediaFile *gst_m3u8_media_file_new (gchar * uri,
-    gchar * title, gint duration, guint sequence);
+    gchar * title, GstClockTime duration, guint sequence);
 static void gst_m3u8_media_file_free (GstM3U8MediaFile * self);
 
 static GstM3U8 *
@@ -76,7 +78,7 @@ gst_m3u8_free (GstM3U8 * self)
 }
 
 static GstM3U8MediaFile *
-gst_m3u8_media_file_new (gchar * uri, gchar * title, gint duration,
+gst_m3u8_media_file_new (gchar * uri, gchar * title, GstClockTime duration,
     guint sequence)
 {
   GstM3U8MediaFile *file;
@@ -131,6 +133,36 @@ int_from_string (gchar * ptr, gchar ** endptr, gint * val)
 }
 
 static gboolean
+double_from_string (gchar * ptr, gchar ** endptr, gdouble * val)
+{
+  gchar *end;
+  gdouble ret;
+
+  g_return_val_if_fail (ptr != NULL, FALSE);
+  g_return_val_if_fail (val != NULL, FALSE);
+
+  errno = 0;
+  ret = strtod (ptr, &end);
+  if ((errno == ERANGE && (ret == HUGE_VAL || ret == -HUGE_VAL))
+      || (errno != 0 && ret == 0)) {
+    GST_WARNING ("%s", g_strerror (errno));
+    return FALSE;
+  }
+
+  if (!isfinite (ret)) {
+    GST_WARNING ("%s", g_strerror (ERANGE));
+    return FALSE;
+  }
+
+  if (endptr)
+    *endptr = end;
+
+  *val = (gint) ret;
+
+  return end != ptr;
+}
+
+static gboolean
 parse_attributes (gchar ** ptr, gchar ** a, gchar ** v)
 {
   gchar *end, *p;
@@ -185,7 +217,8 @@ gst_m3u8_compare_playlist_by_bitrate (gconstpointer a, gconstpointer b)
 static gboolean
 gst_m3u8_update (GstM3U8 * self, gchar * data, gboolean * updated)
 {
-  gint val, duration;
+  gint val;
+  GstClockTime duration;
   gchar *title, *end;
 //  gboolean discontinuity;
   GstM3U8 *list;
@@ -221,7 +254,7 @@ gst_m3u8_update (GstM3U8 * self, gchar * data, gboolean * updated)
   }
 
   list = NULL;
-  duration = -1;
+  duration = 0;
   title = NULL;
   data += 7;
   while (TRUE) {
@@ -232,7 +265,7 @@ gst_m3u8_update (GstM3U8 * self, gchar * data, gboolean * updated)
     if (data[0] != '#') {
       gchar *r;
 
-      if (duration < 0 && list == NULL) {
+      if (duration <= 0 && list == NULL) {
         GST_LOG ("%s: got line without EXTINF or EXTSTREAMINF, dropping", data);
         goto next_line;
       }
@@ -276,7 +309,7 @@ gst_m3u8_update (GstM3U8 * self, gchar * data, gboolean * updated)
         file =
             gst_m3u8_media_file_new (data, title, duration,
             self->mediasequence++);
-        duration = -1;
+        duration = 0;
         title = NULL;
         self->files = g_list_append (self->files, file);
       }
@@ -320,7 +353,7 @@ gst_m3u8_update (GstM3U8 * self, gchar * data, gboolean * updated)
       }
     } else if (g_str_has_prefix (data, "#EXT-X-TARGETDURATION:")) {
       if (int_from_string (data + 22, &data, &val))
-        self->targetduration = val;
+        self->targetduration = val * GST_SECOND;
     } else if (g_str_has_prefix (data, "#EXT-X-MEDIA-SEQUENCE:")) {
       if (int_from_string (data + 22, &data, &val))
         self->mediasequence = val;
@@ -333,11 +366,12 @@ gst_m3u8_update (GstM3U8 * self, gchar * data, gboolean * updated)
       g_free (self->allowcache);
       self->allowcache = g_strdup (data + 19);
     } else if (g_str_has_prefix (data, "#EXTINF:")) {
-      if (!int_from_string (data + 8, &data, &val)) {
+      gdouble fval;
+      if (!double_from_string (data + 8, &data, &fval)) {
         GST_WARNING ("Can't read EXTINF duration");
         goto next_line;
       }
-      duration = val;
+      duration = fval * (gdouble) GST_SECOND;
       if (duration > self->targetduration)
         GST_WARNING ("EXTINF duration > TARGETDURATION");
       if (!data || *data != ',')
@@ -484,7 +518,6 @@ gst_m3u8_client_get_current_position (GstM3U8Client * client,
       break;
     *timestamp += GST_M3U8_MEDIA_FILE (walk->data)->duration;
   }
-  *timestamp *= GST_SECOND;
 }
 
 gboolean
@@ -516,7 +549,7 @@ gst_m3u8_client_get_next_fragment (GstM3U8Client * client,
   client->sequence = file->sequence + 1;
 
   *uri = file->uri;
-  *duration = file->duration * GST_SECOND;
+  *duration = file->duration;
 
   GST_M3U8_CLIENT_UNLOCK (client);
   return TRUE;
@@ -544,7 +577,7 @@ gst_m3u8_client_get_duration (GstM3U8Client * client)
 
   g_list_foreach (client->current->files, (GFunc) _sum_duration, &duration);
   GST_M3U8_CLIENT_UNLOCK (client);
-  return duration * GST_SECOND;
+  return duration;
 }
 
 GstClockTime
@@ -557,7 +590,7 @@ gst_m3u8_client_get_target_duration (GstM3U8Client * client)
   GST_M3U8_CLIENT_LOCK (client);
   duration = client->current->targetduration;
   GST_M3U8_CLIENT_UNLOCK (client);
-  return duration * GST_SECOND;
+  return duration;
 }
 
 const gchar *
diff --git a/gst/hls/m3u8.h b/gst/hls/m3u8.h
index a428a67..a038287 100644
--- a/gst/hls/m3u8.h
+++ b/gst/hls/m3u8.h
@@ -41,7 +41,7 @@ struct _GstM3U8
 
   gboolean endlist;             /* if ENDLIST has been reached */
   gint version;                 /* last EXT-X-VERSION */
-  gint targetduration;          /* last EXT-X-TARGETDURATION */
+  GstClockTime targetduration;  /* last EXT-X-TARGETDURATION */
   gchar *allowcache;            /* last EXT-X-ALLOWCACHE */
 
   gint bandwidth;
@@ -62,7 +62,7 @@ struct _GstM3U8
 struct _GstM3U8MediaFile
 {
   gchar *title;
-  gint duration;
+  GstClockTime duration;
   gchar *uri;
   guint sequence;               /* the sequence nb of this file */
 };
diff --git a/gst/inter/Makefile.am b/gst/inter/Makefile.am
index 4a7e78a..e404959 100644
--- a/gst/inter/Makefile.am
+++ b/gst/inter/Makefile.am
@@ -5,6 +5,8 @@ noinst_PROGRAMS = gstintertest
 libgstinter_la_SOURCES = \
 	gstinteraudiosink.c \
 	gstinteraudiosrc.c \
+	gstintersubsink.c \
+	gstintersubsrc.c \
 	gstintervideosink.c \
 	gstintervideosrc.c \
 	gstinter.c \
@@ -13,19 +15,22 @@ libgstinter_la_SOURCES = \
 noinst_HEADERS = \
 	gstinteraudiosink.h \
 	gstinteraudiosrc.h \
+	gstintersubsink.h \
+	gstintersubsrc.h \
 	gstintervideosink.h \
 	gstintervideosrc.h \
 	gstintersurface.h
 
 libgstinter_la_CFLAGS = \
-	$(GST_CFLAGS) \
+	$(GST_PLUGINS_BAD_CFLAGS) \
 	$(GST_PLUGINS_BASE_CFLAGS) \
-	$(GST_BASE_CFLAGS)
+	$(GST_BASE_CFLAGS) \
+	$(GST_CFLAGS)
 
 libgstinter_la_LIBADD = \
-	$(GST_LIBS) \
-	$(GST_BASE_LIBS) \
 	$(GST_PLUGINS_BASE_LIBS) -lgstvideo-@GST_MAJORMINOR@ -lgstaudio-@GST_MAJORMINOR@ \
+	$(GST_BASE_LIBS) \
+	$(GST_LIBS) \
 	$(LIBM)
 
 libgstinter_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
@@ -35,12 +40,13 @@ gstintertest_SOURCES = \
 	gstintertest.c
 
 gstintertest_CFLAGS = \
-	$(GST_CFLAGS) \
-	$(GST_PLUGINS_BASE_CFLAGS)
+	$(GST_PLUGINS_BAD_CFLAGS) \
+	$(GST_PLUGINS_BASE_CFLAGS) \
+	$(GST_CFLAGS)
 
 gstintertest_LDADD = \
-	$(GST_LIBS) \
 	$(GST_PLUGINS_BASE_LIBS) \
+	$(GST_LIBS) \
 	$(LIBM)
 
 Android.mk: Makefile.am $(BUILT_SOURCES)
diff --git a/gst/inter/gstinter.c b/gst/inter/gstinter.c
index 60c5bd6..8a7786d 100644
--- a/gst/inter/gstinter.c
+++ b/gst/inter/gstinter.c
@@ -1,5 +1,5 @@
 /* GStreamer
- * Copyright (C) 2011 David A. Schleef <ds@schleef.org>
+ * Copyright (C) 2011 David Schleef <ds@entropywave.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -23,6 +23,8 @@
 
 #include "gstinteraudiosrc.h"
 #include "gstinteraudiosink.h"
+#include "gstintersubsrc.h"
+#include "gstintersubsink.h"
 #include "gstintervideosrc.h"
 #include "gstintervideosink.h"
 #include "gstintersurface.h"
@@ -34,13 +36,15 @@ plugin_init (GstPlugin * plugin)
       GST_TYPE_INTER_AUDIO_SRC);
   gst_element_register (plugin, "interaudiosink", GST_RANK_NONE,
       GST_TYPE_INTER_AUDIO_SINK);
+  gst_element_register (plugin, "intersubsrc", GST_RANK_NONE,
+      GST_TYPE_INTER_SUB_SRC);
+  gst_element_register (plugin, "intersubsink", GST_RANK_NONE,
+      GST_TYPE_INTER_SUB_SINK);
   gst_element_register (plugin, "intervideosrc", GST_RANK_NONE,
       GST_TYPE_INTER_VIDEO_SRC);
   gst_element_register (plugin, "intervideosink", GST_RANK_NONE,
       GST_TYPE_INTER_VIDEO_SINK);
 
-  gst_inter_surface_init ();
-
   return TRUE;
 }
 
diff --git a/gst/inter/gstinteraudiosink.c b/gst/inter/gstinteraudiosink.c
index a05248b..91285f1 100644
--- a/gst/inter/gstinteraudiosink.c
+++ b/gst/inter/gstinteraudiosink.c
@@ -19,14 +19,21 @@
 /**
  * SECTION:element-gstinteraudiosink
  *
- * The interaudiosink element does FIXME stuff.
+ * The interaudiosink element is an audio sink element.  It is used
+ * in connection with a interaudiosrc element in a different pipeline,
+ * similar to intervideosink and intervideosrc.
  *
  * <refsect2>
  * <title>Example launch line</title>
  * |[
- * gst-launch -v fakesrc ! interaudiosink ! FIXME ! fakesink
+ * gst-launch -v audiotestsrc ! queue ! interaudiosink
  * ]|
- * FIXME Describe what the pipeline does.
+ * 
+ * The interaudiosink element cannot be used effectively with gst-launch,
+ * as it requires a second pipeline in the application to receive the
+ * audio.
+ * See the gstintertest.c example in the gst-plugins-bad source code for
+ * more details.
  * </refsect2>
  */
 
@@ -77,7 +84,8 @@ static gboolean gst_inter_audio_sink_unlock_stop (GstBaseSink * sink);
 
 enum
 {
-  PROP_0
+  PROP_0,
+  PROP_CHANNEL
 };
 
 /* pad templates */
@@ -90,8 +98,7 @@ GST_STATIC_PAD_TEMPLATE ("sink",
         "endianness = (int) BYTE_ORDER, "
         "signed = (boolean) true, "
         "width = (int) 16, "
-        "depth = (int) 16, "
-        "rate = (int) [ 1, MAX ], " "channels = (int) [ 1, 2 ]")
+        "depth = (int) 16, " "rate = (int) 48000, " "channels = (int) 2")
     );
 
 
@@ -112,8 +119,11 @@ gst_inter_audio_sink_base_init (gpointer g_class)
   gst_element_class_add_static_pad_template (element_class,
       &gst_inter_audio_sink_sink_template);
 
-  gst_element_class_set_details_simple (element_class, "FIXME Long name",
-      "Generic", "FIXME Description", "FIXME <fixme@example.com>");
+  gst_element_class_set_details_simple (element_class,
+      "Internal audio sink",
+      "Sink/Audio",
+      "Virtual audio sink for internal process communication",
+      "David Schleef <ds@schleef.org>");
 }
 
 static void
@@ -150,22 +160,32 @@ gst_inter_audio_sink_class_init (GstInterAudioSinkClass * klass)
   base_sink_class->unlock_stop =
       GST_DEBUG_FUNCPTR (gst_inter_audio_sink_unlock_stop);
 
+#if 0
+  g_object_class_install_property (gobject_class, PROP_CHANNEL,
+      g_param_spec_string ("channel", "Channel",
+          "Channel name to match inter src and sink elements",
+          "default", G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+#endif
 }
 
 static void
 gst_inter_audio_sink_init (GstInterAudioSink * interaudiosink,
     GstInterAudioSinkClass * interaudiosink_class)
 {
-  interaudiosink->surface = gst_inter_surface_get ("default");
+  interaudiosink->channel = g_strdup ("default");
 }
 
 void
 gst_inter_audio_sink_set_property (GObject * object, guint property_id,
     const GValue * value, GParamSpec * pspec)
 {
-  /* GstInterAudioSink *interaudiosink = GST_INTER_AUDIO_SINK (object); */
+  GstInterAudioSink *interaudiosink = GST_INTER_AUDIO_SINK (object);
 
   switch (property_id) {
+    case PROP_CHANNEL:
+      g_free (interaudiosink->channel);
+      interaudiosink->channel = g_value_dup_string (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -176,9 +196,12 @@ void
 gst_inter_audio_sink_get_property (GObject * object, guint property_id,
     GValue * value, GParamSpec * pspec)
 {
-  /* GstInterAudioSink *interaudiosink = GST_INTER_AUDIO_SINK (object); */
+  GstInterAudioSink *interaudiosink = GST_INTER_AUDIO_SINK (object);
 
   switch (property_id) {
+    case PROP_CHANNEL:
+      g_value_set_string (value, interaudiosink->channel);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -254,6 +277,11 @@ gst_inter_audio_sink_get_times (GstBaseSink * sink, GstBuffer * buffer,
 static gboolean
 gst_inter_audio_sink_start (GstBaseSink * sink)
 {
+  GstInterAudioSink *interaudiosink = GST_INTER_AUDIO_SINK (sink);
+
+  GST_DEBUG ("start");
+
+  interaudiosink->surface = gst_inter_surface_get (interaudiosink->channel);
 
   return TRUE;
 }
@@ -269,6 +297,9 @@ gst_inter_audio_sink_stop (GstBaseSink * sink)
   gst_adapter_clear (interaudiosink->surface->audio_adapter);
   g_mutex_unlock (interaudiosink->surface->mutex);
 
+  gst_inter_surface_unref (interaudiosink->surface);
+  interaudiosink->surface = NULL;
+
   return TRUE;
 }
 
diff --git a/gst/inter/gstinteraudiosink.h b/gst/inter/gstinteraudiosink.h
index b0a3276..5ea0999 100644
--- a/gst/inter/gstinteraudiosink.h
+++ b/gst/inter/gstinteraudiosink.h
@@ -39,6 +39,7 @@ struct _GstInterAudioSink
   GstBaseSink base_interaudiosink;
 
   GstInterSurface *surface;
+  char *channel;
 
   int fps_n;
   int fps_d;
diff --git a/gst/inter/gstinteraudiosrc.c b/gst/inter/gstinteraudiosrc.c
index 1b98adc..0a136ee 100644
--- a/gst/inter/gstinteraudiosrc.c
+++ b/gst/inter/gstinteraudiosrc.c
@@ -19,14 +19,19 @@
 /**
  * SECTION:element-gstinteraudiosrc
  *
- * The interaudiosrc element does FIXME stuff.
+ * The interaudiosrc element is an audio source element.  It is used
+ * in connection with a interaudiosink element in a different pipeline.
  *
  * <refsect2>
  * <title>Example launch line</title>
  * |[
- * gst-launch -v fakesrc ! interaudiosrc ! FIXME ! fakesink
+ * gst-launch -v interaudiosrc ! queue ! audiosink
  * ]|
- * FIXME Describe what the pipeline does.
+ * 
+ * The interaudiosrc element cannot be used effectively with gst-launch,
+ * as it requires a second pipeline in the application to send audio.
+ * See the gstintertest.c example in the gst-plugins-bad source code for
+ * more details.
  * </refsect2>
  */
 
@@ -79,7 +84,8 @@ gst_inter_audio_src_prepare_seek_segment (GstBaseSrc * src, GstEvent * seek,
 
 enum
 {
-  PROP_0
+  PROP_0,
+  PROP_CHANNEL
 };
 
 /* pad templates */
@@ -92,8 +98,7 @@ GST_STATIC_PAD_TEMPLATE ("src",
         "endianness = (int) BYTE_ORDER, "
         "signed = (boolean) true, "
         "width = (int) 16, "
-        "depth = (int) 16, "
-        "rate = (int) [ 1, MAX ], " "channels = (int) [ 1, 2 ]")
+        "depth = (int) 16, " "rate = (int) 48000, " "channels = (int) 2")
     );
 
 
@@ -114,8 +119,11 @@ gst_inter_audio_src_base_init (gpointer g_class)
   gst_element_class_add_static_pad_template (element_class,
       &gst_inter_audio_src_src_template);
 
-  gst_element_class_set_details_simple (element_class, "FIXME Long name",
-      "Generic", "FIXME Description", "FIXME <fixme@example.com>");
+  gst_element_class_set_details_simple (element_class,
+      "Internal audio source",
+      "Source/Audio",
+      "Virtual audio source for internal process communication",
+      "David Schleef <ds@schleef.org>");
 }
 
 static void
@@ -158,7 +166,12 @@ gst_inter_audio_src_class_init (GstInterAudioSrcClass * klass)
     base_src_class->prepare_seek_segment =
         GST_DEBUG_FUNCPTR (gst_inter_audio_src_prepare_seek_segment);
 
-
+#if 0
+  g_object_class_install_property (gobject_class, PROP_CHANNEL,
+      g_param_spec_string ("channel", "Channel",
+          "Channel name to match inter src and sink elements",
+          "default", G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+#endif
 }
 
 static void
@@ -169,16 +182,20 @@ gst_inter_audio_src_init (GstInterAudioSrc * interaudiosrc,
   gst_base_src_set_live (GST_BASE_SRC (interaudiosrc), TRUE);
   gst_base_src_set_blocksize (GST_BASE_SRC (interaudiosrc), -1);
 
-  interaudiosrc->surface = gst_inter_surface_get ("default");
+  interaudiosrc->channel = g_strdup ("default");
 }
 
 void
 gst_inter_audio_src_set_property (GObject * object, guint property_id,
     const GValue * value, GParamSpec * pspec)
 {
-  /* GstInterAudioSrc *interaudiosrc = GST_INTER_AUDIO_SRC (object); */
+  GstInterAudioSrc *interaudiosrc = GST_INTER_AUDIO_SRC (object);
 
   switch (property_id) {
+    case PROP_CHANNEL:
+      g_free (interaudiosrc->channel);
+      interaudiosrc->channel = g_value_dup_string (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -189,9 +206,12 @@ void
 gst_inter_audio_src_get_property (GObject * object, guint property_id,
     GValue * value, GParamSpec * pspec)
 {
-  /* GstInterAudioSrc *interaudiosrc = GST_INTER_AUDIO_SRC (object); */
+  GstInterAudioSrc *interaudiosrc = GST_INTER_AUDIO_SRC (object);
 
   switch (property_id) {
+    case PROP_CHANNEL:
+      g_value_set_string (value, interaudiosrc->channel);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -276,6 +296,8 @@ gst_inter_audio_src_start (GstBaseSrc * src)
 
   GST_DEBUG_OBJECT (interaudiosrc, "start");
 
+  interaudiosrc->surface = gst_inter_surface_get (interaudiosrc->channel);
+
   return TRUE;
 }
 
@@ -286,6 +308,9 @@ gst_inter_audio_src_stop (GstBaseSrc * src)
 
   GST_DEBUG_OBJECT (interaudiosrc, "stop");
 
+  gst_inter_surface_unref (interaudiosrc->surface);
+  interaudiosrc->surface = NULL;
+
   return TRUE;
 }
 
@@ -340,12 +365,20 @@ static gboolean
 gst_inter_audio_src_event (GstBaseSrc * src, GstEvent * event)
 {
   GstInterAudioSrc *interaudiosrc = GST_INTER_AUDIO_SRC (src);
+  gboolean ret;
 
   GST_DEBUG_OBJECT (interaudiosrc, "event");
 
-  return TRUE;
+  switch (GST_EVENT_TYPE (event)) {
+    default:
+      ret = GST_BASE_SRC_CLASS (parent_class)->event (src, event);
+  }
+
+  return ret;
 }
 
+#define SIZE 1600
+
 static GstFlowReturn
 gst_inter_audio_src_create (GstBaseSrc * src, guint64 offset, guint size,
     GstBuffer ** buf)
@@ -360,31 +393,31 @@ gst_inter_audio_src_create (GstBaseSrc * src, guint64 offset, guint size,
 
   g_mutex_lock (interaudiosrc->surface->mutex);
   n = gst_adapter_available (interaudiosrc->surface->audio_adapter) / 4;
-  if (n > 1600 * 2) {
-    GST_DEBUG ("flushing %d samples", 800);
-    gst_adapter_flush (interaudiosrc->surface->audio_adapter, 800 * 4);
-    n -= 800;
+  if (n > SIZE * 2) {
+    GST_DEBUG ("flushing %d samples", SIZE / 2);
+    gst_adapter_flush (interaudiosrc->surface->audio_adapter, (SIZE / 2) * 4);
+    n -= (SIZE / 2);
   }
-  if (n > 1600)
-    n = 1600;
+  if (n > SIZE)
+    n = SIZE;
   if (n > 0) {
     buffer = gst_adapter_take_buffer (interaudiosrc->surface->audio_adapter,
         n * 4);
   }
   g_mutex_unlock (interaudiosrc->surface->mutex);
 
-  if (n < 1600) {
-    GstBuffer *newbuf = gst_buffer_new_and_alloc (1600 * 4);
+  if (n < SIZE) {
+    GstBuffer *newbuf = gst_buffer_new_and_alloc (SIZE * 4);
 
-    GST_DEBUG ("creating %d samples of silence", 1600 - n);
-    memset (GST_BUFFER_DATA (newbuf) + n * 4, 0, 1600 * 4 - n * 4);
+    GST_DEBUG ("creating %d samples of silence", SIZE - n);
+    memset (GST_BUFFER_DATA (newbuf) + n * 4, 0, SIZE * 4 - n * 4);
     if (buffer) {
       memcpy (GST_BUFFER_DATA (newbuf), GST_BUFFER_DATA (buffer), n * 4);
       gst_buffer_unref (buffer);
     }
     buffer = newbuf;
   }
-  n = 1600;
+  n = SIZE;
 
   GST_BUFFER_OFFSET (buffer) = interaudiosrc->n_samples;
   GST_BUFFER_OFFSET_END (buffer) = interaudiosrc->n_samples + n;
@@ -424,10 +457,34 @@ static gboolean
 gst_inter_audio_src_query (GstBaseSrc * src, GstQuery * query)
 {
   GstInterAudioSrc *interaudiosrc = GST_INTER_AUDIO_SRC (src);
+  gboolean ret;
 
   GST_DEBUG_OBJECT (interaudiosrc, "query");
 
-  return TRUE;
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_LATENCY:{
+      GstClockTime min_latency, max_latency;
+
+      min_latency = 30 * gst_util_uint64_scale_int (GST_SECOND, SIZE, 48000);
+
+      max_latency = min_latency;
+
+      GST_ERROR_OBJECT (src,
+          "report latency min %" GST_TIME_FORMAT " max %" GST_TIME_FORMAT,
+          GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
+
+      gst_query_set_latency (query,
+          gst_base_src_is_live (src), min_latency, max_latency);
+
+      ret = TRUE;
+      break;
+    }
+    default:
+      ret = GST_BASE_SRC_CLASS (parent_class)->query (src, query);
+      break;
+  }
+
+  return ret;
 }
 
 static gboolean
diff --git a/gst/inter/gstinteraudiosrc.h b/gst/inter/gstinteraudiosrc.h
index 958a1a5..4ccc7f5 100644
--- a/gst/inter/gstinteraudiosrc.h
+++ b/gst/inter/gstinteraudiosrc.h
@@ -39,6 +39,7 @@ struct _GstInterAudioSrc
   GstBaseSrc base_interaudiosrc;
 
   GstInterSurface *surface;
+  char *channel;
 
   guint64 n_samples;
   int sample_rate;
diff --git a/gst/inter/gstintersubsink.c b/gst/inter/gstintersubsink.c
new file mode 100644
index 0000000..a42b3e5
--- /dev/null
+++ b/gst/inter/gstintersubsink.c
@@ -0,0 +1,352 @@
+/* GStreamer
+ * Copyright (C) 2011 David Schleef <ds@entropywave.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
+ * Boston, MA 02110-1335, USA.
+ */
+/**
+ * SECTION:element-gstintersubsink
+ *
+ * The intersubsink element is a subtitle sink element.  It is used
+ * in connection with a intersubsrc element in a different pipeline.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch -v ... ! intersubsink
+ * ]|
+ * 
+ * The intersubsink element cannot be used effectively with gst-launch,
+ * as it requires a second pipeline in the application to send audio.
+ * See the gstintertest.c example in the gst-plugins-bad source code for
+ * more details.
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/base/gstbasesink.h>
+#include "gstintersubsink.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_inter_sub_sink_debug_category);
+#define GST_CAT_DEFAULT gst_inter_sub_sink_debug_category
+
+/* prototypes */
+
+
+static void gst_inter_sub_sink_set_property (GObject * object,
+    guint property_id, const GValue * value, GParamSpec * pspec);
+static void gst_inter_sub_sink_get_property (GObject * object,
+    guint property_id, GValue * value, GParamSpec * pspec);
+static void gst_inter_sub_sink_dispose (GObject * object);
+static void gst_inter_sub_sink_finalize (GObject * object);
+
+static GstCaps *gst_inter_sub_sink_get_caps (GstBaseSink * sink);
+static gboolean gst_inter_sub_sink_set_caps (GstBaseSink * sink,
+    GstCaps * caps);
+static GstFlowReturn gst_inter_sub_sink_buffer_alloc (GstBaseSink * sink,
+    guint64 offset, guint size, GstCaps * caps, GstBuffer ** buf);
+static void gst_inter_sub_sink_get_times (GstBaseSink * sink,
+    GstBuffer * buffer, GstClockTime * start, GstClockTime * end);
+static gboolean gst_inter_sub_sink_start (GstBaseSink * sink);
+static gboolean gst_inter_sub_sink_stop (GstBaseSink * sink);
+static gboolean gst_inter_sub_sink_unlock (GstBaseSink * sink);
+static gboolean gst_inter_sub_sink_event (GstBaseSink * sink, GstEvent * event);
+static GstFlowReturn
+gst_inter_sub_sink_preroll (GstBaseSink * sink, GstBuffer * buffer);
+static GstFlowReturn
+gst_inter_sub_sink_render (GstBaseSink * sink, GstBuffer * buffer);
+static GstStateChangeReturn gst_inter_sub_sink_async_play (GstBaseSink * sink);
+static gboolean gst_inter_sub_sink_activate_pull (GstBaseSink * sink,
+    gboolean active);
+static gboolean gst_inter_sub_sink_unlock_stop (GstBaseSink * sink);
+
+enum
+{
+  PROP_0,
+  PROP_CHANNEL
+};
+
+/* pad templates */
+
+static GstStaticPadTemplate gst_inter_sub_sink_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("text/plain")
+    );
+
+
+/* class initialization */
+
+#define DEBUG_INIT(bla) \
+  GST_DEBUG_CATEGORY_INIT (gst_inter_sub_sink_debug_category, "intersubsink", 0, \
+      "debug category for intersubsink element");
+
+GST_BOILERPLATE_FULL (GstInterSubSink, gst_inter_sub_sink, GstBaseSink,
+    GST_TYPE_BASE_SINK, DEBUG_INIT);
+
+static void
+gst_inter_sub_sink_base_init (gpointer g_class)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_inter_sub_sink_sink_template));
+
+  gst_element_class_set_details_simple (element_class,
+      "Internal subtitle sink",
+      "Sink/Subtitle",
+      "Virtual subtitle sink for internal process communication",
+      "David Schleef <ds@schleef.org>");
+}
+
+static void
+gst_inter_sub_sink_class_init (GstInterSubSinkClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstBaseSinkClass *base_sink_class = GST_BASE_SINK_CLASS (klass);
+
+  gobject_class->set_property = gst_inter_sub_sink_set_property;
+  gobject_class->get_property = gst_inter_sub_sink_get_property;
+  gobject_class->dispose = gst_inter_sub_sink_dispose;
+  gobject_class->finalize = gst_inter_sub_sink_finalize;
+  base_sink_class->get_caps = GST_DEBUG_FUNCPTR (gst_inter_sub_sink_get_caps);
+  base_sink_class->set_caps = GST_DEBUG_FUNCPTR (gst_inter_sub_sink_set_caps);
+  if (0)
+    base_sink_class->buffer_alloc =
+        GST_DEBUG_FUNCPTR (gst_inter_sub_sink_buffer_alloc);
+  base_sink_class->get_times = GST_DEBUG_FUNCPTR (gst_inter_sub_sink_get_times);
+  base_sink_class->start = GST_DEBUG_FUNCPTR (gst_inter_sub_sink_start);
+  base_sink_class->stop = GST_DEBUG_FUNCPTR (gst_inter_sub_sink_stop);
+  base_sink_class->unlock = GST_DEBUG_FUNCPTR (gst_inter_sub_sink_unlock);
+  if (0)
+    base_sink_class->event = GST_DEBUG_FUNCPTR (gst_inter_sub_sink_event);
+  base_sink_class->preroll = GST_DEBUG_FUNCPTR (gst_inter_sub_sink_preroll);
+  base_sink_class->render = GST_DEBUG_FUNCPTR (gst_inter_sub_sink_render);
+  if (0)
+    base_sink_class->async_play =
+        GST_DEBUG_FUNCPTR (gst_inter_sub_sink_async_play);
+  if (0)
+    base_sink_class->activate_pull =
+        GST_DEBUG_FUNCPTR (gst_inter_sub_sink_activate_pull);
+  base_sink_class->unlock_stop =
+      GST_DEBUG_FUNCPTR (gst_inter_sub_sink_unlock_stop);
+
+  g_object_class_install_property (gobject_class, PROP_CHANNEL,
+      g_param_spec_string ("channel", "Channel",
+          "Channel name to match inter src and sink elements",
+          "default", G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+}
+
+static void
+gst_inter_sub_sink_init (GstInterSubSink * intersubsink,
+    GstInterSubSinkClass * intersubsink_class)
+{
+
+  intersubsink->channel = g_strdup ("default");
+
+  intersubsink->fps_n = 1;
+  intersubsink->fps_d = 1;
+}
+
+void
+gst_inter_sub_sink_set_property (GObject * object, guint property_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstInterSubSink *intersubsink = GST_INTER_SUB_SINK (object);
+
+  switch (property_id) {
+    case PROP_CHANNEL:
+      g_free (intersubsink->channel);
+      intersubsink->channel = g_value_dup_string (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_inter_sub_sink_get_property (GObject * object, guint property_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstInterSubSink *intersubsink = GST_INTER_SUB_SINK (object);
+
+  switch (property_id) {
+    case PROP_CHANNEL:
+      g_value_set_string (value, intersubsink->channel);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_inter_sub_sink_dispose (GObject * object)
+{
+  /* GstInterSubSink *intersubsink = GST_INTER_SUB_SINK (object); */
+
+  /* clean up as possible.  may be called multiple times */
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+void
+gst_inter_sub_sink_finalize (GObject * object)
+{
+  /* GstInterSubSink *intersubsink = GST_INTER_SUB_SINK (object); */
+
+  /* clean up object here */
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+
+
+static GstCaps *
+gst_inter_sub_sink_get_caps (GstBaseSink * sink)
+{
+
+  return NULL;
+}
+
+static gboolean
+gst_inter_sub_sink_set_caps (GstBaseSink * sink, GstCaps * caps)
+{
+
+  return FALSE;
+}
+
+static GstFlowReturn
+gst_inter_sub_sink_buffer_alloc (GstBaseSink * sink, guint64 offset, guint size,
+    GstCaps * caps, GstBuffer ** buf)
+{
+
+  return GST_FLOW_ERROR;
+}
+
+static void
+gst_inter_sub_sink_get_times (GstBaseSink * sink, GstBuffer * buffer,
+    GstClockTime * start, GstClockTime * end)
+{
+  GstInterSubSink *intersubsink = GST_INTER_SUB_SINK (sink);
+
+  if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer)) {
+    *start = GST_BUFFER_TIMESTAMP (buffer);
+    if (GST_BUFFER_DURATION_IS_VALID (buffer)) {
+      *end = *start + GST_BUFFER_DURATION (buffer);
+    } else {
+      if (intersubsink->fps_n > 0) {
+        *end = *start +
+            gst_util_uint64_scale_int (GST_SECOND, intersubsink->fps_d,
+            intersubsink->fps_n);
+      }
+    }
+  }
+
+
+}
+
+static gboolean
+gst_inter_sub_sink_start (GstBaseSink * sink)
+{
+  GstInterSubSink *intersubsink = GST_INTER_SUB_SINK (sink);
+
+  intersubsink->surface = gst_inter_surface_get (intersubsink->channel);
+
+  return TRUE;
+}
+
+static gboolean
+gst_inter_sub_sink_stop (GstBaseSink * sink)
+{
+  GstInterSubSink *intersubsink = GST_INTER_SUB_SINK (sink);
+
+  g_mutex_lock (intersubsink->surface->mutex);
+  if (intersubsink->surface->sub_buffer) {
+    gst_buffer_unref (intersubsink->surface->sub_buffer);
+  }
+  intersubsink->surface->sub_buffer = NULL;
+  g_mutex_unlock (intersubsink->surface->mutex);
+
+  gst_inter_surface_unref (intersubsink->surface);
+  intersubsink->surface = NULL;
+
+  return TRUE;
+}
+
+static gboolean
+gst_inter_sub_sink_unlock (GstBaseSink * sink)
+{
+
+  return TRUE;
+}
+
+static gboolean
+gst_inter_sub_sink_event (GstBaseSink * sink, GstEvent * event)
+{
+
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_inter_sub_sink_preroll (GstBaseSink * sink, GstBuffer * buffer)
+{
+
+  return GST_FLOW_OK;
+}
+
+static GstFlowReturn
+gst_inter_sub_sink_render (GstBaseSink * sink, GstBuffer * buffer)
+{
+  GstInterSubSink *intersubsink = GST_INTER_SUB_SINK (sink);
+
+  g_mutex_lock (intersubsink->surface->mutex);
+  if (intersubsink->surface->sub_buffer) {
+    gst_buffer_unref (intersubsink->surface->sub_buffer);
+  }
+  intersubsink->surface->sub_buffer = gst_buffer_ref (buffer);
+  //intersubsink->surface->sub_buffer_count = 0;
+  g_mutex_unlock (intersubsink->surface->mutex);
+
+  return GST_FLOW_OK;
+}
+
+static GstStateChangeReturn
+gst_inter_sub_sink_async_play (GstBaseSink * sink)
+{
+
+  return GST_STATE_CHANGE_SUCCESS;
+}
+
+static gboolean
+gst_inter_sub_sink_activate_pull (GstBaseSink * sink, gboolean active)
+{
+
+  return TRUE;
+}
+
+static gboolean
+gst_inter_sub_sink_unlock_stop (GstBaseSink * sink)
+{
+
+  return TRUE;
+}
diff --git a/gst/inter/gstintersubsink.h b/gst/inter/gstintersubsink.h
new file mode 100644
index 0000000..33b48f7
--- /dev/null
+++ b/gst/inter/gstintersubsink.h
@@ -0,0 +1,58 @@
+/* GStreamer
+ * Copyright (C) 2011 David Schleef <ds@entropywave.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_INTER_SUB_SINK_H_
+#define _GST_INTER_SUB_SINK_H_
+
+#include <gst/base/gstbasesink.h>
+#include "gstintersurface.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_INTER_SUB_SINK   (gst_inter_sub_sink_get_type())
+#define GST_INTER_SUB_SINK(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_INTER_SUB_SINK,GstInterSubSink))
+#define GST_INTER_SUB_SINK_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_INTER_SUB_SINK,GstInterSubSinkClass))
+#define GST_IS_INTER_SUB_SINK(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_INTER_SUB_SINK))
+#define GST_IS_INTER_SUB_SINK_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_INTER_SUB_SINK))
+
+typedef struct _GstInterSubSink GstInterSubSink;
+typedef struct _GstInterSubSinkClass GstInterSubSinkClass;
+
+struct _GstInterSubSink
+{
+  GstBaseSink base_intersubsink;
+
+  GstPad *sinkpad;
+  GstInterSurface *surface;
+  char *channel;
+
+  int fps_n;
+  int fps_d;
+};
+
+struct _GstInterSubSinkClass
+{
+  GstBaseSinkClass base_intersubsink_class;
+};
+
+GType gst_inter_sub_sink_get_type (void);
+
+G_END_DECLS
+
+#endif
diff --git a/gst/inter/gstintersubsrc.c b/gst/inter/gstintersubsrc.c
new file mode 100644
index 0000000..437a3e1
--- /dev/null
+++ b/gst/inter/gstintersubsrc.c
@@ -0,0 +1,486 @@
+/* GStreamer
+ * Copyright (C) 2011 David Schleef <ds@entropywave.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
+ * Boston, MA 02110-1335, USA.
+ */
+/**
+ * SECTION:element-gstintersubsrc
+ *
+ * The intersubsrc element is a subtitle source element.  It is used
+ * in connection with a intersubsink element in a different pipeline,
+ * similar to interaudiosink and interaudiosrc.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch -v intersubsrc ! kateenc ! oggmux ! filesink location=out.ogv
+ * ]|
+ * 
+ * The intersubsrc element cannot be used effectively with gst-launch,
+ * as it requires a second pipeline in the application to send subtitles.
+ * See the gstintertest.c example in the gst-plugins-bad source code for
+ * more details.
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/base/gstbasesrc.h>
+#include "gstintersubsrc.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_inter_sub_src_debug_category);
+#define GST_CAT_DEFAULT gst_inter_sub_src_debug_category
+
+/* prototypes */
+
+
+static void gst_inter_sub_src_set_property (GObject * object,
+    guint property_id, const GValue * value, GParamSpec * pspec);
+static void gst_inter_sub_src_get_property (GObject * object,
+    guint property_id, GValue * value, GParamSpec * pspec);
+static void gst_inter_sub_src_dispose (GObject * object);
+static void gst_inter_sub_src_finalize (GObject * object);
+
+static GstCaps *gst_inter_sub_src_get_caps (GstBaseSrc * src);
+static gboolean gst_inter_sub_src_set_caps (GstBaseSrc * src, GstCaps * caps);
+static gboolean gst_inter_sub_src_negotiate (GstBaseSrc * src);
+static gboolean gst_inter_sub_src_newsegment (GstBaseSrc * src);
+static gboolean gst_inter_sub_src_start (GstBaseSrc * src);
+static gboolean gst_inter_sub_src_stop (GstBaseSrc * src);
+static void
+gst_inter_sub_src_get_times (GstBaseSrc * src, GstBuffer * buffer,
+    GstClockTime * start, GstClockTime * end);
+static gboolean gst_inter_sub_src_is_seekable (GstBaseSrc * src);
+static gboolean gst_inter_sub_src_unlock (GstBaseSrc * src);
+static gboolean gst_inter_sub_src_event (GstBaseSrc * src, GstEvent * event);
+static GstFlowReturn
+gst_inter_sub_src_create (GstBaseSrc * src, guint64 offset, guint size,
+    GstBuffer ** buf);
+static gboolean gst_inter_sub_src_do_seek (GstBaseSrc * src,
+    GstSegment * segment);
+static gboolean gst_inter_sub_src_query (GstBaseSrc * src, GstQuery * query);
+static gboolean gst_inter_sub_src_check_get_range (GstBaseSrc * src);
+static void gst_inter_sub_src_fixate (GstBaseSrc * src, GstCaps * caps);
+static gboolean gst_inter_sub_src_unlock_stop (GstBaseSrc * src);
+static gboolean
+gst_inter_sub_src_prepare_seek_segment (GstBaseSrc * src, GstEvent * seek,
+    GstSegment * segment);
+
+enum
+{
+  PROP_0,
+  PROP_CHANNEL
+};
+
+/* pad templates */
+
+static GstStaticPadTemplate gst_inter_sub_src_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("application/unknown")
+    );
+
+
+/* class initialization */
+
+#define DEBUG_INIT(bla) \
+  GST_DEBUG_CATEGORY_INIT (gst_inter_sub_src_debug_category, "intersubsrc", 0, \
+      "debug category for intersubsrc element");
+
+GST_BOILERPLATE_FULL (GstInterSubSrc, gst_inter_sub_src, GstBaseSrc,
+    GST_TYPE_BASE_SRC, DEBUG_INIT);
+
+static void
+gst_inter_sub_src_base_init (gpointer g_class)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_inter_sub_src_src_template));
+
+  gst_element_class_set_details_simple (element_class,
+      "Internal subtitle source",
+      "Source/Subtitle",
+      "Virtual subtitle source for internal process communication",
+      "David Schleef <ds@schleef.org>");
+}
+
+static void
+gst_inter_sub_src_class_init (GstInterSubSrcClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstBaseSrcClass *base_src_class = GST_BASE_SRC_CLASS (klass);
+
+  gobject_class->set_property = gst_inter_sub_src_set_property;
+  gobject_class->get_property = gst_inter_sub_src_get_property;
+  gobject_class->dispose = gst_inter_sub_src_dispose;
+  gobject_class->finalize = gst_inter_sub_src_finalize;
+  if (0)
+    base_src_class->get_caps = GST_DEBUG_FUNCPTR (gst_inter_sub_src_get_caps);
+  base_src_class->set_caps = GST_DEBUG_FUNCPTR (gst_inter_sub_src_set_caps);
+  if (0)
+    base_src_class->negotiate = GST_DEBUG_FUNCPTR (gst_inter_sub_src_negotiate);
+  if (0)
+    base_src_class->newsegment =
+        GST_DEBUG_FUNCPTR (gst_inter_sub_src_newsegment);
+  base_src_class->start = GST_DEBUG_FUNCPTR (gst_inter_sub_src_start);
+  base_src_class->stop = GST_DEBUG_FUNCPTR (gst_inter_sub_src_stop);
+  base_src_class->get_times = GST_DEBUG_FUNCPTR (gst_inter_sub_src_get_times);
+  if (0)
+    base_src_class->is_seekable =
+        GST_DEBUG_FUNCPTR (gst_inter_sub_src_is_seekable);
+  base_src_class->unlock = GST_DEBUG_FUNCPTR (gst_inter_sub_src_unlock);
+  base_src_class->event = GST_DEBUG_FUNCPTR (gst_inter_sub_src_event);
+  base_src_class->create = GST_DEBUG_FUNCPTR (gst_inter_sub_src_create);
+  if (0)
+    base_src_class->do_seek = GST_DEBUG_FUNCPTR (gst_inter_sub_src_do_seek);
+  base_src_class->query = GST_DEBUG_FUNCPTR (gst_inter_sub_src_query);
+  if (0)
+    base_src_class->check_get_range =
+        GST_DEBUG_FUNCPTR (gst_inter_sub_src_check_get_range);
+  base_src_class->fixate = GST_DEBUG_FUNCPTR (gst_inter_sub_src_fixate);
+  if (0)
+    base_src_class->unlock_stop =
+        GST_DEBUG_FUNCPTR (gst_inter_sub_src_unlock_stop);
+  if (0)
+    base_src_class->prepare_seek_segment =
+        GST_DEBUG_FUNCPTR (gst_inter_sub_src_prepare_seek_segment);
+
+  g_object_class_install_property (gobject_class, PROP_CHANNEL,
+      g_param_spec_string ("channel", "Channel",
+          "Channel name to match inter src and sink elements",
+          "default", G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+static void
+gst_inter_sub_src_init (GstInterSubSrc * intersubsrc,
+    GstInterSubSrcClass * intersubsrc_class)
+{
+
+  intersubsrc->srcpad =
+      gst_pad_new_from_static_template (&gst_inter_sub_src_src_template, "src");
+
+  gst_base_src_set_format (GST_BASE_SRC (intersubsrc), GST_FORMAT_TIME);
+  gst_base_src_set_live (GST_BASE_SRC (intersubsrc), TRUE);
+
+  intersubsrc->channel = g_strdup ("default");
+}
+
+void
+gst_inter_sub_src_set_property (GObject * object, guint property_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (object);
+
+  switch (property_id) {
+    case PROP_CHANNEL:
+      g_free (intersubsrc->channel);
+      intersubsrc->channel = g_value_dup_string (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_inter_sub_src_get_property (GObject * object, guint property_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (object);
+
+  switch (property_id) {
+    case PROP_CHANNEL:
+      g_value_set_string (value, intersubsrc->channel);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_inter_sub_src_dispose (GObject * object)
+{
+  /* GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (object); */
+
+  /* clean up as possible.  may be called multiple times */
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+void
+gst_inter_sub_src_finalize (GObject * object)
+{
+  /* GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (object); */
+
+  /* clean up object here */
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+
+static GstCaps *
+gst_inter_sub_src_get_caps (GstBaseSrc * src)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "get_caps");
+
+  return NULL;
+}
+
+static gboolean
+gst_inter_sub_src_set_caps (GstBaseSrc * src, GstCaps * caps)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "set_caps");
+
+  return TRUE;
+}
+
+static gboolean
+gst_inter_sub_src_negotiate (GstBaseSrc * src)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "negotiate");
+
+  return TRUE;
+}
+
+static gboolean
+gst_inter_sub_src_newsegment (GstBaseSrc * src)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "newsegment");
+
+  return TRUE;
+}
+
+static gboolean
+gst_inter_sub_src_start (GstBaseSrc * src)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "start");
+
+  intersubsrc->surface = gst_inter_surface_get (intersubsrc->channel);
+
+  return TRUE;
+}
+
+static gboolean
+gst_inter_sub_src_stop (GstBaseSrc * src)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "stop");
+
+  gst_inter_surface_unref (intersubsrc->surface);
+  intersubsrc->surface = NULL;
+
+  return TRUE;
+}
+
+static void
+gst_inter_sub_src_get_times (GstBaseSrc * src, GstBuffer * buffer,
+    GstClockTime * start, GstClockTime * end)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "get_times");
+
+  /* for live sources, sync on the timestamp of the buffer */
+  if (gst_base_src_is_live (src)) {
+    GstClockTime timestamp = GST_BUFFER_TIMESTAMP (buffer);
+
+    if (GST_CLOCK_TIME_IS_VALID (timestamp)) {
+      /* get duration to calculate end time */
+      GstClockTime duration = GST_BUFFER_DURATION (buffer);
+
+      if (GST_CLOCK_TIME_IS_VALID (duration)) {
+        *end = timestamp + duration;
+      }
+      *start = timestamp;
+    }
+  } else {
+    *start = -1;
+    *end = -1;
+  }
+}
+
+static gboolean
+gst_inter_sub_src_is_seekable (GstBaseSrc * src)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "is_seekable");
+
+  return FALSE;
+}
+
+static gboolean
+gst_inter_sub_src_unlock (GstBaseSrc * src)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "unlock");
+
+  return TRUE;
+}
+
+static gboolean
+gst_inter_sub_src_event (GstBaseSrc * src, GstEvent * event)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+  gboolean ret;
+
+  GST_DEBUG_OBJECT (intersubsrc, "event");
+
+  switch (GST_EVENT_TYPE (event)) {
+    default:
+      ret = GST_BASE_SRC_CLASS (parent_class)->event (src, event);
+  }
+
+  return ret;
+}
+
+static GstFlowReturn
+gst_inter_sub_src_create (GstBaseSrc * src, guint64 offset, guint size,
+    GstBuffer ** buf)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+  GstBuffer *buffer;
+
+  GST_DEBUG_OBJECT (intersubsrc, "create");
+
+  buffer = NULL;
+
+  g_mutex_lock (intersubsrc->surface->mutex);
+  if (intersubsrc->surface->sub_buffer) {
+    buffer = gst_buffer_ref (intersubsrc->surface->sub_buffer);
+    //intersubsrc->surface->sub_buffer_count++;
+    //if (intersubsrc->surface->sub_buffer_count >= 30) {
+    gst_buffer_unref (intersubsrc->surface->sub_buffer);
+    intersubsrc->surface->sub_buffer = NULL;
+    //}
+  }
+  g_mutex_unlock (intersubsrc->surface->mutex);
+
+  if (buffer == NULL) {
+    guint8 *data;
+
+    buffer = gst_buffer_new_and_alloc (1);
+
+    data = GST_BUFFER_DATA (buffer);
+    data[0] = 0;
+  }
+
+  buffer = gst_buffer_make_metadata_writable (buffer);
+
+  GST_BUFFER_TIMESTAMP (buffer) =
+      gst_util_uint64_scale_int (GST_SECOND, intersubsrc->n_frames,
+      intersubsrc->rate);
+  GST_DEBUG_OBJECT (intersubsrc, "create ts %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)));
+  GST_BUFFER_DURATION (buffer) =
+      gst_util_uint64_scale_int (GST_SECOND, (intersubsrc->n_frames + 1),
+      intersubsrc->rate) - GST_BUFFER_TIMESTAMP (buffer);
+  GST_BUFFER_OFFSET (buffer) = intersubsrc->n_frames;
+  GST_BUFFER_OFFSET_END (buffer) = -1;
+  GST_BUFFER_FLAG_UNSET (buffer, GST_BUFFER_FLAG_DISCONT);
+  if (intersubsrc->n_frames == 0) {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+  }
+  gst_buffer_set_caps (buffer, GST_PAD_CAPS (GST_BASE_SRC_PAD (intersubsrc)));
+  intersubsrc->n_frames++;
+
+  *buf = buffer;
+
+  return GST_FLOW_OK;
+}
+
+static gboolean
+gst_inter_sub_src_do_seek (GstBaseSrc * src, GstSegment * segment)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "do_seek");
+
+  return FALSE;
+}
+
+static gboolean
+gst_inter_sub_src_query (GstBaseSrc * src, GstQuery * query)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+  gboolean ret;
+
+  GST_DEBUG_OBJECT (intersubsrc, "query");
+
+  switch (GST_QUERY_TYPE (query)) {
+    default:
+      ret = GST_BASE_SRC_CLASS (parent_class)->query (src, query);
+  }
+
+  return ret;
+}
+
+static gboolean
+gst_inter_sub_src_check_get_range (GstBaseSrc * src)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "get_range");
+
+  return FALSE;
+}
+
+static void
+gst_inter_sub_src_fixate (GstBaseSrc * src, GstCaps * caps)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "fixate");
+}
+
+static gboolean
+gst_inter_sub_src_unlock_stop (GstBaseSrc * src)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "stop");
+
+  return TRUE;
+}
+
+static gboolean
+gst_inter_sub_src_prepare_seek_segment (GstBaseSrc * src, GstEvent * seek,
+    GstSegment * segment)
+{
+  GstInterSubSrc *intersubsrc = GST_INTER_SUB_SRC (src);
+
+  GST_DEBUG_OBJECT (intersubsrc, "seek_segment");
+
+  return FALSE;
+}
diff --git a/gst/inter/gstintersubsrc.h b/gst/inter/gstintersubsrc.h
new file mode 100644
index 0000000..38f7a66
--- /dev/null
+++ b/gst/inter/gstintersubsrc.h
@@ -0,0 +1,58 @@
+/* GStreamer
+ * Copyright (C) 2011 David Schleef <ds@entropywave.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_INTER_SUB_SRC_H_
+#define _GST_INTER_SUB_SRC_H_
+
+#include <gst/base/gstbasesrc.h>
+#include "gstintersurface.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_INTER_SUB_SRC   (gst_inter_sub_src_get_type())
+#define GST_INTER_SUB_SRC(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_INTER_SUB_SRC,GstInterSubSrc))
+#define GST_INTER_SUB_SRC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_INTER_SUB_SRC,GstInterSubSrcClass))
+#define GST_IS_INTER_SUB_SRC(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_INTER_SUB_SRC))
+#define GST_IS_INTER_SUB_SRC_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_INTER_SUB_SRC))
+
+typedef struct _GstInterSubSrc GstInterSubSrc;
+typedef struct _GstInterSubSrcClass GstInterSubSrcClass;
+
+struct _GstInterSubSrc
+{
+  GstBaseSrc base_intersubsrc;
+
+  GstPad *srcpad;
+  GstInterSurface *surface;
+  char *channel;
+
+  int rate;
+  int n_frames;
+};
+
+struct _GstInterSubSrcClass
+{
+  GstBaseSrcClass base_intersubsrc_class;
+};
+
+GType gst_inter_sub_src_get_type (void);
+
+G_END_DECLS
+
+#endif
diff --git a/gst/inter/gstintersurface.c b/gst/inter/gstintersurface.c
index 545cd6f..0fc1c84 100644
--- a/gst/inter/gstintersurface.c
+++ b/gst/inter/gstintersurface.c
@@ -21,22 +21,44 @@
 #include "config.h"
 #endif
 
+#include <string.h>
+
+#include <gst/glib-compat-private.h>
 #include "gstintersurface.h"
 
-static GstInterSurface *surface;
+static GList *list;
+static GStaticMutex mutex = G_STATIC_MUTEX_INIT;
 
 
 GstInterSurface *
 gst_inter_surface_get (const char *name)
 {
-  return surface;
+  GList *g;
+  GstInterSurface *surface;
 
-}
+  g_static_mutex_lock (&mutex);
+
+  for (g = list; g; g = g_list_next (g)) {
+    surface = (GstInterSurface *) g->data;
+    if (strcmp (name, surface->name) == 0) {
+      g_static_mutex_unlock (&mutex);
+      return surface;
+    }
+  }
 
-void
-gst_inter_surface_init (void)
-{
   surface = g_malloc0 (sizeof (GstInterSurface));
+  surface->name = g_strdup (name);
   surface->mutex = g_mutex_new ();
   surface->audio_adapter = gst_adapter_new ();
+
+  list = g_list_append (list, surface);
+  g_static_mutex_unlock (&mutex);
+
+  return surface;
+}
+
+void
+gst_inter_surface_unref (GstInterSurface * surface)
+{
+
 }
diff --git a/gst/inter/gstintersurface.h b/gst/inter/gstintersurface.h
index 9244044..d8ba11f 100644
--- a/gst/inter/gstintersurface.h
+++ b/gst/inter/gstintersurface.h
@@ -30,6 +30,7 @@ typedef struct _GstInterSurface GstInterSurface;
 struct _GstInterSurface
 {
   GMutex *mutex;
+  char *name;
 
   /* video */
   GstVideoFormat format;
@@ -45,12 +46,13 @@ struct _GstInterSurface
   int n_channels;
 
   GstBuffer *video_buffer;
+  GstBuffer *sub_buffer;
   GstAdapter *audio_adapter;
 };
 
 
 GstInterSurface * gst_inter_surface_get (const char *name);
-void gst_inter_surface_init (void);
+void gst_inter_surface_unref (GstInterSurface *surface);
 
 
 G_END_DECLS
diff --git a/gst/inter/gstintertest.c b/gst/inter/gstintertest.c
index cb7b08c..269d642 100644
--- a/gst/inter/gstintertest.c
+++ b/gst/inter/gstintertest.c
@@ -1,5 +1,5 @@
 /* GstInterTest
- * Copyright (C) 2011 FIXME <fixme@example.com>
+ * Copyright (C) 2011 David Schleef <ds@schleef.org>
  * Copyright (C) 2010 Entropy Wave Inc
  *
  * Redistribution and use in source and binary forms, with or without
@@ -29,6 +29,7 @@
 #endif
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <stdlib.h>
 
 //#define GETTEXT_PACKAGE "intertest"
@@ -80,10 +81,12 @@ main (int argc, char *argv[])
   GstInterTest *intertest2;
   GMainLoop *main_loop;
 
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
-  context = g_option_context_new ("- FIXME");
+  context = g_option_context_new ("- Internal src/sink test");
   g_option_context_add_main_entries (context, entries, GETTEXT_PACKAGE);
   g_option_context_add_group (context, gst_init_get_option_group ());
   if (!g_option_context_parse (context, &argc, &argv, &error)) {
@@ -185,14 +188,14 @@ gst_inter_test_create_pipeline_vts (GstInterTest * intertest)
 
   pipe_desc = g_string_new ("");
 
-  g_string_append (pipe_desc, "videotestsrc name=source num-buffers=10000 ! ");
+  g_string_append (pipe_desc, "videotestsrc name=source num-buffers=100 ! ");
   g_string_append (pipe_desc,
       "video/x-raw-yuv,format=(fourcc)I420,width=320,height=240 ! ");
   g_string_append (pipe_desc, "timeoverlay ! ");
   g_string_append (pipe_desc, "intervideosink name=sink sync=true ");
   g_string_append (pipe_desc,
-      "audiotestsrc samplesperbuffer=1600 num-buffers=100 ! ");
-  g_string_append (pipe_desc, "interaudiosink ");
+      "audiotestsrc samplesperbuffer=1600 num-buffers=100 ! audioconvert ! ");
+  g_string_append (pipe_desc, "interaudiosink sync=true ");
 
   if (verbose)
     g_print ("pipeline: %s\n", pipe_desc->str);
@@ -229,7 +232,7 @@ gst_inter_test_create_pipeline_server (GstInterTest * intertest)
   g_string_append (pipe_desc, "intervideosrc ! queue ! ");
   g_string_append (pipe_desc, "xvimagesink name=sink ");
   g_string_append (pipe_desc, "interaudiosrc ! queue ! ");
-  g_string_append (pipe_desc, "alsasink latency-time=100000000 ");
+  g_string_append (pipe_desc, "alsasink ");
 
   if (verbose)
     g_print ("pipeline: %s\n", pipe_desc->str);
@@ -334,7 +337,7 @@ gst_inter_test_handle_paused_to_ready (GstInterTest * intertest)
 static void
 gst_inter_test_handle_ready_to_null (GstInterTest * intertest)
 {
-  g_main_loop_quit (intertest->main_loop);
+  //g_main_loop_quit (intertest->main_loop);
 
 }
 
diff --git a/gst/inter/gstintervideosink.c b/gst/inter/gstintervideosink.c
index 43349f9..554bf1a 100644
--- a/gst/inter/gstintervideosink.c
+++ b/gst/inter/gstintervideosink.c
@@ -19,14 +19,20 @@
 /**
  * SECTION:element-gstintervideosink
  *
- * The intervideosink element does FIXME stuff.
+ * The intervideosink element is a video sink element.  It is used
+ * in connection with an intervideosrc element in a different pipeline,
+ * similar to interaudiosink and interaudiosrc.
  *
  * <refsect2>
  * <title>Example launch line</title>
  * |[
- * gst-launch -v fakesrc ! intervideosink ! FIXME ! fakesink
+ * gst-launch -v videotestsrc ! intervideosink
  * ]|
- * FIXME Describe what the pipeline does.
+ * 
+ * The intervideosink element cannot be used effectively with gst-launch,
+ * as it requires a second pipeline in the application to send video to.
+ * See the gstintertest.c example in the gst-plugins-bad source code for
+ * more details.
  * </refsect2>
  */
 
@@ -76,7 +82,8 @@ static gboolean gst_inter_video_sink_unlock_stop (GstBaseSink * sink);
 
 enum
 {
-  PROP_0
+  PROP_0,
+  PROP_CHANNEL
 };
 
 /* pad templates */
@@ -106,8 +113,11 @@ gst_inter_video_sink_base_init (gpointer g_class)
   gst_element_class_add_static_pad_template (element_class,
       &gst_inter_video_sink_sink_template);
 
-  gst_element_class_set_details_simple (element_class, "FIXME Long name",
-      "Generic", "FIXME Description", "FIXME <fixme@example.com>");
+  gst_element_class_set_details_simple (element_class,
+      "Internal video sink",
+      "Sink/Video",
+      "Virtual video sink for internal process communication",
+      "David Schleef <ds@schleef.org>");
 }
 
 static void
@@ -144,22 +154,30 @@ gst_inter_video_sink_class_init (GstInterVideoSinkClass * klass)
   base_sink_class->unlock_stop =
       GST_DEBUG_FUNCPTR (gst_inter_video_sink_unlock_stop);
 
+  g_object_class_install_property (gobject_class, PROP_CHANNEL,
+      g_param_spec_string ("channel", "Channel",
+          "Channel name to match inter src and sink elements",
+          "default", G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 }
 
 static void
 gst_inter_video_sink_init (GstInterVideoSink * intervideosink,
     GstInterVideoSinkClass * intervideosink_class)
 {
-  intervideosink->surface = gst_inter_surface_get ("default");
+  intervideosink->channel = g_strdup ("default");
 }
 
 void
 gst_inter_video_sink_set_property (GObject * object, guint property_id,
     const GValue * value, GParamSpec * pspec)
 {
-  /* GstInterVideoSink *intervideosink = GST_INTER_VIDEO_SINK (object); */
+  GstInterVideoSink *intervideosink = GST_INTER_VIDEO_SINK (object);
 
   switch (property_id) {
+    case PROP_CHANNEL:
+      g_free (intervideosink->channel);
+      intervideosink->channel = g_value_dup_string (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -170,9 +188,12 @@ void
 gst_inter_video_sink_get_property (GObject * object, guint property_id,
     GValue * value, GParamSpec * pspec)
 {
-  /* GstInterVideoSink *intervideosink = GST_INTER_VIDEO_SINK (object); */
+  GstInterVideoSink *intervideosink = GST_INTER_VIDEO_SINK (object);
 
   switch (property_id) {
+    case PROP_CHANNEL:
+      g_value_set_string (value, intervideosink->channel);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -192,9 +213,10 @@ gst_inter_video_sink_dispose (GObject * object)
 void
 gst_inter_video_sink_finalize (GObject * object)
 {
-  /* GstInterVideoSink *intervideosink = GST_INTER_VIDEO_SINK (object); */
+  GstInterVideoSink *intervideosink = GST_INTER_VIDEO_SINK (object);
 
   /* clean up object here */
+  g_free (intervideosink->channel);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
@@ -248,6 +270,9 @@ gst_inter_video_sink_get_times (GstBaseSink * sink, GstBuffer * buffer,
 static gboolean
 gst_inter_video_sink_start (GstBaseSink * sink)
 {
+  GstInterVideoSink *intervideosink = GST_INTER_VIDEO_SINK (sink);
+
+  intervideosink->surface = gst_inter_surface_get (intervideosink->channel);
 
   return TRUE;
 }
@@ -264,6 +289,9 @@ gst_inter_video_sink_stop (GstBaseSink * sink)
   intervideosink->surface->video_buffer = NULL;
   g_mutex_unlock (intervideosink->surface->mutex);
 
+  gst_inter_surface_unref (intervideosink->surface);
+  intervideosink->surface = NULL;
+
   return TRUE;
 }
 
diff --git a/gst/inter/gstintervideosink.h b/gst/inter/gstintervideosink.h
index 5b02efe..5e421c6 100644
--- a/gst/inter/gstintervideosink.h
+++ b/gst/inter/gstintervideosink.h
@@ -39,6 +39,7 @@ struct _GstInterVideoSink
   GstBaseSink base_intervideosink;
 
   GstInterSurface *surface;
+  char *channel;
 
   int fps_n;
   int fps_d;
diff --git a/gst/inter/gstintervideosrc.c b/gst/inter/gstintervideosrc.c
index 2f5dbba..e58cb7f 100644
--- a/gst/inter/gstintervideosrc.c
+++ b/gst/inter/gstintervideosrc.c
@@ -19,14 +19,18 @@
 /**
  * SECTION:element-gstintervideosrc
  *
- * The intervideosrc element does FIXME stuff.
+ * The intervideosrc element is a video source element.  It is used
+ * in connection with a intervideosink element in a different pipeline,
+ * similar to interaudiosink and interaudiosrc.
  *
  * <refsect2>
  * <title>Example launch line</title>
  * |[
- * gst-launch -v fakesrc ! intervideosrc ! FIXME ! fakesink
+ * gst-launch -v intervideosrc ! queue ! xvimagesink
  * ]|
- * FIXME Describe what the pipeline does.
+ * 
+ * The intersubsrc element cannot be used effectively with gst-launch,
+ * as it requires a second pipeline in the application to send subtitles.
  * </refsect2>
  */
 
@@ -80,7 +84,8 @@ gst_inter_video_src_prepare_seek_segment (GstBaseSrc * src, GstEvent * seek,
 
 enum
 {
-  PROP_0
+  PROP_0,
+  PROP_CHANNEL
 };
 
 /* pad templates */
@@ -110,8 +115,11 @@ gst_inter_video_src_base_init (gpointer g_class)
   gst_element_class_add_static_pad_template (element_class,
       &gst_inter_video_src_src_template);
 
-  gst_element_class_set_details_simple (element_class, "FIXME Long name",
-      "Generic", "FIXME Description", "FIXME <fixme@example.com>");
+  gst_element_class_set_details_simple (element_class,
+      "Internal video source",
+      "Source/Video",
+      "Virtual video source for internal process communication",
+      "David Schleef <ds@schleef.org>");
 }
 
 static void
@@ -156,6 +164,10 @@ gst_inter_video_src_class_init (GstInterVideoSrcClass * klass)
     base_src_class->prepare_seek_segment =
         GST_DEBUG_FUNCPTR (gst_inter_video_src_prepare_seek_segment);
 
+  g_object_class_install_property (gobject_class, PROP_CHANNEL,
+      g_param_spec_string ("channel", "Channel",
+          "Channel name to match inter src and sink elements",
+          "default", G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
 }
 
@@ -166,16 +178,20 @@ gst_inter_video_src_init (GstInterVideoSrc * intervideosrc,
   gst_base_src_set_format (GST_BASE_SRC (intervideosrc), GST_FORMAT_TIME);
   gst_base_src_set_live (GST_BASE_SRC (intervideosrc), TRUE);
 
-  intervideosrc->surface = gst_inter_surface_get ("default");
+  intervideosrc->channel = g_strdup ("default");
 }
 
 void
 gst_inter_video_src_set_property (GObject * object, guint property_id,
     const GValue * value, GParamSpec * pspec)
 {
-  /* GstInterVideoSrc *intervideosrc = GST_INTER_VIDEO_SRC (object); */
+  GstInterVideoSrc *intervideosrc = GST_INTER_VIDEO_SRC (object);
 
   switch (property_id) {
+    case PROP_CHANNEL:
+      g_free (intervideosrc->channel);
+      intervideosrc->channel = g_value_dup_string (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -186,9 +202,12 @@ void
 gst_inter_video_src_get_property (GObject * object, guint property_id,
     GValue * value, GParamSpec * pspec)
 {
-  /* GstInterVideoSrc *intervideosrc = GST_INTER_VIDEO_SRC (object); */
+  GstInterVideoSrc *intervideosrc = GST_INTER_VIDEO_SRC (object);
 
   switch (property_id) {
+    case PROP_CHANNEL:
+      g_value_set_string (value, intervideosrc->channel);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -208,9 +227,10 @@ gst_inter_video_src_dispose (GObject * object)
 void
 gst_inter_video_src_finalize (GObject * object)
 {
-  /* GstInterVideoSrc *intervideosrc = GST_INTER_VIDEO_SRC (object); */
+  GstInterVideoSrc *intervideosrc = GST_INTER_VIDEO_SRC (object);
 
   /* clean up object here */
+  g_free (intervideosrc->channel);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
@@ -279,6 +299,8 @@ gst_inter_video_src_start (GstBaseSrc * src)
 
   GST_DEBUG_OBJECT (intervideosrc, "start");
 
+  intervideosrc->surface = gst_inter_surface_get (intervideosrc->channel);
+
   return TRUE;
 }
 
@@ -289,6 +311,9 @@ gst_inter_video_src_stop (GstBaseSrc * src)
 
   GST_DEBUG_OBJECT (intervideosrc, "stop");
 
+  gst_inter_surface_unref (intervideosrc->surface);
+  intervideosrc->surface = NULL;
+
   return TRUE;
 }
 
@@ -343,10 +368,16 @@ static gboolean
 gst_inter_video_src_event (GstBaseSrc * src, GstEvent * event)
 {
   GstInterVideoSrc *intervideosrc = GST_INTER_VIDEO_SRC (src);
+  gboolean ret;
 
   GST_DEBUG_OBJECT (intervideosrc, "event");
 
-  return TRUE;
+  switch (GST_EVENT_TYPE (event)) {
+    default:
+      ret = GST_BASE_SRC_CLASS (parent_class)->event (src, event);
+  }
+
+  return ret;
 }
 
 static GstFlowReturn
@@ -391,15 +422,6 @@ gst_inter_video_src_create (GstBaseSrc * src, guint64 offset, guint size,
             intervideosrc->width) *
         gst_video_format_get_component_height (intervideosrc->format, 1,
             intervideosrc->height));
-
-#if 0
-    {
-      int i;
-      for (i = 0; i < 10000; i++) {
-        data[i] = g_random_int () & 0xff;
-      }
-    }
-#endif
   }
 
   buffer = gst_buffer_make_metadata_writable (buffer);
@@ -441,10 +463,16 @@ static gboolean
 gst_inter_video_src_query (GstBaseSrc * src, GstQuery * query)
 {
   GstInterVideoSrc *intervideosrc = GST_INTER_VIDEO_SRC (src);
+  gboolean ret;
 
   GST_DEBUG_OBJECT (intervideosrc, "query");
 
-  return TRUE;
+  switch (GST_QUERY_TYPE (query)) {
+    default:
+      ret = GST_BASE_SRC_CLASS (parent_class)->query (src, query);
+  }
+
+  return ret;
 }
 
 static gboolean
diff --git a/gst/inter/gstintervideosrc.h b/gst/inter/gstintervideosrc.h
index e7a3cd0..100c214 100644
--- a/gst/inter/gstintervideosrc.h
+++ b/gst/inter/gstintervideosrc.h
@@ -41,6 +41,8 @@ struct _GstInterVideoSrc
 
   GstInterSurface *surface;
 
+  char *channel;
+
   GstVideoFormat format;
   int fps_n;
   int fps_d;
diff --git a/gst/jp2kdecimator/jp2kcodestream.c b/gst/jp2kdecimator/jp2kcodestream.c
index 6fb2878..a532168 100644
--- a/gst/jp2kdecimator/jp2kcodestream.c
+++ b/gst/jp2kdecimator/jp2kcodestream.c
@@ -828,7 +828,11 @@ write_plt (GstJP2kDecimator * self, GstByteWriter * writer,
 
   plt_end_pos = gst_byte_writer_get_pos (writer);
   gst_byte_writer_set_pos (writer, plt_start_pos);
-  gst_byte_writer_put_uint16_be (writer, plt_end_pos - plt_start_pos);
+  if (!gst_byte_writer_put_uint16_be (writer, plt_end_pos - plt_start_pos)) {
+    GST_ERROR_OBJECT (self, "Not enough space to write plt size");
+    return GST_FLOW_ERROR;
+  }
+
   gst_byte_writer_set_pos (writer, plt_end_pos);
 
   return GST_FLOW_OK;
@@ -1328,9 +1332,9 @@ write_packet (GstJP2kDecimator * self, GstByteWriter * writer,
   }
 
   if (packet->sop) {
-    gst_byte_writer_put_uint16_be (writer, MARKER_SOP);
-    gst_byte_writer_put_uint16_be (writer, 4);
-    gst_byte_writer_put_uint16_be (writer, packet->seqno);
+    gst_byte_writer_put_uint16_be_unchecked (writer, MARKER_SOP);
+    gst_byte_writer_put_uint16_be_unchecked (writer, 4);
+    gst_byte_writer_put_uint16_be_unchecked (writer, packet->seqno);
   }
 
   if (packet->data) {
@@ -1696,7 +1700,7 @@ write_main_header (GstJP2kDecimator * self, GstByteWriter * writer,
     return GST_FLOW_ERROR;
   }
 
-  gst_byte_writer_put_uint16_be (writer, MARKER_SOC);
+  gst_byte_writer_put_uint16_be_unchecked (writer, MARKER_SOC);
 
   ret = write_siz (self, writer, &header->siz);
   if (ret != GST_FLOW_OK)
diff --git a/gst/liveadder/Makefile.am b/gst/liveadder/Makefile.am
index 4fe8e29..0bbeff9 100644
--- a/gst/liveadder/Makefile.am
+++ b/gst/liveadder/Makefile.am
@@ -1,7 +1,7 @@
 plugin_LTLIBRARIES = libgstliveadder.la
 
 libgstliveadder_la_SOURCES = liveadder.c
-libgstliveadder_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS)
+libgstliveadder_la_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS)
 libgstliveadder_la_LIBADD = \
 	$(GST_PLUGINS_BASE_LIBS) -lgstaudio-@GST_MAJORMINOR@ \
 	$(GST_BASE_LIBS) $(GST_LIBS)
diff --git a/gst/liveadder/liveadder.c b/gst/liveadder/liveadder.c
index 205bd02..f9a39e7 100644
--- a/gst/liveadder/liveadder.c
+++ b/gst/liveadder/liveadder.c
@@ -44,6 +44,7 @@
 
 #include "liveadder.h"
 
+#include <gst/glib-compat-private.h>
 #include <gst/audio/audio.h>
 
 #include <string.h>
diff --git a/gst/mpegdemux/flutspmtinfo.c b/gst/mpegdemux/flutspmtinfo.c
index 65402e7..5b25e25 100644
--- a/gst/mpegdemux/flutspmtinfo.c
+++ b/gst/mpegdemux/flutspmtinfo.c
@@ -45,6 +45,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/gst.h>
 
 #include "flutspmtinfo.h"
diff --git a/gst/mpegdemux/flutspmtstreaminfo.c b/gst/mpegdemux/flutspmtstreaminfo.c
index 7ab5ba4..95177f8 100644
--- a/gst/mpegdemux/flutspmtstreaminfo.c
+++ b/gst/mpegdemux/flutspmtstreaminfo.c
@@ -45,6 +45,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/gst.h>
 
 #include "flutspmtstreaminfo.h"
diff --git a/gst/mpegdemux/gstmpegdemux.c b/gst/mpegdemux/gstmpegdemux.c
index 8359285..c742a95 100644
--- a/gst/mpegdemux/gstmpegdemux.c
+++ b/gst/mpegdemux/gstmpegdemux.c
@@ -46,6 +46,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 
 #include "gstmpegdefs.h"
@@ -60,6 +64,8 @@
 #define SEGMENT_THRESHOLD (300*GST_MSECOND)
 #define VIDEO_SEGMENT_THRESHOLD (500*GST_MSECOND)
 
+#define DURATION_SCAN_LIMIT         4 * 1024 * 1024
+
 typedef enum
 {
   SCAN_SCR,
@@ -154,9 +160,9 @@ static GstStateChangeReturn gst_flups_demux_change_state (GstElement * element,
     GstStateChange transition);
 
 static inline gboolean gst_flups_demux_scan_forward_ts (GstFluPSDemux * demux,
-    guint64 * pos, SCAN_MODE mode, guint64 * rts);
+    guint64 * pos, SCAN_MODE mode, guint64 * rts, gint limit);
 static inline gboolean gst_flups_demux_scan_backward_ts (GstFluPSDemux * demux,
-    guint64 * pos, SCAN_MODE mode, guint64 * rts);
+    guint64 * pos, SCAN_MODE mode, guint64 * rts, gint limit);
 
 static inline void gst_flups_demux_send_segment_updates (GstFluPSDemux * demux,
     GstClockTime new_time);
@@ -646,7 +652,7 @@ gst_flups_demux_handle_dvd_event (GstFluPSDemux * demux, GstEvent * event)
     /* Store the language codes event on the element, then iterate over the 
      * streams it specifies and retrieve them. The stream creation code then 
      * creates the pad appropriately and sends tag events as needed */
-    p_ev = &demux->lang_codes, event;
+    p_ev = &demux->lang_codes;
     gst_event_replace (p_ev, event);
 
     GST_DEBUG_OBJECT (demux, "Handling language codes event");
@@ -1051,19 +1057,22 @@ gst_flups_demux_do_seek (GstFluPSDemux * demux, GstSegment * seeksegment)
       MIN (gst_util_uint64_scale (scr - demux->first_scr, scr_rate_n,
           scr_rate_d), demux->sink_segment.stop);
 
-  found = gst_flups_demux_scan_forward_ts (demux, &offset, SCAN_SCR, &fscr);
+  found = gst_flups_demux_scan_forward_ts (demux, &offset, SCAN_SCR, &fscr, 0);
   if (!found) {
-    found = gst_flups_demux_scan_backward_ts (demux, &offset, SCAN_SCR, &fscr);
+    found =
+        gst_flups_demux_scan_backward_ts (demux, &offset, SCAN_SCR, &fscr, 0);
   }
 
   while (found && fscr < scr) {
     offset++;
-    found = gst_flups_demux_scan_forward_ts (demux, &offset, SCAN_SCR, &fscr);
+    found =
+        gst_flups_demux_scan_forward_ts (demux, &offset, SCAN_SCR, &fscr, 0);
   }
 
   while (found && fscr > scr && offset > 0) {
     offset--;
-    found = gst_flups_demux_scan_backward_ts (demux, &offset, SCAN_SCR, &fscr);
+    found =
+        gst_flups_demux_scan_backward_ts (demux, &offset, SCAN_SCR, &fscr, 0);
   }
 
   GST_INFO_OBJECT (demux, "doing seek at offset %" G_GUINT64_FORMAT
@@ -2382,7 +2391,7 @@ beach:
 
 static inline gboolean
 gst_flups_demux_scan_forward_ts (GstFluPSDemux * demux, guint64 * pos,
-    SCAN_MODE mode, guint64 * rts)
+    SCAN_MODE mode, guint64 * rts, gint limit)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   GstBuffer *buffer = NULL;
@@ -2392,12 +2401,15 @@ gst_flups_demux_scan_forward_ts (GstFluPSDemux * demux, guint64 * pos,
   guint scan_sz = (mode == SCAN_SCR ? SCAN_SCR_SZ : SCAN_PTS_SZ);
   guint cursor, to_read = BLOCK_SZ;
   guint8 *data;
-  guint end_scan;
+  guint end_scan, data_size;
 
   do {
     if (offset + scan_sz > demux->sink_segment.stop)
       return FALSE;
 
+    if (limit && offset > *pos + limit)
+      return FALSE;
+
     if (offset + to_read > demux->sink_segment.stop)
       to_read = demux->sink_segment.stop - offset;
 
@@ -2406,8 +2418,14 @@ gst_flups_demux_scan_forward_ts (GstFluPSDemux * demux, guint64 * pos,
     if (G_UNLIKELY (ret != GST_FLOW_OK))
       return FALSE;
 
+    /* may get a short buffer at the end of the file */
+    data_size = GST_BUFFER_SIZE (buffer);
+    if (G_UNLIKELY (data_size <= scan_sz))
+      return FALSE;
+
     data = GST_BUFFER_DATA (buffer);
-    end_scan = GST_BUFFER_SIZE (buffer) - scan_sz;
+    end_scan = data_size - scan_sz;
+
     /* scan the block */
     for (cursor = 0; !found && cursor <= end_scan; cursor++) {
       found = gst_flups_demux_scan_ts (demux, data++, mode, &ts);
@@ -2429,7 +2447,7 @@ gst_flups_demux_scan_forward_ts (GstFluPSDemux * demux, guint64 * pos,
 
 static inline gboolean
 gst_flups_demux_scan_backward_ts (GstFluPSDemux * demux, guint64 * pos,
-    SCAN_MODE mode, guint64 * rts)
+    SCAN_MODE mode, guint64 * rts, gint limit)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   GstBuffer *buffer = NULL;
@@ -2438,13 +2456,16 @@ gst_flups_demux_scan_backward_ts (GstFluPSDemux * demux, guint64 * pos,
   guint64 ts = 0;
   guint scan_sz = (mode == SCAN_SCR ? SCAN_SCR_SZ : SCAN_PTS_SZ);
   guint cursor, to_read = BLOCK_SZ;
-  guint start_scan;
+  guint start_scan, data_size;
   guint8 *data;
 
   do {
     if (offset < scan_sz - 1)
       return FALSE;
 
+    if (limit && offset < *pos - limit)
+      return FALSE;
+
     if (offset > BLOCK_SZ)
       offset -= BLOCK_SZ;
     else {
@@ -2456,8 +2477,14 @@ gst_flups_demux_scan_backward_ts (GstFluPSDemux * demux, guint64 * pos,
     if (G_UNLIKELY (ret != GST_FLOW_OK))
       return FALSE;
 
-    start_scan = GST_BUFFER_SIZE (buffer) - scan_sz;
+    /* may get a short buffer at the end of the file */
+    data_size = GST_BUFFER_SIZE (buffer);
+    if (G_UNLIKELY (data_size <= scan_sz))
+      return FALSE;
+
+    start_scan = data_size - scan_sz;
     data = GST_BUFFER_DATA (buffer) + start_scan;
+
     /* scan the block */
     for (cursor = (start_scan + 1); !found && cursor > 0; cursor--) {
       found = gst_flups_demux_scan_ts (demux, data--, mode, &ts);
@@ -2510,7 +2537,8 @@ gst_flups_sink_get_duration (GstFluPSDemux * demux)
   /* Scan for notorious SCR and PTS to calculate the duration */
   /* scan for first SCR in the stream */
   offset = demux->sink_segment.start;
-  gst_flups_demux_scan_forward_ts (demux, &offset, SCAN_SCR, &demux->first_scr);
+  gst_flups_demux_scan_forward_ts (demux, &offset, SCAN_SCR, &demux->first_scr,
+      DURATION_SCAN_LIMIT);
   GST_DEBUG_OBJECT (demux, "First SCR: %" G_GINT64_FORMAT " %" GST_TIME_FORMAT
       " in packet starting at %" G_GUINT64_FORMAT,
       demux->first_scr, GST_TIME_ARGS (MPEGTIME_TO_GSTTIME (demux->first_scr)),
@@ -2518,7 +2546,8 @@ gst_flups_sink_get_duration (GstFluPSDemux * demux)
   demux->first_scr_offset = offset;
   /* scan for last SCR in the stream */
   offset = demux->sink_segment.stop;
-  gst_flups_demux_scan_backward_ts (demux, &offset, SCAN_SCR, &demux->last_scr);
+  gst_flups_demux_scan_backward_ts (demux, &offset, SCAN_SCR,
+      &demux->last_scr, 0);
   GST_DEBUG_OBJECT (demux, "Last SCR: %" G_GINT64_FORMAT " %" GST_TIME_FORMAT
       " in packet starting at %" G_GUINT64_FORMAT,
       demux->last_scr, GST_TIME_ARGS (MPEGTIME_TO_GSTTIME (demux->last_scr)),
@@ -2526,7 +2555,8 @@ gst_flups_sink_get_duration (GstFluPSDemux * demux)
   demux->last_scr_offset = offset;
   /* scan for first PTS in the stream */
   offset = demux->sink_segment.start;
-  gst_flups_demux_scan_forward_ts (demux, &offset, SCAN_PTS, &demux->first_pts);
+  gst_flups_demux_scan_forward_ts (demux, &offset, SCAN_PTS, &demux->first_pts,
+      DURATION_SCAN_LIMIT);
   GST_DEBUG_OBJECT (demux, "First PTS: %" G_GINT64_FORMAT " %" GST_TIME_FORMAT
       " in packet starting at %" G_GUINT64_FORMAT,
       demux->first_pts, GST_TIME_ARGS (MPEGTIME_TO_GSTTIME (demux->first_pts)),
@@ -2535,7 +2565,7 @@ gst_flups_sink_get_duration (GstFluPSDemux * demux)
     /* scan for last PTS in the stream */
     offset = demux->sink_segment.stop;
     gst_flups_demux_scan_backward_ts (demux, &offset, SCAN_PTS,
-        &demux->last_pts);
+        &demux->last_pts, DURATION_SCAN_LIMIT);
     GST_DEBUG_OBJECT (demux,
         "Last PTS: %" G_GINT64_FORMAT " %" GST_TIME_FORMAT
         " in packet starting at %" G_GUINT64_FORMAT, demux->last_pts,
@@ -2548,7 +2578,7 @@ gst_flups_sink_get_duration (GstFluPSDemux * demux)
     offset = demux->first_scr_offset;
     for (i = 0; i < 10; i++) {
       offset++;
-      gst_flups_demux_scan_forward_ts (demux, &offset, SCAN_SCR, &scr);
+      gst_flups_demux_scan_forward_ts (demux, &offset, SCAN_SCR, &scr, 0);
       if (scr < demux->last_scr) {
         demux->first_scr = scr;
         demux->first_scr_offset = offset;
diff --git a/gst/mpegdemux/gstmpegtsdemux.c b/gst/mpegdemux/gstmpegtsdemux.c
index 012c1cc..78bf656 100644
--- a/gst/mpegdemux/gstmpegtsdemux.c
+++ b/gst/mpegdemux/gstmpegtsdemux.c
@@ -45,6 +45,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 #include <stdlib.h>
 
@@ -3547,7 +3551,7 @@ gboolean
 gst_mpegts_demux_plugin_init (GstPlugin * plugin)
 {
   if (!gst_element_register (plugin, "mpegtsdemux",
-          GST_RANK_PRIMARY, GST_TYPE_MPEGTS_DEMUX))
+          GST_RANK_SECONDARY, GST_TYPE_MPEGTS_DEMUX))
     return FALSE;
 
   return TRUE;
diff --git a/gst/mpegdemux/mpegtspacketizer.c b/gst/mpegdemux/mpegtspacketizer.c
index ed1d0ac..089254d 100644
--- a/gst/mpegdemux/mpegtspacketizer.c
+++ b/gst/mpegdemux/mpegtspacketizer.c
@@ -22,6 +22,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <string.h>
 
 #include "mpegtspacketizer.h"
diff --git a/gst/mpegdemux/mpegtsparse.c b/gst/mpegdemux/mpegtsparse.c
index 273b3ed..af50984 100644
--- a/gst/mpegdemux/mpegtsparse.c
+++ b/gst/mpegdemux/mpegtsparse.c
@@ -222,11 +222,9 @@ mpegts_parse_base_init (gpointer klass)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 
-  gst_element_class_add_static_pad_template (element_class,
-      &sink_template);
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
   gst_element_class_add_static_pad_template (element_class, &src_template);
-  gst_element_class_add_static_pad_template (element_class,
-      &program_template);
+  gst_element_class_add_static_pad_template (element_class, &program_template);
 
   gst_element_class_set_details_simple (element_class,
       "MPEG transport stream parser", "Codec/Parser",
@@ -1041,7 +1039,7 @@ mpegts_parse_apply_pmt (MpegTSParse * parse,
   MpegTSParseProgram *program;
   guint program_number;
   guint pcr_pid;
-  guint pid;
+  guint pid = 0;
   guint stream_type;
   GstStructure *stream;
   gint i;
diff --git a/gst/mpegpsmux/mpegpsmux.c b/gst/mpegpsmux/mpegpsmux.c
index e7b0946..947bdb8 100644
--- a/gst/mpegpsmux/mpegpsmux.c
+++ b/gst/mpegpsmux/mpegpsmux.c
@@ -98,7 +98,7 @@ static gboolean new_packet_cb (guint8 * data, guint len, void *user_data);
 static void release_buffer_cb (guint8 * data, void *user_data);
 
 static gboolean mpegpsdemux_prepare_srcpad (MpegPsMux * mux);
-static GstFlowReturn mpegpsmux_collected (GstCollectPads * pads,
+static GstFlowReturn mpegpsmux_collected (GstCollectPads2 * pads,
     MpegPsMux * mux);
 static GstPad *mpegpsmux_request_new_pad (GstElement * element,
     GstPadTemplate * templ, const gchar * name);
@@ -153,9 +153,9 @@ mpegpsmux_init (MpegPsMux * mux, MpegPsMuxClass * g_class)
   gst_pad_use_fixed_caps (mux->srcpad);
   gst_element_add_pad (GST_ELEMENT (mux), mux->srcpad);
 
-  mux->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (mux->collect,
-      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (mpegpsmux_collected), mux);
+  mux->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (mux->collect,
+      (GstCollectPads2Function) GST_DEBUG_FUNCPTR (mpegpsmux_collected), mux);
 
   mux->psmux = psmux_new ();
   psmux_set_write_func (mux->psmux, new_packet_cb, mux);
@@ -371,7 +371,7 @@ mpegpsmux_create_streams (MpegPsMux * mux)
 
   /* Create the streams */
   while (walk) {
-    GstCollectData *c_data = (GstCollectData *) walk->data;
+    GstCollectData2 *c_data = (GstCollectData2 *) walk->data;
     MpegPsPadData *ps_data = (MpegPsPadData *) walk->data;
 
     walk = g_slist_next (walk);
@@ -396,11 +396,11 @@ mpegpsmux_choose_best_stream (MpegPsMux * mux)
   /* Choose from which stream to mux with */
 
   MpegPsPadData *best = NULL;
-  GstCollectData *c_best = NULL;
+  GstCollectData2 *c_best = NULL;
   GSList *walk;
 
   for (walk = mux->collect->data; walk != NULL; walk = g_slist_next (walk)) {
-    GstCollectData *c_data = (GstCollectData *) walk->data;
+    GstCollectData2 *c_data = (GstCollectData2 *) walk->data;
     MpegPsPadData *ps_data = (MpegPsPadData *) walk->data;
 
     if (ps_data->eos == FALSE) {
@@ -408,7 +408,7 @@ mpegpsmux_choose_best_stream (MpegPsMux * mux)
         GstBuffer *buf;
 
         ps_data->queued_buf = buf =
-            gst_collect_pads_peek (mux->collect, c_data);
+            gst_collect_pads2_peek (mux->collect, c_data);
 
         if (buf != NULL) {
           if (ps_data->prepare_func) {
@@ -469,7 +469,7 @@ mpegpsmux_choose_best_stream (MpegPsMux * mux)
     }
   }
   if (c_best) {
-    gst_buffer_unref (gst_collect_pads_pop (mux->collect, c_best));
+    gst_buffer_unref (gst_collect_pads2_pop (mux->collect, c_best));
   }
 
   return best;
@@ -490,7 +490,7 @@ mpegpsmux_push_gop_list (MpegPsMux * mux)
 }
 
 static GstFlowReturn
-mpegpsmux_collected (GstCollectPads * pads, MpegPsMux * mux)
+mpegpsmux_collected (GstCollectPads2 * pads, MpegPsMux * mux)
 {
   /* main muxing function */
 
@@ -597,7 +597,7 @@ mpegpsmux_request_new_pad (GstElement * element,
 
   pad = gst_pad_new_from_template (templ, name);
 
-  pad_data = (MpegPsPadData *) gst_collect_pads_add_pad (mux->collect, pad,
+  pad_data = (MpegPsPadData *) gst_collect_pads2_add_pad (mux->collect, pad,
       sizeof (MpegPsPadData));
   if (pad_data == NULL)
     goto pad_failure;
@@ -614,7 +614,7 @@ mpegpsmux_request_new_pad (GstElement * element,
 could_not_add:
   GST_ELEMENT_ERROR (element, STREAM, FAILED,
       ("Internal data stream error."), ("Could not add pad to element"));
-  gst_collect_pads_remove_pad (mux->collect, pad);
+  gst_collect_pads2_remove_pad (mux->collect, pad);
   gst_object_unref (pad);
   return NULL;
 pad_failure:
@@ -649,7 +649,7 @@ mpegpsmux_release_pad (GstElement * element, GstPad * pad)
     mux->video_stream_id = 0;
   GST_OBJECT_UNLOCK (pad);
 
-  gst_collect_pads_remove_pad (mux->collect, pad);
+  gst_collect_pads2_remove_pad (mux->collect, pad);
 }
 
 static void
@@ -763,12 +763,12 @@ mpegpsmux_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_NULL_TO_READY:
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (mux->collect);
+      gst_collect_pads2_start (mux->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_collect_pads_stop (mux->collect);
+      gst_collect_pads2_stop (mux->collect);
       break;
     case GST_STATE_CHANGE_READY_TO_NULL:
       break;
diff --git a/gst/mpegpsmux/mpegpsmux.h b/gst/mpegpsmux/mpegpsmux.h
index 6d994f4..69de48a 100644
--- a/gst/mpegpsmux/mpegpsmux.h
+++ b/gst/mpegpsmux/mpegpsmux.h
@@ -46,7 +46,7 @@
 #define __MPEGPSMUX_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 #include <gst/base/gstadapter.h>
 
 G_BEGIN_DECLS
@@ -70,7 +70,7 @@ struct MpegPsMux {
 
   guint video_stream_id;   /* stream id of primary video stream */
 
-  GstCollectPads *collect; /* pads collector */
+  GstCollectPads2 *collect; /* pads collector */
 
   PsMux *psmux;
 
@@ -88,7 +88,7 @@ struct MpegPsMuxClass  {
 };
 
 struct MpegPsPadData {
-  GstCollectData collect; /* Parent */
+  GstCollectData2 collect; /* Parent */
 
   guint8 stream_id;
   guint8 stream_id_ext; 
diff --git a/gst/mpegtsdemux/Makefile.am b/gst/mpegtsdemux/Makefile.am
index 55b57d9..ced0eac 100644
--- a/gst/mpegtsdemux/Makefile.am
+++ b/gst/mpegtsdemux/Makefile.am
@@ -6,7 +6,6 @@ libgstmpegtsdemux_la_SOURCES = \
 	mpegtsbase.c	\
 	mpegtspacketizer.c \
 	mpegtsparse.c \
-	payload_parsers.c \
 	tsdemux.c	\
 	pesparse.c
 
@@ -25,7 +24,6 @@ noinst_HEADERS = \
 	mpegtsbase.h	\
 	mpegtspacketizer.h \
 	mpegtsparse.h \
-	payload_parsers.h \
 	tsdemux.h	\
 	pesparse.h
 
diff --git a/gst/mpegtsdemux/TODO b/gst/mpegtsdemux/TODO
index 66e1d5f..d4d2563 100644
--- a/gst/mpegtsdemux/TODO
+++ b/gst/mpegtsdemux/TODO
@@ -1,35 +1,30 @@
 tsdemux/tsparse TODO
 --------------------
 
-* clock for live streams
-  In order for playback to happen at the same rate as on the producer,
-  we need to estimate the remote clock based on capture time and PCR
-  values.
-  For this estimation to be as accurate as possible, the capture time
-  needs to happen on the sources.
-    => Ensure live sources actually timestamp their buffers
-  Once we have accurate timestamps, we can use an algorithm to
-  calculate the PCR/local-clock skew.
-    => Use the EPTLA algorithm as used in -good/rtp/rtpmanager/
-     gstrtpjitterbuffer
-
-* Seeking
-  => Split out in a separate file/object. It is polluting tsdemux for
-  code readability/clarity.
-
-* Perfomance : Creation/Destruction of buffers is slow
-  * => This is due to g_type_instance_create using a dogslow rwlock
-  which take up to 50% of gst_adapter_take_buffer()
-  => Bugzilla #585375 (performance and contention problems)
-
-* mpegtspacketizer
-  * offset/timestamp of incoming buffers need to be carried on to the
-  sub-buffers in order for several demuxer features to work correctly.
+* Perfomance
+  * Bufferlist : Creating/Destroying very small buffers is too
+  costly. Switch to pre-/re-allocating outgoing buffers in which we
+  copy the data. 
+  * Adapter : Use gst_adapter_peek()/_flush() instead of constantly
+  creating buffers.
+
+* Latency
+  * Calculate the actual latency instead of returning a fixed
+  value. The latency (for live streams) is the difference between the
+  currently inputted buffer timestamp (can be stored in the
+  packetizer) and the buffer we're pushing out.
+  This value should be reported/updated (leave a bit of extra margin
+  in addition to the calculated value).
 
 * mpegtsparser
-  * SERIOUS room for improvement performance-wise (see callgrind)
-
+  * SERIOUS room for improvement performance-wise (see callgrind),
+  mostly related to performance issues mentionned above.
 
+* Random-access seeking
+  * Do minimal parsing of video headers to detect keyframes and use
+  that to compute the keyframe intervals. Use that interval to offset
+  the seek position in order to maximize the chance of pushing out the
+  requested frames. 
 
 
 Synchronization, Scheduling and Timestamping
@@ -50,6 +45,9 @@ pay extra attention to the outgoing NEWSEGMENT event and buffer
 timestamps in order to guarantee proper playback and synchronization
 of the stream.
 
+  In the following, 'timestamps' correspond to GStreamer
+  buffer/segment values. The mpeg-ts PCR/DTS/PTS values are indicated
+  with their actual name.
 
  1) Live push-based scheduling
 
@@ -60,26 +58,25 @@ of the stream.
   the outgoing buffer timestamps need to correspond to the incoming
   buffer timestamp values.
 
-    => A delta, DTS_delta between incoming buffer timestamp and
-       DTS/PTS needs to be computed.
+    => mpegtspacketizer keeps track of PCR and input timestamp and
+       extrapolates a clock skew using the EPTLA algorithm.
 
     => The outgoing buffers will be timestamped with their PTS values
-       (overflow corrected) offseted by that initial DTS_delta.
+       (overflow corrected) corrected by that calculated clock skew.
 
   A latency is introduced between the time the buffer containing the
   first bit of a Access Unit is received in the demuxer and the moment
   the demuxer pushed out the buffer corresponding to that Access Unit.
 
-    => That latency needs to be reported. It corresponds to the
-       biggest Access Unit spacing, in this case 1/video-framerate.
+    => That latency needs to be reported.
 
   According to the ISO/IEC 13818-1:2007 specifications, D.0.1 Timing
   mode, the "coded audio and video that represent sound and pictures
   that are to be presented simultaneously may be separated in time
   within the coded bit stream by ==>as much as one second<=="
 
-    => The demuxer will therefore report an added latency of 1s to
-       handle this interleave.
+    => The algorithm to calculate the latency should take that into
+       account. 
 
 
  2) Non-live push-based scheduling
@@ -97,11 +94,22 @@ of the stream.
   do not have capture timestamps, we need to ensure the first buffer
   we push out corresponds to the base segment start runing time.
 
-    => A delta between the first DTS to output and the segment start
-       position needs to be computed.
+    => The packetizer keeps track of PCR locations and offsets in
+       addition to the clock skew (in the case of upstream buffers
+       being timestamped, which is the case for HLS).
+
+    => The demuxer indicates to the packetizer when he sees the
+       'beginning' of the program (i.e. the first valid PAT/PMT
+       combination). The packetizer will then use that location as
+       "timestamp 0", or "reference position/PCR".
+
+    => The lowest DTS is passed to the packetizer to be converted to
+       timestamp. That value is computed in the same way as live
+       streams if upstream buffers have timestamps, or will be
+       subtracted from the reference PCR.
 
     => The outgoing buffers will be timestamped with their PTS values
-       (overflow corrected) offseted by that initial delta.
+       (overflow corrected) adjusted by the packetizer.
 
   Latency is reported just as with the live use-case.
 
@@ -111,37 +119,13 @@ of the stream.
   We do not get a NEWSEGMENT event from upstream, we therefore need to
   compute the outgoing values.
 
-  The base stream/running time corresponds to the DTS of the first
-  buffer we will output. The DTS_delta becomes that earliest DTS.
-
-  =>  FILLME
-
- X) General notes
-
-  It is assumed that PTS/DTS rollovers are detected and corrected such
-  as the outgoing timestamps never rollover. This can be easily
-  handled by correcting the DTS_delta when such rollovers are
-  detected. The maximum value of a GstClockTimeDiff is almost 3
-  centuries, we therefore have enough margin to handle a decent number
-  of rollovers.
-
-  The generic equation for calculating outgoing buffer timestamps
-  therefore becomes:
-
-    D   = DTS_delta, with rollover corrections
-    PTS = PTS of the buffer we are going to push out
-    TS  = Timestamp of the outgoing buffer
-
-    ==>   TS = PTS + D
+    => The outgoing values for the newsegment are calculated like for
+       the non-live push-based mode when upstream doesn't provide
+       timestamp'ed buffers.
 
-  If seeking is handled upstream for push-based cases, whether live or
-  not, no extra modification is required.
+    => The outgoing buffer timestamps are timestamped with their PTS
+       values (overflow corrected) adjusted by the packetizer.
 
-  If seeking is handled by the demuxer in the non-live push-based
-  cases (converting from TIME to BYTES), the demuxer will need to
-  set the segment start/time values to the requested seek position.
-  The DTS_delta will also have to be recomputed to take into account
-  the seek position.
 
 
 [0] When talking about live sources, we mean this in the GStreamer
diff --git a/gst/mpegtsdemux/gstmpegdefs.h b/gst/mpegtsdemux/gstmpegdefs.h
index be6209a..62d98c7 100644
--- a/gst/mpegtsdemux/gstmpegdefs.h
+++ b/gst/mpegtsdemux/gstmpegdefs.h
@@ -151,8 +151,9 @@
 #define ST_DSMCC_D                      0x0d
 
 /* later extensions */
-#define ST_AUDIO_AAC                    0x0f
+#define ST_AUDIO_AAC_ADTS               0x0f
 #define ST_VIDEO_MPEG4                  0x10
+#define ST_AUDIO_AAC_LATM               0x11
 #define ST_VIDEO_H264                   0x1b
 
 /* Un-official Dirac extension */
@@ -205,6 +206,8 @@
             GST_MSECOND/10, CLOCK_BASE))
 #define GSTTIME_TO_MPEGTIME(time) (gst_util_uint64_scale ((time), \
             CLOCK_BASE, GST_MSECOND/10))
+#define GSTTIME_TO_PCRTIME(time) (gst_util_uint64_scale ((time), \
+            300 * CLOCK_BASE, GST_MSECOND/10))
 
 #define MPEG_MUX_RATE_MULT      50
 
diff --git a/gst/mpegtsdemux/gstmpegdesc.h b/gst/mpegtsdemux/gstmpegdesc.h
index 06aa17b..c4ae91c 100644
--- a/gst/mpegtsdemux/gstmpegdesc.h
+++ b/gst/mpegtsdemux/gstmpegdesc.h
@@ -29,6 +29,7 @@
 #define __GST_MPEG_DESC_H__
 
 #include <glib.h>
+
 /*
  * descriptor_tag TS  PS                      Identification
  *        0       n/a n/a Reserved
@@ -53,93 +54,94 @@
  *      19-63     n/a n/a ITU-T Rec. H.222.0 | ISO/IEC 13818-1 Reserved
  *     64-255     n/a n/a User Private
  */
-#define DESC_VIDEO_STREAM			2
-#define DESC_AUDIO_STREAM			3
-#define DESC_HIERARCHY				4
-#define DESC_REGISTRATION			5
-#define DESC_DATA_STREAM_ALIGNMENT		6
-#define DESC_TARGET_BACKGROUND_GRID		7
-#define DESC_VIDEO_WINDOW			8
-#define DESC_CA					9
-#define DESC_ISO_639_LANGUAGE			10
-#define DESC_SYSTEM_CLOCK			11
-#define DESC_MULTIPLEX_BUFFER_UTILISATION	12
-#define DESC_COPYRIGHT				13
-#define DESC_MAXIMUM_BITRATE			14
-#define DESC_PRIVATE_DATA_INDICATOR		15
-#define DESC_SMOOTHING_BUFFER			16
-#define DESC_STD				17
-#define DESC_IBP				18
-
-#define DESC_DIRAC_TC_PRIVATE			0xAC
+#define DESC_VIDEO_STREAM                     0x02
+#define DESC_AUDIO_STREAM                     0x03
+#define DESC_HIERARCHY                        0x04
+#define DESC_REGISTRATION                     0x05
+#define DESC_DATA_STREAM_ALIGNMENT            0x06
+#define DESC_TARGET_BACKGROUND_GRID           0x07
+#define DESC_VIDEO_WINDOW                     0x08
+#define DESC_CA                               0x09
+#define DESC_ISO_639_LANGUAGE                 0x0A
+#define DESC_SYSTEM_CLOCK                     0x0B
+#define DESC_MULTIPLEX_BUFFER_UTILISATION     0x0C
+#define DESC_COPYRIGHT                        0x0D
+#define DESC_MAXIMUM_BITRATE                  0x0E
+#define DESC_PRIVATE_DATA_INDICATOR           0x0F
+#define DESC_SMOOTHING_BUFFER                 0x10
+#define DESC_STD                              0x11
+#define DESC_IBP                              0x12
+
+#define DESC_DIRAC_TC_PRIVATE                 0xAC
 
 /* DVB tags */
-#define DESC_DVB_CAROUSEL_IDENTIFIER	0x13
-#define DESC_DVB_NETWORK_NAME   0x40
-#define DESC_DVB_SERVICE_LIST   0x41
-#define DESC_DVB_STUFFING       0x42
+#define DESC_DVB_CAROUSEL_IDENTIFIER          0x13
+#define DESC_DVB_NETWORK_NAME                 0x40
+#define DESC_DVB_SERVICE_LIST                 0x41
+#define DESC_DVB_STUFFING                     0x42
 #define DESC_DVB_SATELLITE_DELIVERY_SYSTEM    0x43
-#define DESC_DVB_CABLE_DELIVERY_SYSTEM    0x44
-#define DESC_DVB_VBI_DATA       0x45
-#define DESC_DVB_VBI_TELETEXT   0x46
-#define DESC_DVB_BOUQUET_NAME   0x47
-#define DESC_DVB_SERVICE        0x48
-#define DESC_DVB_COUNTRY_AVAILABILITY   0x49
-#define DESC_DVB_LINKAGE        0x4A
-#define DESC_DVB_NVOD_REFERENCE 0x4B
-#define DESC_DVB_TIME_SHIFTED_SERVICE   0x4C
-#define DESC_DVB_SHORT_EVENT    0x4D
-#define DESC_DVB_EXTENDED_EVENT 0x4E
-#define DESC_DVB_TIME_SHIFTED_EVENT   0x4F
-#define DESC_DVB_COMPONENT      0x50
-#define DESC_DVB_MOSAIC         0x51
-#define DESC_DVB_STREAM_IDENTIFIER    0x52
-#define DESC_DVB_CA_IDENTIFIER  0x53
-#define DESC_DVB_CONTENT        0x54
-#define DESC_DVB_PARENTAL_RATING    0x55
-#define DESC_DVB_TELETEXT       0x56
-#define DESC_DVB_TELEPHONE      0x57
-#define DESC_DVB_LOCAL_TIME_OFFSET  0x58
-#define DESC_DVB_SUBTITLING     0x59
+#define DESC_DVB_CABLE_DELIVERY_SYSTEM        0x44
+#define DESC_DVB_VBI_DATA                     0x45
+#define DESC_DVB_VBI_TELETEXT                 0x46
+#define DESC_DVB_BOUQUET_NAME                 0x47
+#define DESC_DVB_SERVICE                      0x48
+#define DESC_DVB_COUNTRY_AVAILABILITY         0x49
+#define DESC_DVB_LINKAGE                      0x4A
+#define DESC_DVB_NVOD_REFERENCE               0x4B
+#define DESC_DVB_TIME_SHIFTED_SERVICE         0x4C
+#define DESC_DVB_SHORT_EVENT                  0x4D
+#define DESC_DVB_EXTENDED_EVENT               0x4E
+#define DESC_DVB_TIME_SHIFTED_EVENT           0x4F
+#define DESC_DVB_COMPONENT                    0x50
+#define DESC_DVB_MOSAIC                       0x51
+#define DESC_DVB_STREAM_IDENTIFIER            0x52
+#define DESC_DVB_CA_IDENTIFIER                0x53
+#define DESC_DVB_CONTENT                      0x54
+#define DESC_DVB_PARENTAL_RATING              0x55
+#define DESC_DVB_TELETEXT                     0x56
+#define DESC_DVB_TELEPHONE                    0x57
+#define DESC_DVB_LOCAL_TIME_OFFSET            0x58
+#define DESC_DVB_SUBTITLING                   0x59
 #define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM  0x5A
 #define DESC_DVB_MULTILINGUAL_NETWORK_NAME    0x5B
 #define DESC_DVB_MULTILINGUAL_BOUQUET_NAME    0x5C
 #define DESC_DVB_MULTILINGUAL_SERVICE_NAME    0x5D
-#define DESC_DVB_MULTILINGUAL_COMPONENT   0x5E
-#define DESC_DVB_PRIVATE_DATA   0x5F
-#define DESC_DVB_SERVICE_MOVE   0x60
-#define DESC_DVB_SHORT_SMOOTHING_BUFFER   0x61
-#define DESC_DVB_FREQUENCY_LIST 0x62
-#define DESC_DVB_PARTIAL_TRANSPORT_STREAM   0x63
-#define DESC_DVB_DATA_BROADCAST 0x64
-#define DESC_DVB_SCRAMBLING     0x65
-#define DESC_DVB_DATA_BROADCAST_ID    0x66
-#define DESC_DVB_TRANSPORT_STREAM   0x67
-#define DESC_DVB_DSNG           0x68
-#define DESC_DVB_PDC            0x69
-#define DESC_DVB_AC3            0x6A
-#define DESC_DVB_ANCILLARY_DATA 0x6B
-#define DESC_DVB_CELL_LIST          0x6C
-#define DESC_DVB_CELL_FREQUENCY_LINK    0x6D
-#define DESC_DVB_ANNOUNCEMENT_SUPPORT   0x6E
-#define DESC_DVB_APPLICATION_SIGNALLING   0x6F
-#define DESC_DVB_ADAPTATION_FIELD_DATA    0x70
-#define DESC_DVB_SERVICE_IDENTIFIER   0x71
-#define DESC_DVB_SERVICE_AVAILABILITY   0x72
-#define DESC_DVB_DEFAULT_AUTHORITY    0x73
-#define DESC_DVB_RELATED_CONTENT    0x74
-#define DESC_DVB_TVA_ID         0x75
-#define DESC_DVB_CONTENT_IDENTIFIER   0x76
-#define DESC_DVB_TIMESLICE_FEC_IDENTIFIER   0x77
-#define DESC_DVB_ECM_REPETITION_RATE    0x78
-#define DESC_DVB_S2_SATELLITE_DELIVERY_SYSTEM   0x79
-#define DESC_DVB_ENHANCED_AC3   0x7A
-#define DESC_DVB_DTS            0x7B
-#define DESC_DVB_AAC            0x7C
+#define DESC_DVB_MULTILINGUAL_COMPONENT       0x5E
+#define DESC_DVB_PRIVATE_DATA                 0x5F
+#define DESC_DVB_SERVICE_MOVE                 0x60
+#define DESC_DVB_SHORT_SMOOTHING_BUFFER       0x61
+#define DESC_DVB_FREQUENCY_LIST               0x62
+#define DESC_DVB_PARTIAL_TRANSPORT_STREAM     0x63
+#define DESC_DVB_DATA_BROADCAST               0x64
+#define DESC_DVB_SCRAMBLING                   0x65
+#define DESC_DVB_DATA_BROADCAST_ID            0x66
+#define DESC_DVB_TRANSPORT_STREAM             0x67
+#define DESC_DVB_DSNG                         0x68
+#define DESC_DVB_PDC                          0x69
+#define DESC_DVB_AC3                          0x6A
+#define DESC_DVB_ANCILLARY_DATA               0x6B
+#define DESC_DVB_CELL_LIST                    0x6C
+#define DESC_DVB_CELL_FREQUENCY_LINK          0x6D
+#define DESC_DVB_ANNOUNCEMENT_SUPPORT         0x6E
+#define DESC_DVB_APPLICATION_SIGNALLING       0x6F
+#define DESC_DVB_ADAPTATION_FIELD_DATA        0x70
+#define DESC_DVB_SERVICE_IDENTIFIER           0x71
+#define DESC_DVB_SERVICE_AVAILABILITY         0x72
+#define DESC_DVB_DEFAULT_AUTHORITY            0x73
+#define DESC_DVB_RELATED_CONTENT              0x74
+#define DESC_DVB_TVA_ID                       0x75
+#define DESC_DVB_CONTENT_IDENTIFIER           0x76
+#define DESC_DVB_TIMESLICE_FEC_IDENTIFIER     0x77
+#define DESC_DVB_ECM_REPETITION_RATE          0x78
+#define DESC_DVB_S2_SATELLITE_DELIVERY_SYSTEM 0x79
+#define DESC_DVB_ENHANCED_AC3                 0x7A
+#define DESC_DVB_DTS                          0x7B
+#define DESC_DVB_AAC                          0x7C
 /* 0x7D and 0x7E are reserved for future use */
-#define DESC_DVB_EXTENSION      0x7F
+#define DESC_DVB_EXTENSION                    0x7F
 /* 0x80 - 0xFE are user defined */
-#define DESC_DTG_LOGICAL_CHANNEL	0x83 /* from DTG D-Book */
+#define DESC_AC3_AUDIO_STREAM                 0x81
+#define DESC_DTG_LOGICAL_CHANNEL              0x83    /* from DTG D-Book */
 /* 0xFF is forbidden */
 
 /* common for all descriptors */
@@ -196,7 +198,7 @@
 #define DESC_ISO_639_LANGUAGE_language_code_nth(desc,i)		(&(desc[2 + (4*i)]))
 #define DESC_ISO_639_LANGUAGE_audio_type_nth(desc,i)		((desc)[5 + (4*i)])
 
-/* system_clock_descriptor */ 
+/* system_clock_descriptor */
 #define DESC_SYSTEM_CLOCK_external_clock_reference_indicator(desc) (((desc)[2] & 0x80) == 0x80)
 #define DESC_SYSTEM_CLOCK_clock_accuracy_integer(desc)		((desc)[2] & 0x3f)
 #define DESC_SYSTEM_CLOCK_clock_accuracy_exponent(desc)		(((desc)[3] & 0xe0) >> 5)
@@ -213,7 +215,7 @@
 
 /* maximum_bitrate_descriptor */
 #define DESC_MAXIMUM_BITRAT_maximum_bitrate(desc)		(((((guint32)desc[2]) & 0x3f) << 16) | \
-								 GST_READ_UINT16_BE ((desc)+3)) 
+								 GST_READ_UINT16_BE ((desc)+3))
 
 /* private_data_indicator_descriptor */
 #define DESC_PRIVATE_DATA_INDICATOR_indicator(desc)		(GST_READ_UINT32_BE(&desc[2]))
@@ -268,7 +270,7 @@
 #define DESC_DVB_EXTENDED_EVENT_last_descriptor_number(desc) (desc[2] & 0x0F)
 #define DESC_DVB_EXTENDED_EVENT_iso639_language_code(desc) (desc + 3)
 #define DESC_DVB_EXTENDED_EVENT_items_length(desc) (desc[6])
-#define DESC_DVB_EXTENDED_EVENT_items(desc) (desc + 7) 
+#define DESC_DVB_EXTENDED_EVENT_items(desc) (desc + 7)
 #define DESC_DVB_EXTENDED_EVENT_text_length(desc) (desc[7 + DESC_DVB_EXTENDED_EVENT_items_length(desc)])
 #define DESC_DVB_EXTENDED_EVENT_text(desc) (desc + 7 + DESC_DVB_EXTENDED_EVENT_items_length(desc) + 1)
 
@@ -315,24 +317,31 @@
 /* DVB Carousel Identifier Descriptor */
 #define DESC_DVB_CAROUSEL_IDENTIFIER_carousel_id(desc)		(GST_READ_UINT32_BE((desc) + 2))
 
+/* AC3_audio_stream_descriptor */
+#define DESC_AC_AUDIO_STREAM_bsid(desc)             ((desc)[2] & 0x1f)
+
 /* registration_descriptor format IDs */
 #define DRF_ID_HDMV       0x48444d56
 #define DRF_ID_VC1        0x56432D31   /* defined in RP227 */
-
-typedef struct {
-  guint    n_desc;
-  guint8   data_length;
-  guint8  *data;
+#define DRF_ID_DTS1       0x44545331
+#define DRF_ID_DTS2       0x44545332
+#define DRF_ID_DTS3       0x44545333
+
+typedef struct
+{
+  guint n_desc;
+  guint8 data_length;
+  guint8 *data;
 } GstMPEGDescriptor;
 
 void gst_mpegtsdesc_init_debug (void);
-GstMPEGDescriptor* 	gst_mpeg_descriptor_parse 	(guint8 *data, guint size);
-void		 	gst_mpeg_descriptor_free 	(GstMPEGDescriptor *desc);
+GstMPEGDescriptor *gst_mpeg_descriptor_parse (guint8 * data, guint size);
+void gst_mpeg_descriptor_free                (GstMPEGDescriptor * desc);
 
-guint 			gst_mpeg_descriptor_n_desc	(GstMPEGDescriptor *desc);
-guint8*			gst_mpeg_descriptor_find	(GstMPEGDescriptor *desc, gint tag);
-GArray*         gst_mpeg_descriptor_find_all (GstMPEGDescriptor * desc, gint tag);
+guint gst_mpeg_descriptor_n_desc             (GstMPEGDescriptor * desc);
+guint8 *gst_mpeg_descriptor_find             (GstMPEGDescriptor * desc, gint tag);
+GArray *gst_mpeg_descriptor_find_all         (GstMPEGDescriptor * desc, gint tag);
 
-guint8*			gst_mpeg_descriptor_nth		(GstMPEGDescriptor *desc, guint i);
+guint8 *gst_mpeg_descriptor_nth              (GstMPEGDescriptor * desc, guint i);
 
 #endif /* __GST_MPEG_DESC_H__ */
diff --git a/gst/mpegtsdemux/mpegtsbase.c b/gst/mpegtsdemux/mpegtsbase.c
index c63170e..7193429 100644
--- a/gst/mpegtsdemux/mpegtsbase.c
+++ b/gst/mpegtsdemux/mpegtsbase.c
@@ -32,6 +32,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <stdlib.h>
 #include <string.h>
 
@@ -89,6 +93,9 @@ static void mpegts_base_get_tags_from_sdt (MpegTSBase * base,
     GstStructure * sdt_info);
 static void mpegts_base_get_tags_from_eit (MpegTSBase * base,
     GstStructure * eit_info);
+static gboolean
+remove_each_program (gpointer key, MpegTSBaseProgram * program,
+    MpegTSBase * base);
 
 GST_BOILERPLATE_FULL (MpegTSBase, mpegts_base, GstElement, GST_TYPE_ELEMENT,
     _extra_init);
@@ -169,8 +176,7 @@ mpegts_base_base_init (gpointer klass)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 
-  gst_element_class_add_static_pad_template (element_class,
-      &sink_template);
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
 }
 
 static void
@@ -218,9 +224,13 @@ mpegts_base_reset (MpegTSBase * base)
 
   base->mode = BASE_MODE_STREAMING;
   base->seen_pat = FALSE;
-  base->first_pat_offset = -1;
-  base->in_gap = 0;
-  base->first_buf_ts = GST_CLOCK_TIME_NONE;
+  base->seek_offset = -1;
+
+  base->upstream_live = FALSE;
+  base->queried_latency = FALSE;
+
+  g_hash_table_foreach_remove (base->programs, (GHRFunc) remove_each_program,
+      base);
 
   if (klass->reset)
     klass->reset (base);
@@ -565,6 +575,74 @@ mpegts_base_program_remove_stream (MpegTSBase * base,
   program->streams[pid] = NULL;
 }
 
+/* Return TRUE if programs are equal */
+static gboolean
+mpegts_base_is_same_program (MpegTSBase * base, MpegTSBaseProgram * oldprogram,
+    guint16 new_pmt_pid, GstStructure * new_pmt_info)
+{
+  guint i, nbstreams;
+  guint pcr_pid;
+  guint pid;
+  guint stream_type;
+  GstStructure *stream;
+  MpegTSBaseStream *oldstream;
+  gboolean sawpcrpid = FALSE;
+  const GValue *new_streams;
+  const GValue *value;
+
+  if (oldprogram->pmt_pid != new_pmt_pid) {
+    GST_DEBUG ("Different pmt_pid (new:0x%04x, old:0x%04x)", new_pmt_pid,
+        oldprogram->pmt_pid);
+    return FALSE;
+  }
+
+  gst_structure_id_get (new_pmt_info, QUARK_PCR_PID, G_TYPE_UINT, &pcr_pid,
+      NULL);
+  if (oldprogram->pcr_pid != pcr_pid) {
+    GST_DEBUG ("Different pcr_pid (new:0x%04x, old:0x%04x)",
+        pcr_pid, oldprogram->pcr_pid);
+    return FALSE;
+  }
+
+  /* Check the streams */
+  new_streams = gst_structure_id_get_value (new_pmt_info, QUARK_STREAMS);
+  nbstreams = gst_value_list_get_size (new_streams);
+
+  for (i = 0; i < nbstreams; ++i) {
+    value = gst_value_list_get_value (new_streams, i);
+    stream = g_value_get_boxed (value);
+
+    gst_structure_id_get (stream, QUARK_PID, G_TYPE_UINT, &pid,
+        QUARK_STREAM_TYPE, G_TYPE_UINT, &stream_type, NULL);
+    oldstream = oldprogram->streams[pid];
+    if (!oldstream) {
+      GST_DEBUG ("New stream 0x%04x not present in old program", pid);
+      return FALSE;
+    }
+    if (oldstream->stream_type != stream_type) {
+      GST_DEBUG
+          ("New stream 0x%04x has a different stream type (new:%d, old:%d)",
+          pid, stream_type, oldstream->stream_type);
+      return FALSE;
+    }
+    if (pid == oldprogram->pcr_pid)
+      sawpcrpid = TRUE;
+  }
+
+  /* If the pcr is not shared with an existing stream, we'll have one extra stream */
+  if (!sawpcrpid)
+    nbstreams += 1;
+
+  if (nbstreams != g_list_length (oldprogram->stream_list)) {
+    GST_DEBUG ("Different number of streams (new:%d, old:%d)",
+        nbstreams, g_list_length (oldprogram->stream_list));
+    return FALSE;
+  }
+
+  GST_DEBUG ("Programs are equal");
+  return TRUE;
+}
+
 static void
 mpegts_base_deactivate_program (MpegTSBase * base, MpegTSBaseProgram * program)
 {
@@ -615,7 +693,7 @@ mpegts_base_deactivate_program (MpegTSBase * base, MpegTSBaseProgram * program)
 
 static void
 mpegts_base_activate_program (MpegTSBase * base, MpegTSBaseProgram * program,
-    guint16 pmt_pid, GstStructure * pmt_info)
+    guint16 pmt_pid, GstStructure * pmt_info, gboolean initial_program)
 {
   guint i, nbstreams;
   guint pcr_pid;
@@ -636,6 +714,7 @@ mpegts_base_activate_program (MpegTSBase * base, MpegTSBaseProgram * program,
   /* activate new pmt */
   if (program->pmt_info)
     gst_structure_free (program->pmt_info);
+
   program->pmt_info = gst_structure_copy (pmt_info);
   program->pmt_pid = pmt_pid;
   program->pcr_pid = pcr_pid;
@@ -659,8 +738,8 @@ mpegts_base_activate_program (MpegTSBase * base, MpegTSBaseProgram * program,
   mpegts_base_program_add_stream (base, program, (guint16) pcr_pid, -1, NULL);
   MPEGTS_BIT_SET (base->is_pes, pcr_pid);
 
-
   program->active = TRUE;
+  program->initial_program = initial_program;
 
   klass = GST_MPEGTS_BASE_GET_CLASS (base);
   if (klass->program_started != NULL)
@@ -673,7 +752,7 @@ gboolean
 mpegts_base_is_psi (MpegTSBase * base, MpegTSPacketizerPacket * packet)
 {
   gboolean retval = FALSE;
-  guint8 table_id;
+  guint8 *data, table_id, pointer;
   int i;
   static const guint8 si_tables[] =
       { 0x00, 0x01, 0x02, 0x03, 0x40, 0x41, 0x42, 0x46, 0x4A,
@@ -686,12 +765,24 @@ mpegts_base_is_psi (MpegTSBase * base, MpegTSPacketizerPacket * packet)
   if (MPEGTS_BIT_IS_SET (base->known_psi, packet->pid))
     retval = TRUE;
 
-  /* check is it is a pes pid */
+  /* check if it is a pes pid */
   if (MPEGTS_BIT_IS_SET (base->is_pes, packet->pid))
     return FALSE;
 
   if (!retval) {
     if (packet->payload_unit_start_indicator) {
+      data = packet->data;
+      pointer = *data++;
+      data += pointer;
+      /* 'pointer' value may be invalid on malformed packet
+       * so we need to avoid out of range
+       */
+      if (!(data < packet->data_end)) {
+        GST_WARNING_OBJECT (base,
+            "Wrong offset when retrieving table id: 0x%x", pointer);
+        return FALSE;
+      }
+
       table_id = *(packet->data);
       i = 0;
       while (si_tables[i] != TABLE_ID_UNSET) {
@@ -836,7 +927,7 @@ mpegts_base_apply_pmt (MpegTSBase * base,
 {
   MpegTSBaseProgram *program, *old_program;
   guint program_number;
-  gboolean deactivate_old_program = FALSE;
+  gboolean initial_program = TRUE;
 
   /* FIXME : not so sure this is valid anymore */
   if (G_UNLIKELY (base->seen_pat == FALSE)) {
@@ -861,24 +952,27 @@ mpegts_base_apply_pmt (MpegTSBase * base,
   if (G_UNLIKELY (old_program == NULL))
     goto no_program;
 
+  if (G_UNLIKELY (mpegts_base_is_same_program (base, old_program, pmt_pid,
+              pmt_info)))
+    goto same_program;
+
   /* If the current program is active, this means we have a new program */
   if (old_program->active) {
     old_program = mpegts_base_steal_program (base, program_number);
     program = mpegts_base_new_program (base, program_number, pmt_pid);
     g_hash_table_insert (base->programs,
         GINT_TO_POINTER (program_number), program);
-    deactivate_old_program = TRUE;
+
+    /* Desactivate the old program */
+    mpegts_base_deactivate_program (base, old_program);
+    mpegts_base_free_program (old_program);
+    initial_program = FALSE;
   } else
     program = old_program;
 
   /* First activate program */
-  mpegts_base_activate_program (base, program, pmt_pid, pmt_info);
-
-  if (deactivate_old_program) {
-    /* deactivate old pmt */ ;
-    mpegts_base_deactivate_program (base, old_program);
-    mpegts_base_free_program (old_program);
-  }
+  mpegts_base_activate_program (base, program, pmt_pid, pmt_info,
+      initial_program);
 
   /* if (program->pmt_info) */
   /*   gst_structure_free (program->pmt_info); */
@@ -895,6 +989,12 @@ no_program:
     GST_ERROR ("Attempted to apply a PMT on a program that wasn't created");
     return;
   }
+
+same_program:
+  {
+    GST_DEBUG ("Not applying identical program");
+    return;
+  }
 }
 
 static void
@@ -971,9 +1071,10 @@ mpegts_base_handle_psi (MpegTSBase * base, MpegTSPacketizerSection * section)
         mpegts_base_apply_pat (base, structure);
         if (base->seen_pat == FALSE) {
           base->seen_pat = TRUE;
-          base->first_pat_offset = GST_BUFFER_OFFSET (section->buffer);
           GST_DEBUG ("First PAT offset: %" G_GUINT64_FORMAT,
-              base->first_pat_offset);
+              GST_BUFFER_OFFSET (section->buffer));
+          mpegts_packetizer_set_reference_offset (base->packetizer,
+              GST_BUFFER_OFFSET (section->buffer));
         }
 
       } else
@@ -1142,20 +1243,26 @@ mpegts_base_get_tags_from_eit (MpegTSBase * base, GstStructure * eit_info)
   }
 }
 
-static void
+static gboolean
 remove_each_program (gpointer key, MpegTSBaseProgram * program,
     MpegTSBase * base)
 {
+  MpegTSBaseClass *klass = GST_MPEGTS_BASE_GET_CLASS (base);
+
   /* First deactivate it */
   mpegts_base_deactivate_program (base, program);
   /* Then remove it */
-  mpegts_base_remove_program (base, program->program_number);
+  if (klass->program_stopped)
+    klass->program_stopped (base, program);
+
+  return TRUE;
 }
 
 static gboolean
 gst_mpegts_base_handle_eos (MpegTSBase * base)
 {
-  g_hash_table_foreach (base->programs, (GHFunc) remove_each_program, base);
+  g_hash_table_foreach_remove (base->programs, (GHRFunc) remove_each_program,
+      base);
   /* finally remove  */
   return TRUE;
 }
@@ -1200,8 +1307,6 @@ mpegts_base_sink_event (GstPad * pad, GstEvent * event)
       gst_segment_set_newsegment_full (&base->segment, update, rate,
           applied_rate, format, start, stop, position);
       gst_event_unref (event);
-      base->in_gap = GST_CLOCK_TIME_NONE;
-      base->first_buf_ts = GST_CLOCK_TIME_NONE;
     }
       break;
     case GST_EVENT_EOS:
@@ -1216,7 +1321,6 @@ mpegts_base_sink_event (GstPad * pad, GstEvent * event)
     case GST_EVENT_FLUSH_STOP:
       gst_segment_init (&base->segment, GST_FORMAT_UNDEFINED);
       base->seen_pat = FALSE;
-      base->first_pat_offset = -1;
       /* Passthrough */
     default:
       res = GST_MPEGTS_BASE_GET_CLASS (base)->push_event (base, event);
@@ -1227,6 +1331,22 @@ mpegts_base_sink_event (GstPad * pad, GstEvent * event)
   return res;
 }
 
+static void
+query_upstream_latency (MpegTSBase * base)
+{
+  GstQuery *query;
+
+  query = gst_query_new_latency ();
+  if (gst_pad_peer_query (base->sinkpad, query)) {
+    gst_query_parse_latency (query, &base->upstream_live, NULL, NULL);
+    GST_DEBUG_OBJECT (base, "Upstream is %s",
+        base->upstream_live ? "LIVE" : "NOT LIVE");
+  } else
+    GST_WARNING_OBJECT (base, "Failed to query upstream latency");
+  gst_query_unref (query);
+  base->queried_latency = TRUE;
+}
+
 static inline GstFlowReturn
 mpegts_base_push (MpegTSBase * base, MpegTSPacketizerPacket * packet,
     MpegTSPacketizerSection * section)
@@ -1255,16 +1375,12 @@ mpegts_base_chain (GstPad * pad, GstBuffer * buf)
   base = GST_MPEGTS_BASE (gst_object_get_parent (GST_OBJECT (pad)));
   packetizer = base->packetizer;
 
-  if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (base->first_buf_ts)) &&
-      GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
-    base->first_buf_ts = GST_BUFFER_TIMESTAMP (buf);
-    GST_DEBUG_OBJECT (base, "first buffer timestamp %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (base->first_buf_ts));
+  if (G_UNLIKELY (base->queried_latency == FALSE)) {
+    query_upstream_latency (base);
   }
 
   mpegts_packetizer_push (base->packetizer, buf);
-  while (((pret =
-              mpegts_packetizer_next_packet (base->packetizer,
+  while (((pret = mpegts_packetizer_next_packet (base->packetizer,
                   &packet)) != PACKET_NEED_MORE) && res == GST_FLOW_OK) {
     if (G_UNLIKELY (pret == PACKET_BAD))
       /* bad header, skip the packet */
@@ -1283,9 +1399,11 @@ mpegts_base_chain (GstPad * pad, GstBuffer * buf)
         based = mpegts_base_handle_psi (base, &section);
         gst_buffer_unref (section.buffer);
 
-        if (G_UNLIKELY (!based))
+        if (G_UNLIKELY (!based)) {
+          gst_buffer_unref (packet.buffer);
           /* bad PSI table */
           goto next;
+        }
       }
       /* we need to push section packet downstream */
       res = mpegts_base_push (base, &packet, &section);
@@ -1310,16 +1428,20 @@ mpegts_base_scan (MpegTSBase * base)
   GstFlowReturn ret;
   GstBuffer *buf;
   guint i;
-  MpegTSBaseClass *klass = GST_MPEGTS_BASE_GET_CLASS (base);
+  gboolean done = FALSE;
+  MpegTSPacketizerPacketReturn pret;
+  gint64 tmpval;
+  guint64 upstream_size, seek_pos;
+  GstFormat format;
+  guint initial_pcr_seen;
 
   GST_DEBUG ("Scanning for initial sync point");
 
-  /* Find initial sync point */
-  for (i = 0; i < 10; i++) {
-    GST_DEBUG ("Grabbing %d => %d",
-        i * 50 * MPEGTS_MAX_PACKETSIZE, 50 * MPEGTS_MAX_PACKETSIZE);
-    ret = gst_pad_pull_range (base->sinkpad, i * 50 * MPEGTS_MAX_PACKETSIZE,
-        50 * MPEGTS_MAX_PACKETSIZE, &buf);
+  /* Find initial sync point and at least 5 PCR values */
+  for (i = 0; i < 10 && !done; i++) {
+    GST_DEBUG ("Grabbing %d => %d", i * 65536, 65536);
+
+    ret = gst_pad_pull_range (base->sinkpad, i * 65536, 65536, &buf);
     if (G_UNLIKELY (ret != GST_FLOW_OK))
       goto beach;
 
@@ -1327,33 +1449,80 @@ mpegts_base_scan (MpegTSBase * base)
     mpegts_packetizer_push (base->packetizer, buf);
 
     if (mpegts_packetizer_has_packets (base->packetizer)) {
-      /* Mark the initial sync point and remember the packetsize */
-      base->initial_sync_point = base->seek_offset = base->packetizer->offset;
-      GST_DEBUG ("Sync point is now %" G_GUINT64_FORMAT, base->seek_offset);
-      base->packetsize = base->packetizer->packet_size;
+      if (base->seek_offset == -1) {
+        /* Mark the initial sync point and remember the packetsize */
+        base->seek_offset = base->packetizer->offset;
+        GST_DEBUG ("Sync point is now %" G_GUINT64_FORMAT, base->seek_offset);
+        base->packetsize = base->packetizer->packet_size;
+      }
+      while (1) {
+        /* Eat up all packets */
+        pret = mpegts_packetizer_process_next_packet (base->packetizer);
+        if (pret == PACKET_NEED_MORE)
+          break;
+        if (pret != PACKET_BAD &&
+            mpegts_packetizer_get_seen_pcr (base->packetizer) >= 5) {
+          GST_DEBUG ("Got enough initial PCR");
+          done = TRUE;
+          break;
+        }
+      }
+    }
+  }
 
-      /* If the subclass can seek for timestamps, do that */
-      if (klass->find_timestamps) {
-        guint64 offset;
-        mpegts_packetizer_clear (base->packetizer);
+  initial_pcr_seen = mpegts_packetizer_get_seen_pcr (base->packetizer);
+  if (G_UNLIKELY (initial_pcr_seen == 0))
+    goto no_initial_pcr;
+  GST_DEBUG ("Seen %d initial PCR", initial_pcr_seen);
 
-        ret = klass->find_timestamps (base, 0, &offset);
+  /* Now send data from the end */
+  mpegts_packetizer_clear (base->packetizer);
 
-        base->initial_sync_point = base->seek_offset =
-            base->packetizer->offset = base->first_pat_offset;
-        GST_DEBUG ("Sync point is now %" G_GUINT64_FORMAT, base->seek_offset);
-      }
+  /* Get the size of upstream */
+  format = GST_FORMAT_BYTES;
+  if (!gst_pad_query_peer_duration (base->sinkpad, &format, &tmpval))
+    goto beach;
+  upstream_size = tmpval;
+  done = FALSE;
+
+  /* Find last PCR value */
+  for (seek_pos = MAX (0, upstream_size - 655360);
+      seek_pos < upstream_size && !done; seek_pos += 65536) {
+    GST_DEBUG ("Grabbing %" G_GUINT64_FORMAT " => %d", seek_pos, 65536);
+
+    ret = gst_pad_pull_range (base->sinkpad, seek_pos, 65536, &buf);
+    if (G_UNLIKELY (ret != GST_FLOW_OK))
       goto beach;
+
+    /* Push to packetizer */
+    mpegts_packetizer_push (base->packetizer, buf);
+
+    if (mpegts_packetizer_has_packets (base->packetizer)) {
+      while (1) {
+        /* Eat up all packets */
+        pret = mpegts_packetizer_process_next_packet (base->packetizer);
+        if (pret == PACKET_NEED_MORE)
+          break;
+        if (pret != PACKET_BAD &&
+            mpegts_packetizer_get_seen_pcr (base->packetizer) >
+            initial_pcr_seen) {
+          GST_DEBUG ("Got last PCR");
+          done = TRUE;
+          break;
+        }
+      }
     }
   }
 
-  GST_WARNING ("Didn't find initial sync point");
-  ret = GST_FLOW_ERROR;
-
 beach:
   mpegts_packetizer_clear (base->packetizer);
   return ret;
 
+no_initial_pcr:
+  mpegts_packetizer_clear (base->packetizer);
+  GST_WARNING_OBJECT (base, "Couldn't find any PCR within the first %d bytes",
+      10 * 65536);
+  return GST_FLOW_ERROR;
 }
 
 
@@ -1371,7 +1540,7 @@ mpegts_base_loop (MpegTSBase * base)
       GST_DEBUG ("Changing to Streaming");
       break;
     case BASE_MODE_SEEKING:
-      /* FIXME : yes, we should do something here */
+      /* FIXME : unclear if we still need mode_seeking... */
       base->mode = BASE_MODE_STREAMING;
       break;
     case BASE_MODE_STREAMING:
@@ -1401,9 +1570,16 @@ error:
   {
     const gchar *reason = gst_flow_get_name (ret);
     GST_DEBUG_OBJECT (base, "Pausing task, reason %s", reason);
-    if (ret == GST_FLOW_UNEXPECTED)
-      GST_MPEGTS_BASE_GET_CLASS (base)->push_event (base, gst_event_new_eos ());
-    else if (ret == GST_FLOW_NOT_LINKED || ret < GST_FLOW_UNEXPECTED) {
+    if (ret == GST_FLOW_UNEXPECTED) {
+      /* Push EOS downstream */
+      if (!GST_MPEGTS_BASE_GET_CLASS (base)->push_event (base,
+              gst_event_new_eos ())) {
+        /* If that failed, emit an error so the pipeline can be stopped */
+        GST_ELEMENT_ERROR (base, STREAM, DEMUX, (NULL),
+            ("got eos but no streams (yet)"));
+
+      }
+    } else if (ret == GST_FLOW_NOT_LINKED || ret < GST_FLOW_UNEXPECTED) {
       GST_ELEMENT_ERROR (base, STREAM, FAILED,
           (_("Internal data stream error.")),
           ("stream stopped, reason %s", reason));
@@ -1426,8 +1602,6 @@ mpegts_base_handle_seek_event (MpegTSBase * base, GstPad * pad,
   GstSeekFlags flags;
   GstSeekType start_type, stop_type;
   gint64 start, stop;
-  gchar *pad_name;
-  guint16 pid = 0;
 
   gst_event_parse_seek (event, &rate, &format, &flags, &start_type, &start,
       &stop_type, &stop);
@@ -1446,20 +1620,11 @@ mpegts_base_handle_seek_event (MpegTSBase * base, GstPad * pad,
       " stop: %" GST_TIME_FORMAT, rate, GST_TIME_ARGS (start),
       GST_TIME_ARGS (stop));
 
-  /* extract the pid from the pad name */
-  pad_name = gst_pad_get_name (pad);
-  if (pad_name) {
-    gchar *pidstr = g_strrstr (pad_name, "_");
-    if (pidstr) {
-      pidstr++;
-      pid = g_ascii_strtoull (pidstr, NULL, 16);
-    }
-    g_free (pad_name);
-  }
-
   flush = flags & GST_SEEK_FLAG_FLUSH;
 
   if (base->mode == BASE_MODE_PUSHING) {
+    /* FIXME : Actually ... it is supported, we just need to convert
+     * the seek event to BYTES */
     GST_ERROR ("seeking in push mode not supported");
     goto push_mode;
   }
@@ -1473,6 +1638,7 @@ mpegts_base_handle_seek_event (MpegTSBase * base, GstPad * pad,
         gst_event_new_flush_start ());
   } else
     gst_pad_pause_task (base->sinkpad);
+
   /* wait for streaming to finish */
   GST_PAD_STREAM_LOCK (base->sinkpad);
 
@@ -1480,6 +1646,9 @@ mpegts_base_handle_seek_event (MpegTSBase * base, GstPad * pad,
     /* send a FLUSH_STOP for the sinkpad, since we need data for seeking */
     GST_DEBUG_OBJECT (base, "sending flush stop");
     gst_pad_push_event (base->sinkpad, gst_event_new_flush_stop ());
+    /* And actually flush our pending data */
+    mpegts_base_flush (base);
+    mpegts_packetizer_flush (base->packetizer);
   }
 
   if (flags & (GST_SEEK_FLAG_SEGMENT | GST_SEEK_FLAG_SKIP)) {
@@ -1491,14 +1660,12 @@ mpegts_base_handle_seek_event (MpegTSBase * base, GstPad * pad,
   if (format == GST_FORMAT_TIME) {
     /* If the subclass can seek, do that */
     if (klass->seek) {
-      ret = klass->seek (base, event, pid);
+      ret = klass->seek (base, event);
       if (G_UNLIKELY (ret != GST_FLOW_OK)) {
         GST_WARNING ("seeking failed %s", gst_flow_get_name (ret));
-        goto done;
       }
     } else {
       GST_WARNING ("subclass has no seek implementation");
-      goto done;
     }
   }
 
@@ -1536,6 +1703,7 @@ mpegts_base_sink_activate_pull (GstPad * pad, gboolean active)
   MpegTSBase *base = GST_MPEGTS_BASE (GST_OBJECT_PARENT (pad));
   if (active) {
     base->mode = BASE_MODE_SCANNING;
+    base->packetizer->calculate_offset = TRUE;
     return gst_pad_start_task (pad, (GstTaskFunction) mpegts_base_loop, base);
   } else
     return gst_pad_stop_task (pad);
@@ -1546,6 +1714,7 @@ mpegts_base_sink_activate_push (GstPad * pad, gboolean active)
 {
   MpegTSBase *base = GST_MPEGTS_BASE (GST_OBJECT_PARENT (pad));
   base->mode = BASE_MODE_PUSHING;
+  base->packetizer->calculate_skew = TRUE;
   return TRUE;
 }
 
diff --git a/gst/mpegtsdemux/mpegtsbase.h b/gst/mpegtsdemux/mpegtsbase.h
index 872e77e..edce58d 100644
--- a/gst/mpegtsdemux/mpegtsbase.h
+++ b/gst/mpegtsdemux/mpegtsbase.h
@@ -48,6 +48,8 @@ G_BEGIN_DECLS
 #define GST_MPEGTS_BASE_GET_CLASS(obj) \
   (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_MPEGTS_BASE, MpegTSBaseClass))
 
+#define MPEG_TS_BASE_PACKETIZER(b) (((MpegTSBase*)b)->packetizer)
+
 typedef struct _MpegTSBase MpegTSBase;
 typedef struct _MpegTSBaseClass MpegTSBaseClass;
 typedef struct _MpegTSBaseStream MpegTSBaseStream;
@@ -76,6 +78,8 @@ struct _MpegTSBaseProgram
 
   /* TRUE if the program is currently being used */
   gboolean active;
+  /* TRUE if this is the first program created */
+  gboolean initial_program;
 };
 
 typedef enum {
@@ -96,9 +100,6 @@ struct _MpegTSBase {
   /* pull-based behaviour */
   MpegTSBaseMode mode;
 
-  /* location of first sync point */
-  guint64	initial_sync_point;
-
   /* Current pull offset (also set by seek handler) */
   guint64	seek_offset;
 
@@ -130,12 +131,10 @@ struct _MpegTSBase {
   /* Whether we saw a PAT yet */
   gboolean seen_pat;
 
-  /* Offset from the origin to the first PAT (pullmode) */
-  guint64    first_pat_offset;
-
-  /* interpolation gap between the upstream timestamp and the pts */
-  GstClockTime in_gap;
-  GstClockTime first_buf_ts;
+  /* Whether upstream is live or not */
+  gboolean upstream_live;
+  /* Whether we queried the upstream latency or not */
+  gboolean queried_latency;
 
   /* Upstream segment */
   GstSegment segment;
@@ -163,7 +162,7 @@ struct _MpegTSBaseClass {
   GstFlowReturn (*find_timestamps) (MpegTSBase * base, guint64 initoff, guint64 *offset);
 
   /* seek is called to wait for seeking */
-  GstFlowReturn (*seek) (MpegTSBase * base, GstEvent * event, guint16 pid);
+  GstFlowReturn (*seek) (MpegTSBase * base, GstEvent * event);
 
   /* flush all streams */
   void (*flush) (MpegTSBase * base);
diff --git a/gst/mpegtsdemux/mpegtspacketizer.c b/gst/mpegtsdemux/mpegtspacketizer.c
index 25d75cf..41ff6dd 100644
--- a/gst/mpegtsdemux/mpegtspacketizer.c
+++ b/gst/mpegtsdemux/mpegtspacketizer.c
@@ -1,7 +1,7 @@
 /*
- * mpegtspacketizer.c - 
+ * mpegtspacketizer.c -
  * Copyright (C) 2007, 2008 Alessandro Decina, Zaheer Merali
- * 
+ *
  * Authors:
  *   Zaheer Merali <zaheerabbas at merali dot org>
  *   Alessandro Decina <alessandro@nnva.org>
@@ -24,6 +24,17 @@
 
 #include <string.h>
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GValueArray
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
+/* Skew calculation pameters */
+#define MAX_TIME	(2 * GST_SECOND)
+
+/* maximal PCR time */
+#define PCR_MAX_VALUE (((((guint64)1)<<33) * 300) + 298)
+#define PTS_DTS_MAX_VALUE (((guint64)1) << 33)
+
 #include "mpegtspacketizer.h"
 #include "gstmpegdesc.h"
 
@@ -62,10 +73,37 @@ static GQuark QUARK_SEGMENT_LAST_SECTION_NUMBER;
 static GQuark QUARK_LAST_TABLE_ID;
 static GQuark QUARK_EVENTS;
 
+
+#define MPEGTS_PACKETIZER_GET_PRIVATE(obj)  \
+   (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_MPEGTS_PACKETIZER, MpegTSPacketizerPrivate))
+
 static void _init_local (void);
 G_DEFINE_TYPE_EXTENDED (MpegTSPacketizer2, mpegts_packetizer, G_TYPE_OBJECT, 0,
     _init_local ());
 
+typedef struct
+{
+  guint64 offset;               /* offset in upstream */
+  guint64 pcr;                  /* pcr (wraparound not fixed) */
+} MpegTSPacketizerOffset;
+
+struct _MpegTSPacketizerPrivate
+{
+  /* Used for bitrate calculation */
+  /* FIXME : Replace this later on with a balanced tree or sequence */
+  guint64 first_offset;
+  guint64 first_pcr;
+  GstClockTime first_pcr_ts;
+  guint64 last_offset;
+  guint64 last_pcr;
+  GstClockTime last_pcr_ts;
+
+  /* Reference offset */
+  guint64 refoffset;
+
+  guint nb_seen_offsets;
+};
+
 static void mpegts_packetizer_dispose (GObject * object);
 static void mpegts_packetizer_finalize (GObject * object);
 static gchar *convert_to_utf8 (const gchar * text, gint length, guint start,
@@ -73,11 +111,17 @@ static gchar *convert_to_utf8 (const gchar * text, gint length, guint start,
 static gchar *get_encoding (const gchar * text, guint * start_text,
     gboolean * is_multibyte);
 static gchar *get_encoding_and_convert (const gchar * text, guint length);
+static GstClockTime calculate_skew (MpegTSPacketizer2 * packetizer,
+    guint64 pcrtime, GstClockTime time);
+static void record_pcr (MpegTSPacketizer2 * packetizer, guint64 pcr,
+    guint64 offset);
+static void mpegts_packetizer_reset_skew (MpegTSPacketizer2 * packetizer);
 
 #define CONTINUITY_UNSET 255
 #define MAX_CONTINUITY 15
 #define VERSION_NUMBER_UNSET 255
 #define TABLE_ID_UNSET 0xFF
+#define PACKET_SYNC_BYTE 0x47
 
 static gint
 mpegts_packetizer_stream_subtable_compare (gconstpointer a, gconstpointer b)
@@ -145,6 +189,8 @@ mpegts_packetizer_class_init (MpegTSPacketizer2Class * klass)
 {
   GObjectClass *gobject_class;
 
+  g_type_class_add_private (klass, sizeof (MpegTSPacketizerPrivate));
+
   gobject_class = G_OBJECT_CLASS (klass);
 
   gobject_class->dispose = mpegts_packetizer_dispose;
@@ -154,11 +200,24 @@ mpegts_packetizer_class_init (MpegTSPacketizer2Class * klass)
 static void
 mpegts_packetizer_init (MpegTSPacketizer2 * packetizer)
 {
+  packetizer->priv = MPEGTS_PACKETIZER_GET_PRIVATE (packetizer);
   packetizer->adapter = gst_adapter_new ();
   packetizer->offset = 0;
   packetizer->empty = TRUE;
   packetizer->streams = g_new0 (MpegTSPacketizerStream *, 8192);
   packetizer->know_packet_size = FALSE;
+  packetizer->calculate_skew = FALSE;
+  packetizer->calculate_offset = FALSE;
+  mpegts_packetizer_reset_skew (packetizer);
+
+  packetizer->priv->first_offset = -1;
+  packetizer->priv->first_pcr = -1;
+  packetizer->priv->first_pcr_ts = GST_CLOCK_TIME_NONE;
+  packetizer->priv->last_offset = -1;
+  packetizer->priv->last_pcr = -1;
+  packetizer->priv->last_pcr_ts = GST_CLOCK_TIME_NONE;
+  packetizer->priv->nb_seen_offsets = 0;
+  packetizer->priv->refoffset = -1;
 }
 
 static void
@@ -199,7 +258,7 @@ mpegts_packetizer_finalize (GObject * object)
     G_OBJECT_CLASS (mpegts_packetizer_parent_class)->finalize (object);
 }
 
-guint64
+static inline guint64
 mpegts_packetizer_compute_pcr (const guint8 * data)
 {
   guint32 pcr1;
@@ -257,12 +316,23 @@ mpegts_packetizer_parse_adaptation_field_control (MpegTSPacketizer2 *
   if (afcflags & MPEGTS_AFC_PCR_FLAG) {
     packet->pcr = mpegts_packetizer_compute_pcr (data);
     *data += 6;
+    GST_DEBUG ("pcr %" G_GUINT64_FORMAT " (%" GST_TIME_FORMAT ")",
+        packet->pcr, GST_TIME_ARGS (PCRTIME_TO_GSTTIME (packet->pcr)));
+
+    if (packetizer->calculate_skew)
+      GST_BUFFER_TIMESTAMP (packet->buffer) =
+          calculate_skew (packetizer, packet->pcr,
+          GST_BUFFER_TIMESTAMP (packet->buffer));
+    if (packetizer->calculate_offset)
+      record_pcr (packetizer, packet->pcr, packet->offset);
   }
 
   /* OPCR */
   if (afcflags & MPEGTS_AFC_OPCR_FLAG) {
     packet->opcr = mpegts_packetizer_compute_pcr (data);
-    *data += 6;
+    /* *data += 6; */
+    GST_DEBUG ("opcr %" G_GUINT64_FORMAT " (%" GST_TIME_FORMAT ")",
+        packet->pcr, GST_TIME_ARGS (PCRTIME_TO_GSTTIME (packet->pcr)));
   }
 
   return TRUE;
@@ -396,7 +466,7 @@ mpegts_packetizer_parse_descriptors (MpegTSPacketizer2 * packetizer,
     /* include length */
     desc = g_string_new_len ((gchar *) data - 2, length + 2);
     data += length;
-    /* G_TYPE_GSTING is a GBoxed type and is used so properly marshalled from python */
+    /* G_TYPE_GSTRING is a GBoxed type and is used so properly marshalled from python */
     g_value_init (&value, G_TYPE_GSTRING);
     g_value_take_boxed (&value, desc);
     g_value_array_append (descriptors, &value);
@@ -521,6 +591,8 @@ mpegts_packetizer_parse_pmt (MpegTSPacketizer2 * packetizer,
   program_number = GST_READ_UINT16_BE (data);
   data += 2;
 
+  GST_DEBUG ("Parsing %d Program Map Table", program_number);
+
   tmp = *data++;
   section->version_number = (tmp >> 1) & 0x1F;
   section->current_next_indicator = tmp & 0x01;
@@ -565,6 +637,7 @@ mpegts_packetizer_parse_pmt (MpegTSPacketizer2 * packetizer,
    * bytes) plus the CRC */
   while (data <= end - 4 - 5) {
     stream_type = *data++;
+    GST_DEBUG ("Stream type 0x%02x found", stream_type);
 
     pid = GST_READ_UINT16_BE (data) & 0x1FFF;
     data += 2;
@@ -2159,13 +2232,14 @@ mpegts_try_discover_packet_size (MpegTSPacketizer2 * packetizer)
     /* find first sync byte */
     pos = -1;
     for (i = 0; i < MPEGTS_MAX_PACKETSIZE; i++) {
-      if (dest[i] == 0x47) {
+      if (dest[i] == PACKET_SYNC_BYTE) {
         for (j = 0; j < 4; j++) {
           guint packetsize = psizes[j];
           /* check each of the packet size possibilities in turn */
-          if (dest[i] == 0x47 && dest[i + packetsize] == 0x47 &&
-              dest[i + packetsize * 2] == 0x47 &&
-              dest[i + packetsize * 3] == 0x47) {
+          if (dest[i] == PACKET_SYNC_BYTE
+              && dest[i + packetsize] == PACKET_SYNC_BYTE
+              && dest[i + packetsize * 2] == PACKET_SYNC_BYTE
+              && dest[i + packetsize * 3] == PACKET_SYNC_BYTE) {
             packetizer->know_packet_size = TRUE;
             packetizer->packet_size = packetsize;
             packetizer->caps = gst_caps_new_simple ("video/mpegts",
@@ -2200,10 +2274,10 @@ mpegts_try_discover_packet_size (MpegTSPacketizer2 * packetizer)
       GST_DEBUG ("Flushing out %d bytes", pos);
       gst_adapter_flush (packetizer->adapter, pos);
       packetizer->offset += pos;
-    } else if (!packetizer->know_packet_size) {
-      /* drop invalid data and move to the next possible packets */
-      gst_adapter_flush (packetizer->adapter, MPEGTS_MAX_PACKETSIZE);
     }
+  } else {
+    /* drop invalid data and move to the next possible packets */
+    GST_DEBUG ("Could not determine packet size");
   }
 
   return packetizer->know_packet_size;
@@ -2235,6 +2309,7 @@ mpegts_packetizer_next_packet (MpegTSPacketizer2 * packetizer,
   while ((avail = packetizer->adapter->size) >= packetizer->packet_size) {
     packet->buffer = gst_adapter_take_buffer (packetizer->adapter,
         packetizer->packet_size);
+
     /* M2TS packets don't start with the sync byte, all other variants do */
     if (packetizer->packet_size == MPEGTS_M2TS_PACKETSIZE) {
       packet->data_start = GST_BUFFER_DATA (packet->buffer) + 4;
@@ -2250,6 +2325,8 @@ mpegts_packetizer_next_packet (MpegTSPacketizer2 * packetizer,
     packetizer->offset += packetizer->packet_size;
     GST_MEMDUMP ("buffer", GST_BUFFER_DATA (packet->buffer), 16);
     GST_MEMDUMP ("data_start", packet->data_start, 16);
+    GST_BUFFER_TIMESTAMP (packet->buffer) =
+        gst_adapter_prev_timestamp (packetizer->adapter, NULL);
 
     /* Check sync byte */
     if (G_UNLIKELY (packet->data_start[0] != 0x47)) {
@@ -2294,6 +2371,19 @@ done:
   return PACKET_NEED_MORE;
 }
 
+MpegTSPacketizerPacketReturn
+mpegts_packetizer_process_next_packet (MpegTSPacketizer2 * packetizer)
+{
+  MpegTSPacketizerPacket packet;
+  MpegTSPacketizerPacketReturn ret;
+
+  ret = mpegts_packetizer_next_packet (packetizer, &packet);
+  if (packet.buffer)
+    gst_buffer_unref (packet.buffer);
+
+  return ret;
+}
+
 void
 mpegts_packetizer_clear_packet (MpegTSPacketizer2 * packetizer,
     MpegTSPacketizerPacket * packet)
@@ -2332,6 +2422,12 @@ mpegts_packetizer_push_section (MpegTSPacketizer2 * packetizer,
   if (packet->pid == 0x14) {
     table_id = data[0];
     section->section_length = GST_READ_UINT24_BE (data) & 0x000FFF;
+    if (data - GST_BUFFER_DATA (packet->buffer) + section->section_length + 3 >
+        GST_BUFFER_SIZE (packet->buffer)) {
+      GST_WARNING ("PID %dd PSI section length extends past the end "
+          "of the buffer", packet->pid);
+      goto out;
+    }
     section->buffer = gst_buffer_create_sub (packet->buffer,
         data - GST_BUFFER_DATA (packet->buffer), section->section_length + 3);
     section->table_id = table_id;
@@ -2347,7 +2443,6 @@ mpegts_packetizer_push_section (MpegTSPacketizer2 * packetizer,
   sub_buf = gst_buffer_create_sub (packet->buffer,
       data - GST_BUFFER_DATA (packet->buffer), packet->data_end - data);
 
-
   stream = packetizer->streams[packet->pid];
   if (stream == NULL) {
     stream = mpegts_packetizer_stream_new ();
@@ -2356,7 +2451,7 @@ mpegts_packetizer_push_section (MpegTSPacketizer2 * packetizer,
 
   if (packet->payload_unit_start_indicator) {
     table_id = *data++;
-    /* subtable_extension should be read from 4th and 5th bytes only if 
+    /* subtable_extension should be read from 4th and 5th bytes only if
      * section_syntax_indicator is 1 */
     if ((data[0] & 0x80) == 0)
       subtable_extension = 0;
@@ -2481,7 +2576,7 @@ _init_local (void)
  * @is_multibyte: Location where information whether it's a multibyte encoding
  * or not is stored
  * @returns: Name of encoding or NULL of encoding could not be detected.
- * 
+ *
  * The returned string should be freed with g_free () when no longer needed.
  */
 static gchar *
@@ -2519,13 +2614,22 @@ get_encoding (const gchar * text, guint * start_text, gboolean * is_multibyte)
     *start_text = 1;
     *is_multibyte = TRUE;
   } else if (firstbyte == 0x12) {
-    /* That's korean encoding.
-     * The spec says it's encoded in KSC 5601, but iconv only knows KSC 5636.
-     * Couldn't find any information about either of them.
-     */
-    encoding = NULL;
+    /*  EUC-KR implements KSX1001 */
+    encoding = g_strdup ("EUC-KR");
     *start_text = 1;
     *is_multibyte = TRUE;
+  } else if (firstbyte == 0x13) {
+    encoding = g_strdup ("GB2312");
+    *start_text = 1;
+    *is_multibyte = FALSE;
+  } else if (firstbyte == 0x14) {
+    encoding = g_strdup ("UTF-16BE");
+    *start_text = 1;
+    *is_multibyte = TRUE;
+  } else if (firstbyte == 0x15) {
+    encoding = g_strdup ("ISO-10646/UTF8");
+    *start_text = 1;
+    *is_multibyte = FALSE;
   } else {
     /* reserved */
     encoding = NULL;
@@ -2577,7 +2681,7 @@ convert_to_utf8 (const gchar * text, gint length, guint start,
             /* skip it */
             break;
           case 0xE08A:{
-            guint8 nl[] = { 0x0A, 0x00 };       /* new line */
+            guint8 nl[] = { 0x00, 0x0A };       /* new line */
             g_byte_array_append (sb, nl, 2);
             break;
           }
@@ -2598,7 +2702,7 @@ convert_to_utf8 (const gchar * text, gint length, guint start,
             /* skip it */
             break;
           case 0xE08A:{
-            guint8 nl[] = { 0x0A, 0x00 };       /* new line */
+            guint8 nl[] = { 0x00, 0x0A };       /* new line */
             g_byte_array_append (sb, nl, 2);
             break;
           }
@@ -2726,3 +2830,434 @@ failed:
     return g_strndup (text, length - start_text);
   }
 }
+
+/**
+ * mpegts_packetizer_reset_skew:
+ * @packetizer: an #MpegTSPacketizer2
+ *
+ * Reset the skew calculations in @packetizer.
+ */
+static void
+mpegts_packetizer_reset_skew (MpegTSPacketizer2 * packetizer)
+{
+  /* FIXME : These variables should be *per* PCR PID */
+  packetizer->base_time = GST_CLOCK_TIME_NONE;
+  packetizer->base_pcrtime = GST_CLOCK_TIME_NONE;
+  packetizer->last_pcrtime = GST_CLOCK_TIME_NONE;
+  packetizer->window_pos = 0;
+  packetizer->window_filling = TRUE;
+  packetizer->window_min = 0;
+  packetizer->skew = 0;
+  packetizer->prev_send_diff = GST_CLOCK_TIME_NONE;
+  packetizer->prev_out_time = GST_CLOCK_TIME_NONE;
+  GST_DEBUG ("reset skew correction");
+}
+
+static void
+mpegts_packetizer_resync (MpegTSPacketizer2 * packetizer, GstClockTime time,
+    GstClockTime gstpcrtime, gboolean reset_skew)
+{
+  /* FIXME : These variables should be *per* PCR PID */
+  packetizer->base_time = time;
+  packetizer->base_pcrtime = gstpcrtime;
+  packetizer->prev_out_time = GST_CLOCK_TIME_NONE;
+  packetizer->prev_send_diff = GST_CLOCK_TIME_NONE;
+  if (reset_skew) {
+    packetizer->window_filling = TRUE;
+    packetizer->window_pos = 0;
+    packetizer->window_min = 0;
+    packetizer->window_size = 0;
+    packetizer->skew = 0;
+  }
+}
+
+
+/* Code mostly copied from -good/gst/rtpmanager/rtpjitterbuffer.c */
+
+/* For the clock skew we use a windowed low point averaging algorithm as can be
+ * found in Fober, Orlarey and Letz, 2005, "Real Time Clock Skew Estimation
+ * over Network Delays":
+ * http://www.grame.fr/Ressources/pub/TR-050601.pdf
+ * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.1546
+ *
+ * The idea is that the jitter is composed of:
+ *
+ *  J = N + n
+ *
+ *   N   : a constant network delay.
+ *   n   : random added noise. The noise is concentrated around 0
+ *
+ * In the receiver we can track the elapsed time at the sender with:
+ *
+ *  send_diff(i) = (Tsi - Ts0);
+ *
+ *   Tsi : The time at the sender at packet i
+ *   Ts0 : The time at the sender at the first packet
+ *
+ * This is the difference between the RTP timestamp in the first received packet
+ * and the current packet.
+ *
+ * At the receiver we have to deal with the jitter introduced by the network.
+ *
+ *  recv_diff(i) = (Tri - Tr0)
+ *
+ *   Tri : The time at the receiver at packet i
+ *   Tr0 : The time at the receiver at the first packet
+ *
+ * Both of these values contain a jitter Ji, a jitter for packet i, so we can
+ * write:
+ *
+ *  recv_diff(i) = (Cri + D + ni) - (Cr0 + D + n0))
+ *
+ *    Cri    : The time of the clock at the receiver for packet i
+ *    D + ni : The jitter when receiving packet i
+ *
+ * We see that the network delay is irrelevant here as we can elliminate D:
+ *
+ *  recv_diff(i) = (Cri + ni) - (Cr0 + n0))
+ *
+ * The drift is now expressed as:
+ *
+ *  Drift(i) = recv_diff(i) - send_diff(i);
+ *
+ * We now keep the W latest values of Drift and find the minimum (this is the
+ * one with the lowest network jitter and thus the one which is least affected
+ * by it). We average this lowest value to smooth out the resulting network skew.
+ *
+ * Both the window and the weighting used for averaging influence the accuracy
+ * of the drift estimation. Finding the correct parameters turns out to be a
+ * compromise between accuracy and inertia.
+ *
+ * We use a 2 second window or up to 512 data points, which is statistically big
+ * enough to catch spikes (FIXME, detect spikes).
+ * We also use a rather large weighting factor (125) to smoothly adapt. During
+ * startup, when filling the window, we use a parabolic weighting factor, the
+ * more the window is filled, the faster we move to the detected possible skew.
+ *
+ * Returns: @time adjusted with the clock skew.
+ */
+static GstClockTime
+calculate_skew (MpegTSPacketizer2 * packetizer, guint64 pcrtime,
+    GstClockTime time)
+{
+  guint64 send_diff, recv_diff;
+  gint64 delta;
+  gint64 old;
+  gint pos, i;
+  GstClockTime gstpcrtime, out_time;
+  guint64 slope;
+
+  gstpcrtime = PCRTIME_TO_GSTTIME (pcrtime);
+
+  /* keep track of the last extended pcrtime */
+  packetizer->last_pcrtime = gstpcrtime;
+
+  /* first time, lock on to time and gstpcrtime */
+  if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (packetizer->base_time))) {
+    packetizer->base_time = time;
+    packetizer->prev_out_time = GST_CLOCK_TIME_NONE;
+    GST_DEBUG ("Taking new base time %" GST_TIME_FORMAT, GST_TIME_ARGS (time));
+  }
+
+  if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (packetizer->base_pcrtime))) {
+    packetizer->base_pcrtime = gstpcrtime;
+    packetizer->prev_send_diff = -1;
+    GST_DEBUG ("Taking new base pcrtime %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (gstpcrtime));
+  }
+
+  if (G_LIKELY (gstpcrtime >= packetizer->base_pcrtime))
+    send_diff = gstpcrtime - packetizer->base_pcrtime;
+  else if (GST_CLOCK_TIME_IS_VALID (time)) {
+    /* elapsed time at sender, timestamps can go backwards and thus be smaller
+     * than our base time, take a new base time in that case. */
+    GST_WARNING ("backward timestamps at server, taking new base time");
+    mpegts_packetizer_resync (packetizer, time, gstpcrtime, FALSE);
+    send_diff = 0;
+  } else {
+    GST_WARNING ("backward timestamps at server but no timestamps");
+    send_diff = 0;
+    /* at least try to get a new timestamp.. */
+    packetizer->base_time = -1;
+  }
+
+  GST_DEBUG ("gstpcr %" GST_TIME_FORMAT ", buftime %" GST_TIME_FORMAT ", base %"
+      GST_TIME_FORMAT ", send_diff %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (gstpcrtime), GST_TIME_ARGS (time),
+      GST_TIME_ARGS (packetizer->base_pcrtime), GST_TIME_ARGS (send_diff));
+
+  /* we don't have an arrival timestamp so we can't do skew detection. we
+   * should still apply a timestamp based on RTP timestamp and base_time */
+  if (!GST_CLOCK_TIME_IS_VALID (time)
+      || !GST_CLOCK_TIME_IS_VALID (packetizer->base_time))
+    goto no_skew;
+
+  /* elapsed time at receiver, includes the jitter */
+  recv_diff = time - packetizer->base_time;
+
+  /* Ignore packets received at 100% the same time (i.e. from the same input buffer) */
+  if (G_UNLIKELY (time == packetizer->prev_in_time
+          && GST_CLOCK_TIME_IS_VALID (packetizer->prev_in_time)))
+    goto no_skew;
+
+  /* measure the diff */
+  delta = ((gint64) recv_diff) - ((gint64) send_diff);
+
+  /* measure the slope, this gives a rought estimate between the sender speed
+   * and the receiver speed. This should be approximately 8, higher values
+   * indicate a burst (especially when the connection starts) */
+  slope = recv_diff > 0 ? (send_diff * 8) / recv_diff : 8;
+
+  GST_DEBUG ("time %" GST_TIME_FORMAT ", base %" GST_TIME_FORMAT ", recv_diff %"
+      GST_TIME_FORMAT ", slope %" G_GUINT64_FORMAT, GST_TIME_ARGS (time),
+      GST_TIME_ARGS (packetizer->base_time), GST_TIME_ARGS (recv_diff), slope);
+
+  /* if the difference between the sender timeline and the receiver timeline
+   * changed too quickly we have to resync because the server likely restarted
+   * its timestamps. */
+  if (ABS (delta - packetizer->skew) > GST_SECOND) {
+    GST_WARNING ("delta - skew: %" GST_TIME_FORMAT " too big, reset skew",
+        GST_TIME_ARGS (delta - packetizer->skew));
+    mpegts_packetizer_resync (packetizer, time, gstpcrtime, TRUE);
+    send_diff = 0;
+    delta = 0;
+  }
+
+  pos = packetizer->window_pos;
+
+  if (G_UNLIKELY (packetizer->window_filling)) {
+    /* we are filling the window */
+    GST_DEBUG ("filling %d, delta %" G_GINT64_FORMAT, pos, delta);
+    packetizer->window[pos++] = delta;
+    /* calc the min delta we observed */
+    if (G_UNLIKELY (pos == 1 || delta < packetizer->window_min))
+      packetizer->window_min = delta;
+
+    if (G_UNLIKELY (send_diff >= MAX_TIME || pos >= MAX_WINDOW)) {
+      packetizer->window_size = pos;
+
+      /* window filled */
+      GST_DEBUG ("min %" G_GINT64_FORMAT, packetizer->window_min);
+
+      /* the skew is now the min */
+      packetizer->skew = packetizer->window_min;
+      packetizer->window_filling = FALSE;
+    } else {
+      gint perc_time, perc_window, perc;
+
+      /* figure out how much we filled the window, this depends on the amount of
+       * time we have or the max number of points we keep. */
+      perc_time = send_diff * 100 / MAX_TIME;
+      perc_window = pos * 100 / MAX_WINDOW;
+      perc = MAX (perc_time, perc_window);
+
+      /* make a parabolic function, the closer we get to the MAX, the more value
+       * we give to the scaling factor of the new value */
+      perc = perc * perc;
+
+      /* quickly go to the min value when we are filling up, slowly when we are
+       * just starting because we're not sure it's a good value yet. */
+      packetizer->skew =
+          (perc * packetizer->window_min + ((10000 -
+                  perc) * packetizer->skew)) / 10000;
+      packetizer->window_size = pos + 1;
+    }
+  } else {
+    /* pick old value and store new value. We keep the previous value in order
+     * to quickly check if the min of the window changed */
+    old = packetizer->window[pos];
+    packetizer->window[pos++] = delta;
+
+    if (G_UNLIKELY (delta <= packetizer->window_min)) {
+      /* if the new value we inserted is smaller or equal to the current min,
+       * it becomes the new min */
+      packetizer->window_min = delta;
+    } else if (G_UNLIKELY (old == packetizer->window_min)) {
+      gint64 min = G_MAXINT64;
+
+      /* if we removed the old min, we have to find a new min */
+      for (i = 0; i < packetizer->window_size; i++) {
+        /* we found another value equal to the old min, we can stop searching now */
+        if (packetizer->window[i] == old) {
+          min = old;
+          break;
+        }
+        if (packetizer->window[i] < min)
+          min = packetizer->window[i];
+      }
+      packetizer->window_min = min;
+    }
+    /* average the min values */
+    packetizer->skew =
+        (packetizer->window_min + (124 * packetizer->skew)) / 125;
+    GST_DEBUG ("delta %" G_GINT64_FORMAT ", new min: %" G_GINT64_FORMAT, delta,
+        packetizer->window_min);
+  }
+  /* wrap around in the window */
+  if (G_UNLIKELY (pos >= packetizer->window_size))
+    pos = 0;
+
+  packetizer->window_pos = pos;
+
+no_skew:
+  /* the output time is defined as the base timestamp plus the PCR time
+   * adjusted for the clock skew .*/
+  if (packetizer->base_time != -1) {
+    out_time = packetizer->base_time + send_diff;
+    /* skew can be negative and we don't want to make invalid timestamps */
+    if (packetizer->skew < 0 && out_time < -packetizer->skew) {
+      out_time = 0;
+    } else {
+      out_time += packetizer->skew;
+    }
+    /* check if timestamps are not going backwards, we can only check this if we
+     * have a previous out time and a previous send_diff */
+    if (G_LIKELY (packetizer->prev_out_time != -1
+            && packetizer->prev_send_diff != -1)) {
+      /* now check for backwards timestamps */
+      if (G_UNLIKELY (
+              /* if the server timestamps went up and the out_time backwards */
+              (send_diff > packetizer->prev_send_diff
+                  && out_time < packetizer->prev_out_time) ||
+              /* if the server timestamps went backwards and the out_time forwards */
+              (send_diff < packetizer->prev_send_diff
+                  && out_time > packetizer->prev_out_time) ||
+              /* if the server timestamps did not change */
+              send_diff == packetizer->prev_send_diff)) {
+        GST_DEBUG ("backwards timestamps, using previous time");
+        out_time = GSTTIME_TO_MPEGTIME (out_time);
+      }
+    }
+  } else {
+    /* We simply use the pcrtime without applying any skew compensation */
+    out_time = time;
+  }
+
+  packetizer->prev_out_time = out_time;
+  packetizer->prev_in_time = time;
+  packetizer->prev_send_diff = send_diff;
+
+  GST_DEBUG ("skew %" G_GINT64_FORMAT ", out %" GST_TIME_FORMAT,
+      packetizer->skew, GST_TIME_ARGS (out_time));
+
+  return out_time;
+}
+
+static void
+record_pcr (MpegTSPacketizer2 * packetizer, guint64 pcr, guint64 offset)
+{
+  MpegTSPacketizerPrivate *priv = packetizer->priv;
+
+  /* Check against first PCR */
+  if (priv->first_pcr == -1 || priv->first_offset > offset) {
+    GST_DEBUG ("Recording first value. PCR:%" G_GUINT64_FORMAT " offset:%"
+        G_GUINT64_FORMAT, pcr, offset);
+    priv->first_pcr = pcr;
+    priv->first_pcr_ts = PCRTIME_TO_GSTTIME (pcr);
+    priv->first_offset = offset;
+    priv->nb_seen_offsets++;
+  } else
+    /* If we didn't update the first PCR, let's check against last PCR */
+  if (priv->last_pcr == -1 || priv->last_offset < offset) {
+    GST_DEBUG ("Recording last value. PCR:%" G_GUINT64_FORMAT " offset:%"
+        G_GUINT64_FORMAT, pcr, offset);
+    if (G_UNLIKELY (priv->first_pcr != -1 && pcr < priv->first_pcr)) {
+      GST_DEBUG ("rollover detected");
+      pcr += PCR_MAX_VALUE;
+    }
+    priv->last_pcr = pcr;
+    priv->last_pcr_ts = PCRTIME_TO_GSTTIME (pcr);
+    priv->last_offset = offset;
+    priv->nb_seen_offsets++;
+  }
+}
+
+guint
+mpegts_packetizer_get_seen_pcr (MpegTSPacketizer2 * packetizer)
+{
+  return packetizer->priv->nb_seen_offsets;
+}
+
+GstClockTime
+mpegts_packetizer_offset_to_ts (MpegTSPacketizer2 * packetizer, guint64 offset)
+{
+  MpegTSPacketizerPrivate *priv = packetizer->priv;
+  GstClockTime res;
+
+  if (G_UNLIKELY (!packetizer->calculate_offset))
+    return GST_CLOCK_TIME_NONE;
+
+  if (G_UNLIKELY (priv->refoffset == -1))
+    return GST_CLOCK_TIME_NONE;
+
+  if (G_UNLIKELY (offset < priv->refoffset))
+    return GST_CLOCK_TIME_NONE;
+
+  /* Convert byte difference into time difference */
+  res = PCRTIME_TO_GSTTIME (gst_util_uint64_scale (offset - priv->refoffset,
+          priv->last_pcr - priv->first_pcr,
+          priv->last_offset - priv->first_offset));
+  GST_DEBUG ("Returning timestamp %" GST_TIME_FORMAT " for offset %"
+      G_GUINT64_FORMAT, GST_TIME_ARGS (res), offset);
+
+  return res;
+}
+
+GstClockTime
+mpegts_packetizer_pts_to_ts (MpegTSPacketizer2 * packetizer, GstClockTime pts)
+{
+  GstClockTime res = GST_CLOCK_TIME_NONE;
+
+  /* Use clock skew if present */
+  if (packetizer->calculate_skew
+      && GST_CLOCK_TIME_IS_VALID (packetizer->base_time)) {
+    GST_DEBUG ("pts %" G_GUINT64_FORMAT " base_pcrtime:%" G_GUINT64_FORMAT
+        " base_time:%" GST_TIME_FORMAT, pts, packetizer->base_pcrtime,
+        GST_TIME_ARGS (packetizer->base_time));
+    res = pts - packetizer->base_pcrtime + packetizer->base_time +
+        packetizer->skew;
+  } else
+    /* If not, use pcr observations */
+  if (packetizer->calculate_offset && packetizer->priv->first_pcr != -1) {
+    /* Rollover */
+    if (G_UNLIKELY (pts < packetizer->priv->first_pcr_ts))
+      pts += MPEGTIME_TO_GSTTIME (PTS_DTS_MAX_VALUE);
+    res = pts - packetizer->priv->first_pcr_ts;
+  }
+
+  GST_DEBUG ("Returning timestamp %" GST_TIME_FORMAT " for pts %"
+      GST_TIME_FORMAT, GST_TIME_ARGS (res), GST_TIME_ARGS (pts));
+  return res;
+}
+
+guint64
+mpegts_packetizer_ts_to_offset (MpegTSPacketizer2 * packetizer, GstClockTime ts)
+{
+  MpegTSPacketizerPrivate *priv = packetizer->priv;
+  guint64 res;
+
+  if (!packetizer->calculate_offset || packetizer->priv->first_pcr == -1)
+    return -1;
+
+  GST_DEBUG ("ts(pcr) %" G_GUINT64_FORMAT " first_pcr:%" G_GUINT64_FORMAT,
+      GSTTIME_TO_MPEGTIME (ts), priv->first_pcr);
+
+  /* Convert ts to PCRTIME */
+  res = gst_util_uint64_scale (GSTTIME_TO_PCRTIME (ts),
+      priv->last_offset - priv->first_offset, priv->last_pcr - priv->first_pcr);
+  res += priv->first_offset + priv->refoffset;
+
+  GST_DEBUG ("Returning offset %" G_GUINT64_FORMAT " for ts %" GST_TIME_FORMAT,
+      res, GST_TIME_ARGS (ts));
+
+  return res;
+}
+
+void
+mpegts_packetizer_set_reference_offset (MpegTSPacketizer2 * packetizer,
+    guint64 refoffset)
+{
+  GST_DEBUG ("Setting reference offset to %" G_GUINT64_FORMAT, refoffset);
+
+  packetizer->priv->refoffset = refoffset;
+}
diff --git a/gst/mpegtsdemux/mpegtspacketizer.h b/gst/mpegtsdemux/mpegtspacketizer.h
index 8328625..418da08 100644
--- a/gst/mpegtsdemux/mpegtspacketizer.h
+++ b/gst/mpegtsdemux/mpegtspacketizer.h
@@ -28,6 +28,8 @@
 #include <gst/base/gstadapter.h>
 #include <glib.h>
 
+#include "gstmpegdefs.h"
+
 #define MPEGTS_NORMAL_PACKETSIZE  188
 #define MPEGTS_M2TS_PACKETSIZE    192
 #define MPEGTS_DVB_ASI_PACKETSIZE 204
@@ -39,6 +41,8 @@
 #define MPEGTS_AFC_PCR_FLAG	0x10
 #define MPEGTS_AFC_OPCR_FLAG	0x08
 
+#define MAX_WINDOW 512
+
 G_BEGIN_DECLS
 
 #define GST_TYPE_MPEGTS_PACKETIZER \
@@ -54,6 +58,7 @@ G_BEGIN_DECLS
 
 typedef struct _MpegTSPacketizer2 MpegTSPacketizer2;
 typedef struct _MpegTSPacketizer2Class MpegTSPacketizer2Class;
+typedef struct _MpegTSPacketizerPrivate MpegTSPacketizerPrivate;
 
 typedef struct
 {
@@ -70,6 +75,7 @@ struct _MpegTSPacketizer2 {
 
   GstAdapter *adapter;
   /* streams hashed by pid */
+  /* FIXME : be more memory efficient (see how it's done in mpegtsbase) */
   MpegTSPacketizerStream **streams;
   gboolean disposed;
   gboolean know_packet_size;
@@ -79,6 +85,30 @@ struct _MpegTSPacketizer2 {
   /* current offset of the tip of the adapter */
   guint64 offset;
   gboolean empty;
+
+  /* clock skew calculation */
+  gboolean       calculate_skew;
+
+  /* Following variables are only active/used when
+   * calculate_skew is TRUE */
+  /* FIXME : These variables should be *per* PCR PID */
+  GstClockTime   base_time;
+  GstClockTime   base_pcrtime;
+  GstClockTime   prev_out_time;
+  GstClockTime   prev_in_time;
+  GstClockTime   last_pcrtime;
+  gint64         window[MAX_WINDOW];
+  guint          window_pos;
+  guint          window_size;
+  gboolean       window_filling;
+  gint64         window_min;
+  gint64         skew;
+  gint64         prev_send_diff;
+
+  /* offset/bitrate calculator */
+  gboolean       calculate_offset;
+
+  MpegTSPacketizerPrivate *priv;
 };
 
 struct _MpegTSPacketizer2Class {
@@ -143,6 +173,8 @@ void mpegts_packetizer_push (MpegTSPacketizer2 *packetizer, GstBuffer *buffer);
 gboolean mpegts_packetizer_has_packets (MpegTSPacketizer2 *packetizer);
 MpegTSPacketizerPacketReturn mpegts_packetizer_next_packet (MpegTSPacketizer2 *packetizer,
   MpegTSPacketizerPacket *packet);
+MpegTSPacketizerPacketReturn
+mpegts_packetizer_process_next_packet(MpegTSPacketizer2 * packetizer);
 void mpegts_packetizer_clear_packet (MpegTSPacketizer2 *packetizer,
   MpegTSPacketizerPacket *packet);
 void mpegts_packetizer_remove_stream(MpegTSPacketizer2 *packetizer,
@@ -162,8 +194,22 @@ GstStructure *mpegts_packetizer_parse_eit (MpegTSPacketizer2 *packetizer,
   MpegTSPacketizerSection *section);
 GstStructure *mpegts_packetizer_parse_tdt (MpegTSPacketizer2 *packetizer,
   MpegTSPacketizerSection *section);
-guint64 mpegts_packetizer_compute_pcr(const guint8 * data);
 
+/* Only valid if calculate_offset is TRUE */
+guint mpegts_packetizer_get_seen_pcr (MpegTSPacketizer2 *packetizer);
+
+GstClockTime
+mpegts_packetizer_offset_to_ts (MpegTSPacketizer2 * packetizer,
+				guint64 offset);
+guint64
+mpegts_packetizer_ts_to_offset (MpegTSPacketizer2 * packetizer,
+				GstClockTime ts);
+GstClockTime
+mpegts_packetizer_pts_to_ts (MpegTSPacketizer2 * packetizer,
+			     GstClockTime pts);
+void
+mpegts_packetizer_set_reference_offset (MpegTSPacketizer2 * packetizer,
+					guint64 refoffset);
 G_END_DECLS
 
 #endif /* GST_MPEGTS_PACKETIZER_H */
diff --git a/gst/mpegtsdemux/mpegtsparse.c b/gst/mpegtsdemux/mpegtsparse.c
index 26dde89..37b6da6 100644
--- a/gst/mpegtsdemux/mpegtsparse.c
+++ b/gst/mpegtsdemux/mpegtsparse.c
@@ -126,8 +126,7 @@ mpegts_parse_base_init (gpointer klass)
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 
   gst_element_class_add_static_pad_template (element_class, &src_template);
-  gst_element_class_add_static_pad_template (element_class,
-      &program_template);
+  gst_element_class_add_static_pad_template (element_class, &program_template);
 
   gst_element_class_set_details_simple (element_class,
       "MPEG transport stream parser", "Codec/Parser",
diff --git a/gst/mpegtsdemux/payload_parsers.c b/gst/mpegtsdemux/payload_parsers.c
deleted file mode 100644
index ca2c75e..0000000
--- a/gst/mpegtsdemux/payload_parsers.c
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * payload_parsers.c
- * Copyright (C) 2011 Janne Grunau
- *
- * Authors:
- *   Janne Grunau <janne.grunau@collabora.co.uk>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "payload_parsers.h"
-#include <gst/base/gstbitreader.h>
-
-#define PICTURE_START_CODE 0x00000100
-#define GROUP_START_CODE   0x000001B8
-
-#define SLICE_NAL_UNIT_TYPE     0x01
-#define SLICE_IDR_NAL_UNIT_TYPE 0x05
-#define SEI_NAL_UNIT_TYPE       0x06
-
-#define SEI_TYPE_RECOVERY_POINT 0x06
-
-typedef struct Mpeg2PictureHeader
-{
-  guint16 temporal_reference;
-  guint8 picture_coding_type;
-  guint16 vbv_delay;
-
-  /* picture_coding_type == 2 || picture_coding_type */
-  guint8 full_pel_forward_vector;
-  guint8 forward_f_code;
-
-  /* picture_coding_type == 3 */
-  guint8 full_pel_backward_vector;
-  guint8 backward_f_code;
-} Mpeg2PictureHeader;
-
-/* shortened slice header */
-typedef struct H264SliceHeader
-{
-  guint32 first_mb_in_slice;
-  guint8 slice_type;
-} H264SliceHeader;
-
-
-static guint8 *
-find_start_code (guint32 * start_code, guint8 * buffer, guint8 * buffer_end)
-{
-  if (G_UNLIKELY (buffer == NULL) || G_UNLIKELY (buffer_end == NULL)
-      || G_UNLIKELY (start_code == NULL))
-    return NULL;
-
-  while (buffer <= buffer_end) {
-
-    *start_code <<= 8;
-    *start_code |= *buffer++;
-
-    if ((*start_code & 0xffffff00) == 0x00000100)
-      return buffer;
-  }
-
-  return NULL;
-}
-
-static gboolean
-parse_mpeg2_picture_header (Mpeg2PictureHeader * hdr, guint8 * buffer,
-    guint8 * buffer_end)
-{
-  GstBitReader br = GST_BIT_READER_INIT (buffer, buffer_end - buffer);
-
-  if (gst_bit_reader_get_remaining (&br) < 40)
-    return FALSE;
-
-  hdr->temporal_reference = gst_bit_reader_get_bits_uint16_unchecked (&br, 10);
-  hdr->picture_coding_type = gst_bit_reader_get_bits_uint8_unchecked (&br, 3);
-  hdr->vbv_delay = gst_bit_reader_get_bits_uint16_unchecked (&br, 16);
-
-  if (hdr->picture_coding_type == 2 || hdr->picture_coding_type == 3) {
-    hdr->full_pel_forward_vector =
-        gst_bit_reader_get_bits_uint8_unchecked (&br, 1);
-    hdr->forward_f_code = gst_bit_reader_get_bits_uint8_unchecked (&br, 3);
-  }
-  if (hdr->picture_coding_type == 3) {
-    hdr->full_pel_backward_vector =
-        gst_bit_reader_get_bits_uint8_unchecked (&br, 1);
-    hdr->backward_f_code = gst_bit_reader_get_bits_uint8_unchecked (&br, 3);
-  }
-  return TRUE;
-}
-
-gboolean
-gst_tsdemux_has_mpeg2_keyframe (guint32 * state,
-    MpegTSPacketizerPacket * packet, gboolean * need_more)
-{
-  guint8 *data = packet->payload;
-  guint8 *data_end = packet->data_end;
-
-  GST_LOG ("state: 0x%08x", *state);
-
-  while (data <= data_end) {
-
-    data = find_start_code (state, data, data_end);
-
-    if (!data)
-      return FALSE;
-
-    GST_LOG ("found start code: 0x%08x", *state);
-
-    if (*state == GROUP_START_CODE) {
-      GST_DEBUG ("found group start code");
-      *state = 0xffffffff;
-      *need_more = FALSE;
-      return TRUE;
-    } else if (*state == PICTURE_START_CODE) {
-      Mpeg2PictureHeader hdr = { 0 };
-      gboolean success;
-
-      success = parse_mpeg2_picture_header (&hdr, data, data_end);
-      GST_DEBUG ("found picture start code, %sparsed, picture coding type: %d",
-          success ? "" : "not ", hdr.picture_coding_type);
-
-      *state = 0xffffffff;
-      *need_more = FALSE;
-      return success && hdr.picture_coding_type == 1;
-    }
-  }
-
-  return FALSE;
-}
-
-/* variable length Exp-Golomb parsing according to H.264 spec 9.1*/
-static gboolean
-read_golomb (GstBitReader * br, guint32 * value)
-{
-  guint8 b, leading_zeros = -1;
-  *value = 1;
-
-  for (b = 0; !b; leading_zeros++) {
-    if (!gst_bit_reader_get_bits_uint8 (br, &b, 1))
-      return FALSE;
-    *value *= 2;
-  }
-
-  *value = (*value >> 1) - 1;
-  if (leading_zeros > 0) {
-    guint32 tmp = 0;
-    if (!gst_bit_reader_get_bits_uint32 (br, &tmp, leading_zeros))
-      return FALSE;
-    *value += tmp;
-  }
-
-  return TRUE;
-}
-
-/* just parse the requirred bits of the slice header */
-static gboolean
-parse_h264_slice_header (H264SliceHeader * hdr, guint8 * buffer,
-    guint8 * buffer_end)
-{
-  guint32 value;
-  GstBitReader br = GST_BIT_READER_INIT (buffer, buffer_end - buffer);
-
-  if (!read_golomb (&br, &value))
-    return FALSE;
-  hdr->first_mb_in_slice = value;
-
-  if (!read_golomb (&br, &value))
-    return FALSE;
-  hdr->slice_type = value;
-
-  return TRUE;
-}
-
-enum H264SliceTypes
-{
-  h264_p_slice = 0,
-  h264_b_slice,
-  h264_i_slice,
-  h264_sp_slice,
-  h264_si_slice,
-  h264_p_slice_a,
-  h264_b_slice_a,
-  h264_i_slice_a,
-  h264_sp_slice_a,
-  h264_si_slice_a,
-};
-
-static gboolean
-is_key_slice (guint8 slice_type)
-{
-  switch (slice_type) {
-    case h264_i_slice:
-    case h264_si_slice:
-    case h264_i_slice_a:
-    case h264_si_slice_a:
-      return TRUE;
-  }
-  return FALSE;
-}
-
-gboolean
-gst_tsdemux_has_h264_keyframe (guint32 * state, MpegTSPacketizerPacket * packet,
-    gboolean * need_more)
-{
-  guint8 *data = packet->payload;
-  guint8 *data_end = packet->data_end;
-
-  GST_LOG ("state: 0x%08x", *state);
-
-  while (data <= data_end) {
-    guint8 nal_unit_type;
-    guint8 *next_data = NULL;
-
-    data = find_start_code (state, data, data_end);
-
-    if (!data)
-      goto beach;
-
-    GST_LOG ("found start code: 0x%08x", *state);
-
-    /* determine length */
-    nal_unit_type = *state & 0x1f;
-    next_data = find_start_code (state, data, data_end);
-
-    if (nal_unit_type == SEI_NAL_UNIT_TYPE && !next_data) {
-      GST_WARNING ("NAL unit 0x%02x not completely in ts packet",
-          nal_unit_type);
-      goto beach;
-    }
-    next_data -= 4;
-
-    switch (nal_unit_type) {
-      case SLICE_IDR_NAL_UNIT_TYPE:
-        GST_DEBUG ("found SLICE_IDR NAL unit type");
-        *state = 0xffffffff;
-        *need_more = FALSE;
-        return TRUE;
-      case SLICE_NAL_UNIT_TYPE:
-      {
-        H264SliceHeader hdr = { 0 };
-        gboolean success;
-
-        success = parse_h264_slice_header (&hdr, data, data_end);
-        GST_DEBUG ("found SLICE NAL unit type with slice type %d",
-            hdr.slice_type);
-
-        *state = 0xffffffff;
-        *need_more = FALSE;
-        return success && is_key_slice (hdr.slice_type);
-      }
-      case SEI_NAL_UNIT_TYPE:
-      {
-        guint32 recovery_frame_count;
-        GstBitReader br = GST_BIT_READER_INIT (data, next_data - data);
-
-        break;
-
-        /* SEI message is at least 24 bit long */
-        while (gst_bit_reader_get_remaining (&br) >= 24) {
-          gint type = 0, size = 0;
-          guint8 tmp = 0;
-
-          do {
-            if (!gst_bit_reader_get_bits_uint8 (&br, &tmp, 8))
-              goto beach;
-            type += tmp;
-          } while (tmp == 255);
-
-          do {
-            if (!gst_bit_reader_get_bits_uint8 (&br, &tmp, 8))
-              goto beach;
-            size += tmp;
-          } while (tmp == 255);
-
-
-          GST_LOG ("found SEI msg type: %d, len: %d", type, size);
-
-          switch (type) {
-            case SEI_TYPE_RECOVERY_POINT:
-              if (!read_golomb (&br, &recovery_frame_count))
-                return FALSE;
-              gst_bit_reader_skip (&br, 1);     /* exact_match */
-              gst_bit_reader_skip (&br, 1);     /* broken_link_flag */
-              gst_bit_reader_skip (&br, 2);     /* changing_slice_group_idc */
-              GST_DEBUG ("found SEI with recovery point message, "
-                  "recovery_frame_count: %d", recovery_frame_count);
-              return TRUE;
-            default:
-              /* skip all other sei messages */
-              gst_bit_reader_skip (&br, size * 8);
-          }
-        }
-      }
-        data = next_data;
-        *state = 0xffffffff;
-    }
-  }
-beach:
-  return FALSE;
-}
diff --git a/gst/mpegtsdemux/payload_parsers.h b/gst/mpegtsdemux/payload_parsers.h
deleted file mode 100644
index 7f7a480..0000000
--- a/gst/mpegtsdemux/payload_parsers.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * payload_parsers.h
- * Copyright (C) 2011 Janne Grunau
- *
- * Authors:
- *   Janne Grunau <janne.grunau@collabora.co.uk>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "mpegtspacketizer.h"
-
-typedef gboolean (*payload_parse_keyframe) (guint32 *state,
-					    MpegTSPacketizerPacket * packet,
-					    gboolean *need_more);
-
-gboolean gst_tsdemux_has_mpeg2_keyframe (guint32 *state,
-					 MpegTSPacketizerPacket * packet,
-					 gboolean *need_more);
-
-gboolean gst_tsdemux_has_h264_keyframe (guint32 *state,
-					MpegTSPacketizerPacket * packet,
-					gboolean *need_more);
diff --git a/gst/mpegtsdemux/tsdemux.c b/gst/mpegtsdemux/tsdemux.c
index 166089b..96eb75c 100644
--- a/gst/mpegtsdemux/tsdemux.c
+++ b/gst/mpegtsdemux/tsdemux.c
@@ -41,10 +41,9 @@
 #include "gstmpegdesc.h"
 #include "gstmpegdefs.h"
 #include "mpegtspacketizer.h"
-#include "payload_parsers.h"
 #include "pesparse.h"
 
-/* 
+/*
  * tsdemux
  *
  * See TODO for explanations on improvements needed
@@ -56,7 +55,7 @@
 #define TABLE_ID_UNSET 0xFF
 
 /* Size of the pendingbuffers array. */
-#define TS_MAX_PENDING_BUFFERS	256
+#define TS_MAX_PENDING_BUFFERS  256
 
 #define PCR_WRAP_SIZE_128KBPS (((gint64)1490)*(1024*1024))
 /* small PCR for wrap detection */
@@ -65,10 +64,23 @@
 #define PCR_MAX_VALUE (((((guint64)1)<<33) * 300) + 298)
 #define PTS_DTS_MAX_VALUE (((guint64)1) << 33)
 
+/* Seeking/Scanning related variables */
+
 /* seek to SEEK_TIMESTAMP_OFFSET before the desired offset and search then
  * either accurately or for the next timestamp
  */
-#define SEEK_TIMESTAMP_OFFSET (1000 * GST_MSECOND)
+#define SEEK_TIMESTAMP_OFFSET (500 * GST_MSECOND)
+
+#define SEGMENT_FORMAT "[format:%s, rate:%f, start:%"			\
+  GST_TIME_FORMAT", stop:%"GST_TIME_FORMAT", time:%"GST_TIME_FORMAT	\
+  ", accum:%"GST_TIME_FORMAT", last_stop:%"GST_TIME_FORMAT		\
+  ", duration:%"GST_TIME_FORMAT"]"
+
+#define SEGMENT_ARGS(a) gst_format_get_name((a).format), (a).rate,	\
+    GST_TIME_ARGS((a).start), GST_TIME_ARGS((a).stop),			\
+    GST_TIME_ARGS((a).time), GST_TIME_ARGS((a).accum),			\
+    GST_TIME_ARGS((a).last_stop), GST_TIME_ARGS((a).duration)
+
 
 GST_DEBUG_CATEGORY_STATIC (ts_demux_debug);
 #define GST_CAT_DEFAULT ts_demux_debug
@@ -102,6 +114,8 @@ struct _TSDemuxStream
   MpegTSBaseStream stream;
 
   GstPad *pad;
+  /* Whether the pad was added or not */
+  gboolean active;
 
   /* the return of the latest push */
   GstFlowReturn flow_return;
@@ -114,6 +128,11 @@ struct _TSDemuxStream
   GstBuffer *pendingbuffers[TS_MAX_PENDING_BUFFERS];
   guint8 nbpending;
 
+  /* Size of data to push (if known) */
+  guint expected_size;
+  /* Size of currently queued data */
+  guint current_size;
+
   /* Current data to be pushed out */
   GstBufferList *current;
   GstBufferListIterator *currentit;
@@ -125,9 +144,15 @@ struct _TSDemuxStream
   /* Raw value of current PTS/DTS */
   guint64 raw_pts;
   guint64 raw_dts;
+  /* PTS/DTS with rollover fixed */
+  guint64 fixed_pts;
+  guint64 fixed_dts;
   /* Number of rollover seen for PTS/DTS (default:0) */
   guint nb_pts_rollover;
   guint nb_dts_rollover;
+
+  /* Whether this stream needs to send a newsegment */
+  gboolean need_newsegment;
 };
 
 #define VIDEO_CAPS \
@@ -148,8 +173,11 @@ struct _TSDemuxStream
     "audio/mpeg, " \
       "mpegversion = (int) 1;" \
     "audio/mpeg, " \
-      "mpegversion = (int) 4, " \
+      "mpegversion = (int) 2, " \
       "stream-format = (string) adts; " \
+    "audio/mpeg, " \
+      "mpegversion = (int) 4, " \
+      "stream-format = (string) latm; " \
     "audio/x-lpcm, " \
       "width = (int) { 16, 20, 24 }, " \
       "rate = (int) { 48000, 96000 }, " \
@@ -198,8 +226,6 @@ enum
 };
 
 /* Pad functions */
-static const GstQueryType *gst_ts_demux_srcpad_query_types (GstPad * pad);
-static gboolean gst_ts_demux_srcpad_query (GstPad * pad, GstQuery * query);
 
 
 /* mpegtsbase methods */
@@ -215,23 +241,15 @@ gst_ts_demux_stream_added (MpegTSBase * base, MpegTSBaseStream * stream,
     MpegTSBaseProgram * program);
 static void
 gst_ts_demux_stream_removed (MpegTSBase * base, MpegTSBaseStream * stream);
-static GstFlowReturn gst_ts_demux_do_seek (MpegTSBase * base, GstEvent * event,
-    guint16 pid);
-static GstFlowReturn find_pcr_packet (MpegTSBase * base, guint64 offset,
-    gint64 length, TSPcrOffset * pcroffset);
-static GstFlowReturn find_timestamps (MpegTSBase * base, guint64 initoff,
-    guint64 * offset);
+static GstFlowReturn gst_ts_demux_do_seek (MpegTSBase * base, GstEvent * event);
 static void gst_ts_demux_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec);
 static void gst_ts_demux_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
-static void gst_ts_demux_finalize (GObject * object);
-static GstFlowReturn
-process_pcr (MpegTSBase * base, guint64 initoff, TSPcrOffset * pcroffset,
-    guint numpcr, gboolean isinitial);
 static void gst_ts_demux_flush_streams (GstTSDemux * tsdemux);
 static GstFlowReturn
 gst_ts_demux_push_pending_data (GstTSDemux * demux, TSDemuxStream * stream);
+static void gst_ts_demux_stream_flush (TSDemuxStream * stream);
 
 static gboolean push_event (MpegTSBase * base, GstEvent * event);
 static void _extra_init (GType type);
@@ -256,14 +274,11 @@ gst_ts_demux_base_init (gpointer klass)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 
-  gst_element_class_add_static_pad_template (element_class,
-      &video_template);
-  gst_element_class_add_static_pad_template (element_class,
-      &audio_template);
+  gst_element_class_add_static_pad_template (element_class, &video_template);
+  gst_element_class_add_static_pad_template (element_class, &audio_template);
   gst_element_class_add_static_pad_template (element_class,
       &subpicture_template);
-  gst_element_class_add_static_pad_template (element_class,
-      &private_template);
+  gst_element_class_add_static_pad_template (element_class, &private_template);
 
   gst_element_class_set_details_simple (element_class,
       "MPEG transport stream demuxer",
@@ -282,7 +297,6 @@ gst_ts_demux_class_init (GstTSDemuxClass * klass)
   gobject_class = G_OBJECT_CLASS (klass);
   gobject_class->set_property = gst_ts_demux_set_property;
   gobject_class->get_property = gst_ts_demux_get_property;
-  gobject_class->finalize = gst_ts_demux_finalize;
 
   g_object_class_install_property (gobject_class, PROP_PROGRAM_NUMBER,
       g_param_spec_int ("program-number", "Program number",
@@ -302,56 +316,37 @@ gst_ts_demux_class_init (GstTSDemuxClass * klass)
   ts_class->program_started = GST_DEBUG_FUNCPTR (gst_ts_demux_program_started);
   ts_class->stream_added = gst_ts_demux_stream_added;
   ts_class->stream_removed = gst_ts_demux_stream_removed;
-  ts_class->find_timestamps = GST_DEBUG_FUNCPTR (find_timestamps);
   ts_class->seek = GST_DEBUG_FUNCPTR (gst_ts_demux_do_seek);
   ts_class->flush = GST_DEBUG_FUNCPTR (gst_ts_demux_flush);
 }
 
 static void
-gst_ts_demux_init (GstTSDemux * demux, GstTSDemuxClass * klass)
-{
-  demux->need_newsegment = TRUE;
-  demux->program_number = -1;
-  demux->duration = GST_CLOCK_TIME_NONE;
-  GST_MPEGTS_BASE (demux)->stream_size = sizeof (TSDemuxStream);
-  gst_segment_init (&demux->segment, GST_FORMAT_TIME);
-  demux->first_pcr = (TSPcrOffset) {
-  GST_CLOCK_TIME_NONE, 0, 0};
-  demux->cur_pcr = (TSPcrOffset) {
-  0};
-  demux->last_pcr = (TSPcrOffset) {
-  0};
-}
-
-static void
 gst_ts_demux_reset (MpegTSBase * base)
 {
   GstTSDemux *demux = (GstTSDemux *) base;
 
-  if (demux->index) {
-    g_array_free (demux->index, TRUE);
-    demux->index = NULL;
-  }
-  demux->index_size = 0;
-  demux->need_newsegment = TRUE;
   demux->program_number = -1;
-  demux->duration = GST_CLOCK_TIME_NONE;
+  demux->calculate_update_segment = FALSE;
+
   gst_segment_init (&demux->segment, GST_FORMAT_TIME);
-  demux->first_pcr = (TSPcrOffset) {
-  GST_CLOCK_TIME_NONE, 0, 0};
-  demux->cur_pcr = (TSPcrOffset) {
-  0};
-  demux->last_pcr = (TSPcrOffset) {
-  0};
+  if (demux->segment_event) {
+    gst_event_unref (demux->segment_event);
+    demux->segment_event = NULL;
+  }
+
+  if (demux->update_segment) {
+    gst_event_unref (demux->update_segment);
+    demux->update_segment = NULL;
+  }
 }
 
 static void
-gst_ts_demux_finalize (GObject * object)
+gst_ts_demux_init (GstTSDemux * demux, GstTSDemuxClass * klass)
 {
-  if (G_OBJECT_CLASS (parent_class)->finalize)
-    G_OBJECT_CLASS (parent_class)->finalize (object);
-}
+  GST_MPEGTS_BASE (demux)->stream_size = sizeof (TSDemuxStream);
 
+  gst_ts_demux_reset ((MpegTSBase *) demux);
+}
 
 
 static void
@@ -398,6 +393,7 @@ gst_ts_demux_srcpad_query_types (GstPad * pad)
   static const GstQueryType query_types[] = {
     GST_QUERY_DURATION,
     GST_QUERY_SEEKING,
+    GST_QUERY_LATENCY,
     0
   };
 
@@ -417,18 +413,57 @@ gst_ts_demux_srcpad_query (GstPad * pad, GstQuery * query)
 
   switch (GST_QUERY_TYPE (query)) {
     case GST_QUERY_DURATION:
+    {
       GST_DEBUG ("query duration");
       gst_query_parse_duration (query, &format, NULL);
       if (format == GST_FORMAT_TIME) {
-        if (!gst_pad_peer_query (base->sinkpad, query))
-          gst_query_set_duration (query, GST_FORMAT_TIME,
-              demux->segment.duration);
+        if (!gst_pad_peer_query (base->sinkpad, query)) {
+          gint64 val;
+
+          format = GST_FORMAT_BYTES;
+          if (!gst_pad_query_peer_duration (base->sinkpad, &format, &val))
+            res = FALSE;
+          else {
+            GstClockTime dur =
+                mpegts_packetizer_offset_to_ts (base->packetizer, val);
+            if (GST_CLOCK_TIME_IS_VALID (dur))
+              gst_query_set_duration (query, GST_FORMAT_TIME, dur);
+            else
+              res = FALSE;
+          }
+        }
       } else {
         GST_DEBUG_OBJECT (demux, "only query duration on TIME is supported");
         res = FALSE;
       }
       break;
+    }
+    case GST_QUERY_LATENCY:
+    {
+      GST_DEBUG ("query latency");
+      res = gst_pad_peer_query (base->sinkpad, query);
+      if (res && base->upstream_live) {
+        GstClockTime min_lat, max_lat;
+        gboolean live;
+
+        /* According to H.222.0
+           Annex D.0.3 (System Time Clock recovery in the decoder)
+           and D.0.2 (Audio and video presentation synchronization)
+
+           We can end up with an interval of up to 700ms between valid
+           PCR/SCR. We therefore allow a latency of 700ms for that.
+         */
+        gst_query_parse_latency (query, &live, &min_lat, &max_lat);
+        if (min_lat != -1)
+          min_lat += 700 * GST_MSECOND;
+        if (max_lat != -1)
+          max_lat += 700 * GST_MSECOND;
+        gst_query_set_latency (query, live, min_lat, max_lat);
+      }
+      break;
+    }
     case GST_QUERY_SEEKING:
+    {
       GST_DEBUG ("query seeking");
       gst_query_parse_seeking (query, &format, NULL, NULL, NULL);
       if (format == GST_FORMAT_TIME) {
@@ -448,6 +483,7 @@ gst_ts_demux_srcpad_query (GstPad * pad, GstQuery * query)
         res = FALSE;
       }
       break;
+    }
     default:
       res = gst_pad_query_default (pad, query);
   }
@@ -457,374 +493,8 @@ gst_ts_demux_srcpad_query (GstPad * pad, GstQuery * query)
 
 }
 
-static inline GstClockTime
-calculate_gsttime (TSPcrOffset * start, guint64 pcr)
-{
-
-  GstClockTime time = start->gsttime;
-
-  if (start->pcr > pcr)
-    time += PCRTIME_TO_GSTTIME (PCR_MAX_VALUE - start->pcr) +
-        PCRTIME_TO_GSTTIME (pcr);
-  else
-    time += PCRTIME_TO_GSTTIME (pcr - start->pcr);
-
-  return time;
-}
-
-static GstFlowReturn
-gst_ts_demux_parse_pes_header_pts (GstTSDemux * demux,
-    MpegTSPacketizerPacket * packet, guint64 * time)
-{
-  PESHeader header;
-  gint offset = 0;
-
-  if (mpegts_parse_pes_header (packet->payload,
-          packet->data_end - packet->payload, &header, &offset))
-    return GST_FLOW_ERROR;
-
-  *time = header.PTS;
-  return GST_FLOW_OK;
-}
-
-/* performs a accurate/key_unit seek */
-static GstFlowReturn
-gst_ts_demux_perform_auxiliary_seek (MpegTSBase * base, GstClockTime seektime,
-    TSPcrOffset * pcroffset, gint64 length, gint16 pid, GstSeekFlags flags,
-    payload_parse_keyframe auxiliary_seek_fn)
-{
-  GstTSDemux *demux = (GstTSDemux *) base;
-  GstFlowReturn res = GST_FLOW_ERROR;
-  gboolean done = FALSE;
-  gboolean found_keyframe = FALSE, found_accurate = FALSE, need_more = TRUE;
-  GstBuffer *buf;
-  MpegTSPacketizerPacket packet;
-  MpegTSPacketizerPacketReturn pret;
-  gint64 offset = pcroffset->offset;
-  gint64 scan_offset = MIN (length, 50 * MPEGTS_MAX_PACKETSIZE);
-  guint32 state = 0xffffffff;
-  TSPcrOffset key_pos = { 0 };
-
-  GST_DEBUG ("auxiliary seek for %" GST_TIME_FORMAT " from offset: %"
-      G_GINT64_FORMAT " in %" G_GINT64_FORMAT " bytes for PID: %d "
-      "%s %s", GST_TIME_ARGS (seektime), pcroffset->offset, length, pid,
-      (flags & GST_SEEK_FLAG_ACCURATE) ? "accurate" : "",
-      (flags & GST_SEEK_FLAG_KEY_UNIT) ? "key_unit" : "");
-
-  mpegts_packetizer_flush (base->packetizer);
-
-  if (base->packetizer->packet_size == MPEGTS_M2TS_PACKETSIZE)
-    offset -= 4;
-
-  while (!done && scan_offset <= length) {
-    res =
-        gst_pad_pull_range (base->sinkpad, offset + scan_offset,
-        50 * MPEGTS_MAX_PACKETSIZE, &buf);
-    if (res != GST_FLOW_OK)
-      goto beach;
-    mpegts_packetizer_push (base->packetizer, buf);
-
-    while ((!done)
-        && ((pret =
-                mpegts_packetizer_next_packet (base->packetizer,
-                    &packet)) != PACKET_NEED_MORE)) {
-      if (G_UNLIKELY (pret == PACKET_BAD))
-        /* bad header, skip the packet */
-        goto next;
-
-      if (packet.payload_unit_start_indicator)
-        GST_DEBUG ("found packet for PID: %d with pcr: %" GST_TIME_FORMAT
-            " at offset: %" G_GINT64_FORMAT, packet.pid,
-            GST_TIME_ARGS (packet.pcr), packet.offset);
-
-      if (packet.payload != NULL && packet.pid == pid) {
-
-        if (packet.payload_unit_start_indicator) {
-          guint64 pts = 0;
-          GstFlowReturn ok =
-              gst_ts_demux_parse_pes_header_pts (demux, &packet, &pts);
-          if (ok == GST_FLOW_OK) {
-            GstClockTime time = calculate_gsttime (pcroffset, pts * 300);
-
-            GST_DEBUG ("packet has PTS: %" GST_TIME_FORMAT,
-                GST_TIME_ARGS (time));
-
-            if (time <= seektime) {
-              pcroffset->gsttime = time;
-              pcroffset->pcr = packet.pcr;
-              pcroffset->offset = packet.offset;
-            } else
-              found_accurate = TRUE;
-          } else
-            goto next;
-          /* reset state for new packet */
-          state = 0xffffffff;
-          need_more = TRUE;
-        }
-
-        if (auxiliary_seek_fn) {
-          if (need_more) {
-            if (auxiliary_seek_fn (&state, &packet, &need_more)) {
-              found_keyframe = TRUE;
-              key_pos = *pcroffset;
-              GST_DEBUG ("found keyframe: time: %" GST_TIME_FORMAT " pcr: %"
-                  GST_TIME_FORMAT " offset %" G_GINT64_FORMAT,
-                  GST_TIME_ARGS (pcroffset->gsttime),
-                  GST_TIME_ARGS (pcroffset->pcr), pcroffset->offset);
-            }
-          }
-        } else {
-          /* if we don't have a payload parsing function
-           * every frame is a keyframe */
-          found_keyframe = TRUE;
-        }
-      }
-      if (flags & GST_SEEK_FLAG_ACCURATE)
-        done = found_accurate && found_keyframe;
-      else
-        done = found_keyframe;
-      if (done)
-        *pcroffset = key_pos;
-    next:
-      mpegts_packetizer_clear_packet (base->packetizer, &packet);
-    }
-    scan_offset += 50 * MPEGTS_MAX_PACKETSIZE;
-  }
-
-beach:
-  if (done)
-    res = GST_FLOW_OK;
-  else if (GST_FLOW_OK == res)
-    res = GST_FLOW_CUSTOM_ERROR_1;
-
-  mpegts_packetizer_flush (base->packetizer);
-  return res;
-}
-
-static gint
-TSPcrOffset_find (gconstpointer a, gconstpointer b, gpointer user_data)
-{
-
-/*   GST_INFO ("a: %" GST_TIME_FORMAT " offset: %" G_GINT64_FORMAT, */
-/*       GST_TIME_ARGS (((TSPcrOffset *) a)->gsttime), ((TSPcrOffset *) a)->offset); */
-/*   GST_INFO ("b: %" GST_TIME_FORMAT " offset: %" G_GINT64_FORMAT, */
-/*       GST_TIME_ARGS (((TSPcrOffset *) b)->gsttime), ((TSPcrOffset *) b)->offset); */
-
-  if (((TSPcrOffset *) a)->gsttime < ((TSPcrOffset *) b)->gsttime)
-    return -1;
-  else if (((TSPcrOffset *) a)->gsttime > ((TSPcrOffset *) b)->gsttime)
-    return 1;
-  else
-    return 0;
-}
-
 static GstFlowReturn
-gst_ts_demux_perform_seek (MpegTSBase * base, GstSegment * segment, guint16 pid)
-{
-  GstTSDemux *demux = (GstTSDemux *) base;
-  GstFlowReturn res = GST_FLOW_ERROR;
-  int max_loop_cnt, loop_cnt = 0;
-  gint64 seekpos = 0;
-  gint64 time_diff;
-  GstClockTime seektime;
-  TSPcrOffset seekpcroffset, pcr_start, pcr_stop, *tmp;
-
-  max_loop_cnt = (segment->flags & GST_SEEK_FLAG_ACCURATE) ? 25 : 10;
-
-  seektime =
-      MAX (0,
-      segment->last_stop - SEEK_TIMESTAMP_OFFSET) + demux->first_pcr.gsttime;
-  seekpcroffset.gsttime = seektime;
-
-  GST_DEBUG ("seeking to %" GST_TIME_FORMAT, GST_TIME_ARGS (seektime));
-
-  gst_ts_demux_flush_streams (demux);
-
-  if (G_UNLIKELY (!demux->index)) {
-    GST_ERROR ("no index");
-    goto done;
-  }
-
-  /* get the first index entry before the seek position */
-  tmp = gst_util_array_binary_search (demux->index->data, demux->index_size,
-      sizeof (*tmp), TSPcrOffset_find, GST_SEARCH_MODE_BEFORE, &seekpcroffset,
-      NULL);
-
-  if (G_UNLIKELY (!tmp)) {
-    GST_ERROR ("value not found");
-    goto done;
-  }
-
-  pcr_start = *tmp;
-  pcr_stop = *(++tmp);
-
-  if (G_UNLIKELY (!pcr_stop.offset)) {
-    GST_ERROR ("invalid entry");
-    goto done;
-  }
-
-  /* check if the last recorded pcr can be used */
-  if (pcr_start.offset < demux->cur_pcr.offset
-      && demux->cur_pcr.offset < pcr_stop.offset) {
-    demux->cur_pcr.gsttime = calculate_gsttime (&pcr_start, demux->cur_pcr.pcr);
-    if (demux->cur_pcr.gsttime < seekpcroffset.gsttime)
-      pcr_start = demux->cur_pcr;
-    else
-      pcr_stop = demux->cur_pcr;
-  }
-
-  GST_DEBUG ("start %" GST_TIME_FORMAT " offset: %" G_GINT64_FORMAT,
-      GST_TIME_ARGS (pcr_start.gsttime), pcr_start.offset);
-  GST_DEBUG ("stop  %" GST_TIME_FORMAT " offset: %" G_GINT64_FORMAT,
-      GST_TIME_ARGS (pcr_stop.gsttime), pcr_stop.offset);
-
-  time_diff = seektime - pcr_start.gsttime;
-  seekpcroffset = pcr_start;
-
-  GST_DEBUG ("cur  %" GST_TIME_FORMAT " offset: %" G_GINT64_FORMAT
-      " time diff: %" G_GINT64_FORMAT,
-      GST_TIME_ARGS (demux->cur_pcr.gsttime), demux->cur_pcr.offset, time_diff);
-
-  /* seek loop */
-  while (loop_cnt++ < max_loop_cnt && (time_diff > SEEK_TIMESTAMP_OFFSET >> 1)
-      && (pcr_stop.gsttime - pcr_start.gsttime > SEEK_TIMESTAMP_OFFSET)) {
-    gint64 duration = pcr_stop.gsttime - pcr_start.gsttime;
-    gint64 size = pcr_stop.offset - pcr_start.offset;
-
-    if (loop_cnt & 1)
-      seekpos = pcr_start.offset + (size >> 1);
-    else
-      seekpos =
-          pcr_start.offset + size * ((double) (seektime -
-              pcr_start.gsttime) / duration);
-
-    /* look a litle bit behind */
-    seekpos =
-        MAX (pcr_start.offset + 188, seekpos - 55 * MPEGTS_MAX_PACKETSIZE);
-
-    GST_DEBUG ("looking for time: %" GST_TIME_FORMAT " .. %" GST_TIME_FORMAT
-        " .. %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (pcr_start.gsttime),
-        GST_TIME_ARGS (seektime), GST_TIME_ARGS (pcr_stop.gsttime));
-    GST_DEBUG ("looking in bytes: %" G_GINT64_FORMAT " .. %" G_GINT64_FORMAT
-        " .. %" G_GINT64_FORMAT, pcr_start.offset, seekpos, pcr_stop.offset);
-
-    res =
-        find_pcr_packet (&demux->parent, seekpos, 4000 * MPEGTS_MAX_PACKETSIZE,
-        &seekpcroffset);
-    if (G_UNLIKELY (res == GST_FLOW_UNEXPECTED)) {
-      seekpos =
-          MAX ((gint64) pcr_start.offset,
-          seekpos - 2000 * MPEGTS_MAX_PACKETSIZE) + 188;
-      res =
-          find_pcr_packet (&demux->parent, seekpos,
-          8000 * MPEGTS_MAX_PACKETSIZE, &seekpcroffset);
-    }
-    if (G_UNLIKELY (res != GST_FLOW_OK)) {
-      GST_WARNING ("seeking failed %s", gst_flow_get_name (res));
-      goto done;
-    }
-
-    seekpcroffset.gsttime = calculate_gsttime (&pcr_start, seekpcroffset.pcr);
-
-    /* validate */
-    if (G_UNLIKELY ((seekpcroffset.gsttime < pcr_start.gsttime) ||
-            (seekpcroffset.gsttime > pcr_stop.gsttime))) {
-      GST_ERROR ("Unexpected timestamp found, seeking failed! %"
-          GST_TIME_FORMAT, GST_TIME_ARGS (seekpcroffset.gsttime));
-      res = GST_FLOW_ERROR;
-      goto done;
-    }
-
-    if (seekpcroffset.gsttime > seektime) {
-      pcr_stop = seekpcroffset;
-    } else {
-      pcr_start = seekpcroffset;
-    }
-    time_diff = seektime - pcr_start.gsttime;
-    GST_DEBUG ("seeking: %" GST_TIME_FORMAT " found: %" GST_TIME_FORMAT
-        " diff = %" G_GINT64_FORMAT, GST_TIME_ARGS (seektime),
-        GST_TIME_ARGS (seekpcroffset.gsttime), time_diff);
-  }
-
-  GST_DEBUG ("seeking finished after %d loops", loop_cnt);
-
-  /* use correct seek position for the auxiliary search */
-  seektime += SEEK_TIMESTAMP_OFFSET;
-
-  {
-    payload_parse_keyframe keyframe_seek = NULL;
-    MpegTSBaseProgram *program = demux->program;
-    guint64 avg_bitrate, length;
-
-    if (program->streams[pid]) {
-      switch (program->streams[pid]->stream_type) {
-        case ST_VIDEO_MPEG1:
-        case ST_VIDEO_MPEG2:
-          keyframe_seek = gst_tsdemux_has_mpeg2_keyframe;
-          break;
-        case ST_VIDEO_H264:
-          keyframe_seek = gst_tsdemux_has_h264_keyframe;
-          break;
-        case ST_VIDEO_MPEG4:
-        case ST_VIDEO_DIRAC:
-          GST_WARNING ("no payload parser for stream 0x%04x type: 0x%02x", pid,
-              program->streams[pid]->stream_type);
-          break;
-      }
-    } else
-      GST_WARNING ("no stream info for PID: 0x%04x", pid);
-
-    avg_bitrate =
-        (pcr_stop.offset -
-        pcr_start.offset) * 1000 * GST_MSECOND / (pcr_stop.gsttime -
-        pcr_start.gsttime);
-
-    seekpcroffset = pcr_start;
-    /* search in 2500ms for a keyframe */
-    length =
-        MIN (demux->last_pcr.offset - pcr_start.offset,
-        (avg_bitrate * 25) / 10);
-    res =
-        gst_ts_demux_perform_auxiliary_seek (base, seektime, &seekpcroffset,
-        length, pid, segment->flags, keyframe_seek);
-
-    if (res == GST_FLOW_CUSTOM_ERROR_1) {
-      GST_ERROR ("no keyframe found in %" G_GUINT64_FORMAT
-          " bytes starting from %" G_GUINT64_FORMAT, length,
-          seekpcroffset.offset);
-      res = GST_FLOW_ERROR;
-    }
-    if (res != GST_FLOW_OK)
-      goto done;
-  }
-
-
-  /* update seektime to the actual timestamp of the found keyframe */
-  if (segment->flags & GST_SEEK_FLAG_KEY_UNIT)
-    seektime = seekpcroffset.gsttime;
-
-  seektime -= demux->first_pcr.gsttime;
-
-  segment->last_stop = seektime;
-  segment->time = seektime;
-
-  /* we stop at the end */
-  if (segment->stop == -1)
-    segment->stop = demux->first_pcr.gsttime + segment->duration;
-
-  demux->need_newsegment = TRUE;
-  demux->parent.seek_offset = seekpcroffset.offset;
-  GST_DEBUG ("seeked to postion:%" GST_TIME_FORMAT, GST_TIME_ARGS (seektime));
-  res = GST_FLOW_OK;
-
-done:
-  return res;
-}
-
-
-static GstFlowReturn
-gst_ts_demux_do_seek (MpegTSBase * base, GstEvent * event, guint16 pid)
+gst_ts_demux_do_seek (MpegTSBase * base, GstEvent * event)
 {
   GstTSDemux *demux = (GstTSDemux *) base;
   GstFlowReturn res = GST_FLOW_ERROR;
@@ -835,6 +505,7 @@ gst_ts_demux_do_seek (MpegTSBase * base, GstEvent * event, guint16 pid)
   gint64 start, stop;
   GstSegment seeksegment;
   gboolean update;
+  guint64 start_offset;
 
   gst_event_parse_seek (event, &rate, &format, &flags, &start_type, &start,
       &stop_type, &stop);
@@ -855,31 +526,35 @@ gst_ts_demux_do_seek (MpegTSBase * base, GstEvent * event, guint16 pid)
   /* copy segment, we need this because we still need the old
    * segment when we close the current segment. */
   memcpy (&seeksegment, &demux->segment, sizeof (GstSegment));
+  if (demux->segment_event) {
+    gst_event_unref (demux->segment_event);
+    demux->segment_event = NULL;
+  }
   /* configure the segment with the seek variables */
   GST_DEBUG_OBJECT (demux, "configuring seek");
-  GST_DEBUG ("seeksegment: start: %" GST_TIME_FORMAT " stop: %"
-      GST_TIME_FORMAT " time: %" GST_TIME_FORMAT " accum: %" GST_TIME_FORMAT
-      " last_stop: %" GST_TIME_FORMAT " duration: %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (seeksegment.start), GST_TIME_ARGS (seeksegment.stop),
-      GST_TIME_ARGS (seeksegment.time), GST_TIME_ARGS (seeksegment.accum),
-      GST_TIME_ARGS (seeksegment.last_stop),
-      GST_TIME_ARGS (seeksegment.duration));
+  GST_DEBUG ("seeksegment before set_seek " SEGMENT_FORMAT,
+      SEGMENT_ARGS (seeksegment));
+
   gst_segment_set_seek (&seeksegment, rate, format, flags, start_type, start,
       stop_type, stop, &update);
-  GST_DEBUG ("seeksegment: start: %" GST_TIME_FORMAT " stop: %"
-      GST_TIME_FORMAT " time: %" GST_TIME_FORMAT " accum: %" GST_TIME_FORMAT
-      " last_stop: %" GST_TIME_FORMAT " duration: %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (seeksegment.start), GST_TIME_ARGS (seeksegment.stop),
-      GST_TIME_ARGS (seeksegment.time), GST_TIME_ARGS (seeksegment.accum),
-      GST_TIME_ARGS (seeksegment.last_stop),
-      GST_TIME_ARGS (seeksegment.duration));
-
-  res = gst_ts_demux_perform_seek (base, &seeksegment, pid);
-  if (G_UNLIKELY (res != GST_FLOW_OK)) {
-    GST_WARNING ("seeking failed %s", gst_flow_get_name (res));
+
+  GST_DEBUG ("seeksegment after set_seek " SEGMENT_FORMAT,
+      SEGMENT_ARGS (seeksegment));
+
+  /* Convert start/stop to offset */
+  start_offset =
+      mpegts_packetizer_ts_to_offset (base->packetizer, MAX (0,
+          start - SEEK_TIMESTAMP_OFFSET));
+
+  if (G_UNLIKELY (start_offset == -1)) {
+    GST_WARNING ("Couldn't convert start position to an offset");
     goto done;
   }
 
+  /* record offset */
+  base->seek_offset = start_offset;
+  res = GST_FLOW_OK;
+
   /* commit the new segment */
   memcpy (&demux->segment, &seeksegment, sizeof (GstSegment));
 
@@ -1006,8 +681,7 @@ create_pad_for_stream (MpegTSBase * base, MpegTSBaseStream * bstream,
       break;
     case ST_PRIVATE_DATA:
       GST_LOG ("private data");
-      desc =
-          mpegts_get_descriptor_from_stream ((MpegTSBaseStream *) stream,
+      desc = mpegts_get_descriptor_from_stream ((MpegTSBaseStream *) stream,
           DESC_DVB_AC3);
       if (desc) {
         GST_LOG ("ac3 audio");
@@ -1017,8 +691,8 @@ create_pad_for_stream (MpegTSBase * base, MpegTSBaseStream * bstream,
         g_free (desc);
         break;
       }
-      desc =
-          mpegts_get_descriptor_from_stream ((MpegTSBaseStream *) stream,
+
+      desc = mpegts_get_descriptor_from_stream ((MpegTSBaseStream *) stream,
           DESC_DVB_ENHANCED_AC3);
       if (desc) {
         GST_LOG ("ac3 audio");
@@ -1028,8 +702,7 @@ create_pad_for_stream (MpegTSBase * base, MpegTSBaseStream * bstream,
         g_free (desc);
         break;
       }
-      desc =
-          mpegts_get_descriptor_from_stream ((MpegTSBaseStream *) stream,
+      desc = mpegts_get_descriptor_from_stream ((MpegTSBaseStream *) stream,
           DESC_DVB_TELETEXT);
       if (desc) {
         GST_LOG ("teletext");
@@ -1050,6 +723,26 @@ create_pad_for_stream (MpegTSBase * base, MpegTSBaseStream * bstream,
         g_free (desc);
         break;
       }
+
+      desc = mpegts_get_descriptor_from_stream ((MpegTSBaseStream *) stream,
+          DESC_REGISTRATION);
+      if (desc) {
+        switch (DESC_REGISTRATION_format_identifier (desc)) {
+          case DRF_ID_DTS1:
+          case DRF_ID_DTS2:
+          case DRF_ID_DTS3:
+            /* SMPTE registered DTS */
+            GST_LOG ("subtitling");
+            template = gst_static_pad_template_get (&private_template);
+            name = g_strdup_printf ("private_%04x", bstream->pid);
+            caps = gst_caps_new_simple ("audio/x-dts", NULL);
+            break;
+        }
+        g_free (desc);
+      }
+      if (template)
+        break;
+
       /* hack for itv hd (sid 10510, video pid 3401 */
       if (program->program_number == 10510 && bstream->pid == 3401) {
         template = gst_static_pad_template_get (&video_template);
@@ -1080,13 +773,20 @@ create_pad_for_stream (MpegTSBase * base, MpegTSBaseStream * bstream,
     case ST_DSMCC_D:
       MPEGTS_BIT_UNSET (base->is_pes, bstream->pid);
       break;
-    case ST_AUDIO_AAC:         /* ADTS */
+    case ST_AUDIO_AAC_ADTS:
       template = gst_static_pad_template_get (&audio_template);
       name = g_strdup_printf ("audio_%04x", bstream->pid);
       caps = gst_caps_new_simple ("audio/mpeg",
-          "mpegversion", G_TYPE_INT, 4,
+          "mpegversion", G_TYPE_INT, 2,
           "stream-format", G_TYPE_STRING, "adts", NULL);
       break;
+    case ST_AUDIO_AAC_LATM:
+      template = gst_static_pad_template_get (&audio_template);
+      name = g_strdup_printf ("audio_%04x", bstream->pid);
+      caps = gst_caps_new_simple ("audio/mpeg",
+          "mpegversion", G_TYPE_INT, 4,
+          "stream-format", G_TYPE_STRING, "latm", NULL);
+      break;
     case ST_VIDEO_MPEG4:
       template = gst_static_pad_template_get (&video_template);
       name = g_strdup_printf ("video_%04x", bstream->pid);
@@ -1146,18 +846,35 @@ create_pad_for_stream (MpegTSBase * base, MpegTSBaseStream * bstream,
       desc = mpegts_get_descriptor_from_program (program, DESC_REGISTRATION);
       if (desc) {
         if (DESC_REGISTRATION_format_identifier (desc) == DRF_ID_HDMV) {
-          template = gst_static_pad_template_get (&audio_template);
-          name = g_strdup_printf ("audio_%04x", bstream->pid);
-          caps = gst_caps_new_simple ("audio/x-eac3", NULL);
+          guint8 *ac3_desc;
+
+          /* ATSC ac3 audio descriptor */
+          ac3_desc =
+              mpegts_get_descriptor_from_stream ((MpegTSBaseStream *) stream,
+              DESC_AC3_AUDIO_STREAM);
+          if (ac3_desc && DESC_AC_AUDIO_STREAM_bsid (ac3_desc) != 16) {
+            GST_LOG ("ac3 audio");
+            template = gst_static_pad_template_get (&audio_template);
+            name = g_strdup_printf ("audio_%04x", bstream->pid);
+            caps = gst_caps_new_simple ("audio/x-ac3", NULL);
+
+            g_free (ac3_desc);
+          } else {
+            template = gst_static_pad_template_get (&audio_template);
+            name = g_strdup_printf ("audio_%04x", bstream->pid);
+            caps = gst_caps_new_simple ("audio/x-eac3", NULL);
+          }
+
         }
+
         g_free (desc);
       }
       if (template)
         break;
 
+
       /* DVB_ENHANCED_AC3 */
-      desc =
-          mpegts_get_descriptor_from_stream ((MpegTSBaseStream *) stream,
+      desc = mpegts_get_descriptor_from_stream ((MpegTSBaseStream *) stream,
           DESC_DVB_ENHANCED_AC3);
       if (desc) {
         template = gst_static_pad_template_get (&audio_template);
@@ -1226,10 +943,13 @@ create_pad_for_stream (MpegTSBase * base, MpegTSBaseStream * bstream,
     gst_pad_set_query_type_function (pad, gst_ts_demux_srcpad_query_types);
     gst_pad_set_query_function (pad, gst_ts_demux_srcpad_query);
     gst_pad_set_event_function (pad, gst_ts_demux_srcpad_event);
-    gst_caps_unref (caps);
   }
 
-  g_free (name);
+  if (name)
+    g_free (name);
+
+  if (caps)
+    gst_caps_unref (caps);
 
   return pad;
 }
@@ -1244,11 +964,15 @@ gst_ts_demux_stream_added (MpegTSBase * base, MpegTSBaseStream * bstream,
     /* Create the pad */
     if (bstream->stream_type != 0xff)
       stream->pad = create_pad_for_stream (base, bstream, program);
+    stream->active = FALSE;
 
+    stream->need_newsegment = TRUE;
     stream->pts = GST_CLOCK_TIME_NONE;
     stream->dts = GST_CLOCK_TIME_NONE;
     stream->raw_pts = 0;
     stream->raw_dts = 0;
+    stream->fixed_pts = 0;
+    stream->fixed_dts = 0;
     stream->nb_pts_rollover = 0;
     stream->nb_dts_rollover = 0;
   }
@@ -1258,32 +982,24 @@ gst_ts_demux_stream_added (MpegTSBase * base, MpegTSBaseStream * bstream,
 static void
 gst_ts_demux_stream_removed (MpegTSBase * base, MpegTSBaseStream * bstream)
 {
-  GstTSDemux *demux = GST_TS_DEMUX (base);
   TSDemuxStream *stream = (TSDemuxStream *) bstream;
 
   if (stream->pad) {
-    if (gst_pad_is_active (stream->pad)) {
-      gboolean need_newsegment = demux->need_newsegment;
-
-      /* We must not send the newsegment when flushing the pending data
-         on the removed stream. We should only push it when the newly added
-         stream finishes parsing its PTS */
-      demux->need_newsegment = FALSE;
-
+    if (stream->active && gst_pad_is_active (stream->pad)) {
       /* Flush out all data */
       GST_DEBUG_OBJECT (stream->pad, "Flushing out pending data");
       gst_ts_demux_push_pending_data ((GstTSDemux *) base, stream);
 
-      demux->need_newsegment = need_newsegment;
-
       GST_DEBUG_OBJECT (stream->pad, "Pushing out EOS");
       gst_pad_push_event (stream->pad, gst_event_new_eos ());
       GST_DEBUG_OBJECT (stream->pad, "Deactivating and removing pad");
       gst_pad_set_active (stream->pad, FALSE);
       gst_element_remove_pad (GST_ELEMENT_CAST (base), stream->pad);
+      stream->active = FALSE;
     }
     stream->pad = NULL;
   }
+  gst_ts_demux_stream_flush (stream);
   stream->flow_return = GST_FLOW_NOT_LINKED;
 }
 
@@ -1295,6 +1011,7 @@ activate_pad_for_stream (GstTSDemux * tsdemux, TSDemuxStream * stream)
         GST_DEBUG_PAD_NAME (stream->pad), stream);
     gst_pad_set_active (stream->pad, TRUE);
     gst_element_add_pad ((GstElement *) tsdemux, stream->pad);
+    stream->active = TRUE;
     GST_DEBUG_OBJECT (stream->pad, "done adding pad");
   } else
     GST_WARNING_OBJECT (tsdemux,
@@ -1315,7 +1032,34 @@ gst_ts_demux_stream_flush (TSDemuxStream * stream)
   memset (stream->pendingbuffers, 0, TS_MAX_PENDING_BUFFERS);
   stream->nbpending = 0;
 
+  if (stream->current) {
+    gst_buffer_list_unref (stream->current);
+    stream->current = NULL;
+  }
+
+  if (stream->currentit) {
+    gst_buffer_list_iterator_free (stream->currentit);
+    stream->currentit = NULL;
+  }
+
+  if (stream->currentlist) {
+    g_list_foreach (stream->currentlist, (GFunc) gst_buffer_unref, NULL);
+    g_list_free (stream->currentlist);
+    stream->currentlist = NULL;
+  }
+
+  stream->expected_size = 0;
+  stream->current_size = 0;
   stream->current = NULL;
+  stream->need_newsegment = TRUE;
+  stream->pts = GST_CLOCK_TIME_NONE;
+  stream->dts = GST_CLOCK_TIME_NONE;
+  stream->raw_pts = 0;
+  stream->raw_dts = 0;
+  stream->fixed_pts = 0;
+  stream->fixed_dts = 0;
+  stream->nb_pts_rollover = 0;
+  stream->nb_dts_rollover = 0;
 }
 
 static void
@@ -1335,495 +1079,34 @@ gst_ts_demux_program_started (MpegTSBase * base, MpegTSBaseProgram * program)
 
   if (demux->program_number == -1 ||
       demux->program_number == program->program_number) {
-    GList *tmp;
 
     GST_LOG ("program %d started", program->program_number);
     demux->program_number = program->program_number;
     demux->program = program;
 
-    /* Activate all stream pads, pads will already have been created */
-    if (base->mode != BASE_MODE_SCANNING) {
-      for (tmp = program->stream_list; tmp; tmp = tmp->next)
-        activate_pad_for_stream (demux, (TSDemuxStream *) tmp->data);
-      gst_element_no_more_pads ((GstElement *) demux);
+    /* If this is not the initial program, we need to calculate
+     * an update newsegment */
+    demux->calculate_update_segment = !program->initial_program;
+
+    /* If we have an upstream time segment and it's the initial program, just use that */
+    if (program->initial_program && base->segment.format == GST_FORMAT_TIME) {
+      demux->segment = base->segment;
+      demux->segment_event =
+          gst_event_new_new_segment_full (FALSE, base->segment.rate,
+          base->segment.applied_rate, GST_FORMAT_TIME, base->segment.start,
+          base->segment.stop, base->segment.time);
+      GST_EVENT_SRC (demux->segment_event) = gst_object_ref (demux);
     }
 
+    /* FIXME : When do we emit no_more_pads ? */
+
     /* Inform scanner we have got our program */
     demux->current_program_number = program->program_number;
-    demux->need_newsegment = TRUE;
-  }
-}
-
-static gboolean
-process_section (MpegTSBase * base)
-{
-  GstTSDemux *demux = GST_TS_DEMUX (base);
-  gboolean based;
-  gboolean done = FALSE;
-  MpegTSPacketizerPacket packet;
-  MpegTSPacketizerPacketReturn pret;
-
-  while ((!done)
-      && ((pret =
-              mpegts_packetizer_next_packet (base->packetizer,
-                  &packet)) != PACKET_NEED_MORE)) {
-    if (G_UNLIKELY (pret == PACKET_BAD))
-      /* bad header, skip the packet */
-      goto next;
-
-    /* base PSI data */
-    if (packet.payload != NULL && mpegts_base_is_psi (base, &packet)) {
-      MpegTSPacketizerSection section;
-
-      based =
-          mpegts_packetizer_push_section (base->packetizer, &packet, &section);
-      if (G_UNLIKELY (!based))
-        /* bad section data */
-        goto next;
-
-      if (G_LIKELY (section.complete)) {
-        /* section complete */
-        GST_DEBUG ("Section Complete");
-        based = mpegts_base_handle_psi (base, &section);
-        gst_buffer_unref (section.buffer);
-        if (G_UNLIKELY (!based))
-          /* bad PSI table */
-          goto next;
-
-      }
-
-      if (demux->program != NULL) {
-        GST_DEBUG ("Got Program");
-        done = TRUE;
-      }
-    }
-  next:
-    mpegts_packetizer_clear_packet (base->packetizer, &packet);
-  }
-  return done;
-}
-
-static gboolean
-process_pes (MpegTSBase * base, TSPcrOffset * pcroffset)
-{
-  gboolean based, done = FALSE;
-  MpegTSPacketizerPacket packet;
-  MpegTSPacketizerPacketReturn pret;
-  GstTSDemux *demux = GST_TS_DEMUX (base);
-  guint16 pcr_pid = 0;
-
-  while ((!done)
-      && ((pret =
-              mpegts_packetizer_next_packet (base->packetizer,
-                  &packet)) != PACKET_NEED_MORE)) {
-    if (G_UNLIKELY (pret == PACKET_BAD))
-      /* bad header, skip the packet */
-      goto next;
-
-    if (demux->program != NULL) {
-      pcr_pid = demux->program->pcr_pid;
-    }
-
-    /* base PSI data */
-    if (packet.payload != NULL && mpegts_base_is_psi (base, &packet)) {
-      MpegTSPacketizerSection section;
-
-      based =
-          mpegts_packetizer_push_section (base->packetizer, &packet, &section);
-      if (G_UNLIKELY (!based))
-        /* bad section data */
-        goto next;
-
-      if (G_LIKELY (section.complete)) {
-        /* section complete */
-        GST_DEBUG ("Section Complete");
-        based = mpegts_base_handle_psi (base, &section);
-        gst_buffer_unref (section.buffer);
-        if (G_UNLIKELY (!based))
-          /* bad PSI table */
-          goto next;
-
-      }
-    }
-    if (packet.pid == pcr_pid && (packet.adaptation_field_control & 0x02)
-        && (packet.afc_flags & MPEGTS_AFC_PCR_FLAG)) {
-      GST_DEBUG ("PCR[0x%x]: %" G_GINT64_FORMAT, packet.pid, packet.pcr);
-      pcroffset->pcr = packet.pcr;
-      pcroffset->offset = packet.offset;
-      done = TRUE;
-    }
-  next:
-    mpegts_packetizer_clear_packet (base->packetizer, &packet);
-  }
-  return done;
-}
-
-static GstFlowReturn
-find_pcr_packet (MpegTSBase * base, guint64 offset, gint64 length,
-    TSPcrOffset * pcroffset)
-{
-  GstFlowReturn ret = GST_FLOW_OK;
-  GstTSDemux *demux = GST_TS_DEMUX (base);
-  MpegTSBaseProgram *program;
-  GstBuffer *buf;
-  gboolean done = FALSE;
-  guint64 scan_offset = 0;
-
-  GST_DEBUG ("Scanning for PCR between:%" G_GINT64_FORMAT
-      " and the end:%" G_GINT64_FORMAT, offset, offset + length);
-
-  /* Get the program */
-  program = demux->program;
-  if (G_UNLIKELY (program == NULL))
-    return GST_FLOW_ERROR;
-
-  mpegts_packetizer_flush (base->packetizer);
-  if (offset >= 4 && base->packetizer->packet_size == MPEGTS_M2TS_PACKETSIZE)
-    offset -= 4;
-
-  while (!done && scan_offset < length) {
-    ret =
-        gst_pad_pull_range (base->sinkpad, offset + scan_offset,
-        50 * MPEGTS_MAX_PACKETSIZE, &buf);
-    if (ret != GST_FLOW_OK)
-      goto beach;
-    mpegts_packetizer_push (base->packetizer, buf);
-    done = process_pes (base, pcroffset);
-    scan_offset += 50 * MPEGTS_MAX_PACKETSIZE;
-  }
-
-  if (!done || scan_offset >= length) {
-    GST_WARNING ("No PCR found!");
-    ret = GST_FLOW_ERROR;
-    goto beach;
-  }
-
-beach:
-  mpegts_packetizer_flush (base->packetizer);
-  return ret;
-}
-
-static gboolean
-verify_timestamps (MpegTSBase * base, TSPcrOffset * first, TSPcrOffset * last)
-{
-  GstTSDemux *demux = GST_TS_DEMUX (base);
-  guint64 length = 4000 * MPEGTS_MAX_PACKETSIZE;
-  guint64 offset = PCR_WRAP_SIZE_128KBPS;
-
-  demux->index =
-      g_array_sized_new (TRUE, TRUE, sizeof (*first),
-      2 + 1 + ((last->offset - first->offset) / PCR_WRAP_SIZE_128KBPS));
-
-  first->gsttime = PCRTIME_TO_GSTTIME (first->pcr);
-  demux->index = g_array_append_val (demux->index, *first);
-  demux->index_size++;
-  demux->first_pcr = *first;
-  demux->index_pcr = *first;
-  GST_DEBUG ("first time: %" GST_TIME_FORMAT " pcr: %" GST_TIME_FORMAT
-      " offset: %" G_GINT64_FORMAT
-      " last  pcr: %" GST_TIME_FORMAT " offset: %" G_GINT64_FORMAT,
-      GST_TIME_ARGS (first->gsttime),
-      GST_TIME_ARGS (PCRTIME_TO_GSTTIME (first->pcr)), first->offset,
-      GST_TIME_ARGS (PCRTIME_TO_GSTTIME (last->pcr)), last->offset);
-
-  while (offset + length < last->offset) {
-    TSPcrOffset half;
-    GstFlowReturn ret;
-    gint tries = 0;
-
-  retry:
-    ret = find_pcr_packet (base, offset, length, &half);
-    if (G_UNLIKELY (ret != GST_FLOW_OK)) {
-      GST_WARNING ("no pcr found, retrying");
-      if (tries++ < 3) {
-        offset += length;
-        length *= 2;
-        goto retry;
-      }
-      return FALSE;
-    }
-
-    half.gsttime = calculate_gsttime (first, half.pcr);
-
-    GST_DEBUG ("add half time: %" GST_TIME_FORMAT " pcr: %" GST_TIME_FORMAT
-        " offset: %" G_GINT64_FORMAT,
-        GST_TIME_ARGS (half.gsttime),
-        GST_TIME_ARGS (PCRTIME_TO_GSTTIME (half.pcr)), half.offset);
-    demux->index = g_array_append_val (demux->index, half);
-    demux->index_size++;
-
-    length = 4000 * MPEGTS_MAX_PACKETSIZE;
-    offset += PCR_WRAP_SIZE_128KBPS;
-    *first = half;
-  }
-
-  last->gsttime = calculate_gsttime (first, last->pcr);
-
-  GST_DEBUG ("add last time: %" GST_TIME_FORMAT " pcr: %" GST_TIME_FORMAT
-      " offset: %" G_GINT64_FORMAT,
-      GST_TIME_ARGS (last->gsttime),
-      GST_TIME_ARGS (PCRTIME_TO_GSTTIME (last->pcr)), last->offset);
-
-  demux->index = g_array_append_val (demux->index, *last);
-  demux->index_size++;
-
-  demux->last_pcr = *last;
-  return TRUE;
-}
-
-static GstFlowReturn
-find_timestamps (MpegTSBase * base, guint64 initoff, guint64 * offset)
-{
-
-  GstFlowReturn ret = GST_FLOW_OK;
-  GstBuffer *buf;
-  gboolean done = FALSE;
-  GstFormat format = GST_FORMAT_BYTES;
-  gint64 total_bytes;
-  guint64 scan_offset;
-  guint i = 0;
-  TSPcrOffset initial, final;
-  GstTSDemux *demux = GST_TS_DEMUX (base);
-
-  GST_DEBUG ("Scanning for timestamps");
-
-  /* Flush what remained from before */
-  mpegts_packetizer_clear (base->packetizer);
-
-  /* Start scanning from know PAT offset */
-  while (!done) {
-    ret =
-        gst_pad_pull_range (base->sinkpad, i * 50 * MPEGTS_MAX_PACKETSIZE,
-        50 * MPEGTS_MAX_PACKETSIZE, &buf);
-    if (ret != GST_FLOW_OK)
-      goto beach;
-    mpegts_packetizer_push (base->packetizer, buf);
-    done = process_section (base);
-    i++;
-  }
-  mpegts_packetizer_clear (base->packetizer);
-  done = FALSE;
-  i = 1;
-
-
-  *offset = base->seek_offset;
-
-  /* Search for the first PCRs */
-  ret = process_pcr (base, base->first_pat_offset, &initial, 10, TRUE);
-
-  if (ret != GST_FLOW_OK && ret != GST_FLOW_UNEXPECTED) {
-    GST_WARNING ("Problem getting initial PCRs");
-    goto beach;
-  }
-
-  mpegts_packetizer_clear (base->packetizer);
-  /* Remove current program so we ensure looking for a PAT when scanning the 
-   * for the final PCR */
-  gst_structure_free (base->pat);
-  base->pat = NULL;
-  mpegts_base_remove_program (base, demux->current_program_number);
-  demux->program = NULL;
-
-  /* Find end position */
-  if (G_UNLIKELY (!gst_pad_query_peer_duration (base->sinkpad, &format,
-              &total_bytes) || format != GST_FORMAT_BYTES)) {
-    GST_WARNING_OBJECT (base, "Couldn't get upstream size in bytes");
-    ret = GST_FLOW_ERROR;
-    mpegts_packetizer_clear (base->packetizer);
-    return ret;
-  }
-  GST_DEBUG ("Upstream is %" G_GINT64_FORMAT " bytes", total_bytes);
-
-
-  /* Let's start scanning 4000 packets from the end */
-  scan_offset = MAX (188, total_bytes - 4000 * MPEGTS_MAX_PACKETSIZE);
-
-  GST_DEBUG ("Scanning for last sync point between:%" G_GINT64_FORMAT
-      " and the end:%" G_GINT64_FORMAT, scan_offset, total_bytes);
-  while ((!done) && (scan_offset < total_bytes)) {
-    ret =
-        gst_pad_pull_range (base->sinkpad,
-        scan_offset, 50 * MPEGTS_MAX_PACKETSIZE, &buf);
-    if (ret != GST_FLOW_OK)
-      goto beach;
-
-    mpegts_packetizer_push (base->packetizer, buf);
-    done = process_section (base);
-    scan_offset += 50 * MPEGTS_MAX_PACKETSIZE;
-  }
-
-  mpegts_packetizer_clear (base->packetizer);
-
-  GST_DEBUG ("Searching PCR");
-  ret =
-      process_pcr (base, scan_offset - 50 * MPEGTS_MAX_PACKETSIZE, &final, 10,
-      FALSE);
-
-  if (ret != GST_FLOW_OK) {
-    GST_DEBUG ("Problem getting last PCRs");
-    goto beach;
-  }
-
-  verify_timestamps (base, &initial, &final);
-
-  gst_segment_set_duration (&demux->segment, GST_FORMAT_TIME,
-      demux->last_pcr.gsttime - demux->first_pcr.gsttime);
-  demux->duration = demux->last_pcr.gsttime - demux->first_pcr.gsttime;
-  GST_DEBUG ("Done, duration:%" GST_TIME_FORMAT,
-      GST_TIME_ARGS (demux->duration));
-
-beach:
-
-  mpegts_packetizer_clear (base->packetizer);
-  /* Remove current program */
-  if (base->pat) {
-    gst_structure_free (base->pat);
-    base->pat = NULL;
-  }
-  mpegts_base_remove_program (base, demux->current_program_number);
-  demux->program = NULL;
-
-  return ret;
-}
-
-static GstFlowReturn
-process_pcr (MpegTSBase * base, guint64 initoff, TSPcrOffset * pcroffset,
-    guint numpcr, gboolean isinitial)
-{
-  GstTSDemux *demux = GST_TS_DEMUX (base);
-  GstFlowReturn ret = GST_FLOW_OK;
-  MpegTSBaseProgram *program;
-  GstBuffer *buf;
-  guint nbpcr, i = 0;
-  guint32 pcrmask, pcrpattern;
-  guint64 pcrs[50];
-  guint64 pcroffs[50];
-  GstByteReader br;
-
-  GST_DEBUG ("initoff:%" G_GUINT64_FORMAT ", numpcr:%d, isinitial:%d",
-      initoff, numpcr, isinitial);
-
-  /* Get the program */
-  program = demux->program;
-  if (G_UNLIKELY (program == NULL))
-    return GST_FLOW_ERROR;
-
-  /* First find the first X PCR */
-  nbpcr = 0;
-  /* Mask/pattern is PID:PCR_PID, AFC&0x02 */
-  /* sync_byte (0x47)                   : 8bits => 0xff
-   * transport_error_indicator          : 1bit  ACTIVATE
-   * payload_unit_start_indicator       : 1bit  IGNORE
-   * transport_priority                 : 1bit  IGNORE
-   * PID                                : 13bit => 0x9f 0xff
-   * transport_scrambling_control       : 2bit
-   * adaptation_field_control           : 2bit
-   * continuity_counter                 : 4bit  => 0x30
-   */
-  pcrmask = 0xff9fff20;
-  pcrpattern = 0x47000020 | ((program->pcr_pid & 0x1fff) << 8);
-
-  for (i = 0; (i < 20) && (nbpcr < numpcr); i++) {
-    guint offset, size;
-
-    ret =
-        gst_pad_pull_range (base->sinkpad,
-        initoff + i * 500 * base->packetsize, 500 * base->packetsize, &buf);
-
-    if (G_UNLIKELY (ret != GST_FLOW_OK))
-      goto beach;
-
-    gst_byte_reader_init_from_buffer (&br, buf);
-
-    offset = 0;
-    size = GST_BUFFER_SIZE (buf);
-
-  resync:
-    offset = gst_byte_reader_masked_scan_uint32 (&br, 0xff000000, 0x47000000,
-        0, base->packetsize);
-
-    if (offset == -1)
-      continue;
-
-    while ((nbpcr < numpcr) && (size >= base->packetsize)) {
-
-      guint32 header = GST_READ_UINT32_BE (br.data + offset);
-
-      if ((header >> 24) != 0x47)
-        goto resync;
-
-      if ((header & pcrmask) != pcrpattern) {
-        /* Move offset forward by 1 packet */
-        size -= base->packetsize;
-        offset += base->packetsize;
-        continue;
-      }
-
-      /* Potential PCR */
-/*      GST_DEBUG ("offset %" G_GUINT64_FORMAT, GST_BUFFER_OFFSET (buf) + offset);
-      GST_MEMDUMP ("something", GST_BUFFER_DATA (buf) + offset, 16);*/
-      if ((*(br.data + offset + 5)) & MPEGTS_AFC_PCR_FLAG) {
-        guint64 lpcr = mpegts_packetizer_compute_pcr (br.data + offset + 6);
-
-        GST_INFO ("Found PCR %" G_GUINT64_FORMAT " %" GST_TIME_FORMAT
-            " at offset %" G_GUINT64_FORMAT, lpcr,
-            GST_TIME_ARGS (PCRTIME_TO_GSTTIME (lpcr)),
-            GST_BUFFER_OFFSET (buf) + offset);
-        pcrs[nbpcr] = lpcr;
-        pcroffs[nbpcr] = GST_BUFFER_OFFSET (buf) + offset;
-        /* Safeguard against bogus PCR (by detecting if it's the same as the
-         * previous one or wheter the difference with the previous one is
-         * greater than 10mins */
-        if (nbpcr > 1) {
-          if (pcrs[nbpcr] == pcrs[nbpcr - 1]) {
-            GST_WARNING ("Found same PCR at different offset");
-          } else if (pcrs[nbpcr] < pcrs[nbpcr - 1]) {
-            GST_WARNING ("Found PCR wraparound");
-            nbpcr += 1;
-          } else if ((pcrs[nbpcr] - pcrs[nbpcr - 1]) >
-              (guint64) 10 * 60 * 27000000) {
-            GST_WARNING ("PCR differs with previous PCR by more than 10 mins");
-          } else
-            nbpcr += 1;
-        } else
-          nbpcr += 1;
-      }
-      /* Move offset forward by 1 packet */
-      size -= base->packetsize;
-      offset += base->packetsize;
-    }
   }
-
-beach:
-  GST_DEBUG ("Found %d PCR", nbpcr);
-  if (nbpcr) {
-    if (isinitial) {
-      pcroffset->pcr = pcrs[0];
-      pcroffset->offset = pcroffs[0];
-    } else {
-      pcroffset->pcr = pcrs[nbpcr - 1];
-      pcroffset->offset = pcroffs[nbpcr - 1];
-    }
-    if (nbpcr > 1) {
-      GST_DEBUG ("pcrdiff:%" GST_TIME_FORMAT " offsetdiff %" G_GUINT64_FORMAT,
-          GST_TIME_ARGS (PCRTIME_TO_GSTTIME (pcrs[nbpcr - 1] - pcrs[0])),
-          pcroffs[nbpcr - 1] - pcroffs[0]);
-      GST_DEBUG ("Estimated bitrate %" G_GUINT64_FORMAT,
-          gst_util_uint64_scale (GST_SECOND, pcroffs[nbpcr - 1] - pcroffs[0],
-              PCRTIME_TO_GSTTIME (pcrs[nbpcr - 1] - pcrs[0])));
-      GST_DEBUG ("Average PCR interval %" G_GUINT64_FORMAT,
-          (pcroffs[nbpcr - 1] - pcroffs[0]) / nbpcr);
-    }
-  }
-  /* Swallow any errors if it happened during the end scanning */
-  if (!isinitial)
-    ret = GST_FLOW_OK;
-  return ret;
 }
 
 
 
-
 static inline void
 gst_ts_demux_record_pcr (GstTSDemux * demux, TSDemuxStream * stream,
     guint64 pcr, guint64 offset)
@@ -1834,17 +1117,7 @@ gst_ts_demux_record_pcr (GstTSDemux * demux, TSDemuxStream * stream,
       G_GUINT64_FORMAT, bs->pid,
       GST_TIME_ARGS (PCRTIME_TO_GSTTIME (pcr)), offset);
 
-  if (G_LIKELY (bs->pid == demux->program->pcr_pid)) {
-    demux->cur_pcr.gsttime = GST_CLOCK_TIME_NONE;
-    demux->cur_pcr.offset = offset;
-    demux->cur_pcr.pcr = pcr;
-    /* set first_pcr in push mode */
-    if (G_UNLIKELY (!demux->first_pcr.gsttime == GST_CLOCK_TIME_NONE)) {
-      demux->first_pcr.gsttime = PCRTIME_TO_GSTTIME (pcr);
-      demux->first_pcr.offset = offset;
-      demux->first_pcr.pcr = pcr;
-    }
-  }
+  /* FIXME : packetizer should record this */
 
   if (G_UNLIKELY (demux->emit_statistics)) {
     GstStructure *st;
@@ -1868,6 +1141,8 @@ gst_ts_demux_record_opcr (GstTSDemux * demux, TSDemuxStream * stream,
       G_GUINT64_FORMAT, bs->pid,
       GST_TIME_ARGS (PCRTIME_TO_GSTTIME (opcr)), offset);
 
+  /* FIXME : packetizer should record this */
+
   if (G_UNLIKELY (demux->emit_statistics)) {
     GstStructure *st;
     st = gst_structure_id_empty_new (QUARK_TSDEMUX);
@@ -1907,8 +1182,8 @@ gst_ts_demux_record_pts (GstTSDemux * demux, TSDemuxStream * stream,
 
   /* Compute PTS in GstClockTime */
   stream->raw_pts = pts;
-  stream->pts =
-      MPEGTIME_TO_GSTTIME (pts + stream->nb_pts_rollover * PTS_DTS_MAX_VALUE);
+  stream->fixed_pts = pts + stream->nb_pts_rollover * PTS_DTS_MAX_VALUE;
+  stream->pts = MPEGTIME_TO_GSTTIME (stream->fixed_pts);
 
   GST_LOG ("pid 0x%04x Stored PTS %" G_GUINT64_FORMAT " (%" GST_TIME_FORMAT ")",
       bs->pid, stream->raw_pts, GST_TIME_ARGS (stream->pts));
@@ -1953,8 +1228,8 @@ gst_ts_demux_record_dts (GstTSDemux * demux, TSDemuxStream * stream,
 
   /* Compute DTS in GstClockTime */
   stream->raw_dts = dts;
-  stream->dts =
-      MPEGTIME_TO_GSTTIME (dts + stream->nb_dts_rollover * PTS_DTS_MAX_VALUE);
+  stream->fixed_dts = dts + stream->nb_dts_rollover * PTS_DTS_MAX_VALUE;
+  stream->dts = MPEGTIME_TO_GSTTIME (stream->fixed_dts);
 
   GST_LOG ("pid 0x%04x Stored DTS %" G_GUINT64_FORMAT " (%" GST_TIME_FORMAT ")",
       bs->pid, stream->raw_dts, GST_TIME_ARGS (stream->dts));
@@ -1971,32 +1246,6 @@ gst_ts_demux_record_dts (GstTSDemux * demux, TSDemuxStream * stream,
   }
 }
 
-static inline GstClockTime
-calc_gsttime_from_pts (TSPcrOffset * start, guint64 pts)
-{
-  GstClockTime time = start->gsttime - PCRTIME_TO_GSTTIME (start->pcr);
-
-  if (start->pcr > pts * 300)
-    time += PCRTIME_TO_GSTTIME (PCR_MAX_VALUE) + MPEGTIME_TO_GSTTIME (pts);
-  else
-    time += MPEGTIME_TO_GSTTIME (pts);
-
-  return time;
-}
-
-#if 0
-static gint
-TSPcrOffset_find_offset (gconstpointer a, gconstpointer b, gpointer user_data)
-{
-  if (((TSPcrOffset *) a)->offset < ((TSPcrOffset *) b)->offset)
-    return -1;
-  else if (((TSPcrOffset *) a)->offset > ((TSPcrOffset *) b)->offset)
-    return 1;
-  else
-    return 0;
-}
-#endif
-
 static GstFlowReturn
 gst_ts_demux_parse_pes_header (GstTSDemux * demux, TSDemuxStream * stream)
 {
@@ -2030,63 +1279,26 @@ gst_ts_demux_parse_pes_header (GstTSDemux * demux, TSDemuxStream * stream)
   if (header.PTS != -1) {
     gst_ts_demux_record_pts (demux, stream, header.PTS, bufferoffset);
 
-#if 0
-    /* WTH IS THIS ??? */
-    if (demux->index_pcr.offset + PCR_WRAP_SIZE_128KBPS + 1000 * 128 < offset
-        || (demux->index_pcr.offset > offset)) {
-      /* find next entry */
-      TSPcrOffset *next;
-      demux->index_pcr.offset = offset;
-      next = gst_util_array_binary_search (demux->index->data,
-          demux->index_size, sizeof (*next), TSPcrOffset_find_offset,
-          GST_SEARCH_MODE_BEFORE, &demux->index_pcr, NULL);
-      if (next) {
-        GST_INFO ("new index_pcr %" GST_TIME_FORMAT " offset: %"
-            G_GINT64_FORMAT, GST_TIME_ARGS (next->gsttime), next->offset);
-
-        demux->index_pcr = *next;
-      }
-    }
-    time = calc_gsttime_from_pts (&demux->index_pcr, pts);
-#endif
+    GST_DEBUG_OBJECT (base,
+        "stream PTS %" GST_TIME_FORMAT " DTS %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (stream->pts),
+        GST_TIME_ARGS (MPEGTIME_TO_GSTTIME (header.DTS)));
 
-    GST_DEBUG_OBJECT (base, "stream PTS %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (stream->pts));
-
-    /* safe default if insufficient upstream info */
-    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (base->in_gap) &&
-            GST_CLOCK_TIME_IS_VALID (base->first_buf_ts) &&
-            base->mode == BASE_MODE_PUSHING &&
-            base->segment.format == GST_FORMAT_TIME)) {
-      /* Find the earliest current PTS we're going to push */
-      GstClockTime firstpts = GST_CLOCK_TIME_NONE;
-      GList *tmp;
-
-      for (tmp = demux->program->stream_list; tmp; tmp = tmp->next) {
-        TSDemuxStream *pstream = (TSDemuxStream *) tmp->data;
-        if (!GST_CLOCK_TIME_IS_VALID (firstpts) || pstream->pts < firstpts)
-          firstpts = pstream->pts;
-      }
+    {
+      MpegTSPacketizer2 *packetizer = base->packetizer;
 
-      base->in_gap = base->first_buf_ts - firstpts;
-      GST_DEBUG_OBJECT (base, "upstream segment start %" GST_TIME_FORMAT
-          ", first buffer timestamp: %" GST_TIME_FORMAT
-          ", first PTS: %" GST_TIME_FORMAT
-          ", interpolation gap: %" GST_TIME_FORMAT,
-          GST_TIME_ARGS (base->segment.start),
-          GST_TIME_ARGS (base->first_buf_ts), GST_TIME_ARGS (firstpts),
-          GST_TIME_ARGS (base->in_gap));
+      GST_BUFFER_TIMESTAMP (stream->pendingbuffers[0]) =
+          mpegts_packetizer_pts_to_ts (packetizer, stream->pts);
     }
-
-    if (!GST_CLOCK_TIME_IS_VALID (base->in_gap))
-      base->in_gap = 0;
-
-    GST_BUFFER_TIMESTAMP (stream->pendingbuffers[0]) =
-        stream->pts + base->in_gap;
+    GST_DEBUG ("buf %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (stream->pendingbuffers[0])));
   }
 
   /* Remove PES headers */
-  GST_DEBUG ("Moving data forward  by %d bytes", header.header_size);
+  GST_DEBUG ("Moving data forward  by %d bytes (packet_size:%d, have:%d)",
+      header.header_size, header.packet_length,
+      GST_BUFFER_SIZE (stream->pendingbuffers[0]));
+  stream->expected_size = header.packet_length;
   GST_BUFFER_DATA (stream->pendingbuffers[0]) += header.header_size;
   GST_BUFFER_SIZE (stream->pendingbuffers[0]) -= header.header_size;
 
@@ -2152,19 +1364,35 @@ gst_ts_demux_queue_data (GstTSDemux * demux, TSDemuxStream * stream,
     }
   }
 
-  if (stream->state == PENDING_PACKET_HEADER) {
-    GST_LOG ("HEADER: appending data to array");
-    /* Append to the array */
-    stream->pendingbuffers[stream->nbpending++] = buf;
+  switch (stream->state) {
+    case PENDING_PACKET_HEADER:
+    {
+      GST_LOG ("HEADER: appending data to array");
+      /* Append to the array */
+      stream->pendingbuffers[stream->nbpending++] = buf;
+      stream->current_size += GST_BUFFER_SIZE (buf);
 
-    /* parse the header */
-    gst_ts_demux_parse_pes_header (demux, stream);
-  } else if (stream->state == PENDING_PACKET_BUFFER) {
-    GST_LOG ("BUFFER: appending data to bufferlist");
-    stream->currentlist = g_list_prepend (stream->currentlist, buf);
+      /* parse the header */
+      gst_ts_demux_parse_pes_header (demux, stream);
+      break;
+    }
+    case PENDING_PACKET_BUFFER:
+    {
+      GST_LOG ("BUFFER: appending data to bufferlist");
+      stream->currentlist = g_list_prepend (stream->currentlist, buf);
+      stream->current_size += GST_BUFFER_SIZE (buf);
+      break;
+    }
+    case PENDING_PACKET_DISCONT:
+    {
+      GST_LOG ("DISCONT: dropping buffer");
+      gst_buffer_unref (packet->buffer);
+      break;
+    }
+    default:
+      break;
   }
 
-
   return;
 }
 
@@ -2172,85 +1400,92 @@ static void
 calculate_and_push_newsegment (GstTSDemux * demux, TSDemuxStream * stream)
 {
   MpegTSBase *base = (MpegTSBase *) demux;
-  GstEvent *newsegmentevent;
-  gint64 start = 0, stop = GST_CLOCK_TIME_NONE, position = 0;
-  GstClockTime firstpts = GST_CLOCK_TIME_NONE;
+  GstClockTime lowest_pts = GST_CLOCK_TIME_NONE;
+  GstClockTime firstts = 0;
   GList *tmp;
 
   GST_DEBUG ("Creating new newsegment for stream %p", stream);
 
-  /* Outgoing newsegment values
-   * start    : The first/start PTS
-   * stop     : The last PTS (or -1)
-   * position : The stream time corresponding to start
-   *
-   * Except for live mode with incoming GST_TIME_FORMAT newsegment where
-   * it is the same values as that incoming newsegment (and we convert the
-   * PTS to that remote clock).
-   */
+  /* 1) If we need to calculate an update newsegment, do it
+   * 2) If we need to calculate a new newsegment, do it
+   * 3) If an update_segment is valid, push it
+   * 4) If a newsegment is valid, push it */
+
+  /* Speedup : if we don't need to calculate anything, go straight to pushing */
+  if (!demux->calculate_update_segment && demux->segment_event)
+    goto push_new_segment;
 
+  /* Calculate the 'new_start' value, used for both updates and newsegment */
   for (tmp = demux->program->stream_list; tmp; tmp = tmp->next) {
     TSDemuxStream *pstream = (TSDemuxStream *) tmp->data;
 
-    if (!GST_CLOCK_TIME_IS_VALID (firstpts) || pstream->pts < firstpts)
-      firstpts = pstream->pts;
+    if (GST_CLOCK_TIME_IS_VALID (pstream->pts)) {
+      if (!GST_CLOCK_TIME_IS_VALID (lowest_pts) || pstream->pts < lowest_pts)
+        lowest_pts = pstream->pts;
+    }
+    if (GST_CLOCK_TIME_IS_VALID (pstream->dts)) {
+      if (!GST_CLOCK_TIME_IS_VALID (lowest_pts) || pstream->dts < lowest_pts)
+        lowest_pts = pstream->dts;
+    }
+  }
+  if (GST_CLOCK_TIME_IS_VALID (lowest_pts))
+    firstts = mpegts_packetizer_pts_to_ts (base->packetizer, lowest_pts);
+  GST_DEBUG ("lowest_pts %" G_GUINT64_FORMAT " => clocktime %" GST_TIME_FORMAT,
+      lowest_pts, GST_TIME_ARGS (firstts));
+
+  if (demux->calculate_update_segment) {
+    GST_DEBUG ("Calculating update segment");
+    /* If we have a valid segment, create an update of that */
+    if (demux->segment.format == GST_FORMAT_TIME) {
+      GST_DEBUG ("Re-using segment " SEGMENT_FORMAT,
+          SEGMENT_ARGS (demux->segment));
+      demux->update_segment =
+          gst_event_new_new_segment_full (TRUE, demux->segment.rate,
+          demux->segment.applied_rate, GST_FORMAT_TIME, demux->segment.start,
+          firstts, demux->segment.time);
+      GST_EVENT_SRC (demux->update_segment) = gst_object_ref (demux);
+    }
+    demux->calculate_update_segment = FALSE;
   }
 
-  if (base->mode == BASE_MODE_PUSHING) {
-    /* FIXME : We're just ignore the upstream format for the time being */
-    /* FIXME : We should use base->segment.format and a upstream latency query
-     * to decide if we need to use live values or not */
-    GST_DEBUG ("push-based. base Segment start:%" GST_TIME_FORMAT " duration:%"
-        GST_TIME_FORMAT ", stop:%" GST_TIME_FORMAT ", time:%" GST_TIME_FORMAT,
-        GST_TIME_ARGS (base->segment.start),
-        GST_TIME_ARGS (base->segment.duration),
-        GST_TIME_ARGS (base->segment.stop), GST_TIME_ARGS (base->segment.time));
-    GST_DEBUG ("push-based. demux Segment start:%" GST_TIME_FORMAT " duration:%"
-        GST_TIME_FORMAT ", stop:%" GST_TIME_FORMAT ", time:%" GST_TIME_FORMAT,
-        GST_TIME_ARGS (demux->segment.start),
-        GST_TIME_ARGS (demux->segment.duration),
-        GST_TIME_ARGS (demux->segment.stop),
-        GST_TIME_ARGS (demux->segment.time));
-
-    GST_DEBUG ("stream pts: %" GST_TIME_FORMAT " first pts: %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (stream->pts), GST_TIME_ARGS (firstpts));
-
-    if (base->segment.format == GST_FORMAT_TIME) {
-      start = base->segment.start;
-      stop = base->segment.stop;
+  if (!demux->segment_event) {
+    gint64 start, stop, time;
+
+    GST_DEBUG ("Calculating actual segment");
+
+    if (demux->segment.format == GST_FORMAT_TIME) {
+      /* if we have a TIME segment, set NS.start to the target ts so downstream
+       * can clip
+       */
+      start = demux->segment.start;
+      stop = demux->segment.stop;
+      time = demux->segment.time;
+    } else {
+      /* ...else start from the first ts/pts */
+      start = firstts;
+      stop = GST_CLOCK_TIME_NONE;
+      time = firstts;
     }
-    /* Shift the start depending on our position in the stream */
-    start += firstpts + base->in_gap - base->first_buf_ts;
-    position = start;
-  } else {
-    /* pull mode */
-    GST_DEBUG ("pull-based. Segment start:%" GST_TIME_FORMAT " duration:%"
-        GST_TIME_FORMAT ", time:%" GST_TIME_FORMAT,
-        GST_TIME_ARGS (demux->segment.start),
-        GST_TIME_ARGS (demux->segment.duration),
-        GST_TIME_ARGS (demux->segment.time));
-
-    GST_DEBUG ("firstpcr gsttime : %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (demux->first_pcr.gsttime));
-
-    /* FIXME : This is not entirely correct. We should be using the PTS time
-     * realm and not the PCR one. Doesn't matter *too* much if PTS/PCR values
-     * aren't too far apart, but still.  */
-    start = demux->first_pcr.gsttime + demux->segment.start;
-    stop = demux->first_pcr.gsttime + demux->segment.duration;
-    position = demux->segment.time;
+    demux->segment_event =
+        gst_event_new_new_segment_full (FALSE, demux->segment.rate,
+        demux->segment.applied_rate, GST_FORMAT_TIME, start, stop, time);
+    GST_EVENT_SRC (demux->segment_event) = gst_object_ref (demux);
   }
 
-  GST_DEBUG ("new segment:   start: %" GST_TIME_FORMAT " stop: %"
-      GST_TIME_FORMAT " time: %" GST_TIME_FORMAT, GST_TIME_ARGS (start),
-      GST_TIME_ARGS (stop), GST_TIME_ARGS (position));
-  newsegmentevent =
-      gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME, start, stop,
-      position);
+push_new_segment:
+  if (demux->update_segment) {
+    GST_DEBUG_OBJECT (stream->pad, "Pushing update segment");
+    gst_event_ref (demux->update_segment);
+    gst_pad_push_event (stream->pad, demux->update_segment);
+  }
 
-  push_event ((MpegTSBase *) demux, newsegmentevent);
+  if (demux->segment_event) {
+    GST_DEBUG_OBJECT (stream->pad, "Pushing newsegment event");
+    gst_event_ref (demux->segment_event);
+    gst_pad_push_event (stream->pad, demux->segment_event);
+  }
 
-  demux->need_newsegment = FALSE;
+  stream->need_newsegment = FALSE;
 }
 
 static GstFlowReturn
@@ -2258,10 +1493,13 @@ gst_ts_demux_push_pending_data (GstTSDemux * demux, TSDemuxStream * stream)
 {
   GstFlowReturn res = GST_FLOW_OK;
   MpegTSBaseStream *bs = (MpegTSBaseStream *) stream;
+  /* MpegTSBase *base = (MpegTSBase*) demux; */
+  GstBuffer *firstbuffer = NULL;
+  MpegTSPacketizer2 *packetizer = MPEG_TS_BASE_PACKETIZER (demux);
 
-  GST_DEBUG ("stream:%p, pid:0x%04x stream_type:%d state:%d pad:%s:%s",
-      stream, bs->pid, bs->stream_type, stream->state,
-      GST_DEBUG_PAD_NAME (stream->pad));
+  GST_DEBUG_OBJECT (stream->pad,
+      "stream:%p, pid:0x%04x stream_type:%d state:%d", stream, bs->pid,
+      bs->stream_type, stream->state);
 
   if (G_UNLIKELY (stream->current == NULL)) {
     GST_LOG ("stream->current == NULL");
@@ -2273,8 +1511,13 @@ gst_ts_demux_push_pending_data (GstTSDemux * demux, TSDemuxStream * stream)
     goto beach;
   }
 
-  if (G_UNLIKELY (stream->state != PENDING_PACKET_BUFFER))
+  if (G_UNLIKELY (stream->state != PENDING_PACKET_BUFFER)) {
+    GST_LOG ("state:%d, returning", stream->state);
     goto beach;
+  }
+
+  if (G_UNLIKELY (!stream->active))
+    activate_pad_for_stream (demux, stream);
 
   if (G_UNLIKELY (stream->pad == NULL)) {
     g_list_foreach (stream->currentlist, (GFunc) gst_buffer_unref, NULL);
@@ -2284,19 +1527,28 @@ gst_ts_demux_push_pending_data (GstTSDemux * demux, TSDemuxStream * stream)
     goto beach;
   }
 
-  if (G_UNLIKELY (demux->need_newsegment))
+  if (G_UNLIKELY (stream->need_newsegment))
     calculate_and_push_newsegment (demux, stream);
 
   /* We have a confirmed buffer, let's push it out */
-  GST_LOG ("Putting pending data into GstBufferList");
+  GST_LOG_OBJECT (stream->pad, "Putting pending data into GstBufferList");
   stream->currentlist = g_list_reverse (stream->currentlist);
   gst_buffer_list_iterator_add_list (stream->currentit, stream->currentlist);
+  stream->currentlist = NULL;
   gst_buffer_list_iterator_free (stream->currentit);
 
+  firstbuffer = gst_buffer_list_get (stream->current, 0, 0);
+
+  GST_DEBUG_OBJECT (stream->pad, "stream->pts %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (stream->pts));
+  if (GST_CLOCK_TIME_IS_VALID (stream->pts)
+      && !GST_CLOCK_TIME_IS_VALID (GST_BUFFER_TIMESTAMP (firstbuffer)))
+    GST_BUFFER_TIMESTAMP (firstbuffer) =
+        mpegts_packetizer_pts_to_ts (packetizer, stream->pts);
+
   GST_DEBUG_OBJECT (stream->pad,
       "Pushing buffer list with timestamp: %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (gst_buffer_list_get
-              (stream->current, 0, 0))));
+      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (firstbuffer)));
 
   res = gst_pad_push_list (stream->pad, stream->current);
   GST_DEBUG_OBJECT (stream->pad, "Returned %s", gst_flow_get_name (res));
@@ -2305,11 +1557,14 @@ gst_ts_demux_push_pending_data (GstTSDemux * demux, TSDemuxStream * stream)
 
 beach:
   /* Reset everything */
-  GST_LOG ("Resetting to EMPTY");
+  GST_LOG ("Resetting to EMPTY, returning %s", gst_flow_get_name (res));
   stream->state = PENDING_PACKET_EMPTY;
   memset (stream->pendingbuffers, 0, TS_MAX_PENDING_BUFFERS);
   stream->nbpending = 0;
   stream->current = NULL;
+  stream->currentit = NULL;
+  stream->expected_size = 0;
+  stream->current_size = 0;
 
   return res;
 }
@@ -2348,9 +1603,14 @@ gst_ts_demux_handle_packet (GstTSDemux * demux, TSDemuxStream * stream,
           GST_BUFFER_OFFSET (packet->buffer));
   }
 
-  if (packet->payload)
+  if (packet->payload && (res == GST_FLOW_OK || res == GST_FLOW_NOT_LINKED)) {
     gst_ts_demux_queue_data (demux, stream, packet);
-  else
+    GST_DEBUG ("current_size:%d, expected_size:%d",
+        stream->current_size, stream->expected_size);
+    /* Finally check if the data we queued completes a packet */
+    if (stream->expected_size && stream->current_size == stream->expected_size)
+      res = gst_ts_demux_push_pending_data (demux, stream);
+  } else
     gst_buffer_unref (packet->buffer);
 
   return res;
@@ -2361,7 +1621,6 @@ gst_ts_demux_flush (MpegTSBase * base)
 {
   GstTSDemux *demux = GST_TS_DEMUX_CAST (base);
 
-  demux->need_newsegment = TRUE;
   gst_ts_demux_flush_streams (demux);
 }
 
@@ -2395,5 +1654,5 @@ gst_ts_demux_plugin_init (GstPlugin * plugin)
   init_pes_parser ();
 
   return gst_element_register (plugin, "tsdemux",
-      GST_RANK_SECONDARY, GST_TYPE_TS_DEMUX);
+      GST_RANK_PRIMARY, GST_TYPE_TS_DEMUX);
 }
diff --git a/gst/mpegtsdemux/tsdemux.h b/gst/mpegtsdemux/tsdemux.h
index 395cf3e..d23e9d2 100644
--- a/gst/mpegtsdemux/tsdemux.h
+++ b/gst/mpegtsdemux/tsdemux.h
@@ -48,14 +48,6 @@ G_BEGIN_DECLS
 #define GST_TS_DEMUX_CAST(obj) ((GstTSDemux*) obj)
 typedef struct _GstTSDemux GstTSDemux;
 typedef struct _GstTSDemuxClass GstTSDemuxClass;
-typedef struct _TSPcrOffset TSPcrOffset;
-
-struct _TSPcrOffset
-{
-  guint64 gsttime;
-  guint64 pcr;
-  guint64 offset;
-};
 
 struct _GstTSDemux
 {
@@ -69,18 +61,18 @@ struct _GstTSDemux
   /*< private >*/
   MpegTSBaseProgram *program;	/* Current program */
   guint	current_program_number;
-  gboolean need_newsegment;
-  /* Downstream segment */
+
+  /* segments to be sent */
   GstSegment segment;
-  GstClockTime duration;	/* Total duration */
+  GstEvent *segment_event;
+
+  /* Set when program change */
+  gboolean calculate_update_segment;
+  /* update segment is */
+  GstEvent *update_segment;
 
-  /* pcr wrap and seeking */
-  GArray *index;
-  gint index_size;
-  TSPcrOffset first_pcr;
-  TSPcrOffset last_pcr;
-  TSPcrOffset cur_pcr;
-  TSPcrOffset index_pcr;
+  /* Full stream duration */
+  GstClockTime duration;
 };
 
 struct _GstTSDemuxClass
diff --git a/gst/mpegtsmux/mpegtsmux.c b/gst/mpegtsmux/mpegtsmux.c
index a243e40..df7dd58 100644
--- a/gst/mpegtsmux/mpegtsmux.c
+++ b/gst/mpegtsmux/mpegtsmux.c
@@ -88,6 +88,10 @@
 #include <stdio.h>
 #include <string.h>
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/video/video.h>
 
 #include "mpegtsmux.h"
@@ -147,7 +151,7 @@ static gboolean new_packet_cb (guint8 * data, guint len, void *user_data,
 static void release_buffer_cb (guint8 * data, void *user_data);
 
 static void mpegtsdemux_prepare_srcpad (MpegTsMux * mux);
-static GstFlowReturn mpegtsmux_collected (GstCollectPads * pads,
+static GstFlowReturn mpegtsmux_collected (GstCollectPads2 * pads,
     MpegTsMux * mux);
 static GstPad *mpegtsmux_request_new_pad (GstElement * element,
     GstPadTemplate * templ, const gchar * name);
@@ -224,9 +228,9 @@ mpegtsmux_init (MpegTsMux * mux, MpegTsMuxClass * g_class)
   gst_pad_set_event_function (mux->srcpad, mpegtsmux_src_event);
   gst_element_add_pad (GST_ELEMENT (mux), mux->srcpad);
 
-  mux->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (mux->collect,
-      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (mpegtsmux_collected), mux);
+  mux->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (mux->collect,
+      (GstCollectPads2Function) GST_DEBUG_FUNCPTR (mpegtsmux_collected), mux);
 
   mux->tsmux = tsmux_new ();
   tsmux_set_write_func (mux->tsmux, new_packet_cb, mux);
@@ -288,6 +292,7 @@ mpegtsmux_dispose (GObject * object)
     g_list_free (mux->streamheader);
     mux->streamheader = NULL;
   }
+  gst_event_replace (&mux->force_key_unit_event, NULL);
   GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
 }
 
@@ -518,7 +523,7 @@ mpegtsmux_create_streams (MpegTsMux * mux)
 
   /* Create the streams */
   while (walk) {
-    GstCollectData *c_data = (GstCollectData *) walk->data;
+    GstCollectData2 *c_data = (GstCollectData2 *) walk->data;
     MpegTsPadData *ts_data = (MpegTsPadData *) walk->data;
     gchar *name = NULL;
 
@@ -578,11 +583,11 @@ static MpegTsPadData *
 mpegtsmux_choose_best_stream (MpegTsMux * mux)
 {
   MpegTsPadData *best = NULL;
-  GstCollectData *c_best = NULL;
+  GstCollectData2 *c_best = NULL;
   GSList *walk;
 
   for (walk = mux->collect->data; walk != NULL; walk = g_slist_next (walk)) {
-    GstCollectData *c_data = (GstCollectData *) walk->data;
+    GstCollectData2 *c_data = (GstCollectData2 *) walk->data;
     MpegTsPadData *ts_data = (MpegTsPadData *) walk->data;
 
     if (ts_data->eos == FALSE) {
@@ -590,7 +595,7 @@ mpegtsmux_choose_best_stream (MpegTsMux * mux)
         GstBuffer *buf;
 
         ts_data->queued_buf = buf =
-            gst_collect_pads_peek (mux->collect, c_data);
+            gst_collect_pads2_peek (mux->collect, c_data);
 
         if (buf != NULL) {
           if (ts_data->prepare_func) {
@@ -652,35 +657,14 @@ mpegtsmux_choose_best_stream (MpegTsMux * mux)
   }
   if (c_best) {
     GstBuffer *buffer;
-    if ((buffer = gst_collect_pads_pop (mux->collect, c_best)))
+    if ((buffer = gst_collect_pads2_pop (mux->collect, c_best)))
       gst_buffer_unref (buffer);
   }
 
   return best;
 }
 
-#define COLLECT_DATA_PAD(collect_data) (((GstCollectData *)(collect_data))->pad)
-
-static MpegTsPadData *
-find_pad_data (MpegTsMux * mux, GstPad * pad)
-{
-  GSList *walk;
-  MpegTsPadData *ts_data = NULL;
-
-  GST_COLLECT_PADS_PAD_LOCK (mux->collect);
-  walk = mux->collect->abidata.ABI.pad_list;
-  while (walk) {
-    if (((GstCollectData *) walk->data)->pad == pad) {
-      ts_data = (MpegTsPadData *) walk->data;
-      break;
-    }
-
-    walk = g_slist_next (walk);
-  }
-  GST_COLLECT_PADS_PAD_UNLOCK (mux->collect);
-
-  return ts_data;
-}
+#define COLLECT_DATA_PAD(collect_data) (((GstCollectData2 *)(collect_data))->pad)
 
 static gboolean
 mpegtsmux_sink_event (GstPad * pad, GstEvent * event)
@@ -690,7 +674,7 @@ mpegtsmux_sink_event (GstPad * pad, GstEvent * event)
   gboolean res = TRUE;
   gboolean forward = TRUE;
 
-  ts_data = find_pad_data (mux, pad);
+  ts_data = (MpegTsPadData *) gst_pad_get_element_private (pad);
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_CUSTOM_DOWNSTREAM:
@@ -731,6 +715,8 @@ mpegtsmux_sink_event (GstPad * pad, GstEvent * event)
 out:
   if (forward)
     res = ts_data->eventfunc (pad, event);
+  else
+    gst_event_unref (event);
 
   gst_object_unref (mux);
   return res;
@@ -740,7 +726,7 @@ static gboolean
 mpegtsmux_src_event (GstPad * pad, GstEvent * event)
 {
   MpegTsMux *mux = GST_MPEG_TSMUX (gst_pad_get_parent (pad));
-  gboolean res = TRUE;
+  gboolean res = TRUE, forward = TRUE;
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_CUSTOM_UPSTREAM:
@@ -755,6 +741,8 @@ mpegtsmux_src_event (GstPad * pad, GstEvent * event)
       if (!gst_video_event_is_force_key_unit (event))
         break;
 
+      forward = FALSE;
+
       gst_video_event_parse_upstream_force_key_unit (event,
           &running_time, &all_headers, &count);
 
@@ -795,15 +783,18 @@ mpegtsmux_src_event (GstPad * pad, GstEvent * event)
             break;
         }
       }
-
-      gst_event_unref (event);
+      gst_iterator_free (iter);
       break;
     }
     default:
-      res = gst_pad_event_default (pad, event);
       break;
   }
 
+  if (forward)
+    res = gst_pad_event_default (pad, event);
+  else
+    gst_event_unref (event);
+
   gst_object_unref (mux);
   return res;
 }
@@ -857,7 +848,7 @@ out:
 }
 
 static GstFlowReturn
-mpegtsmux_collected (GstCollectPads * pads, MpegTsMux * mux)
+mpegtsmux_collected (GstCollectPads2 * pads, MpegTsMux * mux)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   MpegTsPadData *best = NULL;
@@ -1000,7 +991,7 @@ mpegtsmux_request_new_pad (GstElement * element,
   pad = gst_pad_new_from_template (templ, pad_name);
   g_free (pad_name);
 
-  pad_data = (MpegTsPadData *) gst_collect_pads_add_pad (mux->collect, pad,
+  pad_data = (MpegTsPadData *) gst_collect_pads2_add_pad (mux->collect, pad,
       sizeof (MpegTsPadData));
   if (pad_data == NULL)
     goto pad_failure;
@@ -1029,7 +1020,7 @@ stream_exists:
 could_not_add:
   GST_ELEMENT_ERROR (element, STREAM, FAILED,
       ("Internal data stream error."), ("Could not add pad to element"));
-  gst_collect_pads_remove_pad (mux->collect, pad);
+  gst_collect_pads2_remove_pad (mux->collect, pad);
   gst_object_unref (pad);
   return NULL;
 pad_failure:
@@ -1047,7 +1038,7 @@ mpegtsmux_release_pad (GstElement * element, GstPad * pad)
   GST_DEBUG_OBJECT (mux, "Pad %" GST_PTR_FORMAT " being released", pad);
 
   if (mux->collect) {
-    gst_collect_pads_remove_pad (mux->collect, pad);
+    gst_collect_pads2_remove_pad (mux->collect, pad);
   }
 
   /* chain up */
@@ -1309,12 +1300,12 @@ mpegtsmux_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_NULL_TO_READY:
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (mux->collect);
+      gst_collect_pads2_start (mux->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_collect_pads_stop (mux->collect);
+      gst_collect_pads2_stop (mux->collect);
       break;
     case GST_STATE_CHANGE_READY_TO_NULL:
       if (mux->adapter)
diff --git a/gst/mpegtsmux/mpegtsmux.h b/gst/mpegtsmux/mpegtsmux.h
index 26003a8..c31707b 100644
--- a/gst/mpegtsmux/mpegtsmux.h
+++ b/gst/mpegtsmux/mpegtsmux.h
@@ -84,7 +84,7 @@
 #define __MPEGTSMUX_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 #include <gst/base/gstadapter.h>
 
 G_BEGIN_DECLS
@@ -108,7 +108,7 @@ struct MpegTsMux {
 
   GstPad *srcpad;
 
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
 
   TsMux *tsmux;
   TsMuxProgram **programs;
@@ -139,7 +139,7 @@ struct MpegTsMuxClass  {
 #define MPEG_TS_PAD_DATA(data)  ((MpegTsPadData *)(data))
 
 struct MpegTsPadData {
-  GstCollectData collect; /* Parent */
+  GstCollectData2 collect; /* Parent */
 
   gint pid;
   TsMuxStream *stream;
diff --git a/gst/mve/Makefile.am b/gst/mve/Makefile.am
index 272b918..8be4517 100644
--- a/gst/mve/Makefile.am
+++ b/gst/mve/Makefile.am
@@ -1,6 +1,6 @@
 plugin_LTLIBRARIES = libgstmve.la
 
-libgstmve_la_CFLAGS = $(GST_BASE_CFLAGS) $(GST_CFLAGS)
+libgstmve_la_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_BASE_CFLAGS) $(GST_CFLAGS)
 libgstmve_la_LIBADD = $(GST_BASE_LIBS) $(GST_LIBS) $(LIBM)
 libgstmve_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstmve_la_LIBTOOLFLAGS = --tag=disable-static
diff --git a/gst/mve/gstmvemux.c b/gst/mve/gstmvemux.c
index fad163b..0b1a24c 100644
--- a/gst/mve/gstmvemux.c
+++ b/gst/mve/gstmvemux.c
@@ -31,6 +31,7 @@ gst-launch-0.10 filesrc location=movie.mve ! mvedemux name=d !
 #include <string.h>
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include "gstmvemux.h"
 #include "mve.h"
 
diff --git a/gst/mxf/mxfdemux.c b/gst/mxf/mxfdemux.c
index 13ab13b..de3bb36 100644
--- a/gst/mxf/mxfdemux.c
+++ b/gst/mxf/mxfdemux.c
@@ -54,6 +54,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include "mxfdemux.h"
 #include "mxfessence.h"
 
@@ -2379,7 +2383,7 @@ gst_mxf_demux_find_essence_element (GstMXFDemux * demux,
   GstFlowReturn ret = GST_FLOW_OK;
   guint64 old_offset = demux->offset;
   GstMXFDemuxPartition *old_partition = demux->current_partition;
-  guint i;
+  gint i;
 
   GST_DEBUG_OBJECT (demux, "Trying to find essence element %" G_GINT64_FORMAT
       " of track %u with body_sid %u (keyframe %d)", *position,
@@ -3962,10 +3966,8 @@ gst_mxf_demux_base_init (gpointer g_class)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
 
-  gst_element_class_add_static_pad_template (element_class,
-      &mxf_sink_template);
-  gst_element_class_add_static_pad_template (element_class,
-      &mxf_src_template);
+  gst_element_class_add_static_pad_template (element_class, &mxf_sink_template);
+  gst_element_class_add_static_pad_template (element_class, &mxf_src_template);
   gst_element_class_set_details_simple (element_class, "MXF Demuxer",
       "Codec/Demuxer",
       "Demux MXF files", "Sebastian Dröge <sebastian.droege@collabora.co.uk>");
diff --git a/gst/mxf/mxfmpeg.c b/gst/mxf/mxfmpeg.c
index 08b1a27..45676d0 100644
--- a/gst/mxf/mxfmpeg.c
+++ b/gst/mxf/mxfmpeg.c
@@ -441,7 +441,7 @@ mxf_mpeg_is_mpeg2_keyframe (GstBuffer * buffer)
       guint8 type = 0;
 
       /* Found sync code */
-      gst_byte_reader_skip (&reader, 3);
+      gst_byte_reader_skip_unchecked (&reader, 3);
 
       if (!gst_byte_reader_get_uint8 (&reader, &type))
         break;
@@ -465,9 +465,8 @@ mxf_mpeg_is_mpeg2_keyframe (GstBuffer * buffer)
           return FALSE;
         }
       }
-    } else {
-      gst_byte_reader_skip (&reader, 1);
-    }
+    } else if (gst_byte_reader_skip (&reader, 1) == FALSE)
+      break;
   }
 
   return FALSE;
@@ -484,7 +483,7 @@ mxf_mpeg_is_mpeg4_keyframe (GstBuffer * buffer)
       guint8 type = 0;
 
       /* Found sync code */
-      gst_byte_reader_skip (&reader, 3);
+      gst_byte_reader_skip_unchecked (&reader, 3);
 
       if (!gst_byte_reader_get_uint8 (&reader, &type))
         break;
@@ -502,9 +501,8 @@ mxf_mpeg_is_mpeg4_keyframe (GstBuffer * buffer)
           return FALSE;
         }
       }
-    } else {
-      gst_byte_reader_skip (&reader, 1);
-    }
+    } else if (gst_byte_reader_skip (&reader, 1) == FALSE)
+      break;
   }
 
   return FALSE;
@@ -1024,7 +1022,7 @@ mxf_mpeg_is_mpeg2_frame (GstBuffer * buffer)
       guint8 type = 0;
 
       /* Found sync code */
-      gst_byte_reader_skip (&reader, 3);
+      gst_byte_reader_skip_unchecked (&reader, 3);
 
       if (!gst_byte_reader_get_uint8 (&reader, &type))
         break;
@@ -1034,7 +1032,8 @@ mxf_mpeg_is_mpeg2_frame (GstBuffer * buffer)
         return TRUE;
       }
     } else {
-      gst_byte_reader_skip (&reader, 1);
+      if (gst_byte_reader_skip (&reader, 1) == FALSE)
+        break;
     }
   }
 
@@ -1052,7 +1051,7 @@ mxf_mpeg_is_mpeg4_frame (GstBuffer * buffer)
       guint8 type = 0;
 
       /* Found sync code */
-      gst_byte_reader_skip (&reader, 3);
+      gst_byte_reader_skip_unchecked (&reader, 3);
 
       if (!gst_byte_reader_get_uint8 (&reader, &type))
         break;
@@ -1062,7 +1061,8 @@ mxf_mpeg_is_mpeg4_frame (GstBuffer * buffer)
         return TRUE;
       }
     } else {
-      gst_byte_reader_skip (&reader, 1);
+      if (gst_byte_reader_skip (&reader, 1) == FALSE)
+        break;
     }
   }
 
diff --git a/gst/mxf/mxfmux.c b/gst/mxf/mxfmux.c
index 2074ea0..a743879 100644
--- a/gst/mxf/mxfmux.c
+++ b/gst/mxf/mxfmux.c
@@ -65,7 +65,7 @@ static void gst_mxf_mux_set_property (GObject * object,
 static void gst_mxf_mux_get_property (GObject * object,
     guint prop_id, GValue * value, GParamSpec * pspec);
 
-static GstFlowReturn gst_mxf_mux_collected (GstCollectPads * pads,
+static GstFlowReturn gst_mxf_mux_collected (GstCollectPads2 * pads,
     gpointer user_data);
 
 static gboolean gst_mxf_mux_handle_src_event (GstPad * pad, GstEvent * event);
@@ -145,9 +145,9 @@ gst_mxf_mux_init (GstMXFMux * mux, GstMXFMuxClass * g_class)
   gst_caps_unref (caps);
   gst_element_add_pad (GST_ELEMENT (mux), mux->srcpad);
 
-  mux->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (mux->collect,
-      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (gst_mxf_mux_collected), mux);
+  mux->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (mux->collect,
+      (GstCollectPads2Function) GST_DEBUG_FUNCPTR (gst_mxf_mux_collected), mux);
 
   gst_mxf_mux_reset (mux);
 }
@@ -208,7 +208,7 @@ gst_mxf_mux_reset (GstMXFMux * mux)
     g_object_unref (cpad->adapter);
     g_free (cpad->mapping_data);
 
-    gst_collect_pads_remove_pad (mux->collect, cpad->collect.pad);
+    gst_collect_pads2_remove_pad (mux->collect, cpad->collect.pad);
   }
 
   mux->state = GST_MXF_MUX_STATE_HEADER;
@@ -267,7 +267,7 @@ gst_mxf_mux_handle_sink_event (GstPad * pad, GstEvent * event)
       break;
   }
 
-  /* now GstCollectPads can take care of the rest, e.g. EOS */
+  /* now GstCollectPads2 can take care of the rest, e.g. EOS */
   if (ret)
     ret = mux->collect_event (pad, event);
   gst_object_unref (mux);
@@ -337,13 +337,13 @@ gst_mxf_mux_setcaps (GstPad * pad, GstCaps * caps)
       for (i = 0; i < mux->preface->content_storage->n_packages; i++) {
         MXFMetadataSourcePackage *package;
 
-        if (!MXF_IS_METADATA_SOURCE_PACKAGE (mux->preface->content_storage->
-                packages[i]))
+        if (!MXF_IS_METADATA_SOURCE_PACKAGE (mux->preface->
+                content_storage->packages[i]))
           continue;
 
         package =
-            MXF_METADATA_SOURCE_PACKAGE (mux->preface->content_storage->
-            packages[i]);
+            MXF_METADATA_SOURCE_PACKAGE (mux->preface->
+            content_storage->packages[i]);
 
         if (!package->descriptor)
           continue;
@@ -419,13 +419,13 @@ gst_mxf_mux_request_new_pad (GstElement * element,
   pad = gst_pad_new_from_template (templ, name);
   g_free (name);
   cpad = (GstMXFMuxPad *)
-      gst_collect_pads_add_pad (mux->collect, pad, sizeof (GstMXFMuxPad));
+      gst_collect_pads2_add_pad (mux->collect, pad, sizeof (GstMXFMuxPad));
   cpad->last_timestamp = 0;
   cpad->adapter = gst_adapter_new ();
   cpad->writer = writer;
 
   /* FIXME: hacked way to override/extend the event function of
-   * GstCollectPads; because it sets its own event function giving the
+   * GstCollectPads2; because it sets its own event function giving the
    * element no access to events.
    */
   mux->collect_event = (GstPadEventFunction) GST_PAD_EVENTFUNC (pad);
@@ -449,7 +449,7 @@ gst_mxf_mux_release_pad (GstElement * element, GstPad * pad)
      g_object_unref (cpad->adapter);
      g_free (cpad->mapping_data);
 
-     gst_collect_pads_remove_pad (mux->collect, pad);
+     gst_collect_pads2_remove_pad (mux->collect, pad);
      gst_element_remove_pad (element, pad); */
 }
 
@@ -705,8 +705,8 @@ gst_mxf_mux_create_metadata (GstMXFMux * mux)
           if (p->parent.n_tracks == 1) {
             p->descriptor = (MXFMetadataGenericDescriptor *) cpad->descriptor;
           } else {
-            MXF_METADATA_MULTIPLE_DESCRIPTOR (p->descriptor)->
-                sub_descriptors[n] =
+            MXF_METADATA_MULTIPLE_DESCRIPTOR (p->
+                descriptor)->sub_descriptors[n] =
                 (MXFMetadataGenericDescriptor *) cpad->descriptor;
           }
 
@@ -928,8 +928,8 @@ gst_mxf_mux_create_metadata (GstMXFMux * mux)
         g_new0 (MXFMetadataEssenceContainerData *, 1);
     cstorage->essence_container_data[0] = (MXFMetadataEssenceContainerData *)
         gst_mini_object_new (MXF_TYPE_METADATA_ESSENCE_CONTAINER_DATA);
-    mxf_uuid_init (&MXF_METADATA_BASE (cstorage->essence_container_data[0])->
-        instance_uid, mux->metadata);
+    mxf_uuid_init (&MXF_METADATA_BASE (cstorage->
+            essence_container_data[0])->instance_uid, mux->metadata);
     g_hash_table_insert (mux->metadata,
         &MXF_METADATA_BASE (cstorage->essence_container_data[0])->instance_uid,
         cstorage->essence_container_data[0]);
@@ -1098,9 +1098,8 @@ gst_mxf_mux_handle_buffer (GstMXFMux * mux, GstMXFMuxPad * cpad)
   GstBuffer *packet;
   GstFlowReturn ret = GST_FLOW_OK;
   guint8 slen, ber[9];
-  gboolean flush =
-      (cpad->collect.abidata.ABI.eos && !cpad->have_complete_edit_unit
-      && cpad->collect.buffer == NULL);
+  gboolean flush = ((cpad->collect.state & GST_COLLECT_PADS2_STATE_EOS)
+      && !cpad->have_complete_edit_unit && cpad->collect.buffer == NULL);
 
   if (cpad->have_complete_edit_unit) {
     GST_DEBUG_OBJECT (cpad->collect.pad,
@@ -1108,7 +1107,7 @@ gst_mxf_mux_handle_buffer (GstMXFMux * mux, GstMXFMuxPad * cpad)
         cpad->source_track->parent.track_id, cpad->pos);
     buf = NULL;
   } else if (!flush) {
-    buf = gst_collect_pads_pop (mux->collect, &cpad->collect);
+    buf = gst_collect_pads2_pop (mux->collect, &cpad->collect);
   }
 
   if (buf) {
@@ -1246,22 +1245,23 @@ gst_mxf_mux_handle_eos (GstMXFMux * mux)
 
     /* Update durations */
     cpad->source_track->parent.sequence->duration = cpad->pos;
-    MXF_METADATA_SOURCE_CLIP (cpad->source_track->parent.sequence->
-        structural_components[0])->parent.duration = cpad->pos;
+    MXF_METADATA_SOURCE_CLIP (cpad->source_track->parent.
+        sequence->structural_components[0])->parent.duration = cpad->pos;
     for (i = 0; i < mux->preface->content_storage->packages[0]->n_tracks; i++) {
       MXFMetadataTimelineTrack *track;
 
-      if (!MXF_IS_METADATA_TIMELINE_TRACK (mux->preface->content_storage->
-              packages[0]->tracks[i])
-          || !MXF_IS_METADATA_SOURCE_CLIP (mux->preface->content_storage->
-              packages[0]->tracks[i]->sequence->structural_components[0]))
+      if (!MXF_IS_METADATA_TIMELINE_TRACK (mux->preface->
+              content_storage->packages[0]->tracks[i])
+          || !MXF_IS_METADATA_SOURCE_CLIP (mux->preface->
+              content_storage->packages[0]->tracks[i]->sequence->
+              structural_components[0]))
         continue;
 
       track =
-          MXF_METADATA_TIMELINE_TRACK (mux->preface->content_storage->
-          packages[0]->tracks[i]);
-      if (MXF_METADATA_SOURCE_CLIP (track->parent.sequence->
-              structural_components[0])->source_track_id ==
+          MXF_METADATA_TIMELINE_TRACK (mux->preface->
+          content_storage->packages[0]->tracks[i]);
+      if (MXF_METADATA_SOURCE_CLIP (track->parent.
+              sequence->structural_components[0])->source_track_id ==
           cpad->source_track->parent.track_id) {
         track->parent.sequence->structural_components[0]->duration = cpad->pos;
         track->parent.sequence->duration = cpad->pos;
@@ -1272,8 +1272,8 @@ gst_mxf_mux_handle_eos (GstMXFMux * mux)
   /* Update timecode track duration */
   {
     MXFMetadataTimelineTrack *track =
-        MXF_METADATA_TIMELINE_TRACK (mux->preface->content_storage->
-        packages[0]->tracks[0]);
+        MXF_METADATA_TIMELINE_TRACK (mux->preface->
+        content_storage->packages[0]->tracks[0]);
     MXFMetadataSequence *sequence = track->parent.sequence;
     MXFMetadataTimecodeComponent *component =
         MXF_METADATA_TIMECODE_COMPONENT (sequence->structural_components[0]);
@@ -1368,7 +1368,7 @@ _sort_mux_pads (gconstpointer a, gconstpointer b)
 }
 
 static GstFlowReturn
-gst_mxf_mux_collected (GstCollectPads * pads, gpointer user_data)
+gst_mxf_mux_collected (GstCollectPads2 * pads, gpointer user_data)
 {
   GstMXFMux *mux = GST_MXF_MUX (user_data);
   GstMXFMuxPad *best = NULL;
@@ -1423,14 +1423,17 @@ gst_mxf_mux_collected (GstCollectPads * pads, gpointer user_data)
 
   do {
     for (sl = mux->collect->data; sl; sl = sl->next) {
+      gboolean pad_eos;
       GstMXFMuxPad *cpad = sl->data;
       GstClockTime next_gc_timestamp =
           gst_util_uint64_scale ((mux->last_gc_position + 1) * GST_SECOND,
           mux->min_edit_rate.d, mux->min_edit_rate.n);
 
-      eos &= cpad->collect.abidata.ABI.eos;
+      pad_eos = cpad->collect.state & GST_COLLECT_PADS2_STATE_EOS;
+      if (!pad_eos)
+        eos = FALSE;
 
-      if ((!cpad->collect.abidata.ABI.eos || cpad->have_complete_edit_unit ||
+      if ((!pad_eos || cpad->have_complete_edit_unit ||
               gst_adapter_available (cpad->adapter) > 0 || cpad->collect.buffer)
           && cpad->last_timestamp < next_gc_timestamp) {
         best = cpad;
@@ -1478,12 +1481,12 @@ gst_mxf_mux_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_NULL_TO_READY:
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
-      gst_collect_pads_start (mux->collect);
+      gst_collect_pads2_start (mux->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_collect_pads_stop (mux->collect);
+      gst_collect_pads2_stop (mux->collect);
       break;
     default:
       break;
diff --git a/gst/mxf/mxfmux.h b/gst/mxf/mxfmux.h
index 94330c4..20600ae 100644
--- a/gst/mxf/mxfmux.h
+++ b/gst/mxf/mxfmux.h
@@ -22,7 +22,7 @@
 
 #include <gst/gst.h>
 #include <gst/base/gstadapter.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 
 #include "mxfessence.h"
 
@@ -41,7 +41,7 @@ G_BEGIN_DECLS
 
 typedef struct
 {
-  GstCollectData collect;
+  GstCollectData2 collect;
 
   guint64 pos;
   GstClockTime last_timestamp;
@@ -71,7 +71,7 @@ typedef struct _GstMXFMux {
   GstElement element;
 
   GstPad *srcpad;
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
 
   /* <private> */
   GstPadEventFunction collect_event;
diff --git a/gst/rawparse/gstaudioparse.c b/gst/rawparse/gstaudioparse.c
index d4f82ba..12c5097 100644
--- a/gst/rawparse/gstaudioparse.c
+++ b/gst/rawparse/gstaudioparse.c
@@ -28,6 +28,10 @@
 #  include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include "gstaudioparse.h"
 
 #include <gst/audio/multichannel.h>
diff --git a/gst/rawparse/gstrawparse.c b/gst/rawparse/gstrawparse.c
index cf0f5d0..b49ddd0 100644
--- a/gst/rawparse/gstrawparse.c
+++ b/gst/rawparse/gstrawparse.c
@@ -29,6 +29,10 @@
 
 #include <string.h>
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/gst.h>
 #include <gst/base/gstbasetransform.h>
 #include <gst/base/gstadapter.h>
diff --git a/gst/removesilence/vad_private.c b/gst/removesilence/vad_private.c
index f187a06..0b86531 100644
--- a/gst/removesilence/vad_private.c
+++ b/gst/removesilence/vad_private.c
@@ -74,7 +74,7 @@ vad_new (guint64 hysteresis)
 void
 vad_reset (VADFilter * vad)
 {
-  memset (vad, 0, sizeof (vad));
+  memset (vad, 0, sizeof (*vad));
   vad->cqueue.base.s = vad->vad_buffer;
   vad->cqueue.tail.a = vad->cqueue.head.a = 0;
   vad->cqueue.size = VAD_BUFFER_SIZE;
diff --git a/gst/rtpvp8/gstrtpvp8depay.c b/gst/rtpvp8/gstrtpvp8depay.c
index 74d13b5..6f4a7b0 100644
--- a/gst/rtpvp8/gstrtpvp8depay.c
+++ b/gst/rtpvp8/gstrtpvp8depay.c
@@ -154,8 +154,8 @@ gst_rtp_vp8_depay_process (GstBaseRTPDepayload * depay, GstBuffer * buf)
     /* Check L optional header */
     if ((data[1] & 0x40) != 0)
       offset++;
-    /* Check T optional header */
-    if ((data[1] & 0x20) != 0)
+    /* Check T or K optional headers */
+    if ((data[1] & 0x20) != 0 || (data[1] & 0x10) != 0)
       offset++;
   }
 
diff --git a/gst/rtpvp8/gstrtpvp8pay.c b/gst/rtpvp8/gstrtpvp8pay.c
index 82dceeb..7d4c1f5 100644
--- a/gst/rtpvp8/gstrtpvp8pay.c
+++ b/gst/rtpvp8/gstrtpvp8pay.c
@@ -317,7 +317,7 @@ gst_rtp_vp8_create_header_buffer (GstRtpVP8Pay * self, guint8 partid,
   if (self->picture_id_mode != VP8_PAY_NO_PICTURE_ID) {
     /* Enable X=1 */
     p[0] |= 0x80;
-    /* X: I=1,L=0,T=0,RSVA=0 */
+    /* X: I=1,L=0,T=0,K=0,RSV=0 */
     p[1] = 0x80;
     if (self->picture_id_mode == VP8_PAY_PICTURE_ID_7BITS) {
       /* I: 7 bit picture_id */
diff --git a/gst/sdp/gstsdpdemux.c b/gst/sdp/gstsdpdemux.c
index 9254dbc..9b65b18 100644
--- a/gst/sdp/gstsdpdemux.c
+++ b/gst/sdp/gstsdpdemux.c
@@ -47,6 +47,10 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
diff --git a/gst/siren/Makefile.am b/gst/siren/Makefile.am
index 2be9ede..c6d1d8c 100644
--- a/gst/siren/Makefile.am
+++ b/gst/siren/Makefile.am
@@ -10,7 +10,7 @@ libgstsiren_la_SOURCES = gstsiren.c \
 
 libgstsiren_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) \
 	$(GST_CFLAGS)
-libgstsiren_la_LIBADD = $(GST_PLUGINS_BASE_LIBS) -lgstrtp-@GST_MAJORMINOR@ \
+libgstsiren_la_LIBADD = $(GST_PLUGINS_BASE_LIBS) -lgstaudio-@GST_MAJORMINOR@ \
 	$(GST_BASE_LIBS) $(GST_LIBS) $(LIBM)
 libgstsiren_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstsiren_la_LIBTOOLFLAGS = --tag=disable-static
diff --git a/gst/siren/gstsirendec.c b/gst/siren/gstsirendec.c
index 6325c96..ca0e817 100644
--- a/gst/siren/gstsirendec.c
+++ b/gst/siren/gstsirendec.c
@@ -69,14 +69,14 @@ enum
   ARG_0,
 };
 
-static void gst_siren_dec_finalize (GObject * object);
-
-static GstStateChangeReturn
-gst_siren_change_state (GstElement * element, GstStateChange transition);
-
-static gboolean gst_siren_dec_sink_setcaps (GstPad * pad, GstCaps * caps);
-static gboolean gst_siren_dec_sink_event (GstPad * pad, GstEvent * event);
-static GstFlowReturn gst_siren_dec_chain (GstPad * pad, GstBuffer * buf);
+static gboolean gst_siren_dec_start (GstAudioDecoder * dec);
+static gboolean gst_siren_dec_stop (GstAudioDecoder * dec);
+static gboolean gst_siren_dec_set_format (GstAudioDecoder * dec,
+    GstCaps * caps);
+static gboolean gst_siren_dec_parse (GstAudioDecoder * dec,
+    GstAdapter * adapter, gint * offset, gint * length);
+static GstFlowReturn gst_siren_dec_handle_frame (GstAudioDecoder * dec,
+    GstBuffer * buffer);
 
 static void
 _do_init (GType type)
@@ -84,8 +84,8 @@ _do_init (GType type)
   GST_DEBUG_CATEGORY_INIT (sirendec_debug, "sirendec", 0, "sirendec");
 }
 
-GST_BOILERPLATE_FULL (GstSirenDec, gst_siren_dec, GstElement,
-    GST_TYPE_ELEMENT, _do_init);
+GST_BOILERPLATE_FULL (GstSirenDec, gst_siren_dec, GstAudioDecoder,
+    GST_TYPE_AUDIO_DECODER, _do_init);
 
 static void
 gst_siren_dec_base_init (gpointer klass)
@@ -104,17 +104,15 @@ gst_siren_dec_base_init (gpointer klass)
 static void
 gst_siren_dec_class_init (GstSirenDecClass * klass)
 {
-  GObjectClass *gobject_class;
-  GstElementClass *gstelement_class;
-
-  gobject_class = (GObjectClass *) klass;
-  gstelement_class = (GstElementClass *) klass;
+  GstAudioDecoderClass *base_class = GST_AUDIO_DECODER_CLASS (klass);
 
   GST_DEBUG ("Initializing Class");
 
-  gobject_class->finalize = GST_DEBUG_FUNCPTR (gst_siren_dec_finalize);
-
-  gstelement_class->change_state = GST_DEBUG_FUNCPTR (gst_siren_change_state);
+  base_class->start = GST_DEBUG_FUNCPTR (gst_siren_dec_start);
+  base_class->stop = GST_DEBUG_FUNCPTR (gst_siren_dec_stop);
+  base_class->set_format = GST_DEBUG_FUNCPTR (gst_siren_dec_set_format);
+  base_class->parse = GST_DEBUG_FUNCPTR (gst_siren_dec_parse);
+  base_class->handle_frame = GST_DEBUG_FUNCPTR (gst_siren_dec_handle_frame);
 
   GST_DEBUG ("Class Init done");
 }
@@ -122,119 +120,103 @@ gst_siren_dec_class_init (GstSirenDecClass * klass)
 static void
 gst_siren_dec_init (GstSirenDec * dec, GstSirenDecClass * klass)
 {
+}
 
-  GST_DEBUG_OBJECT (dec, "Initializing");
-  dec->decoder = Siren7_NewDecoder (16000);;
-
-  dec->sinkpad = gst_pad_new_from_static_template (&sinktemplate, "sink");
-  dec->srcpad = gst_pad_new_from_static_template (&srctemplate, "src");
+static gboolean
+gst_siren_dec_start (GstAudioDecoder * dec)
+{
+  GstSirenDec *sdec = GST_SIREN_DEC (dec);
 
-  gst_pad_set_setcaps_function (dec->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_siren_dec_sink_setcaps));
-  gst_pad_set_event_function (dec->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_siren_dec_sink_event));
-  gst_pad_set_chain_function (dec->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_siren_dec_chain));
+  GST_DEBUG_OBJECT (dec, "start");
 
-  gst_element_add_pad (GST_ELEMENT (dec), dec->sinkpad);
-  gst_element_add_pad (GST_ELEMENT (dec), dec->srcpad);
+  sdec->decoder = Siren7_NewDecoder (16000);;
 
-  dec->adapter = gst_adapter_new ();
+  /* no flushing please */
+  gst_audio_decoder_set_drainable (dec, FALSE);
 
-  GST_DEBUG_OBJECT (dec, "Init done");
+  return TRUE;
 }
 
-static void
-gst_siren_dec_finalize (GObject * object)
+static gboolean
+gst_siren_dec_stop (GstAudioDecoder * dec)
 {
-  GstSirenDec *dec = GST_SIREN_DEC (object);
+  GstSirenDec *sdec = GST_SIREN_DEC (dec);
 
-  GST_DEBUG_OBJECT (dec, "Finalize");
+  GST_DEBUG_OBJECT (dec, "stop");
 
-  Siren7_CloseDecoder (dec->decoder);
-  g_object_unref (dec->adapter);
+  Siren7_CloseDecoder (sdec->decoder);
 
-  G_OBJECT_CLASS (parent_class)->finalize (object);
+  return TRUE;
 }
 
 static gboolean
-gst_siren_dec_sink_setcaps (GstPad * pad, GstCaps * caps)
+gst_siren_dec_negotiate (GstSirenDec * dec)
 {
-  GstSirenDec *dec;
   gboolean res;
   GstCaps *outcaps;
 
-  dec = GST_SIREN_DEC (GST_PAD_PARENT (pad));
-
   outcaps = gst_static_pad_template_get_caps (&srctemplate);
-  res = gst_pad_set_caps (dec->srcpad, outcaps);
+  res = gst_pad_set_caps (GST_AUDIO_DECODER_SRC_PAD (dec), outcaps);
   gst_caps_unref (outcaps);
 
   return res;
 }
 
 static gboolean
-gst_siren_dec_sink_event (GstPad * pad, GstEvent * event)
+gst_siren_dec_set_format (GstAudioDecoder * bdec, GstCaps * caps)
 {
   GstSirenDec *dec;
-  gboolean res;
 
-  dec = GST_SIREN_DEC (GST_PAD_PARENT (pad));
-
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_EOS:
-      gst_adapter_clear (dec->adapter);
-      res = gst_pad_push_event (dec->srcpad, event);
-      break;
-    case GST_EVENT_FLUSH_STOP:
-      gst_adapter_clear (dec->adapter);
-      res = gst_pad_push_event (dec->srcpad, event);
-      break;
-    default:
-      res = gst_pad_push_event (dec->srcpad, event);
-      break;
+  dec = GST_SIREN_DEC (bdec);
+
+  return gst_siren_dec_negotiate (dec);
+}
+
+static GstFlowReturn
+gst_siren_dec_parse (GstAudioDecoder * dec, GstAdapter * adapter,
+    gint * offset, gint * length)
+{
+  gint size;
+  GstFlowReturn ret;
+
+  size = gst_adapter_available (adapter);
+  g_return_val_if_fail (size > 0, GST_FLOW_ERROR);
+
+  /* accept any multiple of frames */
+  if (size > 40) {
+    ret = GST_FLOW_OK;
+    *offset = 0;
+    *length = size - (size % 40);
+  } else {
+    ret = GST_FLOW_UNEXPECTED;
   }
-  return res;
+
+  return ret;
 }
 
 static GstFlowReturn
-gst_siren_dec_chain (GstPad * pad, GstBuffer * buf)
+gst_siren_dec_handle_frame (GstAudioDecoder * bdec, GstBuffer * buf)
 {
   GstSirenDec *dec;
   GstFlowReturn ret = GST_FLOW_OK;
   GstBuffer *out_buf;
   guint8 *in_data, *out_data;
-  guint8 *to_free = NULL;
   guint i, size, num_frames;
   gint out_size, in_size;
   gint decode_ret;
-  gboolean discont;
-  GstClockTime timestamp;
-  guint64 distance;
-  GstCaps *outcaps;
-
-  dec = GST_SIREN_DEC (GST_PAD_PARENT (pad));
 
-  discont = GST_BUFFER_IS_DISCONT (buf);
-  if (discont) {
-    GST_DEBUG_OBJECT (dec, "received DISCONT, flush adapter");
-    gst_adapter_clear (dec->adapter);
-    dec->discont = TRUE;
-  }
+  dec = GST_SIREN_DEC (bdec);
 
-  gst_adapter_push (dec->adapter, buf);
+  size = GST_BUFFER_SIZE (buf);
 
-  size = gst_adapter_available (dec->adapter);
+  GST_LOG_OBJECT (dec, "Received buffer of size %u", size);
 
-  GST_LOG_OBJECT (dec, "Received buffer of size %u with adapter of size : %u",
-      GST_BUFFER_SIZE (buf), size);
+  g_return_val_if_fail (size % 40 == 0, GST_FLOW_ERROR);
+  g_return_val_if_fail (size > 0, GST_FLOW_ERROR);
 
   /* process 40 input bytes into 640 output bytes */
   num_frames = size / 40;
 
-  if (num_frames == 0)
-    goto done;
-
   /* this is the input/output size */
   in_size = num_frames * 40;
   out_size = num_frames * 640;
@@ -242,32 +224,19 @@ gst_siren_dec_chain (GstPad * pad, GstBuffer * buf)
   GST_LOG_OBJECT (dec, "we have %u frames, %u in, %u out", num_frames, in_size,
       out_size);
 
-  /* set output caps when needed */
-  if ((outcaps = GST_PAD_CAPS (dec->srcpad)) == NULL) {
-    outcaps = gst_static_pad_template_get_caps (&srctemplate);
-    gst_pad_set_caps (dec->srcpad, outcaps);
-    gst_caps_unref (outcaps);
+  /* allow and handle un-negotiated input */
+  if (G_UNLIKELY (GST_PAD_CAPS (GST_AUDIO_DECODER_SRC_PAD (dec)) == NULL)) {
+    gst_siren_dec_negotiate (dec);
   }
 
   /* get a buffer */
-  ret = gst_pad_alloc_buffer_and_set_caps (dec->srcpad, -1,
-      out_size, outcaps, &out_buf);
+  ret = gst_pad_alloc_buffer_and_set_caps (GST_AUDIO_DECODER_SRC_PAD (dec), -1,
+      out_size, GST_PAD_CAPS (GST_AUDIO_DECODER_SRC_PAD (dec)), &out_buf);
   if (ret != GST_FLOW_OK)
     goto alloc_failed;
 
-  /* get the timestamp for the output buffer */
-  timestamp = gst_adapter_prev_timestamp (dec->adapter, &distance);
-
-  /* add the amount of time taken by the distance, each frame is 20ms */
-  if (timestamp != -1)
-    timestamp += (distance / 40) * FRAME_DURATION;
-
-  GST_LOG_OBJECT (dec,
-      "timestamp %" GST_TIME_FORMAT ", distance %" G_GUINT64_FORMAT,
-      GST_TIME_ARGS (timestamp), distance);
-
   /* get the input data for all the frames */
-  to_free = in_data = gst_adapter_take (dec->adapter, in_size);
+  in_data = GST_BUFFER_DATA (buf);
   out_data = GST_BUFFER_DATA (out_buf);
 
   for (i = 0; i < num_frames; i++) {
@@ -285,21 +254,11 @@ gst_siren_dec_chain (GstPad * pad, GstBuffer * buf)
 
   GST_LOG_OBJECT (dec, "Finished decoding");
 
-  /* mark discont */
-  if (dec->discont) {
-    GST_BUFFER_FLAG_SET (out_buf, GST_BUFFER_FLAG_DISCONT);
-    dec->discont = FALSE;
-  }
-
-  GST_BUFFER_TIMESTAMP (out_buf) = timestamp;
-  GST_BUFFER_DURATION (out_buf) = num_frames * FRAME_DURATION;
-
-  ret = gst_pad_push (dec->srcpad, out_buf);
+  /* might really be multiple frames,
+   * but was treated as one for all purposes here */
+  ret = gst_audio_decoder_finish_frame (bdec, out_buf, 1);
 
 done:
-  if (to_free)
-    g_free (to_free);
-
   return ret;
 
   /* ERRORS */
@@ -311,41 +270,15 @@ alloc_failed:
   }
 decode_error:
   {
-    GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL),
-        ("Error decoding frame: %d", decode_ret));
-    ret = GST_FLOW_ERROR;
+    GST_AUDIO_DECODER_ERROR (bdec, 1, STREAM, DECODE, (NULL),
+        ("Error decoding frame: %d", decode_ret), ret);
+    if (ret == GST_FLOW_OK)
+      gst_audio_decoder_finish_frame (bdec, NULL, 1);
     gst_buffer_unref (out_buf);
     goto done;
   }
 }
 
-static GstStateChangeReturn
-gst_siren_change_state (GstElement * element, GstStateChange transition)
-{
-  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
-  GstSirenDec *dec = GST_SIREN_DEC (element);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_READY_TO_PAUSED:
-      dec->discont = FALSE;
-      break;
-    default:
-      break;
-  }
-
-  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_adapter_clear (dec->adapter);
-      break;
-    default:
-      break;
-  }
-
-  return ret;
-}
-
 gboolean
 gst_siren_dec_plugin_init (GstPlugin * plugin)
 {
diff --git a/gst/siren/gstsirendec.h b/gst/siren/gstsirendec.h
index 7c02089..4c42c4d 100644
--- a/gst/siren/gstsirendec.h
+++ b/gst/siren/gstsirendec.h
@@ -24,7 +24,7 @@
 #define __GST_SIREN_DEC_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstadapter.h>
+#include <gst/audio/gstaudiodecoder.h>
 
 #include "siren7.h"
 
@@ -48,21 +48,15 @@ typedef struct _GstSirenDecPrivate GstSirenDecPrivate;
 
 struct _GstSirenDec
 {
-  GstElement parent;
+  GstAudioDecoder parent;
 
   /* Protected by stream lock */
   SirenDecoder decoder;
-
-  GstAdapter *adapter;
-  gboolean discont;
-
-  GstPad *sinkpad;
-  GstPad *srcpad;
 };
 
 struct _GstSirenDecClass
 {
-  GstElementClass parent_class;
+  GstAudioDecoderClass parent_class;
 };
 
 GType gst_siren_dec_get_type (void);
diff --git a/gst/siren/gstsirenenc.c b/gst/siren/gstsirenenc.c
index dbf0f68..b6789a1 100644
--- a/gst/siren/gstsirenenc.c
+++ b/gst/siren/gstsirenenc.c
@@ -69,17 +69,12 @@ enum
   ARG_0,
 };
 
-
-
-static void gst_siren_enc_finalize (GObject * object);
-
-static gboolean gst_siren_enc_sink_setcaps (GstPad * pad, GstCaps * caps);
-static gboolean gst_siren_enc_sink_event (GstPad * pad, GstEvent * event);
-
-static GstFlowReturn gst_siren_enc_chain (GstPad * pad, GstBuffer * buf);
-static GstStateChangeReturn
-gst_siren_change_state (GstElement * element, GstStateChange transition);
-
+static gboolean gst_siren_enc_start (GstAudioEncoder * enc);
+static gboolean gst_siren_enc_stop (GstAudioEncoder * enc);
+static gboolean gst_siren_enc_set_format (GstAudioEncoder * enc,
+    GstAudioInfo * info);
+static GstFlowReturn gst_siren_enc_handle_frame (GstAudioEncoder * enc,
+    GstBuffer * in_buf);
 
 static void
 _do_init (GType type)
@@ -87,8 +82,8 @@ _do_init (GType type)
   GST_DEBUG_CATEGORY_INIT (sirenenc_debug, "sirenenc", 0, "sirenenc");
 }
 
-GST_BOILERPLATE_FULL (GstSirenEnc, gst_siren_enc, GstElement,
-    GST_TYPE_ELEMENT, _do_init);
+GST_BOILERPLATE_FULL (GstSirenEnc, gst_siren_enc, GstAudioEncoder,
+    GST_TYPE_AUDIO_ENCODER, _do_init);
 
 static void
 gst_siren_enc_base_init (gpointer klass)
@@ -107,17 +102,14 @@ gst_siren_enc_base_init (gpointer klass)
 static void
 gst_siren_enc_class_init (GstSirenEncClass * klass)
 {
-  GObjectClass *gobject_class;
-  GstElementClass *gstelement_class;
-
-  gobject_class = (GObjectClass *) klass;
-  gstelement_class = (GstElementClass *) klass;
+  GstAudioEncoderClass *base_class = GST_AUDIO_ENCODER_CLASS (klass);
 
   GST_DEBUG ("Initializing Class");
 
-  gobject_class->finalize = GST_DEBUG_FUNCPTR (gst_siren_enc_finalize);
-
-  gstelement_class->change_state = GST_DEBUG_FUNCPTR (gst_siren_change_state);
+  base_class->start = GST_DEBUG_FUNCPTR (gst_siren_enc_start);
+  base_class->stop = GST_DEBUG_FUNCPTR (gst_siren_enc_stop);
+  base_class->set_format = GST_DEBUG_FUNCPTR (gst_siren_enc_set_format);
+  base_class->handle_frame = GST_DEBUG_FUNCPTR (gst_siren_enc_handle_frame);
 
   GST_DEBUG ("Class Init done");
 }
@@ -125,120 +117,81 @@ gst_siren_enc_class_init (GstSirenEncClass * klass)
 static void
 gst_siren_enc_init (GstSirenEnc * enc, GstSirenEncClass * klass)
 {
+}
 
-  GST_DEBUG_OBJECT (enc, "Initializing");
-  enc->encoder = Siren7_NewEncoder (16000);
-  enc->adapter = gst_adapter_new ();
-
-  enc->sinkpad = gst_pad_new_from_static_template (&sinktemplate, "sink");
-  enc->srcpad = gst_pad_new_from_static_template (&srctemplate, "src");
+static gboolean
+gst_siren_enc_start (GstAudioEncoder * enc)
+{
+  GstSirenEnc *senc = GST_SIREN_ENC (enc);
 
-  gst_pad_set_setcaps_function (enc->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_siren_enc_sink_setcaps));
-  gst_pad_set_event_function (enc->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_siren_enc_sink_event));
-  gst_pad_set_chain_function (enc->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_siren_enc_chain));
+  GST_DEBUG_OBJECT (enc, "start");
 
-  gst_element_add_pad (GST_ELEMENT (enc), enc->sinkpad);
-  gst_element_add_pad (GST_ELEMENT (enc), enc->srcpad);
+  senc->encoder = Siren7_NewEncoder (16000);
 
-  GST_DEBUG_OBJECT (enc, "Init done");
+  return TRUE;
 }
 
-static void
-gst_siren_enc_finalize (GObject * object)
+static gboolean
+gst_siren_enc_stop (GstAudioEncoder * enc)
 {
-  GstSirenEnc *enc = GST_SIREN_ENC (object);
+  GstSirenEnc *senc = GST_SIREN_ENC (enc);
 
-  GST_DEBUG_OBJECT (object, "Disposing");
+  GST_DEBUG_OBJECT (senc, "stop");
 
-  Siren7_CloseEncoder (enc->encoder);
-  g_object_unref (enc->adapter);
+  Siren7_CloseEncoder (senc->encoder);
 
-  G_OBJECT_CLASS (parent_class)->finalize (object);
+  return TRUE;
 }
 
 static gboolean
-gst_siren_enc_sink_setcaps (GstPad * pad, GstCaps * caps)
+gst_siren_enc_set_format (GstAudioEncoder * benc, GstAudioInfo * info)
 {
   GstSirenEnc *enc;
   gboolean res;
   GstCaps *outcaps;
 
-  enc = GST_SIREN_ENC (GST_PAD_PARENT (pad));
+  enc = GST_SIREN_ENC (benc);
 
   outcaps = gst_static_pad_template_get_caps (&srctemplate);
-  res = gst_pad_set_caps (enc->srcpad, outcaps);
+  res = gst_pad_set_caps (GST_AUDIO_ENCODER_SRC_PAD (enc), outcaps);
   gst_caps_unref (outcaps);
 
-  return res;
-}
-
-static gboolean
-gst_siren_enc_sink_event (GstPad * pad, GstEvent * event)
-{
-  GstSirenEnc *enc;
-  gboolean res;
+  /* report needs to base class */
+  gst_audio_encoder_set_frame_samples_min (benc, 320);
+  gst_audio_encoder_set_frame_samples_max (benc, 320);
+  /* no remainder or flushing please */
+  gst_audio_encoder_set_hard_min (benc, TRUE);
+  gst_audio_encoder_set_drainable (benc, FALSE);
 
-  enc = GST_SIREN_ENC (GST_PAD_PARENT (pad));
-
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_EOS:
-      gst_adapter_clear (enc->adapter);
-      res = gst_pad_push_event (enc->srcpad, event);
-      break;
-    case GST_EVENT_FLUSH_STOP:
-      gst_adapter_clear (enc->adapter);
-      res = gst_pad_push_event (enc->srcpad, event);
-      break;
-    default:
-      res = gst_pad_push_event (enc->srcpad, event);
-      break;
-  }
   return res;
 }
 
 static GstFlowReturn
-gst_siren_enc_chain (GstPad * pad, GstBuffer * buf)
+gst_siren_enc_handle_frame (GstAudioEncoder * benc, GstBuffer * buf)
 {
   GstSirenEnc *enc;
   GstFlowReturn ret = GST_FLOW_OK;
   GstBuffer *out_buf;
   guint8 *in_data, *out_data;
-  guint8 *to_free = NULL;
   guint i, size, num_frames;
   gint out_size, in_size;
   gint encode_ret;
-  gboolean discont;
-  GstClockTime timestamp;
-  guint64 distance;
-  GstCaps *outcaps;
 
-  enc = GST_SIREN_ENC (GST_PAD_PARENT (pad));
+  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);
 
-  discont = GST_BUFFER_IS_DISCONT (buf);
-  if (discont) {
-    GST_DEBUG_OBJECT (enc, "received DISCONT, flush adapter");
-    gst_adapter_clear (enc->adapter);
-    enc->discont = TRUE;
-  }
+  enc = GST_SIREN_ENC (benc);
 
-  gst_adapter_push (enc->adapter, buf);
+  size = GST_BUFFER_SIZE (buf);
 
-  size = gst_adapter_available (enc->adapter);
+  GST_LOG_OBJECT (enc, "Received buffer of size %d", GST_BUFFER_SIZE (buf));
 
-  GST_LOG_OBJECT (enc, "Received buffer of size %d with adapter of size : %d",
-      GST_BUFFER_SIZE (buf), size);
+  g_return_val_if_fail (size > 0, GST_FLOW_ERROR);
+  g_return_val_if_fail (size % 640 == 0, GST_FLOW_ERROR);
 
   /* we need to process 640 input bytes to produce 40 output bytes */
   /* calculate the amount of frames we will handle */
   num_frames = size / 640;
 
-  /* no frames, wait some more */
-  if (num_frames == 0)
-    goto done;
-
   /* this is the input/output size */
   in_size = num_frames * 640;
   out_size = num_frames * 40;
@@ -246,32 +199,14 @@ gst_siren_enc_chain (GstPad * pad, GstBuffer * buf)
   GST_LOG_OBJECT (enc, "we have %u frames, %u in, %u out", num_frames, in_size,
       out_size);
 
-  /* set output caps when needed */
-  if ((outcaps = GST_PAD_CAPS (enc->srcpad)) == NULL) {
-    outcaps = gst_static_pad_template_get_caps (&srctemplate);
-    gst_pad_set_caps (enc->srcpad, outcaps);
-    gst_caps_unref (outcaps);
-  }
-
   /* get a buffer */
-  ret = gst_pad_alloc_buffer_and_set_caps (enc->srcpad, -1,
-      out_size, outcaps, &out_buf);
+  ret = gst_pad_alloc_buffer_and_set_caps (GST_AUDIO_ENCODER_SRC_PAD (benc),
+      -1, out_size, GST_PAD_CAPS (GST_AUDIO_ENCODER_SRC_PAD (benc)), &out_buf);
   if (ret != GST_FLOW_OK)
     goto alloc_failed;
 
-  /* get the timestamp for the output buffer */
-  timestamp = gst_adapter_prev_timestamp (enc->adapter, &distance);
-
-  /* add the amount of time taken by the distance */
-  if (timestamp != -1)
-    timestamp += gst_util_uint64_scale_int (distance / 2, GST_SECOND, 16000);
-
-  GST_LOG_OBJECT (enc,
-      "timestamp %" GST_TIME_FORMAT ", distance %" G_GUINT64_FORMAT,
-      GST_TIME_ARGS (timestamp), distance);
-
   /* get the input data for all the frames */
-  to_free = in_data = gst_adapter_take (enc->adapter, in_size);
+  in_data = GST_BUFFER_DATA (buf);
   out_data = GST_BUFFER_DATA (out_buf);
 
   for (i = 0; i < num_frames; i++) {
@@ -289,20 +224,10 @@ gst_siren_enc_chain (GstPad * pad, GstBuffer * buf)
 
   GST_LOG_OBJECT (enc, "Finished encoding");
 
-  /* mark discont */
-  if (enc->discont) {
-    GST_BUFFER_FLAG_SET (out_buf, GST_BUFFER_FLAG_DISCONT);
-    enc->discont = FALSE;
-  }
-  GST_BUFFER_TIMESTAMP (out_buf) = timestamp;
-  GST_BUFFER_DURATION (out_buf) = num_frames * FRAME_DURATION;
-
-  ret = gst_pad_push (enc->srcpad, out_buf);
+  /* we encode all we get, pass it along */
+  ret = gst_audio_encoder_finish_frame (benc, out_buf, -1);
 
 done:
-  if (to_free)
-    g_free (to_free);
-
   return ret;
 
   /* ERRORS */
@@ -322,33 +247,6 @@ encode_error:
   }
 }
 
-static GstStateChangeReturn
-gst_siren_change_state (GstElement * element, GstStateChange transition)
-{
-  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
-  GstSirenEnc *enc = GST_SIREN_ENC (element);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_READY_TO_PAUSED:
-      enc->discont = FALSE;
-      break;
-    default:
-      break;
-  }
-
-  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_adapter_clear (enc->adapter);
-      break;
-    default:
-      break;
-  }
-
-  return ret;
-}
-
 gboolean
 gst_siren_enc_plugin_init (GstPlugin * plugin)
 {
diff --git a/gst/siren/gstsirenenc.h b/gst/siren/gstsirenenc.h
index 1d63628..3477db1 100644
--- a/gst/siren/gstsirenenc.h
+++ b/gst/siren/gstsirenenc.h
@@ -24,7 +24,7 @@
 #define __GST_SIREN_ENC_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstadapter.h>
+#include <gst/audio/gstaudioencoder.h>
 
 #include "siren7.h"
 
@@ -48,21 +48,15 @@ typedef struct _GstSirenEncPrivate GstSirenEncPrivate;
 
 struct _GstSirenEnc
 {
-  GstElement parent;
+  GstAudioEncoder parent;
 
   /* protected by the stream lock */
   SirenEncoder encoder;
-  GstAdapter *adapter;
-
-  gboolean discont;
-
-  GstPad *srcpad;
-  GstPad *sinkpad;
 };
 
 struct _GstSirenEncClass
 {
-  GstElementClass parent_class;
+  GstAudioEncoderClass parent_class;
 };
 
 GType gst_siren_enc_get_type (void);
diff --git a/gst/tta/gstttaparse.c b/gst/tta/gstttaparse.c
index 52cd8e4..12269ac 100644
--- a/gst/tta/gstttaparse.c
+++ b/gst/tta/gstttaparse.c
@@ -19,6 +19,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/gst.h>
 
 #include <math.h>
diff --git a/gst/videomeasure/gstvideomeasure_ssim.c b/gst/videomeasure/gstvideomeasure_ssim.c
index 63e3472..2a2e493 100644
--- a/gst/videomeasure/gstvideomeasure_ssim.c
+++ b/gst/videomeasure/gstvideomeasure_ssim.c
@@ -114,7 +114,7 @@ static void gst_ssim_release_pad (GstElement * element, GstPad * pad);
 static GstStateChangeReturn gst_ssim_change_state (GstElement * element,
     GstStateChange transition);
 
-static GstFlowReturn gst_ssim_collected (GstCollectPads * pads,
+static GstFlowReturn gst_ssim_collected (GstCollectPads2 * pads,
     gpointer user_data);
 
 static GstElementClass *parent_class = NULL;
@@ -901,7 +901,7 @@ gst_ssim_src_event (GstPad * pad, GstEvent * event)
       /* check if we are flushing */
       if (flags & GST_SEEK_FLAG_FLUSH) {
         /* make sure we accept nothing anymore and return WRONG_STATE */
-        gst_collect_pads_set_flushing (ssim->collect, TRUE);
+        gst_collect_pads2_set_flushing (ssim->collect, TRUE);
 
         /* flushing seek, start flush downstream, the flush will be done
          * when all pads received a FLUSH_STOP. */
@@ -991,7 +991,7 @@ gst_ssim_sink_event (GstPad * pad, GstEvent * event)
       break;
   }
 
-  /* now GstCollectPads can take care of the rest, e.g. EOS */
+  /* now GstCollectPads2 can take care of the rest, e.g. EOS */
   GST_DEBUG ("Dispatching %s event on pad %s:%s", GST_EVENT_TYPE_NAME (event),
       GST_DEBUG_PAD_NAME (pad));
   ret = ssim->collect_event (pad, event);
@@ -1158,10 +1158,10 @@ gst_ssim_request_new_pad (GstElement * element, GstPadTemplate * templ,
   gst_pad_set_getcaps_function (newpad,
       GST_DEBUG_FUNCPTR (gst_ssim_sink_getcaps));
   gst_pad_set_setcaps_function (newpad, GST_DEBUG_FUNCPTR (gst_ssim_setcaps));
-  gst_collect_pads_add_pad (ssim->collect, newpad, sizeof (GstCollectData));
+  gst_collect_pads2_add_pad (ssim->collect, newpad, sizeof (GstCollectData2));
 
   /* FIXME: hacked way to override/extend the event function of
-   * GstCollectPads; because it sets its own event function giving the
+   * GstCollectPads2; because it sets its own event function giving the
    * element no access to events
    */
   GST_DEBUG_OBJECT (ssim, "Current collect_event is %p, changing to %p",
@@ -1233,7 +1233,7 @@ could_not_add_src:
 could_not_add_sink:
   {
     GST_DEBUG_OBJECT (ssim, "could not add sink pad");
-    gst_collect_pads_remove_pad (ssim->collect, newpad);
+    gst_collect_pads2_remove_pad (ssim->collect, newpad);
     gst_object_unref (newpad);
     return NULL;
   }
@@ -1248,7 +1248,7 @@ gst_ssim_release_pad (GstElement * element, GstPad * pad)
 
   GST_DEBUG_OBJECT (ssim, "release pad %s:%s", GST_DEBUG_PAD_NAME (pad));
 
-  gst_collect_pads_remove_pad (ssim->collect, pad);
+  gst_collect_pads2_remove_pad (ssim->collect, pad);
   gst_element_remove_pad (element, pad);
 }
 
@@ -1267,8 +1267,8 @@ gst_ssim_init (GstSSim * ssim)
   ssim->sinkcaps = NULL;
 
   /* keep track of the sinkpads requested */
-  ssim->collect = gst_collect_pads_new ();
-  gst_collect_pads_set_function (ssim->collect,
+  ssim->collect = gst_collect_pads2_new ();
+  gst_collect_pads2_set_function (ssim->collect,
       GST_DEBUG_FUNCPTR (gst_ssim_collected), ssim);
 }
 
@@ -1407,7 +1407,7 @@ gst_ssim_regenerate_windows (GstSSim * ssim)
 }
 
 static GstFlowReturn
-gst_ssim_collected (GstCollectPads * pads, gpointer user_data)
+gst_ssim_collected (GstCollectPads2 * pads, gpointer user_data)
 {
   GstSSim *ssim;
   GSList *collected;
@@ -1440,12 +1440,12 @@ gst_ssim_collected (GstCollectPads * pads, gpointer user_data)
   }
 
   for (collected = pads->data; collected; collected = g_slist_next (collected)) {
-    GstCollectData *collect_data;
+    GstCollectData2 *collect_data;
     GstBuffer *inbuf;
 
-    collect_data = (GstCollectData *) collected->data;
+    collect_data = (GstCollectData2 *) collected->data;
 
-    inbuf = gst_collect_pads_peek (pads, collect_data);
+    inbuf = gst_collect_pads2_peek (pads, collect_data);
 
     if (inbuf == NULL) {
       GST_LOG_OBJECT (ssim, "channel %p: no bytes available", collect_data);
@@ -1469,12 +1469,12 @@ gst_ssim_collected (GstCollectPads * pads, gpointer user_data)
 
     for (collected = pads->data; collected;
         collected = g_slist_next (collected)) {
-      GstCollectData *collect_data;
+      GstCollectData2 *collect_data;
 
-      collect_data = (GstCollectData *) collected->data;
+      collect_data = (GstCollectData2 *) collected->data;
 
       if (collect_data->pad == ssim->orig) {
-        orgbuf = gst_collect_pads_pop (pads, collect_data);;
+        orgbuf = gst_collect_pads2_pop (pads, collect_data);;
 
         GST_DEBUG_OBJECT (ssim, "Original stream - flags(0x%x), timestamp(%"
             GST_TIME_FORMAT "), duration(%" GST_TIME_FORMAT ")",
@@ -1491,14 +1491,14 @@ gst_ssim_collected (GstCollectPads * pads, gpointer user_data)
   GST_LOG_OBJECT (ssim, "starting to cycle through streams");
 
   for (collected = pads->data; collected; collected = g_slist_next (collected)) {
-    GstCollectData *collect_data;
+    GstCollectData2 *collect_data;
     GstBuffer *inbuf;
     guint8 *indata;
 
-    collect_data = (GstCollectData *) collected->data;
+    collect_data = (GstCollectData2 *) collected->data;
 
     if (collect_data->pad != ssim->orig) {
-      inbuf = gst_collect_pads_pop (pads, collect_data);
+      inbuf = gst_collect_pads2_pop (pads, collect_data);
 
       indata = GST_BUFFER_DATA (inbuf);
 
@@ -1659,7 +1659,7 @@ gst_ssim_change_state (GstElement * element, GstStateChange transition)
       ssim->segment_position = 0;
       ssim->segment_rate = 1.0;
       gst_segment_init (&ssim->segment, GST_FORMAT_UNDEFINED);
-      gst_collect_pads_start (ssim->collect);
+      gst_collect_pads2_start (ssim->collect);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       break;
@@ -1667,7 +1667,7 @@ gst_ssim_change_state (GstElement * element, GstStateChange transition)
       /* need to unblock the collectpads before calling the
        * parent change_state so that streaming can finish
        */
-      gst_collect_pads_stop (ssim->collect);
+      gst_collect_pads2_stop (ssim->collect);
       break;
     default:
       break;
diff --git a/gst/videomeasure/gstvideomeasure_ssim.h b/gst/videomeasure/gstvideomeasure_ssim.h
index 57e0907..2760d03 100644
--- a/gst/videomeasure/gstvideomeasure_ssim.h
+++ b/gst/videomeasure/gstvideomeasure_ssim.h
@@ -21,7 +21,7 @@
 #define __GST_SSIM_H__
 
 #include <gst/gst.h>
-#include <gst/base/gstcollectpads.h>
+#include <gst/base/gstcollectpads2.h>
 #include <gst/video/video.h>
 
 G_BEGIN_DECLS
@@ -85,7 +85,7 @@ struct _GstSSim {
   
   gint            padcount;
 
-  GstCollectPads *collect;
+  GstCollectPads2 *collect;
   GstPad         *orig;
 
   gint            frame_rate;
diff --git a/gst/videoparsers/gsth263parse.c b/gst/videoparsers/gsth263parse.c
index 85028c2..d488d5a 100644
--- a/gst/videoparsers/gsth263parse.c
+++ b/gst/videoparsers/gsth263parse.c
@@ -65,10 +65,8 @@ gst_h263_parse_base_init (gpointer g_class)
 {
   GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
 
-  gst_element_class_add_static_pad_template (gstelement_class,
-      &srctemplate);
-  gst_element_class_add_static_pad_template (gstelement_class,
-      &sinktemplate);
+  gst_element_class_add_static_pad_template (gstelement_class, &srctemplate);
+  gst_element_class_add_static_pad_template (gstelement_class, &sinktemplate);
   gst_element_class_set_details_simple (gstelement_class, "H.263 parser",
       "Codec/Parser/Video",
       "Parses H.263 streams",
@@ -163,7 +161,8 @@ find_psc (GstBuffer * buffer, guint skip)
   if (!gst_byte_reader_set_pos (&br, skip))
     goto out;
 
-  gst_byte_reader_peek_uint24_be (&br, &psc);
+  if (gst_byte_reader_peek_uint24_be (&br, &psc) == FALSE)
+    goto out;
 
   /* Scan for the picture start code (22 bits - 0x0020) */
   while ((gst_byte_reader_get_remaining (&br) >= 3)) {
@@ -171,8 +170,8 @@ find_psc (GstBuffer * buffer, guint skip)
         ((psc & 0xffffc0) == 0x000080)) {
       psc_pos = gst_byte_reader_get_pos (&br);
       break;
-    } else
-      gst_byte_reader_skip (&br, 1);
+    } else if (gst_byte_reader_skip (&br, 1) == FALSE)
+      break;
   }
 
 out:
diff --git a/gst/videoparsers/gsth264parse.c b/gst/videoparsers/gsth264parse.c
index cf81657..bfdc4d4 100644
--- a/gst/videoparsers/gsth264parse.c
+++ b/gst/videoparsers/gsth264parse.c
@@ -177,11 +177,7 @@ gst_h264_parse_reset_frame (GstH264Parse * h264parse)
   GST_DEBUG_OBJECT (h264parse, "reset frame");
 
   /* done parsing; reset state */
-  h264parse->nalu.valid = FALSE;
-  h264parse->nalu.offset = 0;
-  h264parse->nalu.sc_offset = 0;
-  h264parse->nalu.size = 0;
-  h264parse->current_off = 0;
+  h264parse->current_off = -1;
 
   h264parse->picture_start = FALSE;
   h264parse->update_caps = FALSE;
@@ -213,6 +209,8 @@ gst_h264_parse_reset (GstH264Parse * h264parse)
 
   h264parse->last_report = GST_CLOCK_TIME_NONE;
   h264parse->push_codec = FALSE;
+  h264parse->have_pps = FALSE;
+  h264parse->have_sps = FALSE;
 
   h264parse->dts = GST_CLOCK_TIME_NONE;
   h264parse->ts_trn_nb = GST_CLOCK_TIME_NONE;
@@ -468,8 +466,15 @@ gst_h264_parse_process_nal (GstH264Parse * h264parse, GstH264NalUnit * nalu)
 
       GST_DEBUG_OBJECT (h264parse, "triggering src caps check");
       h264parse->update_caps = TRUE;
-      /* found in stream, no need to forcibly push at start */
-      h264parse->push_codec = FALSE;
+      h264parse->have_sps = TRUE;
+      if (h264parse->push_codec && h264parse->have_pps) {
+        /* SPS and PPS found in stream before the first pre_push_frame, no need
+         * to forcibly push at start */
+        GST_INFO_OBJECT (h264parse, "have SPS/PPS in stream");
+        h264parse->push_codec = FALSE;
+        h264parse->have_sps = FALSE;
+        h264parse->have_pps = FALSE;
+      }
 
       gst_h264_parser_store_nal (h264parse, sps.id, nal_type, nalu);
       break;
@@ -478,8 +483,15 @@ gst_h264_parse_process_nal (GstH264Parse * h264parse, GstH264NalUnit * nalu)
       /* parameters might have changed, force caps check */
       GST_DEBUG_OBJECT (h264parse, "triggering src caps check");
       h264parse->update_caps = TRUE;
-      /* found in stream, no need to forcibly push at start */
-      h264parse->push_codec = FALSE;
+      h264parse->have_pps = TRUE;
+      if (h264parse->push_codec && h264parse->have_sps) {
+        /* SPS and PPS found in stream before the first pre_push_frame, no need
+         * to forcibly push at start */
+        GST_INFO_OBJECT (h264parse, "have SPS/PPS in stream");
+        h264parse->push_codec = FALSE;
+        h264parse->have_sps = FALSE;
+        h264parse->have_pps = FALSE;
+      }
 
       gst_h264_parser_store_nal (h264parse, pps.id, nal_type, nalu);
       break;
@@ -640,10 +652,12 @@ gst_h264_parse_check_valid_frame (GstBaseParse * parse,
   GstH264Parse *h264parse = GST_H264_PARSE (parse);
   GstBuffer *buffer = frame->buffer;
   guint8 *data;
-  guint size, current_off = 0;
-  gboolean drain;
+  guint size;
+  gint current_off = 0;
+  gboolean drain, nonext;
   GstH264NalParser *nalparser = h264parse->nalparser;
   GstH264NalUnit nalu;
+  GstH264ParserResult pres;
 
   /* expect at least 3 bytes startcode == sc, and 2 bytes NALU payload */
   if (G_UNLIKELY (GST_BUFFER_SIZE (buffer) < 5))
@@ -665,16 +679,38 @@ gst_h264_parse_check_valid_frame (GstBaseParse * parse,
   data = GST_BUFFER_DATA (buffer);
   size = GST_BUFFER_SIZE (buffer);
 
-  drain = FALSE;
-  nalu = h264parse->nalu;
-  current_off = h264parse->current_off;
+  drain = GST_BASE_PARSE_DRAINING (parse);
+  nonext = FALSE;
 
+  current_off = h264parse->current_off;
+  if (current_off < 0)
+    current_off = 0;
   g_assert (current_off < size);
+  GST_DEBUG_OBJECT (h264parse, "last parse position %d", current_off);
 
-  GST_DEBUG_OBJECT (h264parse, "last parse position %u", current_off);
-  while (TRUE) {
-    GstH264ParserResult pres;
+  /* check for initial skip */
+  if (h264parse->current_off == -1) {
+    pres =
+        gst_h264_parser_identify_nalu_unchecked (nalparser, data, current_off,
+        size, &nalu);
+    switch (pres) {
+      case GST_H264_PARSER_OK:
+        if (nalu.sc_offset > 0) {
+          *skipsize = nalu.sc_offset;
+          goto skip;
+        }
+        break;
+      case GST_H264_PARSER_NO_NAL:
+        *skipsize = size - 3;
+        goto skip;
+        break;
+      default:
+        g_assert_not_reached ();
+        break;
+    }
+  }
 
+  while (TRUE) {
     if (h264parse->packetized_chunked)
       pres =
           gst_h264_parser_identify_nalu_unchecked (nalparser, data, current_off,
@@ -686,99 +722,85 @@ gst_h264_parse_check_valid_frame (GstBaseParse * parse,
 
     switch (pres) {
       case GST_H264_PARSER_OK:
-        GST_DEBUG_OBJECT (h264parse, "complete nal found. "
-            "current offset: %u, Nal offset: %u, Nal Size: %u",
-            current_off, nalu.offset, nalu.size);
-
-        GST_DEBUG_OBJECT (h264parse, "current off. %u",
-            nalu.offset + nalu.size);
-
-        if (!h264parse->nalu.size && !h264parse->nalu.valid)
-          h264parse->nalu = nalu;
-
-        /* need 2 bytes of next nal */
-        if (!h264parse->packetized_chunked &&
-            (nalu.offset + nalu.size + 4 + 2 > size)) {
-          if (GST_BASE_PARSE_DRAINING (parse)) {
-            drain = TRUE;
-          } else {
-            GST_DEBUG_OBJECT (h264parse, "need more bytes of next nal");
-            current_off = nalu.sc_offset;
-            goto more;
-          }
-        } else if (h264parse->packetized_chunked) {
-          /* normal next nal based collection not possible,
-           * _chain will have to tell us whether this was last one for AU */
-          drain = h264parse->packetized_last;
-        }
+        GST_DEBUG_OBJECT (h264parse, "complete nal (offset, size): (%u, %u) ",
+            nalu.offset, nalu.size);
         break;
+      case GST_H264_PARSER_NO_NAL_END:
+        GST_DEBUG_OBJECT (h264parse, "not a complete nal found at offset %u",
+            nalu.offset);
+        /* if draining, accept it as complete nal */
+        if (drain) {
+          nonext = TRUE;
+          nalu.size = size - nalu.offset;
+          GST_DEBUG_OBJECT (h264parse, "draining, accepting with size %u",
+              nalu.size);
+          /* if it's not too short at least */
+          if (nalu.size < 2)
+            goto broken;
+          break;
+        }
+        /* otherwise need more */
+        goto more;
       case GST_H264_PARSER_BROKEN_LINK:
-        return FALSE;
+        g_assert_not_reached ();
+        break;
       case GST_H264_PARSER_ERROR:
-        current_off = size - 3;
-        goto parsing_error;
+        /* should not really occur either */
+        GST_DEBUG_OBJECT (h264parse, "error parsing Nal Unit");
+        /* fall-through */
       case GST_H264_PARSER_NO_NAL:
-        /* don't expect to have found any NAL so far */
-        g_assert (h264parse->nalu.size == 0);
-        current_off = h264parse->nalu.sc_offset = size - 3;
-        goto more;
+        g_assert_not_reached ();
+        break;
       case GST_H264_PARSER_BROKEN_DATA:
         GST_WARNING_OBJECT (h264parse, "input stream is corrupt; "
-            "it contains a NAL unit of length %d", nalu.size);
-
+            "it contains a NAL unit of length %u", nalu.size);
+      broken:
         /* broken nal at start -> arrange to skip it,
          * otherwise have it terminate current au
          * (and so it will be skipped on next frame round) */
-        if (nalu.sc_offset == h264parse->nalu.sc_offset) {
-          *skipsize = nalu.offset;
-
+        if (current_off == 0) {
           GST_DEBUG_OBJECT (h264parse, "skipping broken nal");
-          goto invalid;
+          *skipsize = nalu.offset;
+          goto skip;
         } else {
+          GST_DEBUG_OBJECT (h264parse, "terminating au");
           nalu.size = 0;
+          nalu.offset = nalu.sc_offset;
           goto end;
         }
-      case GST_H264_PARSER_NO_NAL_END:
-        GST_DEBUG_OBJECT (h264parse, "not a complete nal found at offset %u",
-            nalu.offset);
-
-        current_off = nalu.sc_offset;
-        /* We keep the reference to this nal so we start over the parsing
-         * here */
-        if (!h264parse->nalu.size && !h264parse->nalu.valid)
-          h264parse->nalu = nalu;
-
-        if (GST_BASE_PARSE_DRAINING (parse)) {
-          drain = TRUE;
-          GST_DEBUG_OBJECT (h264parse, "draining NAL %u %u %u", size,
-              h264parse->nalu.offset, h264parse->nalu.size);
-          /*  Can't parse the nalu */
-          if (size - h264parse->nalu.offset < 2) {
-            *skipsize = nalu.offset;
-            goto invalid;
-          }
-
-          /* We parse it anyway */
-          nalu.size = size - nalu.offset;
-          break;
-        }
-        goto more;
+        break;
+      default:
+        g_assert_not_reached ();
+        break;
     }
 
-    current_off = nalu.offset + nalu.size;
-
     GST_DEBUG_OBJECT (h264parse, "%p complete nal found. Off: %u, Size: %u",
         data, nalu.offset, nalu.size);
 
+    /* simulate no next nal if none needed */
+    nonext = nonext || (h264parse->align == GST_H264_PARSE_ALIGN_NAL);
+
+    if (!nonext && !h264parse->packetized_chunked) {
+      if (nalu.offset + nalu.size + 4 + 2 > size) {
+        GST_DEBUG_OBJECT (h264parse, "not enough data for next NALU");
+        if (drain) {
+          GST_DEBUG_OBJECT (h264parse, "but draining anyway");
+          nonext = TRUE;
+        } else {
+          goto more;
+        }
+      }
+    }
+
     gst_h264_parse_process_nal (h264parse, &nalu);
 
-    /* simulate no next nal if none needed */
-    drain = drain || (h264parse->align == GST_H264_PARSE_ALIGN_NAL);
+    if (nonext)
+      break;
 
     /* In packetized mode we know there's only on NALU in each input packet,
      * but we may not have seen the whole AU already, possibly need more */
     if (h264parse->packetized_chunked) {
-      if (drain)
+      if (h264parse->packetized_last)
         break;
       /* next NALU expected at end of current data */
       current_off = size;
@@ -786,42 +808,30 @@ gst_h264_parse_check_valid_frame (GstBaseParse * parse,
     }
 
     /* if no next nal, we know it's complete here */
-    if (drain || gst_h264_parse_collect_nal (h264parse, data, size, &nalu))
+    if (gst_h264_parse_collect_nal (h264parse, data, size, &nalu))
       break;
 
     GST_DEBUG_OBJECT (h264parse, "Looking for more");
+    current_off = nalu.offset + nalu.size;
   }
 
 end:
-  *skipsize = h264parse->nalu.sc_offset;
-  *framesize = nalu.offset + nalu.size - h264parse->nalu.sc_offset;
-  h264parse->current_off = current_off;
-
+  *framesize = nalu.offset + nalu.size;
   return TRUE;
 
-parsing_error:
-  GST_DEBUG_OBJECT (h264parse, "error parsing Nal Unit");
-
 more:
   /* ask for best next available */
   *framesize = G_MAXUINT;
-  if (!h264parse->nalu.size) {
-    /* skip up to initial startcode */
-    *skipsize = h264parse->nalu.sc_offset;
-    /* but mind some stuff will have been skipped */
-    g_assert (current_off >= *skipsize);
-    current_off -= *skipsize;
-    h264parse->nalu.sc_offset = 0;
-  } else {
-    *skipsize = 0;
-  }
+  *skipsize = 0;
 
   /* Restart parsing from here next time */
-  h264parse->current_off = current_off;
+  if (current_off > 0)
+    h264parse->current_off = current_off;
 
   return FALSE;
 
-invalid:
+skip:
+  GST_DEBUG_OBJECT (h264parse, "skipping %d", *skipsize);
   gst_h264_parse_reset_frame (h264parse);
   return FALSE;
 }
@@ -835,6 +845,7 @@ gst_h264_parse_make_codec_data (GstH264Parse * h264parse)
   guint8 profile_idc = 0, profile_comp = 0, level_idc = 0;
   gboolean found = FALSE;
   guint8 *data;
+  gint nl;
 
   /* only nal payload in stored nals */
 
@@ -867,12 +878,13 @@ gst_h264_parse_make_codec_data (GstH264Parse * h264parse)
 
   buf = gst_buffer_new_and_alloc (5 + 1 + sps_size + 1 + pps_size);
   data = GST_BUFFER_DATA (buf);
+  nl = h264parse->nal_length_size;
 
   data[0] = 1;                  /* AVC Decoder Configuration Record ver. 1 */
   data[1] = profile_idc;        /* profile_idc                             */
   data[2] = profile_comp;       /* profile_compability                     */
   data[3] = level_idc;          /* level_idc                               */
-  data[4] = 0xfc | (4 - 1);     /* nal_length_size_minus1                  */
+  data[4] = 0xfc | (nl - 1);    /* nal_length_size_minus1                  */
   data[5] = 0xe0 | num_sps;     /* number of SPSs */
 
   data += 6;
@@ -1341,12 +1353,10 @@ check_pending_key_unit_event (GstEvent * pending_event, GstSegment * segment,
       running_time < pending_key_unit_ts)
     goto out;
 
-#if 0
   if (flags & GST_BUFFER_FLAG_DELTA_UNIT) {
     GST_DEBUG ("pending force key unit, waiting for keyframe");
     goto out;
   }
-#endif
 
   stream_time = gst_segment_to_stream_time (segment,
       GST_FORMAT_TIME, timestamp);
@@ -1479,32 +1489,33 @@ gst_h264_parse_pre_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
           GstByteWriter bw;
           GstBuffer *new_buf;
           const gboolean bs = h264parse->format == GST_H264_PARSE_FORMAT_BYTE;
+          gboolean ok;
 
           gst_byte_writer_init_with_size (&bw, GST_BUFFER_SIZE (buffer), FALSE);
-          gst_byte_writer_put_data (&bw, GST_BUFFER_DATA (buffer),
+          ok = gst_byte_writer_put_data (&bw, GST_BUFFER_DATA (buffer),
               h264parse->idr_pos);
           GST_DEBUG_OBJECT (h264parse, "- inserting SPS/PPS");
           for (i = 0; i < GST_H264_MAX_SPS_COUNT; i++) {
             if ((codec_nal = h264parse->sps_nals[i])) {
               GST_DEBUG_OBJECT (h264parse, "inserting SPS nal");
-              gst_byte_writer_put_uint32_be (&bw,
+              ok &= gst_byte_writer_put_uint32_be (&bw,
                   bs ? 1 : GST_BUFFER_SIZE (codec_nal));
-              gst_byte_writer_put_data (&bw, GST_BUFFER_DATA (codec_nal),
-                  GST_BUFFER_SIZE (codec_nal));
+              ok &= gst_byte_writer_put_data (&bw,
+                  GST_BUFFER_DATA (codec_nal), GST_BUFFER_SIZE (codec_nal));
               h264parse->last_report = new_ts;
             }
           }
           for (i = 0; i < GST_H264_MAX_PPS_COUNT; i++) {
             if ((codec_nal = h264parse->pps_nals[i])) {
               GST_DEBUG_OBJECT (h264parse, "inserting PPS nal");
-              gst_byte_writer_put_uint32_be (&bw,
+              ok &= gst_byte_writer_put_uint32_be (&bw,
                   bs ? 1 : GST_BUFFER_SIZE (codec_nal));
-              gst_byte_writer_put_data (&bw, GST_BUFFER_DATA (codec_nal),
-                  GST_BUFFER_SIZE (codec_nal));
+              ok &= gst_byte_writer_put_data (&bw,
+                  GST_BUFFER_DATA (codec_nal), GST_BUFFER_SIZE (codec_nal));
               h264parse->last_report = new_ts;
             }
           }
-          gst_byte_writer_put_data (&bw,
+          ok &= gst_byte_writer_put_data (&bw,
               GST_BUFFER_DATA (buffer) + h264parse->idr_pos,
               GST_BUFFER_SIZE (buffer) - h264parse->idr_pos);
           /* collect result and push */
@@ -1515,10 +1526,16 @@ gst_h264_parse_pre_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
           GST_BUFFER_FLAG_UNSET (new_buf, GST_BUFFER_FLAG_DELTA_UNIT);
           gst_buffer_replace (&frame->buffer, new_buf);
           gst_buffer_unref (new_buf);
+          /* some result checking seems to make some compilers happy */
+          if (G_UNLIKELY (!ok)) {
+            GST_ERROR_OBJECT (h264parse, "failed to insert SPS/PPS");
+          }
         }
       }
       /* we pushed whatever we had */
       h264parse->push_codec = FALSE;
+      h264parse->have_sps = FALSE;
+      h264parse->have_pps = FALSE;
     }
   }
 
@@ -1623,10 +1640,10 @@ gst_h264_parse_set_caps (GstBaseParse * parse, GstCaps * caps)
 
     /* if upstream sets codec_data without setting stream-format and alignment, we
      * assume stream-format=avc,alignment=au */
-    if (format == GST_H264_PARSE_FORMAT_NONE) {
+    if (format == GST_H264_PARSE_FORMAT_NONE)
       format = GST_H264_PARSE_FORMAT_AVC;
+    if (align == GST_H264_PARSE_ALIGN_NONE)
       align = GST_H264_PARSE_ALIGN_AU;
-    }
   } else {
     GST_DEBUG_OBJECT (h264parse, "have bytestream h264");
     /* nothing to pre-process */
@@ -1665,6 +1682,8 @@ gst_h264_parse_set_caps (GstBaseParse * parse, GstCaps * caps)
     /* arrange to insert codec-data in-stream if needed.
      * src caps are only arranged for later on */
     h264parse->push_codec = TRUE;
+    h264parse->have_sps = FALSE;
+    h264parse->have_pps = FALSE;
     h264parse->split_packetized = TRUE;
     h264parse->packetized = TRUE;
   }
diff --git a/gst/videoparsers/gsth264parse.h b/gst/videoparsers/gsth264parse.h
index d60d94c..61afe93 100644
--- a/gst/videoparsers/gsth264parse.h
+++ b/gst/videoparsers/gsth264parse.h
@@ -67,15 +67,16 @@ struct _GstH264Parse
 
   /* state */
   GstH264NalParser *nalparser;
-  GstH264NalUnit nalu;
   guint align;
   guint format;
-  guint current_off;
+  gint current_off;
   gboolean packetized_last;
   gboolean packetized_chunked;
 
   GstClockTime last_report;
   gboolean push_codec;
+  gboolean have_sps;
+  gboolean have_pps;
 
   /* collected SPS and PPS NALUs */
   GstBuffer *sps_nals[GST_H264_MAX_SPS_COUNT];
diff --git a/gst/videoparsers/gstmpeg4videoparse.c b/gst/videoparsers/gstmpeg4videoparse.c
index f561c84..49a55d3 100644
--- a/gst/videoparsers/gstmpeg4videoparse.c
+++ b/gst/videoparsers/gstmpeg4videoparse.c
@@ -31,6 +31,7 @@
 #include <string.h>
 #include <gst/base/gstbytereader.h>
 #include <gst/pbutils/codec-utils.h>
+#include <gst/video/video.h>
 
 #include "gstmpeg4videoparse.h"
 
@@ -82,6 +83,9 @@ static void gst_mpeg4vparse_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec);
 static void gst_mpeg4vparse_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
+static gboolean gst_mpeg4vparse_event (GstBaseParse * parse, GstEvent * event);
+static gboolean gst_mpeg4vparse_src_event (GstBaseParse * parse,
+    GstEvent * event);
 
 static void
 gst_mpeg4vparse_base_init (gpointer klass)
@@ -171,6 +175,8 @@ gst_mpeg4vparse_class_init (GstMpeg4VParseClass * klass)
       GST_DEBUG_FUNCPTR (gst_mpeg4vparse_pre_push_frame);
   parse_class->set_sink_caps = GST_DEBUG_FUNCPTR (gst_mpeg4vparse_set_caps);
   parse_class->get_sink_caps = GST_DEBUG_FUNCPTR (gst_mpeg4vparse_get_caps);
+  parse_class->event = GST_DEBUG_FUNCPTR (gst_mpeg4vparse_event);
+  parse_class->src_event = GST_DEBUG_FUNCPTR (gst_mpeg4vparse_src_event);
 }
 
 static void
@@ -197,6 +203,8 @@ gst_mpeg4vparse_reset (GstMpeg4VParse * mp4vparse)
   mp4vparse->update_caps = TRUE;
   mp4vparse->profile = NULL;
   mp4vparse->level = NULL;
+  mp4vparse->pending_key_unit_ts = GST_CLOCK_TIME_NONE;
+  mp4vparse->force_key_unit_event = NULL;
 
   gst_buffer_replace (&mp4vparse->config, NULL);
   memset (&mp4vparse->vol, 0, sizeof (mp4vparse->vol));
@@ -554,14 +562,89 @@ gst_mpeg4vparse_parse_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
     return GST_FLOW_OK;
 }
 
+static GstEvent *
+check_pending_key_unit_event (GstEvent * pending_event, GstSegment * segment,
+    GstClockTime timestamp, guint flags, GstClockTime pending_key_unit_ts)
+{
+  GstClockTime running_time, stream_time;
+  gboolean all_headers;
+  guint count;
+  GstEvent *event = NULL;
+
+  g_return_val_if_fail (segment != NULL, NULL);
+
+  if (pending_event == NULL)
+    goto out;
+
+  if (GST_CLOCK_TIME_IS_VALID (pending_key_unit_ts) &&
+      timestamp == GST_CLOCK_TIME_NONE)
+    goto out;
+
+  running_time = gst_segment_to_running_time (segment,
+      GST_FORMAT_TIME, timestamp);
+
+  GST_INFO ("now %" GST_TIME_FORMAT " wanted %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (running_time), GST_TIME_ARGS (pending_key_unit_ts));
+  if (GST_CLOCK_TIME_IS_VALID (pending_key_unit_ts) &&
+      running_time < pending_key_unit_ts)
+    goto out;
+
+  if (flags & GST_BUFFER_FLAG_DELTA_UNIT) {
+    GST_DEBUG ("pending force key unit, waiting for keyframe");
+    goto out;
+  }
+
+  stream_time = gst_segment_to_stream_time (segment,
+      GST_FORMAT_TIME, timestamp);
+
+  gst_video_event_parse_upstream_force_key_unit (pending_event,
+      NULL, &all_headers, &count);
+
+  event =
+      gst_video_event_new_downstream_force_key_unit (timestamp, stream_time,
+      running_time, all_headers, count);
+  gst_event_set_seqnum (event, gst_event_get_seqnum (pending_event));
+
+out:
+  return event;
+}
+
+static void
+gst_mpeg4vparse_prepare_key_unit (GstMpeg4VParse * parse, GstEvent * event)
+{
+  GstClockTime running_time;
+  guint count;
+
+  parse->pending_key_unit_ts = GST_CLOCK_TIME_NONE;
+  gst_event_replace (&parse->force_key_unit_event, NULL);
+
+  gst_video_event_parse_downstream_force_key_unit (event,
+      NULL, NULL, &running_time, NULL, &count);
+
+  GST_INFO_OBJECT (parse, "pushing downstream force-key-unit event %d "
+      "%" GST_TIME_FORMAT " count %d", gst_event_get_seqnum (event),
+      GST_TIME_ARGS (running_time), count);
+  gst_pad_push_event (GST_BASE_PARSE_SRC_PAD (parse), event);
+}
+
+
 static GstFlowReturn
 gst_mpeg4vparse_pre_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
 {
   GstMpeg4VParse *mp4vparse = GST_MPEG4VIDEO_PARSE (parse);
   GstBuffer *buffer = frame->buffer;
+  gboolean push_codec = FALSE;
+  GstEvent *event = NULL;
+
+  if ((event = check_pending_key_unit_event (mp4vparse->force_key_unit_event,
+              &parse->segment, GST_BUFFER_TIMESTAMP (buffer),
+              GST_BUFFER_FLAGS (buffer), mp4vparse->pending_key_unit_ts))) {
+    gst_mpeg4vparse_prepare_key_unit (mp4vparse, event);
+    push_codec = TRUE;
+  }
 
   /* periodic config sending */
-  if (mp4vparse->interval > 0) {
+  if (mp4vparse->interval > 0 || push_codec) {
     GstClockTime timestamp = GST_BUFFER_TIMESTAMP (buffer);
     guint64 diff;
 
@@ -583,9 +666,9 @@ gst_mpeg4vparse_pre_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
       GST_LOG_OBJECT (mp4vparse,
           "interval since last config %" GST_TIME_FORMAT, GST_TIME_ARGS (diff));
 
-      if (GST_TIME_AS_SECONDS (diff) >= mp4vparse->interval) {
+      if (GST_TIME_AS_SECONDS (diff) >= mp4vparse->interval || push_codec) {
         /* we need to send config now first */
-        GST_LOG_OBJECT (parse, "inserting config in stream");
+        GST_INFO_OBJECT (parse, "inserting config in stream");
 
         /* avoid inserting duplicate config */
         if ((GST_BUFFER_SIZE (buffer) < GST_BUFFER_SIZE (mp4vparse->config)) ||
@@ -600,7 +683,7 @@ gst_mpeg4vparse_pre_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
           gst_buffer_replace (&frame->buffer, superbuf);
           gst_buffer_unref (superbuf);
         } else {
-          GST_LOG_OBJECT (parse, "... but avoiding duplication");
+          GST_INFO_OBJECT (parse, "... but avoiding duplication");
         }
 
         if (G_UNLIKELY (timestamp != -1)) {
@@ -690,3 +773,84 @@ gst_mpeg4vparse_get_caps (GstBaseParse * parse)
 
   return res;
 }
+
+static gboolean
+gst_mpeg4vparse_event (GstBaseParse * parse, GstEvent * event)
+{
+  gboolean handled = FALSE;
+  GstMpeg4VParse *mp4vparse = GST_MPEG4VIDEO_PARSE (parse);
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_CUSTOM_DOWNSTREAM:
+    {
+      GstClockTime timestamp, stream_time, running_time;
+      gboolean all_headers;
+      guint count;
+
+      if (!gst_video_event_is_force_key_unit (event))
+        break;
+
+      gst_video_event_parse_downstream_force_key_unit (event,
+          &timestamp, &stream_time, &running_time, &all_headers, &count);
+
+      GST_INFO_OBJECT (mp4vparse, "received downstream force key unit event, "
+          "seqnum %d running_time %" GST_TIME_FORMAT " all_headers %d count %d",
+          gst_event_get_seqnum (event), GST_TIME_ARGS (running_time),
+          all_headers, count);
+      handled = TRUE;
+
+      if (mp4vparse->force_key_unit_event) {
+        GST_INFO_OBJECT (mp4vparse, "ignoring force key unit event "
+            "as one is already queued");
+        break;
+      }
+
+      mp4vparse->pending_key_unit_ts = running_time;
+      gst_event_replace (&mp4vparse->force_key_unit_event, event);
+      break;
+    }
+    default:
+      break;
+  }
+
+  return handled;
+}
+
+static gboolean
+gst_mpeg4vparse_src_event (GstBaseParse * parse, GstEvent * event)
+{
+  gboolean handled = FALSE;
+  GstMpeg4VParse *mp4vparse = GST_MPEG4VIDEO_PARSE (parse);
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_CUSTOM_UPSTREAM:
+    {
+      GstClockTime running_time;
+      gboolean all_headers;
+      guint count;
+
+      if (!gst_video_event_is_force_key_unit (event))
+        break;
+
+      gst_video_event_parse_upstream_force_key_unit (event,
+          &running_time, &all_headers, &count);
+
+      GST_INFO_OBJECT (mp4vparse, "received upstream force-key-unit event, "
+          "seqnum %d running_time %" GST_TIME_FORMAT " all_headers %d count %d",
+          gst_event_get_seqnum (event), GST_TIME_ARGS (running_time),
+          all_headers, count);
+
+      if (!all_headers)
+        break;
+
+      mp4vparse->pending_key_unit_ts = running_time;
+      gst_event_replace (&mp4vparse->force_key_unit_event, event);
+      /* leave handled = FALSE so that the event gets propagated upstream */
+      break;
+    }
+    default:
+      break;
+  }
+
+  return handled;
+}
diff --git a/gst/videoparsers/gstmpeg4videoparse.h b/gst/videoparsers/gstmpeg4videoparse.h
index 3036853..75d7d6c 100644
--- a/gst/videoparsers/gstmpeg4videoparse.h
+++ b/gst/videoparsers/gstmpeg4videoparse.h
@@ -63,6 +63,8 @@ struct _GstMpeg4VParse {
   /* properties */
   gboolean drop;
   guint interval;
+  GstClockTime pending_key_unit_ts;
+  GstEvent *force_key_unit_event;
 };
 
 struct _GstMpeg4VParseClass {
diff --git a/gst/videoparsers/gstmpegvideoparse.c b/gst/videoparsers/gstmpegvideoparse.c
index 4486cf7..352f5b5 100644
--- a/gst/videoparsers/gstmpegvideoparse.c
+++ b/gst/videoparsers/gstmpegvideoparse.c
@@ -86,8 +86,7 @@ gst_mpegv_parse_base_init (gpointer klass)
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 
   gst_element_class_add_static_pad_template (element_class, &src_template);
-  gst_element_class_add_static_pad_template (element_class,
-      &sink_template);
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
 
   gst_element_class_set_details_simple (element_class,
       "MPEG video elementary stream parser",
@@ -233,11 +232,26 @@ gst_mpegv_parse_process_config (GstMpegvParse * mpvparse, GstBuffer * buf,
 {
   GList *tmp;
   guint8 *data = GST_BUFFER_DATA (buf);
+  guint8 *data_with_prefix;
+
   data = data + mpvparse->seq_offset;
 
-  /* only do stuff if something new */
+  if (mpvparse->seq_offset < 4) {
+    /* This shouldn't happen, but just in case... */
+    GST_WARNING_OBJECT (mpvparse, "Sequence header start code missing.");
+    return FALSE;
+  }
+
+  /* pointer to sequence header data including the start code prefix -
+     used for codec private data */
+  data_with_prefix = data - 4;
+
+  /* only do stuff if something new; only compare first 11 bytes, changes in
+     quantiser matrix doesn't matter here. Also changing the matrices in
+     codec_data seems to cause problem with decoders */
   if (mpvparse->config && size == GST_BUFFER_SIZE (mpvparse->config) &&
-      memcmp (GST_BUFFER_DATA (mpvparse->config), data, size) == 0)
+      memcmp (GST_BUFFER_DATA (mpvparse->config), data_with_prefix, MIN (size,
+              11)) == 0)
     return TRUE;
 
   if (gst_mpeg_video_parse_sequence_header (&mpvparse->sequencehdr, data,
@@ -271,7 +285,7 @@ gst_mpegv_parse_process_config (GstMpegvParse * mpvparse, GstBuffer * buf,
                 tpoffsz->offset)) {
           mpvparse->fps_num =
               mpvparse->sequencehdr.fps_n * (mpvparse->sequenceext.fps_n_ext +
-              1) * 2;
+              1);
           mpvparse->fps_den =
               mpvparse->sequencehdr.fps_d * (mpvparse->sequenceext.fps_d_ext +
               1);
@@ -285,7 +299,7 @@ gst_mpegv_parse_process_config (GstMpegvParse * mpvparse, GstBuffer * buf,
     gst_buffer_unref (mpvparse->config);
 
   mpvparse->config = gst_buffer_new_and_alloc (size);
-  memcpy (GST_BUFFER_DATA (mpvparse->config), data, size);
+  memcpy (GST_BUFFER_DATA (mpvparse->config), data_with_prefix, size);
 
   /* trigger src caps update */
   mpvparse->update_caps = TRUE;
@@ -514,9 +528,6 @@ gst_mpegv_parse_check_valid_frame (GstBaseParse * parse,
 
     GST_LOG_OBJECT (mpvparse, "next start code at %d", codoffsz->offset);
 
-    if (codoffsz->size < 0)
-      break;
-
     ret = gst_mpegv_parse_process_sc (mpvparse, buf, codoffsz->offset,
         codoffsz->type);
 
@@ -531,15 +542,14 @@ end:
   if (fsize > 0) {
     *framesize = fsize;
     ret = TRUE;
+    mpvparse->last_sc = -1;
   } else if (GST_BASE_PARSE_DRAINING (parse)) {
     *framesize = GST_BUFFER_SIZE (buf);
     ret = TRUE;
 
   } else {
     /* resume scan where we left it */
-    if (!mpvparse->last_sc)
-      *skipsize = mpvparse->last_sc = GST_BUFFER_SIZE (buf) - 3;
-    else if (mpvparse->typeoffsize)
+    if (mpvparse->typeoffsize)
       mpvparse->last_sc = GST_BUFFER_SIZE (buf) - 3;
     else
       *skipsize = 0;
@@ -624,18 +634,19 @@ gst_mpegv_parse_update_src_caps (GstMpegvParse * mpvparse)
      *                      3 => SNR Scalable, 4 => Main, 5 => Simple
      * 4:2:2 and Multi-view have profile = 0, with the escape bit set to 1
      */
-    const gchar *profiles[] = { "high", "spatial", "snr", "main", "simple" };
+    const gchar *const profiles[] =
+        { "high", "spatial", "snr", "main", "simple" };
     /*
      * Level indication - 4 => High, 6 => High-1440, 8 => Main, 10 => Low,
      *                    except in the case of profile = 0
      */
-    const gchar *levels[] = { "high", "high-1440", "main", "low" };
+    const gchar *const levels[] = { "high", "high-1440", "main", "low" };
 
     if (profile_c > 0 && profile_c < 6)
       profile = profiles[profile_c - 1];
 
     if ((level_c > 3) && (level_c < 11) && (level_c % 2 == 0))
-      level = levels[(level_c >> 1) - 1];
+      level = levels[(level_c >> 1) - 2];
 
     if (profile_c == 8) {
       /* Non-hierarchical profile */
@@ -663,6 +674,8 @@ gst_mpegv_parse_update_src_caps (GstMpegvParse * mpvparse)
 
     /* FIXME does it make sense to expose profile/level in the caps ? */
 
+    GST_DEBUG_OBJECT (mpvparse, "profile:'%s' level:'%s'", profile, level);
+
     if (profile)
       gst_caps_set_simple (caps, "profile", G_TYPE_STRING, profile, NULL);
     else
@@ -702,8 +715,10 @@ gst_mpegv_parse_parse_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
     GST_BUFFER_DURATION (buffer) = 0;
   }
 
-  GST_BUFFER_DURATION (buffer) =
-      (1 + mpvparse->frame_repeat_count) * GST_BUFFER_DURATION (buffer);
+  if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_DURATION (buffer))) {
+    GST_BUFFER_DURATION (buffer) =
+        (1 + mpvparse->frame_repeat_count) * GST_BUFFER_DURATION (buffer) / 2;
+  }
 
   if (G_UNLIKELY (mpvparse->drop && !mpvparse->config)) {
     GST_DEBUG_OBJECT (mpvparse, "dropping frame as no config yet");
diff --git a/sys/Makefile.am b/sys/Makefile.am
index a48b0d2..879f5f0 100644
--- a/sys/Makefile.am
+++ b/sys/Makefile.am
@@ -1,19 +1,19 @@
-# if USE_DXR3
-# DXR3_DIR=dxr3
-# else
-# DXR3_DIR=
-# endif
+if USE_ACM
+ACM_DIR=acmenc acmmp3dec
+else
+ACM_DIR=
+endif
 
-# if USE_QCAM
-# QCAM_DIR=qcam
-# else
-# QCAM_DIR=
-# endif
+if USE_APPLE_MEDIA
+APPLE_MEDIA_DIR=applemedia
+else
+APPLE_MEDIA_DIR=
+endif
 
-if USE_VCD
-VCD_DIR=vcd
+if USE_AVC
+AVC_DIR=avc
 else
-VCD_DIR=
+AVC_DIR=
 endif
 
 # if USE_CDROM
@@ -58,25 +58,42 @@ else
 DVB_DIR=
 endif
 
+# if USE_DXR3
+# DXR3_DIR=dxr3
+# else
+# DXR3_DIR=
+# endif
+
 if USE_LINSYS
 LINSYS_DIR=linsys
 else
 LINSYS_DIR=
 endif
 
+if USE_OSX_VIDEO
+OSX_VIDEO_DIR=osxvideo
+else
+OSX_VIDEO_DIR=
+endif
 
-if USE_APPLE_MEDIA
-APPLE_MEDIA_DIR=applemedia
+if USE_PVR
+PVR_DIR=pvr2d
 else
-APPLE_MEDIA_DIR=
+PVR_DIR=
 endif
 
-if USE_OSX_VIDEO
-OSX_VIDEO_DIR=osxvideo
+if USE_SHM
+SHM_DIR=shm
 else
-OSX_VIDEO_DIR=
+SHM_DIR=
 endif
 
+# if USE_QCAM
+# QCAM_DIR=qcam
+# else
+# QCAM_DIR=
+# endif
+
 if USE_QUICKTIME
 QT_DIR=qtwrapper
 else
@@ -89,10 +106,10 @@ else
 WININET_DIR=
 endif
 
-if USE_ACM
-ACM_DIR=acmenc acmmp3dec
+if USE_VCD
+VCD_DIR=vcd
 else
-ACM_DIR=
+VCD_DIR=
 endif
 
 if USE_VDPAU
@@ -101,28 +118,15 @@ else
 VDPAU_DIR=
 endif
 
-
-if USE_SHM
-SHM_DIR=shm
+if USE_DIRECT3D9
+WINSCREENCAP_DIR=winscreencap
 else
-SHM_DIR=
-endif
-
-if USE_AVC
-AVC_DIR=avc
-else
-AVC_DIR=
-endif
-
-if USE_PVR
-PVR_DIR=pvr2d
-else
-PVR_DIR=
+WINSCREENCAP_DIR=
 endif
 
-SUBDIRS = $(ACM_DIR) $(APPLE_MEDIA_DIR) $(AVC_DIR) $(D3DVIDEOSINK_DIR) $(DECKLINK_DIR) $(DIRECTDRAW_DIR) $(DIRECTSOUND_DIR) $(DVB_DIR) $(FBDEV_DIR) $(LINSYS_DIR) $(OSX_VIDEO_DIR) $(QT_DIR) $(SHM_DIR) $(VCD_DIR) $(VDPAU_DIR) $(WININET_DIR) $(PVR_DIR)
+SUBDIRS = $(ACM_DIR) $(APPLE_MEDIA_DIR) $(AVC_DIR) $(D3DVIDEOSINK_DIR) $(DECKLINK_DIR) $(DIRECTDRAW_DIR) $(DIRECTSOUND_DIR) $(DVB_DIR) $(FBDEV_DIR) $(LINSYS_DIR) $(OSX_VIDEO_DIR) $(PVR_DIR) $(QT_DIR) $(SHM_DIR) $(VCD_DIR) $(VDPAU_DIR) $(WININET_DIR) $(WINSCREENCAP_DIR)
 
 DIST_SUBDIRS = acmenc acmmp3dec applemedia avc d3dvideosink decklink directdraw directsound dvb linsys fbdev dshowdecwrapper dshowsrcwrapper dshowvideosink \
-		osxvideo qtwrapper shm vcd vdpau wasapi wininet winks winscreencap pvr2d
+		osxvideo pvr2d qtwrapper shm vcd vdpau wasapi wininet winks winscreencap
 
 include $(top_srcdir)/common/parallel-subdirs.mak
diff --git a/sys/d3dvideosink/Makefile.am b/sys/d3dvideosink/Makefile.am
index 183e460..76b7920 100644
--- a/sys/d3dvideosink/Makefile.am
+++ b/sys/d3dvideosink/Makefile.am
@@ -4,11 +4,11 @@ libgstd3dvideosink_la_SOURCES = d3dvideosink.c directx/d3d.c directx/dx.c \
 	directx/directx9/dx9.c directx/directx9/dx9_d3d.c \
 	directx/directx10/dx10.c directx/directx10/dx10_d3d.c \
 	directx/directx11/dx11.c directx/directx11/dx11_d3d.c
-libgstd3dvideosink_la_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_CFLAGS)
+libgstd3dvideosink_la_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_CFLAGS) $(DIRECTX_CFLAGS)
 libgstd3dvideosink_la_LIBADD = $(GST_BASE_LIBS) $(GST_PLUGINS_BASE_LIBS) \
 	-lgstvideo-$(GST_MAJORMINOR) -lgstinterfaces-$(GST_MAJORMINOR) \
 	$(DIRECT3D_LIBS)
-libgstd3dvideosink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstd3dvideosink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS) $(DIRECTX_LDFAGS)
 libgstd3dvideosink_la_LIBTOOLFLAGS = --tag=disable-static
 
 noinst_HEADERS = d3dvideosink.h directx/d3d.h directx/dx.h directx/directx.h \
diff --git a/sys/d3dvideosink/d3dvideosink.c b/sys/d3dvideosink/d3dvideosink.c
index ed4d249..eef480a 100644
--- a/sys/d3dvideosink/d3dvideosink.c
+++ b/sys/d3dvideosink/d3dvideosink.c
@@ -30,28 +30,20 @@
 /* Provide access to data that will be shared among all instantiations of this element */
 #define GST_D3DVIDEOSINK_SHARED_D3D_LOCK	       g_static_mutex_lock (&shared_d3d_lock);
 #define GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK       g_static_mutex_unlock (&shared_d3d_lock);
-#define GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK	   g_static_mutex_lock (&shared_d3d_dev_lock);
-#define GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK   g_static_mutex_unlock (&shared_d3d_dev_lock);
 #define GST_D3DVIDEOSINK_SHARED_D3D_HOOK_LOCK	   g_static_mutex_lock (&shared_d3d_hook_lock);
 #define GST_D3DVIDEOSINK_SHARED_D3D_HOOK_UNLOCK  g_static_mutex_unlock (&shared_d3d_hook_lock);
 typedef struct _GstD3DVideoSinkShared GstD3DVideoSinkShared;
 struct _GstD3DVideoSinkShared
 {
   LPDIRECT3D9 d3d;
-  LPDIRECT3DDEVICE9 d3ddev;
   D3DCAPS9 d3dcaps;
-  D3DFORMAT d3ddmformat;
-  D3DFORMAT d3dformat;
-  D3DFORMAT d3dfourcc;
-  D3DFORMAT d3dstencilformat;
-  D3DTEXTUREFILTERTYPE d3dfiltertype;
-  gboolean d3dEnableAutoDepthStencil;
 
   GList *element_list;
   gint32 element_count;
 
   gboolean device_lost;
   UINT_PTR device_lost_timer;
+  GstD3DVideoSink *device_lost_sink;
 
   HWND hidden_window_handle;
   HANDLE hidden_window_created_signal;
@@ -71,7 +63,6 @@ struct _GstD3DVideoSinkHookData
 static GstD3DVideoSinkShared shared;
 /* Define a shared lock to synchronize the creation/destruction of the d3d device */
 static GStaticMutex shared_d3d_lock = G_STATIC_MUTEX_INIT;
-static GStaticMutex shared_d3d_dev_lock = G_STATIC_MUTEX_INIT;
 static GStaticMutex shared_d3d_hook_lock = G_STATIC_MUTEX_INIT;
 /* Hold a reference to our dll's HINSTANCE */
 static HINSTANCE g_hinstDll = NULL;
@@ -89,12 +80,11 @@ struct _IPCData
 GST_DEBUG_CATEGORY (d3dvideosink_debug);
 #define GST_CAT_DEFAULT d3dvideosink_debug
 
-/* TODO: Support RGB! */
 static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("{ YUY2, UYVY, YV12, I420 }"))
-    //";" GST_VIDEO_CAPS_RGBx)
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("{ YUY2, UYVY, YV12, I420, NV12 }")
+        ";" GST_VIDEO_CAPS_BGRx ";" GST_VIDEO_CAPS_BGRA)
     );
 
 static void gst_d3dvideosink_init_interfaces (GType type);
@@ -164,13 +154,12 @@ static void gst_d3dvideosink_remove_window_for_renderer (GstD3DVideoSink *
     sink);
 static gboolean gst_d3dvideosink_initialize_direct3d (GstD3DVideoSink * sink);
 static gboolean gst_d3dvideosink_initialize_d3d_device (GstD3DVideoSink * sink);
-static gboolean gst_d3dvideosink_initialize_swap_chain (GstD3DVideoSink * sink);
-static gboolean gst_d3dvideosink_resize_swap_chain (GstD3DVideoSink * sink,
-    gint width, gint height);
+
+static gboolean gst_d3dvideosink_notify_device_init (GstD3DVideoSink * sink);
 static gboolean gst_d3dvideosink_notify_device_lost (GstD3DVideoSink * sink);
 static gboolean gst_d3dvideosink_notify_device_reset (GstD3DVideoSink * sink);
+static gboolean gst_d3dvideosink_notify_device_reinit (GstD3DVideoSink * sink);
 static gboolean gst_d3dvideosink_device_lost (GstD3DVideoSink * sink);
-static gboolean gst_d3dvideosink_release_swap_chain (GstD3DVideoSink * sink);
 static gboolean gst_d3dvideosink_release_d3d_device (GstD3DVideoSink * sink);
 static gboolean gst_d3dvideosink_release_direct3d (GstD3DVideoSink * sink);
 static gboolean gst_d3dvideosink_window_size (GstD3DVideoSink * sink,
@@ -178,6 +167,7 @@ static gboolean gst_d3dvideosink_window_size (GstD3DVideoSink * sink,
 static gboolean gst_d3dvideosink_direct3d_supported (GstD3DVideoSink * sink);
 static gboolean gst_d3dvideosink_shared_hidden_window_thread (GstD3DVideoSink *
     sink);
+static void gst_d3dvideosink_flush_gpu (GstD3DVideoSink * sink);
 static void gst_d3dvideosink_hook_window_for_renderer (GstD3DVideoSink * sink);
 static void gst_d3dvideosink_unhook_window_for_renderer (GstD3DVideoSink *
     sink);
@@ -188,7 +178,7 @@ static void gst_d3dvideosink_log_warning (const gchar * file,
     const gchar * function, gint line, const gchar * format, va_list args);
 static void gst_d3dvideosink_log_error (const gchar * file,
     const gchar * function, gint line, const gchar * format, va_list args);
-
+static void gst_d3dvideosink_set_window_for_renderer (GstD3DVideoSink * sink);
 static DirectXInitParams directx_init_params = {
   gst_d3dvideosink_log_debug, gst_d3dvideosink_log_warning,
   gst_d3dvideosink_log_error
@@ -278,8 +268,7 @@ gst_d3dvideosink_base_init (gpointer klass)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 
-  gst_element_class_add_static_pad_template (element_class,
-      &sink_template);
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
 
   gst_element_class_set_details_simple (element_class, "Direct3D video sink",
       "Sink/Video",
@@ -455,9 +444,54 @@ static GstCaps *
 gst_d3dvideosink_get_caps (GstBaseSink * basesink)
 {
   GstD3DVideoSink *sink = GST_D3DVIDEOSINK (basesink);
+  GstCaps *caps = gst_caps_new_empty ();
+  const GstCaps *tempCaps =
+      gst_pad_get_pad_template_caps (GST_VIDEO_SINK_PAD (sink));
 
-  return
-      gst_caps_copy (gst_pad_get_pad_template_caps (GST_VIDEO_SINK_PAD (sink)));
+  /* restrict caps based on the hw capabilities */
+  if (shared.d3d) {
+    D3DDISPLAYMODE d3ddm;
+    if (FAILED (IDirect3D9_GetAdapterDisplayMode (shared.d3d,
+                D3DADAPTER_DEFAULT, &d3ddm))) {
+      GST_WARNING ("Unable to request adapter display mode");
+      gst_caps_unref (caps);
+      caps = gst_caps_copy (tempCaps);
+    } else {
+      gint i;
+      GstCaps *c = gst_caps_normalize (tempCaps);
+
+      for (i = 0; i < gst_caps_get_size (c); i++) {
+        D3DFORMAT d3dfourcc = 0;
+        GstStructure *stru = gst_caps_get_structure (c, i);
+        if (!gst_structure_has_name (stru, "video/x-raw-rgb")) {
+          gst_structure_get_fourcc (stru, "format", (guint32 *) & d3dfourcc);
+          switch ((guint32) d3dfourcc) {
+            case GST_MAKE_FOURCC ('Y', 'V', '1', '2'):
+            case GST_MAKE_FOURCC ('I', '4', '2', '0'):
+              d3dfourcc = (D3DFORMAT) MAKEFOURCC ('Y', 'V', '1', '2');
+              break;
+            default:
+              break;
+          }
+          if (d3dfourcc && SUCCEEDED (IDirect3D9_CheckDeviceFormat (shared.d3d,
+                      D3DADAPTER_DEFAULT,
+                      D3DDEVTYPE_HAL,
+                      d3ddm.Format, 0, D3DRTYPE_SURFACE, d3dfourcc))) {
+            /* hw supports this format */
+            gst_caps_append (caps, gst_caps_copy_nth (c, i));
+          }
+        } else {
+          /* rgb formats */
+          gst_caps_append (caps, gst_caps_copy_nth (c, i));
+        }
+      }
+      gst_caps_unref (c);
+    }
+  } else {
+    gst_caps_unref (caps);
+    caps = gst_caps_copy (tempCaps);
+  }
+  return caps;
 }
 
 static void
@@ -495,9 +529,6 @@ gst_d3dvideosink_create_shared_hidden_window (GstD3DVideoSink * sink)
 
   CloseHandle (shared.hidden_window_created_signal);
 
-  if (!shared.d3ddev)
-     goto failed;
-
   GST_DEBUG ("Successfully created Direct3D hidden window, handle: %p",
       shared.hidden_window_handle);
 
@@ -548,10 +579,6 @@ gst_d3dvideosink_shared_hidden_window_thread (GstD3DVideoSink * sink)
   shared.hidden_window_handle = hWnd;
   shared.device_lost_timer = 0;
 
-  GST_DEBUG ("Initializing Direct3D");
-  SendMessage (shared.hidden_window_handle, WM_DIRECTX_D3D_INIT_DEVICE, 0, 0);
-  GST_DEBUG ("Direct3D initialization complete");
-
   gst_d3dvideosink_shared_hidden_window_created (sink);
 
   GST_DEBUG ("Entering Direct3D hidden window message loop");
@@ -598,36 +625,34 @@ SharedHiddenWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
 {
   GstD3DVideoSink *sink;
 
-  if (message == WM_CREATE) {
-    /* lParam holds a pointer to a CREATESTRUCT instance which in turn holds the parameter used when creating the window. */
-    sink = (GstD3DVideoSink *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
-
-    /* In our case, this is a pointer to the sink. So we immediately attach it for use in subsequent calls. */
-    SetWindowLongPtr (hWnd, GWLP_USERDATA, (LONG_PTR) sink);
-  }
-
-  sink = (GstD3DVideoSink *) GetWindowLongPtr (hWnd, GWLP_USERDATA);
+  /* lParam holds pointer to the sink. */
 
+  sink = (GstD3DVideoSink *) lParam;
   switch (message) {
     case WM_DIRECTX_D3D_INIT_DEVICE:
     {
+      shared.device_lost_sink = NULL;
+      GST_DEBUG ("Initializing Direct3D");
+      GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
       gst_d3dvideosink_initialize_d3d_device (sink);
+      GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
+      GST_DEBUG ("Direct3D initialization complete");
       break;
+
     }
     case WM_DIRECTX_D3D_INIT_DEVICELOST:
     {
       if (!shared.device_lost) {
-        //GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK
-        //GST_D3DVIDEOSINK_SHARED_D3D_LOCK
 
         shared.device_lost = TRUE;
+        shared.device_lost_sink = sink;
 
         /* Handle device lost by creating a timer and posting WM_D3D_DEVICELOST twice a second */
         /* Create a timer to periodically check the d3d device and attempt to recreate it */
         shared.device_lost_timer = SetTimer (hWnd, IDT_DEVICELOST, 500, NULL);
 
         /* Try it once immediately */
-        SendMessage (hWnd, WM_DIRECTX_D3D_DEVICELOST, 0, 0);
+        SendMessage (hWnd, WM_DIRECTX_D3D_DEVICELOST, 0, (LPARAM) sink);
       }
       break;
     }
@@ -635,16 +660,18 @@ SharedHiddenWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
     {
       /* Did we receive a message to check if the device is available again? */
       if (wParam == IDT_DEVICELOST) {
+        GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
         /* This will synchronously call SharedHiddenWndProc() because this thread is the one that created the window. */
-        SendMessage (hWnd, WM_DIRECTX_D3D_DEVICELOST, 0, 0);
+        SendMessage (hWnd, WM_DIRECTX_D3D_DEVICELOST, 0,
+            (LPARAM) shared.device_lost_sink);
+        GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
         return 0;
       }
       break;
     }
     case WM_DIRECTX_D3D_DEVICELOST:
     {
-      gst_d3dvideosink_device_lost (sink);
-      break;
+      return gst_d3dvideosink_device_lost (sink);
     }
     case WM_DIRECTX_D3D_END_DEVICELOST:
     {
@@ -662,9 +689,8 @@ SharedHiddenWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
         /* Then redraw just in case we don't have a last buffer */
         gst_d3dvideosink_refresh_all (sink);
 
-        //GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK
-        //GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK
       }
+      shared.device_lost_sink = NULL;
       break;
     }
     case WM_DESTROY:
@@ -672,6 +698,10 @@ SharedHiddenWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
       PostQuitMessage (0);
       return 0;
     }
+    case WM_DIRECTX_D3D_RESIZE:
+    {
+      return gst_d3dvideosink_device_lost (sink);
+    }
   }
 
   return DefWindowProc (hWnd, message, wParam, lParam);
@@ -704,6 +734,9 @@ WndProcHook (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
   GstD3DVideoSink *sink =
       (GstD3DVideoSink *) GetProp (hWnd, TEXT ("GstD3DVideoSink"));
 
+  if (!sink)
+    return FALSE;
+
   switch (message) {
     case WM_ERASEBKGND:
       return TRUE;
@@ -770,6 +803,8 @@ static void
 gst_d3dvideosink_wnd_proc (GstD3DVideoSink * sink, HWND hWnd, UINT message,
     WPARAM wParam, LPARAM lParam)
 {
+  if (!sink)
+    return;
   switch (message) {
     case WM_COPYDATA:
     {
@@ -797,17 +832,6 @@ gst_d3dvideosink_wnd_proc (GstD3DVideoSink * sink, HWND hWnd, UINT message,
       gst_d3dvideosink_refresh (sink);
       break;
     }
-    case WM_SIZE:
-    case WM_DIRECTX_D3D_RESIZE:
-    {
-      gint width;
-      gint height;
-      gst_d3dvideosink_window_size (sink, &width, &height);
-      gst_d3dvideosink_resize_swap_chain (sink, width, height);
-      gst_d3dvideosink_refresh (sink);
-      //gst_d3dvideosink_resize_swap_chain(sink, MAX(1, ABS(LOWORD(lParam))), MAX(1, ABS(HIWORD(lParam))));
-      break;
-    }
     case WM_CLOSE:
     case WM_DESTROY:
     {
@@ -1046,32 +1070,33 @@ gst_d3dvideosink_set_window_handle (GstXOverlay * overlay, guintptr window_id)
     return;
   }
 
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
-  {
-    /* If we're already playing/paused, then we need to lock the swap chain, and recreate it with the new window. */
-    gboolean init_swap_chain = sink->d3d_swap_chain != NULL;
-
-    gst_d3dvideosink_release_swap_chain (sink);
-
+  /* If we're already playing/paused, then we need to lock the swap chain, and recreate it with the new window. */
+  if (sink->d3ddev != NULL) {
+    GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
     /* Close our existing window if there is one */
     gst_d3dvideosink_close_window (sink);
-
     /* Save our window id */
     sink->window_handle = hWnd;
+    gst_d3dvideosink_set_window_for_renderer (sink);
+    sink->window_closed = FALSE;
 
-    if (init_swap_chain)
-      gst_d3dvideosink_initialize_swap_chain (sink);
+    gst_d3dvideosink_notify_device_reinit (sink);
+    GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
+    //gst_d3dvideosink_notify_device_init(sink);
+
+  } else {
+    sink->window_handle = hWnd;
   }
 
 /*success:*/
-  GST_DEBUG ("Direct3D window id successfully changed for sink %p to %p", sink,
+  GST_DEBUG_OBJECT (sink, "Direct3D window id successfully changed to %p",
       hWnd);
-  GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return;
+
+  gst_d3dvideosink_update (GST_BASE_SINK_CAST (sink));
+  return;
 /*error:*/
 /*  GST_DEBUG("Error attempting to change the window id for sink %d to %d", sink, hWnd); */
 /*  GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK(sink);                                            */
-/*  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK                                               */
 /*  return;                                                                              */
 }
 
@@ -1279,12 +1304,13 @@ gst_d3dvideosink_unhook_all_windows (void)
 {
   /* Unhook all windows that may be currently hooked. This is mainly a precaution in case     */
   /* a wayward process doesn't properly set state back to NULL (which would remove the hook). */
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK
-      GST_D3DVIDEOSINK_SHARED_D3D_LOCK GST_D3DVIDEOSINK_SHARED_D3D_HOOK_LOCK {
+
+  GST_D3DVIDEOSINK_SHARED_D3D_LOCK GST_D3DVIDEOSINK_SHARED_D3D_HOOK_LOCK
+  {
     GList *item;
     GstD3DVideoSink *s;
 
-    GST_DEBUG ("Attempting to unhook all windows for process %lu",
+      GST_DEBUG ("Attempting to unhook all windows for process %lu",
         GetCurrentProcessId ());
 
     for (item = g_list_first (shared.element_list); item; item = item->next) {
@@ -1292,15 +1318,11 @@ gst_d3dvideosink_unhook_all_windows (void)
       gst_d3dvideosink_unhook_window_for_renderer (s);
     }
   }
-GST_D3DVIDEOSINK_SHARED_D3D_HOOK_UNLOCK
-      GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK}
+GST_D3DVIDEOSINK_SHARED_D3D_HOOK_UNLOCK GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK}
 
 static void
 gst_d3dvideosink_remove_window_for_renderer (GstD3DVideoSink * sink)
 {
-  //GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK
-  //GST_D3DVIDEOSINK_SHARED_D3D_LOCK
-  //GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK(sink);
   {
     GST_DEBUG ("Removing custom rendering window procedure");
     if (!sink->is_new_window && sink->window_handle) {
@@ -1327,9 +1349,6 @@ gst_d3dvideosink_remove_window_for_renderer (GstD3DVideoSink * sink)
         /* Remove the property associating our sink with the window */
         RemoveProp (sink->window_handle, TEXT ("GstD3DVideoSink"));
   }
-  //GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK(sink);
-  //GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK
-  //GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK
 }
 
 static void
@@ -1347,8 +1366,7 @@ gst_d3dvideosink_prepare_window (GstD3DVideoSink * sink)
   } else {
     gst_d3dvideosink_create_default_window (sink);
   }
-
-  gst_d3dvideosink_initialize_swap_chain (sink);
+  gst_d3dvideosink_notify_device_init (sink);
 }
 
 static GstStateChangeReturn
@@ -1360,7 +1378,7 @@ gst_d3dvideosink_change_state (GstElement * element, GstStateChange transition)
   switch (transition) {
     case GST_STATE_CHANGE_NULL_TO_READY:
       if (!gst_d3dvideosink_initialize_direct3d (sink))
-        return GST_STATE_CHANGE_FAILURE; 
+        return GST_STATE_CHANGE_FAILURE;
       break;
     case GST_STATE_CHANGE_READY_TO_PAUSED:
       break;
@@ -1538,202 +1556,222 @@ gst_d3dvideosink_stop (GstBaseSink * bsink)
 {
   GstD3DVideoSink *sink = GST_D3DVIDEOSINK (bsink);
   gst_d3dvideosink_close_window (sink);
-  gst_d3dvideosink_release_swap_chain (sink);
   return TRUE;
 }
 
+static void
+gst_d3dvideosink_flush_gpu (GstD3DVideoSink * sink)
+{
+  LPDIRECT3DQUERY9 pEventQuery = NULL;
+
+  IDirect3DDevice9_CreateQuery (sink->d3ddev, D3DQUERYTYPE_EVENT, &pEventQuery);
+  if (pEventQuery) {
+    IDirect3DQuery9_Issue (pEventQuery, D3DISSUE_END);
+    /* Empty the command buffer and wait until the GPU is idle. */
+    while (S_FALSE == IDirect3DQuery9_GetData (pEventQuery, NULL, 0,
+            D3DGETDATA_FLUSH));
+    IDirect3DQuery9_Release (pEventQuery);
+  }
+}
+
+static G_GNUC_UNUSED void
+gst_d3dvideosink_wait_for_vsync (GstD3DVideoSink * sink)
+{
+  if (sink->d3dpp.PresentationInterval == D3DPRESENT_INTERVAL_IMMEDIATE) {
+    D3DRASTER_STATUS raster_stat;
+    D3DDISPLAYMODE d3ddm;
+    UINT lastScanline = 0;
+    UINT vblankStart = 0;
+    HANDLE thdl = GetCurrentThread ();
+    int prio = GetThreadPriority (thdl);
+    ZeroMemory (&d3ddm, sizeof (d3ddm));
+
+    IDirect3DDevice9_GetDisplayMode (sink->d3ddev, 0, &d3ddm);
+    vblankStart = d3ddm.Height - 10;
+    SetThreadPriority (thdl, THREAD_PRIORITY_TIME_CRITICAL);
+    do {
+      if (FAILED (IDirect3DDevice9_GetRasterStatus (sink->d3ddev, 0,
+                  &raster_stat))) {
+        GST_ERROR_OBJECT (sink, "GetRasterStatus failed");
+      }
+      break;
+      if (!raster_stat.InVBlank) {
+        if (raster_stat.ScanLine < lastScanline) {
+          GST_INFO_OBJECT (sink, "missed last vsync curr : %d",
+              raster_stat.ScanLine);
+          break;
+        }
+        lastScanline = raster_stat.ScanLine;
+        SwitchToThread ();
+      }
+    } while (raster_stat.ScanLine < vblankStart);
+    SetThreadPriority (thdl, prio);
+  }
+}
+
 static GstFlowReturn
 gst_d3dvideosink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
 {
   GstD3DVideoSink *sink = GST_D3DVIDEOSINK (vsink);
+  LPDIRECT3DSURFACE9 drawSurface = NULL;
 
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
-  {
-    HRESULT hr;
-    LPDIRECT3DSURFACE9 backBuffer;
-
-    if (!shared.d3ddev) {
-      if (!shared.device_lost) {
-        GST_WARNING ("No Direct3D device has been created, stopping");
-        goto error;
-      } else {
-        GST_WARNING
-            ("Direct3D device is lost. Maintaining flow until it has been reset.");
-        goto success;
-      }
-    }
-
-    if (!sink->d3d_offscreen_surface) {
-      GST_WARNING ("No Direct3D offscreen surface has been created, stopping");
-      goto error;
-    }
-
-    if (!sink->d3d_swap_chain) {
-      GST_WARNING ("No Direct3D swap chain has been created, stopping");
-      goto error;
-    }
-
-    if (sink->window_closed) {
-      GST_WARNING ("Window has been closed, stopping");
+  GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
+  if (!sink->d3ddev) {
+    if (!shared.device_lost) {
+      GST_ERROR_OBJECT (sink, "No Direct3D device has been created, stopping");
       goto error;
+    } else {
+      GST_WARNING_OBJECT (sink,
+          "Direct3D device is lost. Maintaining flow until it has been reset.");
+      goto success;
     }
+  }
 
-    if (sink->window_handle && !sink->is_new_window) {
-      if (shared.d3ddev) {
-        gint win_width = 0, win_height = 0;
-        D3DPRESENT_PARAMETERS d3dpp;
-
-        ZeroMemory (&d3dpp, sizeof (d3dpp));
-
-        if (gst_d3dvideosink_window_size (sink, &win_width, &win_height)) {
-          IDirect3DSwapChain9_GetPresentParameters (sink->d3d_swap_chain,
-              &d3dpp);
-          if ((d3dpp.BackBufferWidth > 0 && d3dpp.BackBufferHeight > 0
-                  && win_width != d3dpp.BackBufferWidth)
-              || win_height != d3dpp.BackBufferHeight)
-            gst_d3dvideosink_resize_swap_chain (sink, win_width, win_height);
-        }
-      }
-    }
-
-    /* Set the render target to our swap chain */
-    IDirect3DSwapChain9_GetBackBuffer (sink->d3d_swap_chain, 0,
-        D3DBACKBUFFER_TYPE_MONO, &backBuffer);
-    IDirect3DDevice9_SetRenderTarget (shared.d3ddev, 0, backBuffer);
-    IDirect3DSurface9_Release (backBuffer);
+  if (sink->window_closed) {
+    GST_ERROR_OBJECT (sink, "Window has been closed, stopping");
+    goto error;
+  }
 
-    /* Clear the target */
-    IDirect3DDevice9_Clear (shared.d3ddev, 0, NULL, D3DCLEAR_TARGET,
-        D3DCOLOR_XRGB (0, 0, 0), 1.0f, 0);
 
-    if (SUCCEEDED (IDirect3DDevice9_BeginScene (shared.d3ddev))) {
-      if (GST_BUFFER_DATA (buffer)) {
-        D3DLOCKED_RECT lr;
-        guint8 *dest, *source;
-        int srcstride, dststride, i;
-
-        IDirect3DSurface9_LockRect (sink->d3d_offscreen_surface, &lr, NULL, 0);
-        dest = (guint8 *) lr.pBits;
-        source = GST_BUFFER_DATA (buffer);
-
-        if (dest) {
-          if (gst_video_format_is_yuv (sink->format)) {
-            guint32 fourcc = gst_video_format_to_fourcc (sink->format);
-
-            switch (fourcc) {
-              case GST_MAKE_FOURCC ('Y', 'U', 'Y', '2'):
-              case GST_MAKE_FOURCC ('Y', 'U', 'Y', 'V'):
-              case GST_MAKE_FOURCC ('U', 'Y', 'V', 'Y'):
-                dststride = lr.Pitch;
-                srcstride = GST_BUFFER_SIZE (buffer) / sink->height;
-                for (i = 0; i < sink->height; ++i)
-                  memcpy (dest + dststride * i, source + srcstride * i,
-                      srcstride);
-                break;
-              case GST_MAKE_FOURCC ('I', '4', '2', '0'):
-              case GST_MAKE_FOURCC ('Y', 'V', '1', '2'):
-              {
-                int srcystride, srcvstride, srcustride;
-                int dstystride, dstvstride, dstustride;
-                int rows;
-                guint8 *srcv, *srcu, *dstv, *dstu;
-
-                rows = sink->height;
-
-                /* Source y, u and v strides */
-                srcystride = GST_ROUND_UP_4 (sink->width);
-                srcustride = GST_ROUND_UP_8 (sink->width) / 2;
-                srcvstride = GST_ROUND_UP_8 (srcystride) / 2;
-
-                /* Destination y, u and v strides */
-                dstystride = lr.Pitch;
-                dstustride = dstystride / 2;
-                dstvstride = dstustride;
-
-                srcu = source + srcystride * GST_ROUND_UP_2 (rows);
-                srcv = srcu + srcustride * GST_ROUND_UP_2 (rows) / 2;
-
-                if (fourcc == GST_MAKE_FOURCC ('I', '4', '2', '0')) {
-                  /* swap u and v planes */
-                  dstv = dest + dstystride * rows;
-                  dstu = dstv + dstustride * rows / 2;
-                } else {
-                  dstu = dest + dstystride * rows;
-                  dstv = dstu + dstustride * rows / 2;
-                }
+  drawSurface = sink->d3d_offscreen_surface;
+
+  if (SUCCEEDED (IDirect3DDevice9_BeginScene (sink->d3ddev))) {
+    if (GST_BUFFER_DATA (buffer)) {
+      D3DLOCKED_RECT lr;
+      guint8 *dest, *source;
+      int srcstride, dststride, i;
+
+      IDirect3DSurface9_LockRect (drawSurface, &lr, NULL, 0);
+      dest = (guint8 *) lr.pBits;
+      source = GST_BUFFER_DATA (buffer);
+
+      if (dest) {
+        if (gst_video_format_is_yuv (sink->format)) {
+          guint32 fourcc = gst_video_format_to_fourcc (sink->format);
+
+          switch (fourcc) {
+            case GST_MAKE_FOURCC ('Y', 'U', 'Y', '2'):
+            case GST_MAKE_FOURCC ('Y', 'U', 'Y', 'V'):
+            case GST_MAKE_FOURCC ('U', 'Y', 'V', 'Y'):
+              dststride = lr.Pitch;
+              srcstride = GST_BUFFER_SIZE (buffer) / sink->height;
+              for (i = 0; i < sink->height; ++i)
+                memcpy (dest + dststride * i, source + srcstride * i,
+                    srcstride);
+              break;
+            case GST_MAKE_FOURCC ('I', '4', '2', '0'):
+            case GST_MAKE_FOURCC ('Y', 'V', '1', '2'):
+            {
+              int srcystride, srcvstride, srcustride;
+              int dstystride, dstvstride, dstustride;
+              int rows;
+              guint8 *srcv, *srcu, *dstv, *dstu;
+
+              rows = sink->height;
+
+              /* Source y, u and v strides */
+              srcystride = GST_ROUND_UP_4 (sink->width);
+              srcustride = GST_ROUND_UP_8 (sink->width) / 2;
+              srcvstride = GST_ROUND_UP_8 (srcystride) / 2;
+
+              /* Destination y, u and v strides */
+              dstystride = lr.Pitch;
+              dstustride = dstystride / 2;
+              dstvstride = dstustride;
+
+              srcu = source + srcystride * GST_ROUND_UP_2 (rows);
+              srcv = srcu + srcustride * GST_ROUND_UP_2 (rows) / 2;
+
+              if (fourcc == GST_MAKE_FOURCC ('I', '4', '2', '0')) {
+                /* swap u and v planes */
+                dstv = dest + dstystride * rows;
+                dstu = dstv + dstustride * rows / 2;
+              } else {
+                dstu = dest + dstystride * rows;
+                dstv = dstu + dstustride * rows / 2;
+              }
 
-                for (i = 0; i < rows; ++i) {
-                  /* Copy the y plane */
-                  memcpy (dest + dstystride * i, source + srcystride * i,
-                      srcystride);
-                }
+              for (i = 0; i < rows; ++i) {
+                /* Copy the y plane */
+                memcpy (dest + dstystride * i, source + srcystride * i,
+                    srcystride);
+              }
 
-                for (i = 0; i < rows / 2; ++i) {
-                  /* Copy the u plane */
-                  memcpy (dstu + dstustride * i, srcu + srcustride * i,
-                      srcustride);
-                  /* Copy the v plane */
-                  memcpy (dstv + dstvstride * i, srcv + srcvstride * i,
-                      srcvstride);
+              for (i = 0; i < rows / 2; ++i) {
+                /* Copy the u plane */
+                memcpy (dstu + dstustride * i, srcu + srcustride * i,
+                    srcustride);
+                /* Copy the v plane */
+                memcpy (dstv + dstvstride * i, srcv + srcvstride * i,
+                    srcvstride);
+              }
+              break;
+            }
+            case GST_MAKE_FOURCC ('N', 'V', '1', '2'):
+            {
+              guint8 *dst = dest;
+              int component;
+              dststride = lr.Pitch;
+              for (component = 0; component < 2; component++) {
+                const int compHeight =
+                    gst_video_format_get_component_height (sink->format,
+                    component, sink->height);
+                guint8 *src =
+                    source +
+                    gst_video_format_get_component_offset (sink->format,
+                    component, sink->width, sink->height);
+                srcstride =
+                    gst_video_format_get_row_stride (sink->format, component,
+                    sink->width);
+                for (i = 0; i < compHeight; i++) {
+                  memcpy (dst + dststride * i, src + srcstride * i, srcstride);
                 }
-                break;
+                dst += dststride * compHeight;
               }
-              default:
-                g_assert_not_reached ();
+              break;
             }
-          } else if (gst_video_format_is_rgb (sink->format)) {
-            dststride = lr.Pitch;
-            srcstride = GST_BUFFER_SIZE (buffer) / sink->height;
-            for (i = 0; i < sink->height; ++i)
-              memcpy (dest + dststride * i, source + srcstride * i, srcstride);
+            default:
+              g_assert_not_reached ();
           }
+        } else if (gst_video_format_is_rgb (sink->format)) {
+          dststride = lr.Pitch;
+          srcstride = GST_BUFFER_SIZE (buffer) / sink->height;
+          for (i = 0; i < sink->height; ++i)
+            memcpy (dest + dststride * i, source + srcstride * i, srcstride);
         }
-
-        IDirect3DSurface9_UnlockRect (sink->d3d_offscreen_surface);
-      }
-      gst_d3dvideosink_stretch (sink, backBuffer);
-      IDirect3DDevice9_EndScene (shared.d3ddev);
-    }
-    /* Swap back and front buffers on video card and present to the user */
-    if (FAILED (hr =
-            IDirect3DSwapChain9_Present (sink->d3d_swap_chain, NULL, NULL, NULL,
-                NULL, 0))) {
-      switch (hr) {
-        case D3DERR_DEVICELOST:
-        case D3DERR_DEVICENOTRESET:
-          gst_d3dvideosink_notify_device_lost (sink);
-          break;
-        default:
-          goto wrong_state;
       }
+      IDirect3DSurface9_UnlockRect (drawSurface);
     }
+    IDirect3DDevice9_EndScene (sink->d3ddev);
   }
-
 success:
   GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return GST_FLOW_OK;
+  gst_d3dvideosink_refresh (sink);
+  return GST_FLOW_OK;
+#if 0
 wrong_state:
   GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return GST_FLOW_WRONG_STATE;
+  return GST_FLOW_WRONG_STATE;
 /*unexpected:*/
 /*  GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK(sink); */
-/*  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK    */
+/*      */
 /*  return GST_FLOW_UNEXPECTED;               */
+#endif
 error:
   GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return GST_FLOW_ERROR;
+  return GST_FLOW_ERROR;
 }
 
 /* Simply redraws the last item on our offscreen surface to the window */
 static gboolean
 gst_d3dvideosink_refresh (GstD3DVideoSink * sink)
 {
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
+  GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
   {
     HRESULT hr;
     LPDIRECT3DSURFACE9 backBuffer;
 
-    if (!shared.d3ddev) {
+    if (!sink->d3ddev) {
       if (!shared.device_lost)
         GST_DEBUG ("No Direct3D device has been created");
       goto error;
@@ -1744,35 +1782,33 @@ gst_d3dvideosink_refresh (GstD3DVideoSink * sink)
       goto error;
     }
 
-    if (!sink->d3d_swap_chain) {
-      GST_DEBUG ("No Direct3D swap chain has been created");
-      goto error;
-    }
-
     if (sink->window_closed) {
       GST_DEBUG ("Window has been closed");
       goto error;
     }
 
     /* Set the render target to our swap chain */
-    IDirect3DSwapChain9_GetBackBuffer (sink->d3d_swap_chain, 0,
-        D3DBACKBUFFER_TYPE_MONO, &backBuffer);
-    IDirect3DDevice9_SetRenderTarget (shared.d3ddev, 0, backBuffer);
+    if (FAILED (IDirect3DDevice9_GetBackBuffer (sink->d3ddev, 0, 0,
+                D3DBACKBUFFER_TYPE_MONO, &backBuffer))) {
+      GST_ERROR_OBJECT (sink, "failed to get back buffer");
+      goto error;
+    }
+    IDirect3DDevice9_SetRenderTarget (sink->d3ddev, 0, backBuffer);
     IDirect3DSurface9_Release (backBuffer);
 
     /* Clear the target */
-    IDirect3DDevice9_Clear (shared.d3ddev, 0, NULL, D3DCLEAR_TARGET,
+    IDirect3DDevice9_Clear (sink->d3ddev, 0, NULL, D3DCLEAR_TARGET,
         D3DCOLOR_XRGB (0, 0, 0), 1.0f, 0);
 
-    if (SUCCEEDED (IDirect3DDevice9_BeginScene (shared.d3ddev))) {
+    if (SUCCEEDED (IDirect3DDevice9_BeginScene (sink->d3ddev))) {
       gst_d3dvideosink_stretch (sink, backBuffer);
-      IDirect3DDevice9_EndScene (shared.d3ddev);
+      IDirect3DDevice9_EndScene (sink->d3ddev);
     }
-
+    IDirect3DSurface9_Release (backBuffer);
+    gst_d3dvideosink_flush_gpu (sink);
     /* Swap back and front buffers on video card and present to the user */
     if (FAILED (hr =
-            IDirect3DSwapChain9_Present (sink->d3d_swap_chain, NULL, NULL, NULL,
-                NULL, 0))) {
+            IDirect3DDevice9_Present (sink->d3ddev, NULL, NULL, NULL, NULL))) {
       switch (hr) {
         case D3DERR_DEVICELOST:
         case D3DERR_DEVICENOTRESET:
@@ -1782,21 +1818,21 @@ gst_d3dvideosink_refresh (GstD3DVideoSink * sink)
           goto error;
       }
     }
+    gst_d3dvideosink_flush_gpu (sink);
   }
 
 /*success:*/
   GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return TRUE;
+  return TRUE;
 error:
   GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return FALSE;
+  return FALSE;
 }
 
 static gboolean
 gst_d3dvideosink_update_all (GstD3DVideoSink * sink)
 {
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SHARED_D3D_LOCK
-  {
+  GST_D3DVIDEOSINK_SHARED_D3D_LOCK {
     GList *item;
     GstD3DVideoSink *s;
     for (item = g_list_first (shared.element_list); item; item = item->next) {
@@ -1805,19 +1841,17 @@ gst_d3dvideosink_update_all (GstD3DVideoSink * sink)
     }
   }
 /*success:*/
-  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK
-      GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return TRUE;
+  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK return TRUE;
 /*error:*/
 /*  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK     */
-/*  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK */
+/*   */
 /*  return FALSE;                          */
 }
 
 static gboolean
 gst_d3dvideosink_refresh_all (GstD3DVideoSink * sink)
 {
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SHARED_D3D_LOCK
-  {
+  GST_D3DVIDEOSINK_SHARED_D3D_LOCK {
     GList *item;
     GstD3DVideoSink *s;
     for (item = g_list_first (shared.element_list); item; item = item->next) {
@@ -1826,11 +1860,9 @@ gst_d3dvideosink_refresh_all (GstD3DVideoSink * sink)
     }
   }
 /*success:*/
-  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK
-      GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return TRUE;
+  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK return TRUE;
 /*error:*/
 /*  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK     */
-/*  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK */
 /*  return FALSE;                          */
 }
 
@@ -1844,26 +1876,44 @@ gst_d3dvideosink_stretch (GstD3DVideoSink * sink, LPDIRECT3DSURFACE9 backBuffer)
     GstVideoRectangle src;
     GstVideoRectangle dst;
     GstVideoRectangle result;
+    gdouble x_scale, y_scale;
 
     gst_d3dvideosink_window_size (sink, &window_width, &window_height);
 
+    src.x = 0;
+    src.y = 0;
     src.w = GST_VIDEO_SINK_WIDTH (sink);
     src.h = GST_VIDEO_SINK_HEIGHT (sink);
 
+    dst.x = 0;
+    dst.y = 0;
     dst.w = window_width;
     dst.h = window_height;
 
+    x_scale = (gdouble) src.w / (gdouble) dst.w;
+    y_scale = (gdouble) src.h / (gdouble) dst.h;
     gst_video_sink_center_rect (src, dst, &result, TRUE);
 
+    result.x = result.x * x_scale;
+    result.y = result.y * y_scale;
+    result.w = result.w * x_scale;
+    result.h = result.h * y_scale;
+
+    //clip to src
+    gst_video_sink_center_rect (result, src, &result, FALSE);
+
     r.left = result.x;
     r.top = result.y;
     r.right = result.x + result.w;
     r.bottom = result.y + result.h;
 
-    IDirect3DDevice9_StretchRect (shared.d3ddev, sink->d3d_offscreen_surface,
-        NULL, backBuffer, &r, sink->d3dfiltertype);
+    if (FAILED (IDirect3DDevice9_StretchRect (sink->d3ddev,
+                sink->d3d_offscreen_surface, NULL, backBuffer, &r,
+                sink->d3dfiltertype))) {
+      GST_ERROR_OBJECT (sink, "StretchRect failed");
+    }
   } else {
-    IDirect3DDevice9_StretchRect (shared.d3ddev, sink->d3d_offscreen_surface,
+    IDirect3DDevice9_StretchRect (sink->d3ddev, sink->d3d_offscreen_surface,
         NULL, backBuffer, NULL, sink->d3dfiltertype);
   }
 }
@@ -1871,14 +1921,8 @@ gst_d3dvideosink_stretch (GstD3DVideoSink * sink, LPDIRECT3DSURFACE9 backBuffer)
 static void
 gst_d3dvideosink_expose (GstXOverlay * overlay)
 {
-  GstD3DVideoSink *sink = GST_D3DVIDEOSINK (overlay);
-  GstBuffer *last_buffer;
-
-  last_buffer = gst_base_sink_get_last_buffer (GST_BASE_SINK (sink));
-  if (last_buffer) {
-    gst_d3dvideosink_show_frame (GST_VIDEO_SINK (sink), last_buffer);
-    gst_buffer_unref (last_buffer);
-  }
+  GstBaseSink *sink = GST_BASE_SINK (overlay);
+  gst_d3dvideosink_update (sink);
 }
 
 static void
@@ -1915,6 +1959,9 @@ gst_d3dvideosink_unlock_stop (GstBaseSink * bsink)
 static gboolean
 gst_d3dvideosink_initialize_direct3d (GstD3DVideoSink * sink)
 {
+  DirectXAPI *api;
+  GstD3DVideoSinkClass *klass;
+
   /* Let's hope this is never a problem (they have millions of d3d elements going at the same time) */
   if (shared.element_count >= G_MAXINT32) {
     GST_ERROR
@@ -1922,10 +1969,10 @@ gst_d3dvideosink_initialize_direct3d (GstD3DVideoSink * sink)
     return FALSE;
   }
 
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SHARED_D3D_LOCK
+  GST_D3DVIDEOSINK_SHARED_D3D_LOCK
       /* Add to our GList containing all of our elements. */
       /* GLists are doubly-linked lists and calling prepend() prevents it from having to traverse the entire list just to add one item. */
-    shared.element_list = g_list_prepend (shared.element_list, sink);
+      shared.element_list = g_list_prepend (shared.element_list, sink);
 
   /* Increment our count of the number of elements we have */
   shared.element_count++;
@@ -1936,19 +1983,42 @@ gst_d3dvideosink_initialize_direct3d (GstD3DVideoSink * sink)
   /* We'll destroy this once all elements using direct3d have been finalized. */
   /* See gst_d3dvideosink_release_direct3d() for details. */
 
-  /* We create a window that's hidden and used by the Direct3D device. The */
-  /* device is shared among all d3dvideosink windows. */
+  if (!sink) {
+    GST_WARNING ("Missing gobject instance.");
+    return FALSE;
+  }
+
+  klass = GST_D3DVIDEOSINK_GET_CLASS (sink);
+  if (!klass) {
+    GST_WARNING ("Unable to retrieve gobject class");
+    goto error;
+  }
+
+  api = klass->directx_api;
+  if (!api) {
+    GST_WARNING ("Missing DirectX api");
+    goto error;
+  }
+
+  shared.d3d =
+      (LPDIRECT3D9) DX9_D3D_COMPONENT_CALL_FUNC (DIRECTX_D3D (api),
+      Direct3DCreate9, D3D_SDK_VERSION);
+  if (!shared.d3d) {
+    GST_ERROR ("Unable to create Direct3D interface");
+    goto error;
+  }
+
+  /* We create a window that's hidden, so we can control the 
+     device's from a single thread */
 
   GST_DEBUG ("Creating hidden window for Direct3D");
   if (!gst_d3dvideosink_create_shared_hidden_window (sink))
     goto error;
 
 success:
-  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK
-      GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return TRUE;
+  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK return TRUE;
 error:
-  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK
-      GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return FALSE;
+  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK return FALSE;
 }
 
 static gboolean
@@ -1956,60 +2026,38 @@ gst_d3dvideosink_initialize_d3d_device (GstD3DVideoSink * sink)
 {
   HRESULT hr;
   DWORD d3dcreate;
-  LPDIRECT3D9 d3d;
   D3DCAPS9 d3dcaps;
-  D3DFORMAT d3ddmformat;
+  HWND hwnd = sink->window_handle;
+  D3DFORMAT d3dformat = sink->d3dformat;
+  D3DFORMAT d3dfourcc;
   D3DDISPLAYMODE d3ddm;
-  LPDIRECT3DDEVICE9 d3ddev;
-  D3DPRESENT_PARAMETERS d3dpp;
   D3DTEXTUREFILTERTYPE d3dfiltertype;
-  GstD3DVideoSinkClass *klass;
-  DirectXAPI *api;
+  gint width, height;
 
-  if (!sink) {
-    GST_WARNING ("Missing gobject instance.");
-    goto error;
-  }
 
-  klass = GST_D3DVIDEOSINK_GET_CLASS (sink);
-  if (!klass) {
-    GST_WARNING ("Unable to retrieve gobject class");
-    goto error;
-  }
 
-  api = klass->directx_api;
-  if (!api) {
-    GST_WARNING ("Missing DirectX api");
-    goto error;
-  }
-  //d3d = Direct3DCreate9(D3D_SDK_VERSION);
-  d3d =
-      (LPDIRECT3D9) DX9_D3D_COMPONENT_CALL_FUNC (DIRECTX_D3D (api),
-      Direct3DCreate9, D3D_SDK_VERSION);
-  if (!d3d) {
-    GST_WARNING ("Unable to create Direct3D interface");
+  /* Get the current size of the window */
+  gst_d3dvideosink_window_size (sink, &width, &height);
+
+  if (!shared.d3d) {
+    GST_WARNING ("Direct3D object has not been initialized");
     goto error;
   }
-
-  if (FAILED (IDirect3D9_GetAdapterDisplayMode (d3d, D3DADAPTER_DEFAULT,
+  if (FAILED (IDirect3D9_GetAdapterDisplayMode (shared.d3d, D3DADAPTER_DEFAULT,
               &d3ddm))) {
-    /* Prevent memory leak */
-    IDirect3D9_Release (d3d);
     GST_WARNING ("Unable to request adapter display mode");
     goto error;
   }
 
-  if (FAILED (IDirect3D9_GetDeviceCaps (d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
-              &d3dcaps))) {
-    /* Prevent memory leak */
-    IDirect3D9_Release (d3d);
+  if (FAILED (IDirect3D9_GetDeviceCaps (shared.d3d, D3DADAPTER_DEFAULT,
+              D3DDEVTYPE_HAL, &d3dcaps))) {
     GST_WARNING ("Unable to request device caps");
     goto error;
   }
 
   /* Ask DirectX to please not clobber the FPU state when making DirectX API calls. */
   /* This can cause libraries such as cairo to misbehave in certain scenarios. */
-  d3dcreate = 0 | D3DCREATE_FPU_PRESERVE;
+  d3dcreate = 0 | D3DCREATE_FPU_PRESERVE | D3DCREATE_MULTITHREADED;
 
   /* Determine vertex processing capabilities. Some cards have issues using software vertex processing. */
   /* Courtesy http://www.chadvernon.com/blog/resources/directx9/improved-direct3d-initialization/ */
@@ -2032,33 +2080,112 @@ gst_d3dvideosink_initialize_d3d_device (GstD3DVideoSink * sink)
     d3dfiltertype = D3DTEXF_NONE;
   }
 
-  /* Setup the display mode format. */
-  d3ddmformat = d3ddm.Format;
+  if (gst_video_format_is_yuv (sink->format)) {
+    switch (gst_video_format_to_fourcc (sink->format)) {
+      case GST_MAKE_FOURCC ('Y', 'U', 'Y', '2'):
+        d3dformat = D3DFMT_X8R8G8B8;
+        d3dfourcc = (D3DFORMAT) MAKEFOURCC ('Y', 'U', 'Y', '2');
+        break;
+        //case GST_MAKE_FOURCC ('Y', 'U', 'V', 'Y'):
+        //  d3dformat = D3DFMT_X8R8G8B8;
+        //  d3dfourcc = (D3DFORMAT)MAKEFOURCC('Y', 'U', 'V', 'Y');
+        //  break;
+      case GST_MAKE_FOURCC ('U', 'Y', 'V', 'Y'):
+        d3dformat = D3DFMT_X8R8G8B8;
+        d3dfourcc = (D3DFORMAT) MAKEFOURCC ('U', 'Y', 'V', 'Y');
+        break;
+      case GST_MAKE_FOURCC ('Y', 'V', '1', '2'):
+      case GST_MAKE_FOURCC ('I', '4', '2', '0'):
+        d3dformat = D3DFMT_X8R8G8B8;
+        d3dfourcc = (D3DFORMAT) MAKEFOURCC ('Y', 'V', '1', '2');
+        break;
+      case GST_MAKE_FOURCC ('N', 'V', '1', '2'):
+        d3dformat = D3DFMT_X8R8G8B8;
+        d3dfourcc = (D3DFORMAT) MAKEFOURCC ('N', 'V', '1', '2');
+        break;
+      default:
+        g_assert_not_reached ();
+        goto error;
+    }
+  } else if (gst_video_format_is_rgb (sink->format)) {
+    d3dformat = D3DFMT_X8R8G8B8;
+    d3dfourcc = D3DFMT_X8R8G8B8;
+  } else {
+    g_assert_not_reached ();
+    goto error;
+  }
+
+  GST_DEBUG ("Determined Direct3D format: %" GST_FOURCC_FORMAT,
+      GST_FOURCC_ARGS (d3dfourcc));
+
+  //Stencil/depth buffers aren't created by default when using swap chains
+  //if (SUCCEEDED(IDirect3D9_CheckDeviceFormat(shared.d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3dformat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D32))) {
+  //  d3dstencilformat = D3DFMT_D32;
+  //  d3dEnableAutoDepthStencil = TRUE;
+  //} else if (SUCCEEDED(IDirect3D9_CheckDeviceFormat(shared.d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3dformat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24X8))) {
+  //  d3dstencilformat = D3DFMT_D24X8;
+  //  d3dEnableAutoDepthStencil = TRUE;
+  //} else if (SUCCEEDED(IDirect3D9_CheckDeviceFormat(shared.d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3dformat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D16))) {
+  //  d3dstencilformat = D3DFMT_D16;
+  //  d3dEnableAutoDepthStencil = TRUE;
+  //} else {
+  //  d3dstencilformat = D3DFMT_X8R8G8B8;
+  //  d3dEnableAutoDepthStencil = FALSE;
+  //}
+  //
+  //GST_DEBUG("Determined Direct3D stencil format: %d", d3dstencilformat);
 
-  ZeroMemory (&d3dpp, sizeof (d3dpp));
-  //d3dpp.Flags = D3DPRESENTFLAG_VIDEO;
-  d3dpp.Windowed = TRUE;
-  d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
-  d3dpp.BackBufferCount = 1;
-  d3dpp.BackBufferFormat = d3ddmformat;
-  d3dpp.BackBufferWidth = 1;
-  d3dpp.BackBufferHeight = 1;
-  d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
-  d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;     //D3DPRESENT_INTERVAL_IMMEDIATE;
+  GST_DEBUG ("Direct3D back buffer size: %dx%d", GST_VIDEO_SINK_WIDTH (sink),
+      GST_VIDEO_SINK_HEIGHT (sink));
 
-  GST_DEBUG ("Creating Direct3D device for hidden window %p",
-      shared.hidden_window_handle);
+  sink->d3dformat = d3dformat;
+  sink->d3dfourcc = d3dfourcc;
+
+
+  ZeroMemory (&sink->d3dpp, sizeof (sink->d3dpp));
+  sink->d3dpp.Flags = D3DPRESENTFLAG_VIDEO | D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;
+  sink->d3dpp.Windowed = TRUE;
+  sink->d3dpp.hDeviceWindow = hwnd;
+  sink->d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
+  sink->d3dpp.BackBufferCount = 1;
+  //sink->d3dpp.BackBufferFormat = d3dformat;
+  sink->d3dpp.BackBufferWidth = sink->width;
+  sink->d3dpp.BackBufferHeight = sink->height;
+  sink->d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
+  sink->d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
 
-  if (FAILED (hr = IDirect3D9_CreateDevice (d3d,
+  GST_DEBUG ("Creating Direct3D device for window %p", hwnd);
+
+  sink->d3ddev = NULL;
+
+  if (FAILED (hr = IDirect3D9_CreateDevice (shared.d3d,
               D3DADAPTER_DEFAULT,
-              D3DDEVTYPE_HAL,
-              shared.hidden_window_handle, d3dcreate, &d3dpp, &d3ddev))) {
-    /* Prevent memory leak */
-    IDirect3D9_Release (d3d);
+              D3DDEVTYPE_HAL, hwnd, d3dcreate, &sink->d3dpp, &sink->d3ddev))) {
     GST_WARNING ("Unable to create Direct3D device. Result: %ld (0x%lx)", hr,
         hr);
     goto error;
   }
+
+  if (FAILED (IDirect3DDevice9_CreateOffscreenPlainSurface (sink->d3ddev,
+              sink->width, sink->height, d3dfourcc, D3DPOOL_DEFAULT,
+              &sink->d3d_offscreen_surface, NULL))) {
+    goto error;
+  }
+
+
+  /* Determine texture filtering support. If it's supported for this format, use the filter 
+     type determined when we created the dev and checked the dev caps. 
+   */
+  if (FAILED (IDirect3D9_CheckDeviceFormat (shared.d3d, D3DADAPTER_DEFAULT,
+              D3DDEVTYPE_HAL, d3dformat, D3DUSAGE_QUERY_FILTER,
+              D3DRTYPE_TEXTURE, d3dformat))) {
+    d3dfiltertype = D3DTEXF_NONE;
+  }
+
+  GST_DEBUG ("Direct3D stretch rect texture filter: %d", d3dfiltertype);
+
+  sink->d3dfiltertype = d3dfiltertype;
+
   //if (FAILED(IDirect3DDevice9_GetDeviceCaps(
   //  d3ddev, 
   //  &d3dcaps
@@ -2069,299 +2196,68 @@ gst_d3dvideosink_initialize_d3d_device (GstD3DVideoSink * sink)
   //  goto error;
   //}
 
-  shared.d3d = d3d;
-  shared.d3ddev = d3ddev;
-  shared.d3ddmformat = d3ddmformat;
-  shared.d3dfiltertype = d3dfiltertype;
-
 /*success:*/
+  //GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
   return TRUE;
 error:
+  //GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
   return FALSE;
 }
 
 static gboolean
-gst_d3dvideosink_initialize_swap_chain (GstD3DVideoSink * sink)
-{
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
-  {
-    gint width;
-    gint height;
-    //D3DDISPLAYMODE mode;
-    D3DPRESENT_PARAMETERS d3dpp;
-    D3DFORMAT d3dformat;
-    D3DFORMAT d3dfourcc;
-    //D3DFORMAT d3dstencilformat;
-    LPDIRECT3DSWAPCHAIN9 d3dswapchain;
-    LPDIRECT3DSURFACE9 d3dsurface;
-    D3DTEXTUREFILTERTYPE d3dfiltertype;
-    //gboolean d3dEnableAutoDepthStencil;
-
-    /* This should always work since gst_d3dvideosink_initialize_direct3d() should have always been called previously */
-    if (!shared.d3ddev) {
-      GST_ERROR ("Direct3D device has not been initialized");
-      goto error;
-    }
-
-    GST_DEBUG ("Initializing Direct3D swap chain for sink %p", sink);
-
-    if (gst_video_format_is_yuv (sink->format)) {
-      switch (gst_video_format_to_fourcc (sink->format)) {
-        case GST_MAKE_FOURCC ('Y', 'U', 'Y', '2'):
-          d3dformat = D3DFMT_X8R8G8B8;
-          d3dfourcc = (D3DFORMAT) MAKEFOURCC ('Y', 'U', 'Y', '2');
-          break;
-          //case GST_MAKE_FOURCC ('Y', 'U', 'V', 'Y'):
-          //  d3dformat = D3DFMT_X8R8G8B8;
-          //  d3dfourcc = (D3DFORMAT)MAKEFOURCC('Y', 'U', 'V', 'Y');
-          //  break;
-        case GST_MAKE_FOURCC ('U', 'Y', 'V', 'Y'):
-          d3dformat = D3DFMT_X8R8G8B8;
-          d3dfourcc = (D3DFORMAT) MAKEFOURCC ('U', 'Y', 'V', 'Y');
-          break;
-        case GST_MAKE_FOURCC ('Y', 'V', '1', '2'):
-        case GST_MAKE_FOURCC ('I', '4', '2', '0'):
-          d3dformat = D3DFMT_X8R8G8B8;
-          d3dfourcc = (D3DFORMAT) MAKEFOURCC ('Y', 'V', '1', '2');
-          break;
-        default:
-          g_assert_not_reached ();
-          goto error;
-      }
-    } else if (gst_video_format_is_rgb (sink->format)) {
-      d3dformat = D3DFMT_X8R8G8B8;
-      d3dfourcc = D3DFMT_X8R8G8B8;
-    } else {
-      g_assert_not_reached ();
-      goto error;
-    }
-
-    GST_DEBUG ("Determined Direct3D format: %d", d3dfourcc);
-
-    //Stencil/depth buffers aren't created by default when using swap chains
-    //if (SUCCEEDED(IDirect3D9_CheckDeviceFormat(shared.d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3dformat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D32))) {
-    //  d3dstencilformat = D3DFMT_D32;
-    //  d3dEnableAutoDepthStencil = TRUE;
-    //} else if (SUCCEEDED(IDirect3D9_CheckDeviceFormat(shared.d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3dformat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24X8))) {
-    //  d3dstencilformat = D3DFMT_D24X8;
-    //  d3dEnableAutoDepthStencil = TRUE;
-    //} else if (SUCCEEDED(IDirect3D9_CheckDeviceFormat(shared.d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3dformat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D16))) {
-    //  d3dstencilformat = D3DFMT_D16;
-    //  d3dEnableAutoDepthStencil = TRUE;
-    //} else {
-    //  d3dstencilformat = D3DFMT_X8R8G8B8;
-    //  d3dEnableAutoDepthStencil = FALSE;
-    //}
-    //
-    //GST_DEBUG("Determined Direct3D stencil format: %d", d3dstencilformat);
-
-    GST_DEBUG ("Direct3D back buffer size: %dx%d", GST_VIDEO_SINK_WIDTH (sink),
-        GST_VIDEO_SINK_HEIGHT (sink));
-
-    /* Get the current size of the window */
-    gst_d3dvideosink_window_size (sink, &width, &height);
-
-    ZeroMemory (&d3dpp, sizeof (d3dpp));
-    d3dpp.Windowed = TRUE;
-    d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
-    d3dpp.hDeviceWindow = sink->window_handle;
-    d3dpp.BackBufferFormat = d3dformat;
-    d3dpp.BackBufferWidth = width;
-    d3dpp.BackBufferHeight = height;
-
-    if (FAILED (IDirect3DDevice9_CreateAdditionalSwapChain (shared.d3ddev,
-                &d3dpp, &d3dswapchain)))
-      goto error;
-
-    if (FAILED (IDirect3DDevice9_CreateOffscreenPlainSurface (shared.d3ddev,
-                sink->width, sink->height, d3dfourcc, D3DPOOL_DEFAULT,
-                &d3dsurface, NULL))) {
-      /* Ensure that we release our newly created swap chain to prevent memory leaks */
-      IDirect3DSwapChain9_Release (d3dswapchain);
-      goto error;
-    }
-
-    /* Determine texture filtering support. If it's supported for this format, use the filter type determined when we created the dev and checked the dev caps. */
-    if (SUCCEEDED (IDirect3D9_CheckDeviceFormat (shared.d3d, D3DADAPTER_DEFAULT,
-                D3DDEVTYPE_HAL, shared.d3ddmformat, D3DUSAGE_QUERY_FILTER,
-                D3DRTYPE_TEXTURE, d3dformat))) {
-      d3dfiltertype = shared.d3dfiltertype;
-    } else {
-      d3dfiltertype = D3DTEXF_NONE;
-    }
-
-    GST_DEBUG ("Direct3D stretch rect texture filter: %d", d3dfiltertype);
-
-    sink->d3dformat = d3dformat;
-    sink->d3dfourcc = d3dfourcc;
-    sink->d3dfiltertype = d3dfiltertype;
-    sink->d3d_swap_chain = d3dswapchain;
-    sink->d3d_offscreen_surface = d3dsurface;
-  }
-
-/*success:*/
-  GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return TRUE;
-error:
-  GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return FALSE;
-}
-
-static gboolean
-gst_d3dvideosink_resize_swap_chain (GstD3DVideoSink * sink, gint width,
-    gint height)
+gst_d3dvideosink_notify_device_init (GstD3DVideoSink * sink)
 {
-  if (width <= 0 || height <= 0 || width > GetSystemMetrics (SM_CXFULLSCREEN)
-      || height > GetSystemMetrics (SM_CYFULLSCREEN)) {
-    GST_DEBUG ("Invalid size");
-    return FALSE;
-  }
-
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
-  {
-    int ref_count;
-    D3DPRESENT_PARAMETERS d3dpp;
-    LPDIRECT3DSWAPCHAIN9 d3dswapchain;
-
-    GST_DEBUG ("Resizing Direct3D swap chain for sink %p to %dx%d", sink, width,
-        height);
-
-    if (!shared.d3d || !shared.d3ddev) {
-      if (!shared.device_lost)
-        GST_WARNING ("Direct3D device has not been initialized");
-      goto error;
-    }
-
-    if (!sink->d3d_swap_chain) {
-      GST_DEBUG ("Direct3D swap chain has not been initialized");
-      goto error;
-    }
-
-    /* Get the parameters used to create this swap chain */
-    if (FAILED (IDirect3DSwapChain9_GetPresentParameters (sink->d3d_swap_chain,
-                &d3dpp))) {
-      GST_DEBUG
-          ("Unable to determine Direct3D present parameters for swap chain");
-      goto error;
-    }
-
-    /* Release twice because IDirect3DSwapChain9_GetPresentParameters() adds a reference */
-    while ((ref_count =
-            IDirect3DSwapChain9_Release (sink->d3d_swap_chain)) > 0);
-    sink->d3d_swap_chain = NULL;
-    GST_DEBUG ("Old Direct3D swap chain released. Reference count: %d",
-        ref_count);
-
-    /* Adjust back buffer width/height */
-    d3dpp.BackBufferWidth = width;
-    d3dpp.BackBufferHeight = height;
-
-    if (FAILED (IDirect3DDevice9_CreateAdditionalSwapChain (shared.d3ddev,
-                &d3dpp, &d3dswapchain)))
-      goto error;
-
-    sink->d3d_swap_chain = d3dswapchain;
+  if (sink->window_handle) {
+    SendMessage (shared.hidden_window_handle, WM_DIRECTX_D3D_INIT_DEVICE, 0,
+        (LPARAM) sink);
   }
-
-/*success:*/
-  GST_DEBUG ("Direct3D swap chain successfully resized for sink %p", sink);
-  GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return TRUE;
-error:
-  GST_DEBUG ("Error attempting to resize the Direct3D swap chain for sink %p",
-      sink);
-  GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return FALSE;
+  return TRUE;
 }
 
 static gboolean
-gst_d3dvideosink_release_swap_chain (GstD3DVideoSink * sink)
+gst_d3dvideosink_notify_device_reinit (GstD3DVideoSink * sink)
 {
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
-  {
-    GST_DEBUG ("Releasing Direct3D swap chain for sink %p", sink);
-
-    /* This should always work since gst_d3dvideosink_initialize_direct3d() should have always been called previously */
-    if (!shared.d3d || !shared.d3ddev) {
-      if (!shared.device_lost)
-        GST_ERROR ("Direct3D device has not been initialized");
-      goto error;
-    }
-
-    if (!sink->d3d_swap_chain && !sink->d3d_offscreen_surface)
-      goto success;
-
-    if (sink->d3d_offscreen_surface) {
-      int ref_count;
-      while ((ref_count =
-              IDirect3DSurface9_Release (sink->d3d_offscreen_surface)) > 0);
-      sink->d3d_offscreen_surface = NULL;
-      GST_DEBUG
-          ("Direct3D offscreen surface released for sink %p. Reference count: %d",
-          sink, ref_count);
-    }
-
-    if (sink->d3d_swap_chain) {
-      int ref_count;
-      while ((ref_count =
-              IDirect3DSwapChain9_Release (sink->d3d_swap_chain)) > 0);
-      sink->d3d_swap_chain = NULL;
-      GST_DEBUG
-          ("Direct3D swap chain released for sink %p. Reference count: %d",
-          sink, ref_count);
-    }
+  if (sink->window_handle) {
+    SendMessage (shared.hidden_window_handle, WM_DIRECTX_D3D_DEVICELOST, 0,
+        (LPARAM) sink);
   }
-
-success:
-  GST_DEBUG ("Direct3D swap chain successfully released for sink %p", sink);
-  GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return TRUE;
-error:
-  GST_DEBUG ("Error attempting to release the Direct3D swap chain for sink %p",
-      sink);
-  GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return FALSE;
+  return TRUE;
 }
 
 static gboolean
 gst_d3dvideosink_notify_device_lost (GstD3DVideoSink * sink)
 {
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SHARED_D3D_LOCK
-  {
-    /* Send notification asynchronously */
-    PostMessage (shared.hidden_window_handle, WM_DIRECTX_D3D_INIT_DEVICELOST, 0,
-        0);
-  }
+  /* Send notification asynchronously */
+  PostMessage (shared.hidden_window_handle, WM_DIRECTX_D3D_INIT_DEVICELOST, 0,
+      (LPARAM) sink);
+
 /*success:*/
   GST_DEBUG ("Successfully sent notification of device lost event for sink %p",
       sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK
-      return TRUE;
+  return TRUE;
 /*error:*/
 /*  GST_DEBUG("Error attempting to send notification of device lost event for sink %d", sink); */
 /*  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK                                                         */
-/*  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK                                                     */
+/*                                                       */
 /*  return FALSE;                                                                              */
 }
 
 static gboolean
 gst_d3dvideosink_notify_device_reset (GstD3DVideoSink * sink)
 {
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SHARED_D3D_LOCK
   {
     /* Send notification synchronously -- let's ensure the timer's been killed before returning */
     SendMessage (shared.hidden_window_handle, WM_DIRECTX_D3D_END_DEVICELOST, 0,
-        0);
+        (LPARAM) sink);
   }
 /*success:*/
   GST_DEBUG ("Successfully sent notification of device reset event for sink %p",
       sink);
-  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK
-      return TRUE;
+  return TRUE;
 /*error:*/
 /*  GST_DEBUG("Error attempting to send notification of reset lost event for sink %d", sink); */
 /*  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK                                                        */
-/*  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK                                                    */
+/*                                                      */
 /*  return FALSE;                                                                             */
 }
 
@@ -2370,38 +2266,32 @@ gst_d3dvideosink_device_lost (GstD3DVideoSink * sink)
 {
   /* Must be called from hidden window's message loop! */
 
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SHARED_D3D_LOCK
   {
-    GST_DEBUG ("Direct3D device lost. Resetting the device.");
+    if (shared.device_lost)
+      GST_DEBUG ("Direct3D device lost");
 
-    if (g_thread_self () != shared.hidden_window_thread)
-    {
+    GST_DEBUG_OBJECT (sink, ". Resetting the device.");
+
+    if (g_thread_self () != shared.hidden_window_thread) {
       GST_ERROR
           ("Direct3D device can only be reset by the thread that created it.");
       goto error;
     }
 
-    if (!shared.device_lost && (!shared.d3d || !shared.d3ddev))
-    {
+    if (!shared.d3d) {
       GST_ERROR ("Direct3D device has not been initialized");
       goto error;
     }
 
     {
-      GList *item;
-      GstD3DVideoSink *s;
+      //GList *item;
+      //GstD3DVideoSink *s;
 
       /* This is technically a bit different from the normal. We don't call reset(), instead */
       /* we recreate everything from scratch. */
 
-      /* Release all swap chains, surfaces, buffers, etc. */
-      for (item = g_list_first (shared.element_list); item; item = item->next) {
-        s = (GstD3DVideoSink *) item->data;
-        gst_d3dvideosink_release_swap_chain (s);
-      }
-
       /* Release the device */
-      if (!gst_d3dvideosink_release_d3d_device (NULL))
+      if (!gst_d3dvideosink_release_d3d_device (sink))
         goto error;
 
       /* Recreate device */
@@ -2409,10 +2299,12 @@ gst_d3dvideosink_device_lost (GstD3DVideoSink * sink)
         goto error;
 
       /* Reinitialize all swap chains, surfaces, buffers, etc. */
-      for (item = g_list_first (shared.element_list); item; item = item->next) {
-        s = (GstD3DVideoSink *) item->data;
-        gst_d3dvideosink_initialize_swap_chain (s);
-      }
+      /*
+         for (item = g_list_first (shared.element_list); item; item = item->next) {
+         s = (GstD3DVideoSink *) item->data;
+         gst_d3dvideosink_initialize_swap_chain (s);
+         }
+       */
     }
 
     /* Let the hidden window know that it's okay to kill the timer */
@@ -2421,42 +2313,40 @@ gst_d3dvideosink_device_lost (GstD3DVideoSink * sink)
 
 /*success:*/
   GST_DEBUG ("Direct3D device has successfully been reset.");
-  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK
-      GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return TRUE;
+  return TRUE;
 error:
   GST_DEBUG ("Unable to successfully reset the Direct3D device.");
-  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK
-      GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return FALSE;
+  return FALSE;
 }
 
 static gboolean
 gst_d3dvideosink_release_d3d_device (GstD3DVideoSink * sink)
 {
-  GST_DEBUG ("Cleaning all Direct3D objects");
-
-  if (shared.d3ddev) {
+  if (sink->d3ddev) {
     int ref_count;
-    ref_count = IDirect3DDevice9_Release (shared.d3ddev);
-    shared.d3ddev = NULL;
-    GST_DEBUG ("Direct3D device released. Reference count: %d", ref_count);
+    ref_count = IDirect3DDevice9_Release (sink->d3ddev);
+    sink->d3ddev = NULL;
+    GST_DEBUG_OBJECT (sink, "Direct3D device released. Reference count: %d",
+        ref_count);
   }
-
-  if (shared.d3d) {
+  if (sink->d3d_offscreen_surface) {
     int ref_count;
-    ref_count = IDirect3D9_Release (shared.d3d);
-    shared.d3d = NULL;
-    GST_DEBUG ("Direct3D object released. Reference count: %d", ref_count);
+    ref_count = IDirect3DSurface9_Release (sink->d3d_offscreen_surface);
+    sink->d3d_offscreen_surface = NULL;
+    GST_DEBUG_OBJECT (sink,
+        "Direct3D offscreen surface released. Reference count: %d", ref_count);
   }
-
+  //GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
   return TRUE;
 }
 
 static gboolean
 gst_d3dvideosink_release_direct3d (GstD3DVideoSink * sink)
 {
-  GST_D3DVIDEOSINK_SHARED_D3D_DEV_LOCK GST_D3DVIDEOSINK_SHARED_D3D_LOCK
+  GST_DEBUG ("Cleaning all Direct3D objects");
+  GST_D3DVIDEOSINK_SHARED_D3D_LOCK
       /* Be absolutely sure that we've released this sink's hook (if any). */
-    gst_d3dvideosink_unhook_window_for_renderer (sink);
+      gst_d3dvideosink_unhook_window_for_renderer (sink);
 
   /* Remove item from the list */
   shared.element_list = g_list_remove (shared.element_list, sink);
@@ -2468,17 +2358,23 @@ gst_d3dvideosink_release_direct3d (GstD3DVideoSink * sink)
   if (shared.element_count > 0)
     goto success;
 
+  GST_D3DVIDEOSINK_SWAP_CHAIN_LOCK (sink);
   gst_d3dvideosink_release_d3d_device (sink);
+  GST_D3DVIDEOSINK_SWAP_CHAIN_UNLOCK (sink);
+  if (shared.d3d) {
+    int ref_count;
+    ref_count = IDirect3D9_Release (shared.d3d);
+    shared.d3d = NULL;
+    GST_DEBUG ("Direct3D object released. Reference count: %d", ref_count);
+  }
 
   GST_DEBUG ("Closing hidden Direct3D window");
   gst_d3dvideosink_close_shared_hidden_window (sink);
 
 success:
-  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK
-      GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK return TRUE;
+  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK return TRUE;
 /*error:*/
 /*  GST_D3DVIDEOSINK_SHARED_D3D_UNLOCK     */
-/*  GST_D3DVIDEOSINK_SHARED_D3D_DEV_UNLOCK */
 /*  return FALSE;                          */
 }
 
diff --git a/sys/d3dvideosink/d3dvideosink.h b/sys/d3dvideosink/d3dvideosink.h
index e067dd3..14b52fd 100644
--- a/sys/d3dvideosink/d3dvideosink.h
+++ b/sys/d3dvideosink/d3dvideosink.h
@@ -83,8 +83,9 @@ struct _GstD3DVideoSink
   gboolean is_hooked;
 
   GMutex *d3d_swap_chain_lock;
-  LPDIRECT3DSWAPCHAIN9 d3d_swap_chain;
   LPDIRECT3DSURFACE9 d3d_offscreen_surface;
+  LPDIRECT3DDEVICE9 d3ddev;
+  D3DPRESENT_PARAMETERS d3dpp;
 
   D3DFORMAT d3dformat;
   D3DFORMAT d3dfourcc;
diff --git a/sys/d3dvideosink/directx/d3d.h b/sys/d3dvideosink/directx/d3d.h
index c58310f..238349c 100644
--- a/sys/d3dvideosink/directx/d3d.h
+++ b/sys/d3dvideosink/directx/d3d.h
@@ -33,8 +33,8 @@ G_BEGIN_DECLS
 #define WM_DIRECTX_D3D_RESIZE           WM_DIRECTX + 5
 
 #define DIRECTX_D3D_API(version, dispatch_table, init_function, create_function, resize_function, device_lost_function, notify_device_reset_function, release_function) \
-  static gpointer DIRECTX_API_COMPONENT_D3D_ ## version ## _DISPATCH_TABLE = &dispatch_table;                                                                           \
-  static DirectXAPIComponentD3D DIRECTX_API_COMPONENT_D3D_ ## version ## _INIT = {                                                                                      \
+  static gpointer G_GNUC_UNUSED DIRECTX_API_COMPONENT_D3D_ ## version ## _DISPATCH_TABLE = &dispatch_table;                                                                           \
+  static DirectXAPIComponentD3D G_GNUC_UNUSED DIRECTX_API_COMPONENT_D3D_ ## version ## _INIT = {                                                                                      \
       create_function               /*create_function*/                                                                                                                 \
     , resize_function               /*resize_function*/                                                                                                                 \
     , device_lost_function          /*device_lost_function*/                                                                                                            \
@@ -42,7 +42,7 @@ G_BEGIN_DECLS
     , release_function              /*release_function*/                                                                                                                \
     , NULL                          /*private_data*/                                                                                                                    \
   };                                                                                                                                                                    \
-  static void init_directx_api_component_d3d_ ## version ## _(const DirectXAPI* api) {                                                                                  \
+  static void G_GNUC_UNUSED init_directx_api_component_d3d_ ## version ## _(const DirectXAPI* api) {                                                                                  \
     gpointer private_data = &DIRECTX_API_COMPONENT_D3D_ ## version ## _INIT;                                                                                            \
     gpointer vtable = DIRECTX_API_COMPONENT_D3D_ ## version ## _DISPATCH_TABLE;                                                                                         \
     DIRECTX_SET_COMPONENT_INIT(DIRECTX_D3D(api), init_function);                                                                                                        \
diff --git a/sys/d3dvideosink/directx/dx.h b/sys/d3dvideosink/directx/dx.h
index 60dd6d8..dcf7c05 100644
--- a/sys/d3dvideosink/directx/dx.h
+++ b/sys/d3dvideosink/directx/dx.h
@@ -111,7 +111,7 @@ typedef enum
     , &DIRECTX_ ## version ## _DIRECTCOMPUTE_COMPONENT                                                                                            \
     , {NULL, NULL, NULL} /*reserved*/                                                                                                             \
   };                                                                                                                                              \
-  static void init_directx_ ## version ## _supported_api(void) {                                                                                  \
+  static void G_GNUC_UNUSED init_directx_ ## version ## _supported_api(void) {                                                                                  \
     DirectXAPI* api;                                                                                                                              \
     api = &DIRECTX_ ## version ## _API;                                                                                                           \
     api->d3d->api      = api;                                                                                                                     \
diff --git a/sys/decklink/Makefile.am b/sys/decklink/Makefile.am
index 63fe397..9d12601 100644
--- a/sys/decklink/Makefile.am
+++ b/sys/decklink/Makefile.am
@@ -10,17 +10,33 @@ libgstdecklink_la_LIBADD = \
 	$(GST_PLUGINS_BASE_LIBS) \
 	$(GST_BASE_LIBS) \
 	$(GST_LIBS) \
+	-lgstvideo-@GST_MAJORMINOR@ \
+	-lgstinterfaces-@GST_MAJORMINOR@ \
 	$(DECKLINK_LIBS) \
 	$(LIBM)
-libgstdecklink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS) 
+libgstdecklink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+
+if DECKLINK_OSX
+libgstdecklink_la_LDFLAGS += \
+	-Wl,-framework,CoreFoundation
+endif
+
 libgstdecklink_la_LIBTOOLFLAGS = --tag=disable-static
 
 libgstdecklink_la_SOURCES = \
 	gstdecklinksrc.cpp \
 	gstdecklinksink.cpp \
 	gstdecklink.cpp \
-	capture.cpp \
+	capture.cpp
+
+if DECKLINK_OSX
+libgstdecklink_la_SOURCES += \
+	osx/DeckLinkAPIDispatch-osx.cpp
+else
+libgstdecklink_la_SOURCES += \
 	linux/DeckLinkAPIDispatch.cpp
+endif
+
 
 noinst_HEADERS = \
 	gstdecklink.h \
@@ -28,10 +44,19 @@ noinst_HEADERS = \
 	gstdecklinksink.h \
 	capture.h \
 	linux/DeckLinkAPI.h \
-	linux/LinuxCOM.h
+	linux/LinuxCOM.h \
+	osx/DeckLinkAPI.h \
+	osx/DeckLinkAPIConfiguration.h \
+	osx/DeckLinkAPIDeckControl.h \
+	osx/DeckLinkAPIDiscovery.h \
+	osx/DeckLinkAPIModes.h \
+	osx/DeckLinkAPIStreaming.h \
+	osx/DeckLinkAPITypes.h \
+	osx/DeckLinkAPIVersion.h
 
 EXTRA_DIST = \
 	win/DeckLinkAPI.h \
 	win/DeckLinkAPIDispatch.cpp \
 	win/DeckLinkAPI_i.c
 
+
diff --git a/sys/decklink/capture.cpp b/sys/decklink/capture.cpp
index bc3d9e0..8804eeb 100644
--- a/sys/decklink/capture.cpp
+++ b/sys/decklink/capture.cpp
@@ -31,6 +31,8 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+#include <gst/glib-compat-private.h>
+
 #include "gstdecklinksrc.h"
 
 #include "capture.h"
@@ -41,11 +43,11 @@ IDeckLink *deckLink;
 IDeckLinkInput *deckLinkInput;
 IDeckLinkDisplayModeIterator *displayModeIterator;
 
-static BMDTimecodeFormat g_timecodeFormat = (BMDTimecodeFormat)0;
+static BMDTimecodeFormat g_timecodeFormat = (BMDTimecodeFormat) 0;
 
 DeckLinkCaptureDelegate::DeckLinkCaptureDelegate ():m_refCount (0)
 {
-  m_mutex = g_mutex_new();
+  m_mutex = g_mutex_new ();
 }
 
 DeckLinkCaptureDelegate::~DeckLinkCaptureDelegate ()
@@ -53,8 +55,7 @@ DeckLinkCaptureDelegate::~DeckLinkCaptureDelegate ()
   g_mutex_free (m_mutex);
 }
 
-ULONG
-DeckLinkCaptureDelegate::AddRef (void)
+ULONG DeckLinkCaptureDelegate::AddRef (void)
 {
   g_mutex_lock (m_mutex);
   m_refCount++;
@@ -63,15 +64,15 @@ DeckLinkCaptureDelegate::AddRef (void)
   return (ULONG) m_refCount;
 }
 
-ULONG
-DeckLinkCaptureDelegate::Release (void)
+ULONG DeckLinkCaptureDelegate::Release (void)
 {
   g_mutex_lock (m_mutex);
   m_refCount--;
   g_mutex_unlock (m_mutex);
 
   if (m_refCount == 0) {
-    delete this;
+    delete
+        this;
     return 0;
   }
 
diff --git a/sys/decklink/gstdecklink.cpp b/sys/decklink/gstdecklink.cpp
index 0920cca..d747fcf 100644
--- a/sys/decklink/gstdecklink.cpp
+++ b/sys/decklink/gstdecklink.cpp
@@ -94,7 +94,8 @@ gst_decklink_audio_connection_get_type (void)
   if (!type) {
     static const GEnumValue connections[] = {
       {GST_DECKLINK_AUDIO_CONNECTION_AUTO, "auto", "Automatic"},
-      {GST_DECKLINK_AUDIO_CONNECTION_EMBEDDED, "embedded", "SDI/HDMI embedded audio"},
+      {GST_DECKLINK_AUDIO_CONNECTION_EMBEDDED, "embedded",
+          "SDI/HDMI embedded audio"},
       {GST_DECKLINK_AUDIO_CONNECTION_AES_EBU, "aes", "AES/EBU input"},
       {GST_DECKLINK_AUDIO_CONNECTION_ANALOG, "analog", "Analog input"},
       {0, NULL, NULL}
@@ -110,29 +111,29 @@ gst_decklink_audio_connection_get_type (void)
 #define HD 1, 1, false, true
 
 static const GstDecklinkMode modes[] = {
-  {bmdModeNTSC, 720, 486, 30000, 1001, true, NTSC },
-  {bmdModeNTSC2398, 720, 486, 24000, 1001, true, NTSC },
-  {bmdModePAL, 720, 576, 25, 1, true, PAL },
-  {bmdModeNTSCp, 720, 486, 30000, 1001, false, NTSC },
-  {bmdModePALp, 720, 576, 25, 1, false, PAL },
-
-  {bmdModeHD1080p2398, 1920, 1080, 24000, 1001, false, HD },
-  {bmdModeHD1080p24, 1920, 1080, 24, 1, false, HD },
-  {bmdModeHD1080p25, 1920, 1080, 25, 1, false, HD },
-  {bmdModeHD1080p2997, 1920, 1080, 30000, 1001, false, HD },
-  {bmdModeHD1080p30, 1920, 1080, 30, 1, false, HD },
-
-  {bmdModeHD1080i50, 1920, 1080, 25, 1, true, HD },
-  {bmdModeHD1080i5994, 1920, 1080, 30000, 1001, true, HD },
-  {bmdModeHD1080i6000, 1920, 1080, 30, 1, true, HD },
-
-  {bmdModeHD1080p50, 1920, 1080, 50, 1, false, HD },
-  {bmdModeHD1080p5994, 1920, 1080, 30000, 1001, false, HD },
-  {bmdModeHD1080p6000, 1920, 1080, 60, 1, false, HD },
-
-  {bmdModeHD720p50, 1280, 720, 50, 1, false, HD },
-  {bmdModeHD720p5994, 1280, 720, 60000, 1001, false, HD },
-  {bmdModeHD720p60, 1280, 720, 60, 1, false, HD }
+  {bmdModeNTSC, 720, 486, 30000, 1001, true, NTSC},
+  {bmdModeNTSC2398, 720, 486, 24000, 1001, true, NTSC},
+  {bmdModePAL, 720, 576, 25, 1, true, PAL},
+  {bmdModeNTSCp, 720, 486, 30000, 1001, false, NTSC},
+  {bmdModePALp, 720, 576, 25, 1, false, PAL},
+
+  {bmdModeHD1080p2398, 1920, 1080, 24000, 1001, false, HD},
+  {bmdModeHD1080p24, 1920, 1080, 24, 1, false, HD},
+  {bmdModeHD1080p25, 1920, 1080, 25, 1, false, HD},
+  {bmdModeHD1080p2997, 1920, 1080, 30000, 1001, false, HD},
+  {bmdModeHD1080p30, 1920, 1080, 30, 1, false, HD},
+
+  {bmdModeHD1080i50, 1920, 1080, 25, 1, true, HD},
+  {bmdModeHD1080i5994, 1920, 1080, 30000, 1001, true, HD},
+  {bmdModeHD1080i6000, 1920, 1080, 30, 1, true, HD},
+
+  {bmdModeHD1080p50, 1920, 1080, 50, 1, false, HD},
+  {bmdModeHD1080p5994, 1920, 1080, 30000, 1001, false, HD},
+  {bmdModeHD1080p6000, 1920, 1080, 60, 1, false, HD},
+
+  {bmdModeHD720p50, 1280, 720, 50, 1, false, HD},
+  {bmdModeHD720p5994, 1280, 720, 60000, 1001, false, HD},
+  {bmdModeHD720p60, 1280, 720, 60, 1, false, HD}
 
 };
 
@@ -155,8 +156,7 @@ gst_decklink_mode_get_structure (GstDecklinkModeEnum e)
       "interlaced", G_TYPE_BOOLEAN, mode->interlaced,
       "pixel-aspect-ratio", GST_TYPE_FRACTION, mode->par_n, mode->par_d,
       "color-matrix", G_TYPE_STRING, mode->is_hdtv ? "hdtv" : "sdtv",
-      "chroma-site", G_TYPE_STRING, "mpeg2",
-      NULL);
+      "chroma-site", G_TYPE_STRING, "mpeg2", NULL);
 }
 
 GstCaps *
@@ -178,14 +178,44 @@ gst_decklink_mode_get_template_caps (void)
   GstStructure *s;
 
   caps = gst_caps_new_empty ();
-  for(i=0;i<(int)G_N_ELEMENTS(modes);i++) {
-    s = gst_decklink_mode_get_structure ((GstDecklinkModeEnum)i);
+  for (i = 0; i < (int) G_N_ELEMENTS (modes); i++) {
+    s = gst_decklink_mode_get_structure ((GstDecklinkModeEnum) i);
     gst_caps_append_structure (caps, s);
   }
 
   return caps;
 }
 
+IDeckLink *
+gst_decklink_get_nth_device (int n)
+{
+  IDeckLinkIterator *iterator;
+  IDeckLink *decklink = NULL;
+  HRESULT ret;
+  int i;
+
+  iterator = CreateDeckLinkIteratorInstance ();
+  if (iterator == NULL) {
+    GST_ERROR ("no driver");
+    return NULL;
+  }
+
+  ret = iterator->Next (&decklink);
+  if (ret != S_OK) {
+    GST_ERROR ("no card");
+    return NULL;
+  }
+  for (i = 0; i < n; i++) {
+    ret = iterator->Next (&decklink);
+    if (ret != S_OK) {
+      GST_ERROR ("no card");
+      return NULL;
+    }
+  }
+
+  return decklink;
+}
+
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
diff --git a/sys/decklink/gstdecklink.h b/sys/decklink/gstdecklink.h
index e69d14b..77c5cc4 100644
--- a/sys/decklink/gstdecklink.h
+++ b/sys/decklink/gstdecklink.h
@@ -107,34 +107,7 @@ const GstDecklinkMode * gst_decklink_get_mode (GstDecklinkModeEnum e);
 GstCaps * gst_decklink_mode_get_caps (GstDecklinkModeEnum e);
 GstCaps * gst_decklink_mode_get_template_caps (void);
 
-#define GST_DECKLINK_MODE_CAPS(w,h,n,d,i) \
-  "video/x-raw-yuv,format=(fourcc)UYVY,width=" #w ",height=" #h \
-  ",framerate=" #n "/" #d ",interlaced=" #i
-
-#define GST_DECKLINK_CAPS \
-  GST_DECKLINK_MODE_CAPS(720,486,30000,1001,true) ";" \
-  GST_DECKLINK_MODE_CAPS(720,486,24000,1001,true) ";" \
-  GST_DECKLINK_MODE_CAPS(720,576,25,1,true) ";" \
-  GST_DECKLINK_MODE_CAPS(720,486,30000,1001,false) ";" \
-  GST_DECKLINK_MODE_CAPS(720,576,25,1,false) ";" \
-  \
-  GST_DECKLINK_MODE_CAPS(1920,1080,24000,1001,false) ";" \
-  GST_DECKLINK_MODE_CAPS(1920,1080,24,1,false) ";" \
-  GST_DECKLINK_MODE_CAPS(1920,1080,25,1,false) ";" \
-  GST_DECKLINK_MODE_CAPS(1920,1080,30000,1001,false) ";" \
-  GST_DECKLINK_MODE_CAPS(1920,1080,30,1,false) ";" \
-  \
-  GST_DECKLINK_MODE_CAPS(1920,1080,25,1,true) ";" \
-  GST_DECKLINK_MODE_CAPS(1920,1080,30000,1001,true) ";" \
-  GST_DECKLINK_MODE_CAPS(1920,1080,30,1,true) ";" \
-  \
-  GST_DECKLINK_MODE_CAPS(1920,1080,50,1,false) ";" \
-  GST_DECKLINK_MODE_CAPS(1920,1080,60000,1001,false) ";" \
-  GST_DECKLINK_MODE_CAPS(1920,1080,60,1,false) ";" \
-  \
-  GST_DECKLINK_MODE_CAPS(1280,720,50,1,false) ";" \
-  GST_DECKLINK_MODE_CAPS(1280,720,60000,1001,false) ";" \
-  GST_DECKLINK_MODE_CAPS(1280,720,60,1,false)
+IDeckLink * gst_decklink_get_nth_device (int n);
 
 
 #endif
diff --git a/sys/decklink/gstdecklinksink.cpp b/sys/decklink/gstdecklinksink.cpp
index bc24cfe..bbf08a7 100644
--- a/sys/decklink/gstdecklinksink.cpp
+++ b/sys/decklink/gstdecklinksink.cpp
@@ -35,7 +35,8 @@
 #endif
 
 #include <gst/gst.h>
-#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/interfaces/propertyprobe.h>
 #include "gstdecklink.h"
 #include "gstdecklinksink.h"
 #include <string.h>
@@ -117,24 +118,25 @@ static GstFlowReturn gst_decklink_sink_audiosink_bufferalloc (GstPad * pad,
     guint64 offset, guint size, GstCaps * caps, GstBuffer ** buf);
 static GstIterator *gst_decklink_sink_audiosink_iterintlink (GstPad * pad);
 
+static void
+gst_decklink_sink_property_probe_interface_init (GstPropertyProbeInterface *
+    iface);
+
 #ifdef _MSC_VER
 /* COM initialization/uninitialization thread */
-static void gst_decklink_sink_com_thread (GstDecklinkSink * src);
+static void gst_decklink_sink_com_thread (GstDecklinkSink * sink);
 #endif /* _MSC_VER */
 
 enum
 {
   PROP_0,
-  PROP_MODE
+  PROP_MODE,
+  PROP_DEVICE
 };
 
 /* pad templates */
 
-static GstStaticPadTemplate gst_decklink_sink_videosink_template =
-GST_STATIC_PAD_TEMPLATE ("videosink",
-    GST_PAD_SINK,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS (GST_DECKLINK_CAPS));
+/* the video sink pad template is created on the fly */
 
 static GstStaticPadTemplate gst_decklink_sink_audiosink_template =
 GST_STATIC_PAD_TEMPLATE ("audiosink",
@@ -150,16 +152,37 @@ GST_STATIC_PAD_TEMPLATE ("audiosink",
   GST_DEBUG_CATEGORY_INIT (gst_decklink_sink_debug_category, "decklinksink", 0, \
       "debug category for decklinksink element");
 
+static void
+gst_decklink_sink_init_interfaces (GType type)
+{
+  static const GInterfaceInfo decklink_sink_propertyprobe_info = {
+    (GInterfaceInitFunc) gst_decklink_sink_property_probe_interface_init,
+    NULL,
+    NULL,
+  };
+
+  GST_DEBUG_CATEGORY_INIT (gst_decklink_sink_debug_category, "decklinksink", 0,
+      "debug category for decklinksink element");
+
+  g_type_add_interface_static (type, GST_TYPE_PROPERTY_PROBE,
+      &decklink_sink_propertyprobe_info);
+}
+
+
 GST_BOILERPLATE_FULL (GstDecklinkSink, gst_decklink_sink, GstElement,
-    GST_TYPE_ELEMENT, DEBUG_INIT);
+    GST_TYPE_ELEMENT, gst_decklink_sink_init_interfaces);
 
 static void
 gst_decklink_sink_base_init (gpointer g_class)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+  GstPadTemplate *pad_template;
 
-  gst_element_class_add_static_pad_template (element_class,
-      &gst_decklink_sink_videosink_template);
+  pad_template =
+      gst_pad_template_new ("videosink", GST_PAD_SINK, GST_PAD_ALWAYS,
+      gst_decklink_mode_get_template_caps ());
+  gst_element_class_add_pad_template (element_class, pad_template);
+  gst_object_unref (pad_template);
   gst_element_class_add_static_pad_template (element_class,
       &gst_decklink_sink_audiosink_template);
 
@@ -188,11 +211,18 @@ gst_decklink_sink_class_init (GstDecklinkSinkClass * klass)
   element_class->query = GST_DEBUG_FUNCPTR (gst_decklink_sink_query);
 
   g_object_class_install_property (gobject_class, PROP_MODE,
-      g_param_spec_enum ("mode", "Mode", "Mode",
+      g_param_spec_enum ("mode", "Playback Mode",
+          "Video Mode to use for playback",
           GST_TYPE_DECKLINK_MODE, GST_DECKLINK_MODE_NTSC,
           (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
               G_PARAM_CONSTRUCT)));
 
+  g_object_class_install_property (gobject_class, PROP_DEVICE,
+      g_param_spec_int ("device", "Device", "Capture device instance to use",
+          0, G_MAXINT, 0,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
+              G_PARAM_CONSTRUCT)));
+
 }
 
 static void
@@ -201,8 +231,8 @@ gst_decklink_sink_init (GstDecklinkSink * decklinksink,
 {
 
   decklinksink->videosinkpad =
-      gst_pad_new_from_static_template (&gst_decklink_sink_videosink_template,
-      "sink");
+      gst_pad_new_from_template (gst_element_class_get_pad_template
+      (GST_ELEMENT_CLASS (decklinksink_class), "videosink"), "videosink");
   gst_pad_set_getcaps_function (decklinksink->videosinkpad,
       GST_DEBUG_FUNCPTR (gst_decklink_sink_videosink_getcaps));
   gst_pad_set_setcaps_function (decklinksink->videosinkpad,
@@ -270,22 +300,23 @@ gst_decklink_sink_init (GstDecklinkSink * decklinksink,
   decklinksink->audio_mutex = g_mutex_new ();
 
   decklinksink->mode = GST_DECKLINK_MODE_NTSC;
+  decklinksink->device = 0;
 
   decklinksink->callback = new Output;
   decklinksink->callback->decklinksink = decklinksink;
 
 #ifdef _MSC_VER
-  decklinksink->com_init_lock = g_mutex_new();
-  decklinksink->com_deinit_lock = g_mutex_new();
-  decklinksink->com_initialized = g_cond_new();
-  decklinksink->com_uninitialize = g_cond_new();
-  decklinksink->com_uninitialized = g_cond_new();
+  decklinksink->com_init_lock = g_mutex_new ();
+  decklinksink->com_deinit_lock = g_mutex_new ();
+  decklinksink->com_initialized = g_cond_new ();
+  decklinksink->com_uninitialize = g_cond_new ();
+  decklinksink->com_uninitialized = g_cond_new ();
 
   g_mutex_lock (decklinksink->com_init_lock);
 
   /* create the COM initialization thread */
-  g_thread_create ((GThreadFunc)gst_decklink_sink_com_thread,
-    decklinksink, FALSE, NULL);
+  g_thread_create ((GThreadFunc) gst_decklink_sink_com_thread,
+      decklinksink, FALSE, NULL);
 
   /* wait until the COM thread signals that COM has been initialized */
   g_cond_wait (decklinksink->com_initialized, decklinksink->com_init_lock);
@@ -306,6 +337,9 @@ gst_decklink_sink_set_property (GObject * object, guint property_id,
     case PROP_MODE:
       decklinksink->mode = (GstDecklinkModeEnum) g_value_get_enum (value);
       break;
+    case PROP_DEVICE:
+      decklinksink->device = g_value_get_int (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -325,6 +359,9 @@ gst_decklink_sink_get_property (GObject * object, guint property_id,
     case PROP_MODE:
       g_value_set_enum (value, decklinksink->mode);
       break;
+    case PROP_DEVICE:
+      g_value_set_int (value, decklinksink->device);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -333,11 +370,11 @@ gst_decklink_sink_get_property (GObject * object, guint property_id,
 
 #ifdef _MSC_VER
 static void
-gst_decklink_sink_com_thread (GstDecklinkSink * src)
+gst_decklink_sink_com_thread (GstDecklinkSink * sink)
 {
   HRESULT res;
 
-  g_mutex_lock (src->com_init_lock);
+  g_mutex_lock (sink->com_init_lock);
 
   /* Initialize COM with a MTA for this process. This thread will
    * be the first one to enter the apartement and the last one to leave
@@ -345,28 +382,29 @@ gst_decklink_sink_com_thread (GstDecklinkSink * src)
 
   res = CoInitializeEx (0, COINIT_MULTITHREADED);
   if (res == S_FALSE)
-    GST_WARNING_OBJECT (src, "COM has been already initialized in the same process");
+    GST_WARNING_OBJECT (sink,
+        "COM has been already initialized in the same process");
   else if (res == RPC_E_CHANGED_MODE)
-    GST_WARNING_OBJECT (src, "The concurrency model of COM has changed.");
+    GST_WARNING_OBJECT (sink, "The concurrency model of COM has changed.");
   else
-    GST_INFO_OBJECT (src, "COM intialized succesfully");
+    GST_INFO_OBJECT (sink, "COM intialized succesfully");
 
-  src->comInitialized = TRUE;
+  sink->comInitialized = TRUE;
 
   /* Signal other threads waiting on this condition that COM was initialized */
-  g_cond_signal (src->com_initialized);
+  g_cond_signal (sink->com_initialized);
 
-  g_mutex_unlock (src->com_init_lock);
+  g_mutex_unlock (sink->com_init_lock);
 
   /* Wait until the unitialize condition is met to leave the COM apartement */
-  g_mutex_lock (src->com_deinit_lock);
-  g_cond_wait (src->com_uninitialize, src->com_deinit_lock);
+  g_mutex_lock (sink->com_deinit_lock);
+  g_cond_wait (sink->com_uninitialize, sink->com_deinit_lock);
 
   CoUninitialize ();
-  GST_INFO_OBJECT (src, "COM unintialized succesfully");
-  src->comInitialized = FALSE;
-  g_cond_signal (src->com_uninitialized);
-  g_mutex_unlock (src->com_deinit_lock);
+  GST_INFO_OBJECT (sink, "COM unintialized succesfully");
+  sink->comInitialized = FALSE;
+  g_cond_signal (sink->com_uninitialized);
+  g_mutex_unlock (sink->com_deinit_lock);
 }
 #endif /* _MSC_VER */
 
@@ -400,7 +438,8 @@ gst_decklink_sink_finalize (GObject * object)
   if (decklinksink->comInitialized) {
     g_mutex_lock (decklinksink->com_deinit_lock);
     g_cond_signal (decklinksink->com_uninitialize);
-    g_cond_wait (decklinksink->com_uninitialized, decklinksink->com_deinit_lock);
+    g_cond_wait (decklinksink->com_uninitialized,
+        decklinksink->com_deinit_lock);
     g_mutex_unlock (decklinksink->com_deinit_lock);
   }
 
@@ -417,27 +456,19 @@ gst_decklink_sink_finalize (GObject * object)
 static gboolean
 gst_decklink_sink_start (GstDecklinkSink * decklinksink)
 {
-  IDeckLinkIterator *iterator;
   HRESULT ret;
   const GstDecklinkMode *mode;
   BMDAudioSampleType sample_depth;
 
-  iterator = CreateDeckLinkIteratorInstance ();
-  if (iterator == NULL) {
-    GST_ERROR ("no driver");
-    return FALSE;
-  }
-
-  ret = iterator->Next (&decklinksink->decklink);
-  if (ret != S_OK) {
-    GST_ERROR ("no card");
+  decklinksink->decklink = gst_decklink_get_nth_device (decklinksink->device);
+  if (decklinksink->decklink) {
     return FALSE;
   }
 
   ret = decklinksink->decklink->QueryInterface (IID_IDeckLinkOutput,
       (void **) &decklinksink->output);
   if (ret != S_OK) {
-    GST_ERROR ("no output");
+    GST_ERROR ("selected device does not have output interface");
     return FALSE;
   }
 
@@ -453,8 +484,8 @@ gst_decklink_sink_start (GstDecklinkSink * decklinksink)
   }
   //decklinksink->video_enabled = TRUE;
 
-  decklinksink->output->
-      SetScheduledFrameCompletionCallback (decklinksink->callback);
+  decklinksink->output->SetScheduledFrameCompletionCallback (decklinksink->
+      callback);
 
   sample_depth = bmdAudioSampleType16bitInteger;
   ret = decklinksink->output->EnableAudioOutput (bmdAudioSampleRate48kHz,
@@ -596,11 +627,24 @@ static gboolean
 gst_decklink_sink_videosink_setcaps (GstPad * pad, GstCaps * caps)
 {
   GstDecklinkSink *decklinksink;
+  gboolean ret;
+  GstVideoFormat format;
+  int width;
+  int height;
 
   decklinksink = GST_DECKLINK_SINK (gst_pad_get_parent (pad));
 
   GST_DEBUG_OBJECT (decklinksink, "setcaps");
 
+  ret = gst_video_format_parse_caps (caps, &format, &width, &height);
+  if (ret) {
+    if (format == GST_VIDEO_FORMAT_v210) {
+      decklinksink->pixel_format = bmdFormat10BitYUV;
+    } else {
+      decklinksink->pixel_format = bmdFormat8BitYUV;
+    }
+  }
+
 
   gst_object_unref (decklinksink);
   return TRUE;
@@ -713,7 +757,7 @@ gst_decklink_sink_videosink_chain (GstPad * pad, GstBuffer * buffer)
   mode = gst_decklink_get_mode (decklinksink->mode);
 
   decklinksink->output->CreateVideoFrame (mode->width,
-      mode->height, mode->width * 2, bmdFormat8BitYUV,
+      mode->height, mode->width * 2, decklinksink->pixel_format,
       bmdFrameFlagDefault, &frame);
 
   frame->GetBytes (&data);
@@ -864,7 +908,6 @@ gst_decklink_sink_audiosink_setcaps (GstPad * pad, GstCaps * caps)
 
   GST_DEBUG_OBJECT (decklinksink, "setcaps");
 
-
   gst_object_unref (decklinksink);
   return TRUE;
 }
@@ -1075,16 +1118,18 @@ HRESULT
   return S_OK;
 }
 
-HRESULT Output::ScheduledPlaybackHasStopped ()
+HRESULT
+Output::ScheduledPlaybackHasStopped ()
 {
   GST_ERROR ("ScheduledPlaybackHasStopped");
   return S_OK;
 }
 
-HRESULT Output::RenderAudioSamples (bool preroll)
+HRESULT
+Output::RenderAudioSamples (bool preroll)
 {
   uint32_t samplesWritten;
-  GstBuffer * buffer;
+  GstBuffer *buffer;
 
   // guint64 samplesToWrite;
 
@@ -1094,9 +1139,7 @@ HRESULT Output::RenderAudioSamples (bool preroll)
     // running = true;
   } else {
     g_mutex_lock (decklinksink->audio_mutex);
-    decklinksink->output->ScheduleAudioSamples (
-        GST_BUFFER_DATA (decklinksink->audio_buffer),
-        GST_BUFFER_SIZE (decklinksink->audio_buffer) / 4, // 2 bytes per sample, stereo
+    decklinksink->output->ScheduleAudioSamples (GST_BUFFER_DATA (decklinksink->audio_buffer), GST_BUFFER_SIZE (decklinksink->audio_buffer) / 4, // 2 bytes per sample, stereo
         0, 0, &samplesWritten);
 
     buffer =
@@ -1119,3 +1162,125 @@ HRESULT Output::RenderAudioSamples (bool preroll)
 
   return S_OK;
 }
+
+
+static const GList *
+gst_decklink_sink_probe_get_properties (GstPropertyProbe * probe)
+{
+  GObjectClass *klass = G_OBJECT_GET_CLASS (probe);
+  static GList *list = NULL;
+  static gsize init = 0;
+
+  if (g_once_init_enter (&init)) {
+    list = g_list_append (NULL, g_object_class_find_property (klass, "device"));
+
+    g_once_init_leave (&init, 1);
+  }
+
+  return list;
+}
+
+
+static gboolean probed = FALSE;
+static int n_devices;
+
+static void
+gst_decklink_sink_class_probe_devices (GstElementClass * klass)
+{
+  IDeckLinkIterator *iterator;
+  IDeckLink *decklink;
+
+  n_devices = 0;
+  iterator = CreateDeckLinkIteratorInstance ();
+  if (iterator) {
+    while (iterator->Next (&decklink) == S_OK) {
+      n_devices++;
+    }
+  }
+
+  probed = TRUE;
+}
+
+static void
+gst_decklink_sink_probe_probe_property (GstPropertyProbe * probe,
+    guint prop_id, const GParamSpec * pspec)
+{
+  GstElementClass *klass = GST_ELEMENT_GET_CLASS (probe);
+
+  switch (prop_id) {
+    case PROP_DEVICE:
+      gst_decklink_sink_class_probe_devices (klass);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (probe, prop_id, pspec);
+      break;
+  }
+}
+
+static gboolean
+gst_decklink_sink_probe_needs_probe (GstPropertyProbe * probe,
+    guint prop_id, const GParamSpec * pspec)
+{
+  gboolean ret = FALSE;
+
+  switch (prop_id) {
+    case PROP_DEVICE:
+      ret = !probed;
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (probe, prop_id, pspec);
+      break;
+  }
+  return ret;
+}
+
+static GValueArray *
+gst_decklink_sink_class_list_devices (GstElementClass * klass)
+{
+  GValueArray *array;
+  GValue value = {
+  0};
+  GList *item;
+  int i;
+
+  array = g_value_array_new (n_devices);
+  g_value_init (&value, G_TYPE_INT);
+  for (i = 0; i < n_devices; i++) {
+    g_value_set_int (&value, i);
+    g_value_array_append (array, &value);
+
+    item = item->next;
+  }
+  g_value_unset (&value);
+
+  return array;
+}
+
+static GValueArray *
+gst_decklink_sink_probe_get_values (GstPropertyProbe * probe,
+    guint prop_id, const GParamSpec * pspec)
+{
+  GstElementClass *klass = GST_ELEMENT_GET_CLASS (probe);
+  GValueArray *array = NULL;
+
+  switch (prop_id) {
+    case PROP_DEVICE:
+      array = gst_decklink_sink_class_list_devices (klass);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (probe, prop_id, pspec);
+      break;
+  }
+
+  return array;
+}
+
+static void
+gst_decklink_sink_property_probe_interface_init (GstPropertyProbeInterface *
+    iface)
+{
+  iface->get_properties = gst_decklink_sink_probe_get_properties;
+  iface->probe_property = gst_decklink_sink_probe_probe_property;
+  iface->needs_probe = gst_decklink_sink_probe_needs_probe;
+  iface->get_values = gst_decklink_sink_probe_get_values;
+}
diff --git a/sys/decklink/gstdecklinksink.h b/sys/decklink/gstdecklinksink.h
index b5f0700..20c47ed 100644
--- a/sys/decklink/gstdecklinksink.h
+++ b/sys/decklink/gstdecklinksink.h
@@ -67,6 +67,7 @@ struct _GstDecklinkSink
   IDeckLinkOutput *output;
   Output *callback;
   BMDDisplayMode display_mode;
+  BMDPixelFormat pixel_format;
   gboolean video_enabled;
   gboolean sched_started;
 
@@ -74,6 +75,7 @@ struct _GstDecklinkSink
 
   /* properties */
   GstDecklinkModeEnum mode;
+  int device;
 
 #ifdef _MSC_VER
   gboolean comInitialized;
diff --git a/sys/decklink/gstdecklinksrc.cpp b/sys/decklink/gstdecklinksrc.cpp
index b2e2c51..7108023 100644
--- a/sys/decklink/gstdecklinksrc.cpp
+++ b/sys/decklink/gstdecklinksrc.cpp
@@ -35,11 +35,18 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include "gstdecklink.h"
 #include "gstdecklinksrc.h"
 #include "capture.h"
 #include <string.h>
+#include <gst/interfaces/propertyprobe.h>
+
 
 GST_DEBUG_CATEGORY (gst_decklink_src_debug_category);
 #define GST_CAT_DEFAULT gst_decklink_src_debug_category
@@ -113,6 +120,10 @@ static gboolean gst_decklink_src_video_src_query (GstPad * pad,
     GstQuery * query);
 static GstIterator *gst_decklink_src_video_src_iterintlink (GstPad * pad);
 
+static void
+gst_decklinksrc_property_probe_interface_init (GstPropertyProbeInterface *
+    iface);
+
 static void gst_decklink_src_task (void *priv);
 
 #ifdef _MSC_VER
@@ -126,7 +137,7 @@ enum
   PROP_MODE,
   PROP_CONNECTION,
   PROP_AUDIO_INPUT,
-  PROP_SUBDEVICE
+  PROP_DEVICE
 };
 
 /* pad templates */
@@ -142,12 +153,24 @@ GST_STATIC_PAD_TEMPLATE ("audiosrc",
 
 /* class initialization */
 
-#define DEBUG_INIT(bla) \
-  GST_DEBUG_CATEGORY_INIT (gst_decklink_src_debug_category, "decklinksrc", 0, \
+static void
+gst_decklinksrc_init_interfaces (GType type)
+{
+  static const GInterfaceInfo decklinksrc_propertyprobe_info = {
+    (GInterfaceInitFunc) gst_decklinksrc_property_probe_interface_init,
+    NULL,
+    NULL,
+  };
+
+  GST_DEBUG_CATEGORY_INIT (gst_decklink_src_debug_category, "decklinksrc", 0,
       "debug category for decklinksrc element");
 
+  g_type_add_interface_static (type, GST_TYPE_PROPERTY_PROBE,
+      &decklinksrc_propertyprobe_info);
+}
+
 GST_BOILERPLATE_FULL (GstDecklinkSrc, gst_decklink_src, GstElement,
-    GST_TYPE_ELEMENT, DEBUG_INIT);
+    GST_TYPE_ELEMENT, gst_decklinksrc_init_interfaces);
 
 static void
 gst_decklink_src_base_init (gpointer g_class)
@@ -191,27 +214,29 @@ gst_decklink_src_class_init (GstDecklinkSrcClass * klass)
   element_class->query = GST_DEBUG_FUNCPTR (gst_decklink_src_query);
 
   g_object_class_install_property (gobject_class, PROP_MODE,
-      g_param_spec_enum ("mode", "Mode", "Mode",
+      g_param_spec_enum ("mode", "Mode", "Video Mode to use for capture",
           GST_TYPE_DECKLINK_MODE, GST_DECKLINK_MODE_NTSC,
           (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
               G_PARAM_CONSTRUCT)));
 
   g_object_class_install_property (gobject_class, PROP_CONNECTION,
-      g_param_spec_enum ("connection", "Connection", "Connection",
+      g_param_spec_enum ("connection", "Connection",
+          "Video Input Connection to use",
           GST_TYPE_DECKLINK_CONNECTION, GST_DECKLINK_CONNECTION_SDI,
           (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
               G_PARAM_CONSTRUCT)));
 
   g_object_class_install_property (gobject_class, PROP_AUDIO_INPUT,
-      g_param_spec_enum ("audio-input", "Audio Input", "Audio Input Connection",
+      g_param_spec_enum ("audio-input", "Audio Input",
+          "Audio Input Connection",
           GST_TYPE_DECKLINK_AUDIO_CONNECTION,
           GST_DECKLINK_AUDIO_CONNECTION_AUTO,
           (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
               G_PARAM_CONSTRUCT)));
 
-  g_object_class_install_property (gobject_class, PROP_SUBDEVICE,
-      g_param_spec_int ("subdevice", "Subdevice", "Subdevice",
-          0, 3, 0,
+  g_object_class_install_property (gobject_class, PROP_DEVICE,
+      g_param_spec_int ("device", "Device", "Capture device instance to use",
+          0, G_MAXINT, 0,
           (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
               G_PARAM_CONSTRUCT)));
 }
@@ -292,25 +317,25 @@ gst_decklink_src_init (GstDecklinkSrc * decklinksrc,
   decklinksrc->mode = GST_DECKLINK_MODE_NTSC;
   decklinksrc->connection = GST_DECKLINK_CONNECTION_SDI;
   decklinksrc->audio_connection = GST_DECKLINK_AUDIO_CONNECTION_AUTO;
-  decklinksrc->subdevice = 0;
+  decklinksrc->device = 0;
 
   decklinksrc->stop = FALSE;
   decklinksrc->dropped_frames = 0;
   decklinksrc->dropped_frames_old = 0;
-  decklinksrc->frame_num = -1; /* -1 so will be 0 after incrementing */
+  decklinksrc->frame_num = -1;  /* -1 so will be 0 after incrementing */
 
 #ifdef _MSC_VER
-  decklinksrc->com_init_lock = g_mutex_new();
-  decklinksrc->com_deinit_lock = g_mutex_new();
-  decklinksrc->com_initialized = g_cond_new();
-  decklinksrc->com_uninitialize = g_cond_new();
-  decklinksrc->com_uninitialized = g_cond_new();
+  decklinksrc->com_init_lock = g_mutex_new ();
+  decklinksrc->com_deinit_lock = g_mutex_new ();
+  decklinksrc->com_initialized = g_cond_new ();
+  decklinksrc->com_uninitialize = g_cond_new ();
+  decklinksrc->com_uninitialized = g_cond_new ();
 
   g_mutex_lock (decklinksrc->com_init_lock);
 
   /* create the COM initialization thread */
-  g_thread_create ((GThreadFunc)gst_decklink_src_com_thread,
-    decklinksrc, FALSE, NULL);
+  g_thread_create ((GThreadFunc) gst_decklink_src_com_thread,
+      decklinksrc, FALSE, NULL);
 
   /* wait until the COM thread signals that COM has been initialized */
   g_cond_wait (decklinksrc->com_initialized, decklinksrc->com_init_lock);
@@ -339,8 +364,8 @@ gst_decklink_src_set_property (GObject * object, guint property_id,
       decklinksrc->audio_connection =
           (GstDecklinkAudioConnectionEnum) g_value_get_enum (value);
       break;
-    case PROP_SUBDEVICE:
-      decklinksrc->subdevice = g_value_get_int (value);
+    case PROP_DEVICE:
+      decklinksrc->device = g_value_get_int (value);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
@@ -367,8 +392,8 @@ gst_decklink_src_get_property (GObject * object, guint property_id,
     case PROP_AUDIO_INPUT:
       g_value_set_enum (value, decklinksrc->audio_connection);
       break;
-    case PROP_SUBDEVICE:
-      g_value_set_int (value, decklinksrc->subdevice);
+    case PROP_DEVICE:
+      g_value_set_int (value, decklinksrc->device);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
@@ -390,7 +415,8 @@ gst_decklink_src_com_thread (GstDecklinkSrc * src)
 
   res = CoInitializeEx (0, COINIT_MULTITHREADED);
   if (res == S_FALSE)
-    GST_WARNING_OBJECT (src, "COM has been already initialized in the same process");
+    GST_WARNING_OBJECT (src,
+        "COM has been already initialized in the same process");
   else if (res == RPC_E_CHANGED_MODE)
     GST_WARNING_OBJECT (src, "The concurrency model of COM has changed.");
   else
@@ -445,7 +471,6 @@ gst_decklink_src_finalize (GObject * object)
   if (decklinksrc->video_caps) {
     gst_caps_unref (decklinksrc->video_caps);
   }
-
 #ifdef _MSC_VER
   /* signal the COM thread that it should uninitialize COM */
   if (decklinksrc->comInitialized) {
@@ -485,7 +510,6 @@ static gboolean
 gst_decklink_src_start (GstElement * element)
 {
   GstDecklinkSrc *decklinksrc = GST_DECKLINK_SRC (element);
-  IDeckLinkIterator *iterator;
   DeckLinkCaptureDelegate *delegate;
   //IDeckLinkDisplayModeIterator *mode_iterator;
   //IDeckLinkDisplayMode *mode;
@@ -496,33 +520,18 @@ gst_decklink_src_start (GstElement * element)
   IDeckLinkConfiguration *config;
   BMDVideoConnection conn;
   BMDAudioConnection aconn;
-  int i;
 
   GST_DEBUG_OBJECT (decklinksrc, "start");
 
-  iterator = CreateDeckLinkIteratorInstance ();
-  if (iterator == NULL) {
-    GST_ERROR ("no driver");
-    return FALSE;
-  }
-
-  ret = iterator->Next (&decklinksrc->decklink);
-  if (ret != S_OK) {
-    GST_ERROR ("no card");
+  decklinksrc->decklink = gst_decklink_get_nth_device (decklinksrc->device);
+  if (decklinksrc->decklink == NULL) {
     return FALSE;
   }
-  for (i = 0; i < decklinksrc->subdevice; i++) {
-    ret = iterator->Next (&decklinksrc->decklink);
-    if (ret != S_OK) {
-      GST_ERROR ("no card");
-      return FALSE;
-    }
-  }
 
   ret = decklinksrc->decklink->QueryInterface (IID_IDeckLinkInput,
       (void **) &decklinksrc->input);
   if (ret != S_OK) {
-    GST_ERROR ("query interface failed");
+    GST_ERROR ("selected device does not have input interface");
     return FALSE;
   }
 
@@ -670,6 +679,9 @@ gst_decklink_src_stop (GstElement * element)
   decklinksrc->input->Release ();
   decklinksrc->input = NULL;
 
+  decklinksrc->decklink->Release ();
+  decklinksrc->decklink = NULL;
+
   return TRUE;
 }
 
@@ -757,8 +769,18 @@ gst_decklink_src_send_event (GstElement * element, GstEvent * event)
 static gboolean
 gst_decklink_src_query (GstElement * element, GstQuery * query)
 {
+  GstDecklinkSrc *decklinksrc = GST_DECKLINK_SRC (element);
+  gboolean ret;
 
-  return FALSE;
+  GST_DEBUG_OBJECT (decklinksrc, "query");
+
+  switch (GST_QUERY_TYPE (query)) {
+    default:
+      ret = GST_ELEMENT_CLASS (parent_class)->query (element, query);
+      break;
+  }
+
+  return ret;
 }
 
 static GstCaps *
@@ -781,28 +803,39 @@ static gboolean
 gst_decklink_src_audio_src_setcaps (GstPad * pad, GstCaps * caps)
 {
   GstDecklinkSrc *decklinksrc;
+  GstCaps *pad_caps;
+  gboolean can_intersect;
 
   decklinksrc = GST_DECKLINK_SRC (gst_pad_get_parent (pad));
 
+  pad_caps = gst_pad_get_caps_reffed (pad);
+  can_intersect = gst_caps_can_intersect (pad_caps, caps);
+  gst_caps_unref (pad_caps);
+
   GST_DEBUG_OBJECT (decklinksrc, "setcaps");
 
 
   gst_object_unref (decklinksrc);
-  return TRUE;
+  return can_intersect;
 }
 
 static gboolean
 gst_decklink_src_audio_src_acceptcaps (GstPad * pad, GstCaps * caps)
 {
   GstDecklinkSrc *decklinksrc;
+  GstCaps *pad_caps;
+  gboolean can_intersect;
 
   decklinksrc = GST_DECKLINK_SRC (gst_pad_get_parent (pad));
 
-  GST_DEBUG_OBJECT (decklinksrc, "acceptcaps");
+  pad_caps = gst_pad_get_caps_reffed (pad);
+  can_intersect = gst_caps_can_intersect (pad_caps, caps);
+  gst_caps_unref (pad_caps);
 
+  GST_DEBUG_OBJECT (decklinksrc, "acceptcaps");
 
   gst_object_unref (decklinksrc);
-  return TRUE;
+  return can_intersect;
 }
 
 static void
@@ -863,9 +896,8 @@ gst_decklink_src_audio_src_activatepull (GstPad * pad, gboolean active)
 
   GST_DEBUG_OBJECT (decklinksrc, "activatepull");
 
-
   gst_object_unref (decklinksrc);
-  return TRUE;
+  return FALSE;
 }
 
 static GstPadLinkReturn
@@ -974,28 +1006,39 @@ static gboolean
 gst_decklink_src_video_src_setcaps (GstPad * pad, GstCaps * caps)
 {
   GstDecklinkSrc *decklinksrc;
+  GstCaps *mode_caps;
+  gboolean can_intersect;
 
   decklinksrc = GST_DECKLINK_SRC (gst_pad_get_parent (pad));
 
   GST_DEBUG_OBJECT (decklinksrc, "setcaps");
 
+  mode_caps = gst_decklink_mode_get_caps (decklinksrc->mode);
+  can_intersect = gst_caps_can_intersect (mode_caps, caps);
+  gst_caps_unref (mode_caps);
 
   gst_object_unref (decklinksrc);
-  return TRUE;
+  return can_intersect;
 }
 
 static gboolean
 gst_decklink_src_video_src_acceptcaps (GstPad * pad, GstCaps * caps)
 {
   GstDecklinkSrc *decklinksrc;
+  GstCaps *mode_caps;
+  gboolean can_intersect;
+
 
   decklinksrc = GST_DECKLINK_SRC (gst_pad_get_parent (pad));
 
   GST_DEBUG_OBJECT (decklinksrc, "acceptcaps");
 
+  mode_caps = gst_decklink_mode_get_caps (decklinksrc->mode);
+  can_intersect = gst_caps_can_intersect (mode_caps, caps);
+  gst_caps_unref (mode_caps);
 
   gst_object_unref (decklinksrc);
-  return TRUE;
+  return can_intersect;
 }
 
 static void
@@ -1058,7 +1101,7 @@ gst_decklink_src_video_src_activatepull (GstPad * pad, gboolean active)
 
 
   gst_object_unref (decklinksrc);
-  return TRUE;
+  return FALSE;
 }
 
 static GstPadLinkReturn
@@ -1113,7 +1156,7 @@ gst_decklink_src_video_src_event (GstPad * pad, GstEvent * event)
 static gboolean
 gst_decklink_src_video_src_query (GstPad * pad, GstQuery * query)
 {
-  gboolean res;
+  gboolean ret;
   GstDecklinkSrc *decklinksrc;
 
   decklinksrc = GST_DECKLINK_SRC (gst_pad_get_parent (pad));
@@ -1121,13 +1164,45 @@ gst_decklink_src_video_src_query (GstPad * pad, GstQuery * query)
   GST_DEBUG_OBJECT (decklinksrc, "query");
 
   switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_LATENCY:{
+      GstClockTime min_latency, max_latency;
+      const GstDecklinkMode *mode;
+
+      /* device must be open */
+      if (decklinksrc->decklink == NULL) {
+        GST_WARNING_OBJECT (decklinksrc,
+            "Can't give latency since device isn't open !");
+        goto done;
+      }
+
+      mode = gst_decklink_get_mode (decklinksrc->mode);
+
+      /* min latency is the time to capture one frame */
+      min_latency =
+          gst_util_uint64_scale_int (GST_SECOND, mode->fps_d, mode->fps_n);
+
+      /* max latency is total duration of the frame buffer */
+      max_latency = 2 * min_latency;
+
+      GST_DEBUG_OBJECT (decklinksrc,
+          "report latency min %" GST_TIME_FORMAT " max %" GST_TIME_FORMAT,
+          GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
+
+      /* we are always live, the min latency is 1 frame and the max latency is
+       * the complete buffer of frames. */
+      gst_query_set_latency (query, TRUE, min_latency, max_latency);
+
+      ret = TRUE;
+      break;
+    }
     default:
-      res = gst_pad_query_default (pad, query);
+      ret = gst_pad_query_default (pad, query);
       break;
   }
 
+done:
   gst_object_unref (decklinksrc);
-  return res;
+  return ret;
 }
 
 static GstIterator *
@@ -1188,10 +1263,9 @@ gst_decklink_src_task (void *priv)
   /* warning on dropped frames */
   if (decklinksrc->dropped_frames - decklinksrc->dropped_frames_old > 0) {
     GST_ELEMENT_WARNING (decklinksrc, RESOURCE, READ,
-                         ("Dropped %d frame(s), for a total of %d frame(s)",
-                          decklinksrc->dropped_frames - decklinksrc->dropped_frames_old,
-                          decklinksrc->dropped_frames),
-                         (NULL));
+        ("Dropped %d frame(s), for a total of %d frame(s)",
+            decklinksrc->dropped_frames - decklinksrc->dropped_frames_old,
+            decklinksrc->dropped_frames), (NULL));
     decklinksrc->dropped_frames_old = decklinksrc->dropped_frames;
   }
 
@@ -1231,11 +1305,28 @@ gst_decklink_src_task (void *priv)
     event = gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME, 0,
         GST_CLOCK_TIME_NONE, 0);
 
-    ret = gst_pad_push_event (decklinksrc->videosrcpad, event);
-    if (!ret) {
-      GST_ERROR_OBJECT (decklinksrc, "new segment event ret=%d", ret);
-      return;
+    if (gst_pad_is_linked (decklinksrc->videosrcpad)) {
+      gst_event_ref (event);
+      ret = gst_pad_push_event (decklinksrc->videosrcpad, event);
+      if (!ret) {
+        GST_ERROR_OBJECT (decklinksrc, "new segment event ret=%d", ret);
+        gst_event_unref (event);
+        return;
+      }
+    } else {
+      gst_event_unref (event);
     }
+
+    if (gst_pad_is_linked (decklinksrc->audiosrcpad)) {
+      ret = gst_pad_push_event (decklinksrc->audiosrcpad, event);
+      if (!ret) {
+        GST_ERROR_OBJECT (decklinksrc, "new segment event ret=%d", ret);
+        gst_event_unref (event);
+      }
+    } else {
+      gst_event_unref (event);
+    }
+
   }
 
   if (decklinksrc->video_caps == NULL) {
@@ -1244,8 +1335,11 @@ gst_decklink_src_task (void *priv)
   gst_buffer_set_caps (buffer, decklinksrc->video_caps);
 
   ret = gst_pad_push (decklinksrc->videosrcpad, buffer);
-  if (ret != GST_FLOW_OK) {
-    GST_ELEMENT_ERROR (decklinksrc, CORE, NEGOTIATION, (NULL), (NULL));
+  if (!(ret == GST_FLOW_OK || ret == GST_FLOW_NOT_LINKED ||
+          ret == GST_FLOW_WRONG_STATE)) {
+    GST_ELEMENT_ERROR (decklinksrc, STREAM, FAILED,
+        ("Internal data stream error."),
+        ("stream stopped, reason %s", gst_flow_get_name (ret)));
   }
 
   if (gst_pad_is_linked (decklinksrc->audiosrcpad)) {
@@ -1258,9 +1352,7 @@ gst_decklink_src_task (void *priv)
         gst_util_uint64_scale_int (decklinksrc->num_audio_samples * GST_SECOND,
         1, 48000);
     GST_BUFFER_DURATION (audio_buffer) =
-        gst_util_uint64_scale_int ((decklinksrc->num_audio_samples +
-            n_samples) * GST_SECOND, 1,
-        48000) - GST_BUFFER_TIMESTAMP (audio_buffer);
+        gst_util_uint64_scale_int (n_samples * GST_SECOND, 1, 48000);
     decklinksrc->num_audio_samples += n_samples;
 
     if (decklinksrc->audio_caps == NULL) {
@@ -1274,9 +1366,132 @@ gst_decklink_src_task (void *priv)
     gst_buffer_set_caps (audio_buffer, decklinksrc->audio_caps);
 
     ret = gst_pad_push (decklinksrc->audiosrcpad, audio_buffer);
-    if (ret != GST_FLOW_OK) {
-      GST_ELEMENT_ERROR (decklinksrc, CORE, NEGOTIATION, (NULL), (NULL));
+    if (!(ret == GST_FLOW_OK || ret == GST_FLOW_NOT_LINKED ||
+            ret == GST_FLOW_WRONG_STATE)) {
+      GST_ELEMENT_ERROR (decklinksrc, STREAM, FAILED,
+          ("Internal data stream error."),
+          ("stream stopped, reason %s", gst_flow_get_name (ret)));
     }
   }
   audio_frame->Release ();
 }
+
+
+static const GList *
+gst_decklinksrc_probe_get_properties (GstPropertyProbe * probe)
+{
+  GObjectClass *klass = G_OBJECT_GET_CLASS (probe);
+  static GList *list = NULL;
+  static gsize init = 0;
+
+  if (g_once_init_enter (&init)) {
+    list = g_list_append (NULL, g_object_class_find_property (klass, "device"));
+
+    g_once_init_leave (&init, 1);
+  }
+
+  return list;
+}
+
+static gboolean probed = FALSE;
+static int n_devices;
+
+static void
+gst_decklinksrc_class_probe_devices (GstElementClass * klass)
+{
+  IDeckLinkIterator *iterator;
+  IDeckLink *decklink;
+
+  n_devices = 0;
+  iterator = CreateDeckLinkIteratorInstance ();
+  if (iterator) {
+    while (iterator->Next (&decklink) == S_OK) {
+      n_devices++;
+    }
+  }
+
+  probed = TRUE;
+}
+
+static void
+gst_decklinksrc_probe_probe_property (GstPropertyProbe * probe,
+    guint prop_id, const GParamSpec * pspec)
+{
+  GstElementClass *klass = GST_ELEMENT_GET_CLASS (probe);
+
+  switch (prop_id) {
+    case PROP_DEVICE:
+      gst_decklinksrc_class_probe_devices (klass);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (probe, prop_id, pspec);
+      break;
+  }
+}
+
+static gboolean
+gst_decklinksrc_probe_needs_probe (GstPropertyProbe * probe,
+    guint prop_id, const GParamSpec * pspec)
+{
+  gboolean ret = FALSE;
+
+  switch (prop_id) {
+    case PROP_DEVICE:
+      ret = !probed;
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (probe, prop_id, pspec);
+      break;
+  }
+  return ret;
+}
+
+static GValueArray *
+gst_decklinksrc_class_list_devices (GstElementClass * klass)
+{
+  GValueArray *array;
+  GValue value = { 0 };
+  GList *item;
+  int i;
+
+  array = g_value_array_new (n_devices);
+  g_value_init (&value, G_TYPE_INT);
+  for (i = 0; i < n_devices; i++) {
+    g_value_set_int (&value, i);
+    g_value_array_append (array, &value);
+
+    item = item->next;
+  }
+  g_value_unset (&value);
+
+  return array;
+}
+
+static GValueArray *
+gst_decklinksrc_probe_get_values (GstPropertyProbe * probe,
+    guint prop_id, const GParamSpec * pspec)
+{
+  GstElementClass *klass = GST_ELEMENT_GET_CLASS (probe);
+  GValueArray *array = NULL;
+
+  switch (prop_id) {
+    case PROP_DEVICE:
+      array = gst_decklinksrc_class_list_devices (klass);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (probe, prop_id, pspec);
+      break;
+  }
+
+  return array;
+}
+
+static void
+gst_decklinksrc_property_probe_interface_init (GstPropertyProbeInterface *
+    iface)
+{
+  iface->get_properties = gst_decklinksrc_probe_get_properties;
+  iface->probe_property = gst_decklinksrc_probe_probe_property;
+  iface->needs_probe = gst_decklinksrc_probe_needs_probe;
+  iface->get_values = gst_decklinksrc_probe_get_values;
+}
diff --git a/sys/decklink/gstdecklinksrc.h b/sys/decklink/gstdecklinksrc.h
index 69dea49..c47279a 100644
--- a/sys/decklink/gstdecklinksrc.h
+++ b/sys/decklink/gstdecklinksrc.h
@@ -73,7 +73,7 @@ struct _GstDecklinkSrc
   GstDecklinkModeEnum mode;
   GstDecklinkConnectionEnum connection;
   GstDecklinkAudioConnectionEnum audio_connection;
-  int subdevice;
+  int device;
 
 #ifdef _MSC_VER
   gboolean comInitialized;
diff --git a/sys/decklink/osx/DeckLinkAPI.h b/sys/decklink/osx/DeckLinkAPI.h
new file mode 100644
index 0000000..b629369
--- /dev/null
+++ b/sys/decklink/osx/DeckLinkAPI.h
@@ -0,0 +1,695 @@
+/* -LICENSE-START-
+** Copyright (c) 2011 Blackmagic Design
+**
+** Permission is hereby granted, free of charge, to any person or organization
+** obtaining a copy of the software and accompanying documentation covered by
+** this license (the "Software") to use, reproduce, display, distribute,
+** execute, and transmit the Software, and to prepare derivative works of the
+** Software, and to permit third-parties to whom the Software is furnished to
+** do so, all subject to the following:
+** 
+** The copyright notices in the Software and this entire statement, including
+** the above license grant, this restriction and the following disclaimer,
+** must be included in all copies of the Software, in whole or in part, and
+** all derivative works of the Software, unless such copies or derivative
+** works are solely in the form of machine-executable object code generated by
+** a source language processor.
+** 
+** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+** DEALINGS IN THE SOFTWARE.
+** -LICENSE-END-
+*/
+
+#ifndef BMD_DECKLINKAPI_H
+#define BMD_DECKLINKAPI_H
+
+/* DeckLink API */
+
+#include <CoreFoundation/CoreFoundation.h>
+#include <CoreFoundation/CFPlugInCOM.h>
+#include <stdint.h>
+
+#include "DeckLinkAPITypes.h"
+#include "DeckLinkAPIModes.h"
+#include "DeckLinkAPIDiscovery.h"
+#include "DeckLinkAPIConfiguration.h"
+#include "DeckLinkAPIDeckControl.h"
+
+#include "DeckLinkAPIStreaming.h"
+
+#define BLACKMAGIC_DECKLINK_API_MAGIC	1
+
+// Type Declarations
+
+
+// Interface ID Declarations
+
+#define IID_IDeckLinkVideoOutputCallback                 /* 20AA5225-1958-47CB-820B-80A8D521A6EE */ (REFIID){0x20,0xAA,0x52,0x25,0x19,0x58,0x47,0xCB,0x82,0x0B,0x80,0xA8,0xD5,0x21,0xA6,0xEE}
+#define IID_IDeckLinkInputCallback                       /* DD04E5EC-7415-42AB-AE4A-E80C4DFC044A */ (REFIID){0xDD,0x04,0xE5,0xEC,0x74,0x15,0x42,0xAB,0xAE,0x4A,0xE8,0x0C,0x4D,0xFC,0x04,0x4A}
+#define IID_IDeckLinkMemoryAllocator                     /* B36EB6E7-9D29-4AA8-92EF-843B87A289E8 */ (REFIID){0xB3,0x6E,0xB6,0xE7,0x9D,0x29,0x4A,0xA8,0x92,0xEF,0x84,0x3B,0x87,0xA2,0x89,0xE8}
+#define IID_IDeckLinkAudioOutputCallback                 /* 403C681B-7F46-4A12-B993-2BB127084EE6 */ (REFIID){0x40,0x3C,0x68,0x1B,0x7F,0x46,0x4A,0x12,0xB9,0x93,0x2B,0xB1,0x27,0x08,0x4E,0xE6}
+#define IID_IDeckLinkIterator                            /* 50FB36CD-3063-4B73-BDBB-958087F2D8BA */ (REFIID){0x50,0xFB,0x36,0xCD,0x30,0x63,0x4B,0x73,0xBD,0xBB,0x95,0x80,0x87,0xF2,0xD8,0xBA}
+#define IID_IDeckLinkAPIInformation                      /* 7BEA3C68-730D-4322-AF34-8A7152B532A4 */ (REFIID){0x7B,0xEA,0x3C,0x68,0x73,0x0D,0x43,0x22,0xAF,0x34,0x8A,0x71,0x52,0xB5,0x32,0xA4}
+#define IID_IDeckLinkOutput                              /* A3EF0963-0862-44ED-92A9-EE89ABF431C7 */ (REFIID){0xA3,0xEF,0x09,0x63,0x08,0x62,0x44,0xED,0x92,0xA9,0xEE,0x89,0xAB,0xF4,0x31,0xC7}
+#define IID_IDeckLinkInput                               /* 6D40EF78-28B9-4E21-990D-95BB7750A04F */ (REFIID){0x6D,0x40,0xEF,0x78,0x28,0xB9,0x4E,0x21,0x99,0x0D,0x95,0xBB,0x77,0x50,0xA0,0x4F}
+#define IID_IDeckLinkVideoFrame                          /* 3F716FE0-F023-4111-BE5D-EF4414C05B17 */ (REFIID){0x3F,0x71,0x6F,0xE0,0xF0,0x23,0x41,0x11,0xBE,0x5D,0xEF,0x44,0x14,0xC0,0x5B,0x17}
+#define IID_IDeckLinkMutableVideoFrame                   /* 69E2639F-40DA-4E19-B6F2-20ACE815C390 */ (REFIID){0x69,0xE2,0x63,0x9F,0x40,0xDA,0x4E,0x19,0xB6,0xF2,0x20,0xAC,0xE8,0x15,0xC3,0x90}
+#define IID_IDeckLinkVideoFrame3DExtensions              /* DA0F7E4A-EDC7-48A8-9CDD-2DB51C729CD7 */ (REFIID){0xDA,0x0F,0x7E,0x4A,0xED,0xC7,0x48,0xA8,0x9C,0xDD,0x2D,0xB5,0x1C,0x72,0x9C,0xD7}
+#define IID_IDeckLinkVideoInputFrame                     /* 05CFE374-537C-4094-9A57-680525118F44 */ (REFIID){0x05,0xCF,0xE3,0x74,0x53,0x7C,0x40,0x94,0x9A,0x57,0x68,0x05,0x25,0x11,0x8F,0x44}
+#define IID_IDeckLinkVideoFrameAncillary                 /* 732E723C-D1A4-4E29-9E8E-4A88797A0004 */ (REFIID){0x73,0x2E,0x72,0x3C,0xD1,0xA4,0x4E,0x29,0x9E,0x8E,0x4A,0x88,0x79,0x7A,0x00,0x04}
+#define IID_IDeckLinkAudioInputPacket                    /* E43D5870-2894-11DE-8C30-0800200C9A66 */ (REFIID){0xE4,0x3D,0x58,0x70,0x28,0x94,0x11,0xDE,0x8C,0x30,0x08,0x00,0x20,0x0C,0x9A,0x66}
+#define IID_IDeckLinkScreenPreviewCallback               /* B1D3F49A-85FE-4C5D-95C8-0B5D5DCCD438 */ (REFIID){0xB1,0xD3,0xF4,0x9A,0x85,0xFE,0x4C,0x5D,0x95,0xC8,0x0B,0x5D,0x5D,0xCC,0xD4,0x38}
+#define IID_IDeckLinkCocoaScreenPreviewCallback          /* D174152F-8F96-4C07-83A5-DD5F5AF0A2AA */ (REFIID){0xD1,0x74,0x15,0x2F,0x8F,0x96,0x4C,0x07,0x83,0xA5,0xDD,0x5F,0x5A,0xF0,0xA2,0xAA}
+#define IID_IDeckLinkGLScreenPreviewHelper               /* 504E2209-CAC7-4C1A-9FB4-C5BB6274D22F */ (REFIID){0x50,0x4E,0x22,0x09,0xCA,0xC7,0x4C,0x1A,0x9F,0xB4,0xC5,0xBB,0x62,0x74,0xD2,0x2F}
+#define IID_IDeckLinkAttributes                          /* ABC11843-D966-44CB-96E2-A1CB5D3135C4 */ (REFIID){0xAB,0xC1,0x18,0x43,0xD9,0x66,0x44,0xCB,0x96,0xE2,0xA1,0xCB,0x5D,0x31,0x35,0xC4}
+#define IID_IDeckLinkKeyer                               /* 89AFCAF5-65F8-421E-98F7-96FE5F5BFBA3 */ (REFIID){0x89,0xAF,0xCA,0xF5,0x65,0xF8,0x42,0x1E,0x98,0xF7,0x96,0xFE,0x5F,0x5B,0xFB,0xA3}
+#define IID_IDeckLinkVideoConversion                     /* 3BBCB8A2-DA2C-42D9-B5D8-88083644E99A */ (REFIID){0x3B,0xBC,0xB8,0xA2,0xDA,0x2C,0x42,0xD9,0xB5,0xD8,0x88,0x08,0x36,0x44,0xE9,0x9A}
+
+/* Enum BMDVideoOutputFlags - Flags to control the output of ancillary data along with video. */
+
+typedef uint32_t BMDVideoOutputFlags;
+enum _BMDVideoOutputFlags {
+    bmdVideoOutputFlagDefault                                    = 0,
+    bmdVideoOutputVANC                                           = 1 << 0,
+    bmdVideoOutputVITC                                           = 1 << 1,
+    bmdVideoOutputRP188                                          = 1 << 2,
+    bmdVideoOutputDualStream3D                                   = 1 << 4
+};
+
+/* Enum BMDFrameFlags - Frame flags */
+
+typedef uint32_t BMDFrameFlags;
+enum _BMDFrameFlags {
+    bmdFrameFlagDefault                                          = 0,
+    bmdFrameFlagFlipVertical                                     = 1 << 0,
+
+    /* Flags that are applicable only to instances of IDeckLinkVideoInputFrame */
+
+    bmdFrameHasNoInputSource                                     = 1 << 31
+};
+
+/* Enum BMDVideoInputFlags - Flags applicable to video input */
+
+typedef uint32_t BMDVideoInputFlags;
+enum _BMDVideoInputFlags {
+    bmdVideoInputFlagDefault                                     = 0,
+    bmdVideoInputEnableFormatDetection                           = 1 << 0,
+    bmdVideoInputDualStream3D                                    = 1 << 1
+};
+
+/* Enum BMDVideoInputFormatChangedEvents - Bitmask passed to the VideoInputFormatChanged notification to identify the properties of the input signal that have changed */
+
+typedef uint32_t BMDVideoInputFormatChangedEvents;
+enum _BMDVideoInputFormatChangedEvents {
+    bmdVideoInputDisplayModeChanged                              = 1 << 0,
+    bmdVideoInputFieldDominanceChanged                           = 1 << 1,
+    bmdVideoInputColorspaceChanged                               = 1 << 2
+};
+
+/* Enum BMDDetectedVideoInputFormatFlags - Flags passed to the VideoInputFormatChanged notification to describe the detected video input signal */
+
+typedef uint32_t BMDDetectedVideoInputFormatFlags;
+enum _BMDDetectedVideoInputFormatFlags {
+    bmdDetectedVideoInputYCbCr422                                = 1 << 0,
+    bmdDetectedVideoInputRGB444                                  = 1 << 1
+};
+
+/* Enum BMDOutputFrameCompletionResult - Frame Completion Callback */
+
+typedef uint32_t BMDOutputFrameCompletionResult;
+enum _BMDOutputFrameCompletionResult {
+    bmdOutputFrameCompleted,                                    
+    bmdOutputFrameDisplayedLate,                                
+    bmdOutputFrameDropped,                                      
+    bmdOutputFrameFlushed                                       
+};
+
+/* Enum BMDReferenceStatus - GenLock input status */
+
+typedef uint32_t BMDReferenceStatus;
+enum _BMDReferenceStatus {
+    bmdReferenceNotSupportedByHardware                           = 1 << 0,
+    bmdReferenceLocked                                           = 1 << 1
+};
+
+/* Enum BMDAudioSampleRate - Audio sample rates supported for output/input */
+
+typedef uint32_t BMDAudioSampleRate;
+enum _BMDAudioSampleRate {
+    bmdAudioSampleRate48kHz                                      = 48000
+};
+
+/* Enum BMDAudioSampleType - Audio sample sizes supported for output/input */
+
+typedef uint32_t BMDAudioSampleType;
+enum _BMDAudioSampleType {
+    bmdAudioSampleType16bitInteger                               = 16,
+    bmdAudioSampleType32bitInteger                               = 32
+};
+
+/* Enum BMDAudioOutputStreamType - Audio output stream type */
+
+typedef uint32_t BMDAudioOutputStreamType;
+enum _BMDAudioOutputStreamType {
+    bmdAudioOutputStreamContinuous,                             
+    bmdAudioOutputStreamContinuousDontResample,                 
+    bmdAudioOutputStreamTimestamped                             
+};
+
+/* Enum BMDDisplayModeSupport - Output mode supported flags */
+
+typedef uint32_t BMDDisplayModeSupport;
+enum _BMDDisplayModeSupport {
+    bmdDisplayModeNotSupported                                   = 0,
+    bmdDisplayModeSupported,                                    
+    bmdDisplayModeSupportedWithConversion                       
+};
+
+/* Enum BMDTimecodeFormat - Timecode formats for frame metadata */
+
+typedef uint32_t BMDTimecodeFormat;
+enum _BMDTimecodeFormat {
+    bmdTimecodeRP188VITC1                                        = 'rpv1',	// RP188 timecode where DBB1 equals VITC1 (line 9)
+    bmdTimecodeRP188VITC2                                        = 'rp12',	// RP188 timecode where DBB1 equals VITC2 (line 571)
+    bmdTimecodeRP188LTC                                          = 'rplt',	// RP188 timecode where DBB1 equals LTC (line 10)
+    bmdTimecodeRP188Any                                          = 'rp18',	// For capture: return the first valid timecode in {VITC1, LTC ,VITC2} - For playback: set the timecode as VITC1
+    bmdTimecodeVITC                                              = 'vitc',
+    bmdTimecodeVITCField2                                        = 'vit2',
+    bmdTimecodeSerial                                            = 'seri'
+};
+
+/* Enum BMDAnalogVideoFlags - Analog video display flags */
+
+typedef uint32_t BMDAnalogVideoFlags;
+enum _BMDAnalogVideoFlags {
+    bmdAnalogVideoFlagCompositeSetup75                           = 1 << 0,
+    bmdAnalogVideoFlagComponentBetacamLevels                     = 1 << 1
+};
+
+/* Enum BMDAudioConnection - Audio connection types */
+
+typedef uint32_t BMDAudioConnection;
+enum _BMDAudioConnection {
+    bmdAudioConnectionEmbedded                                   = 'embd',
+    bmdAudioConnectionAESEBU                                     = 'aes ',
+    bmdAudioConnectionAnalog                                     = 'anlg'
+};
+
+/* Enum BMDAudioOutputAnalogAESSwitch - Audio output Analog/AESEBU switch */
+
+typedef uint32_t BMDAudioOutputAnalogAESSwitch;
+enum _BMDAudioOutputAnalogAESSwitch {
+    bmdAudioOutputSwitchAESEBU                                   = 'aes ',
+    bmdAudioOutputSwitchAnalog                                   = 'anlg'
+};
+
+/* Enum BMDVideoOutputConversionMode - Video/audio conversion mode */
+
+typedef uint32_t BMDVideoOutputConversionMode;
+enum _BMDVideoOutputConversionMode {
+    bmdNoVideoOutputConversion                                   = 'none',
+    bmdVideoOutputLetterboxDownconversion                        = 'ltbx',
+    bmdVideoOutputAnamorphicDownconversion                       = 'amph',
+    bmdVideoOutputHD720toHD1080Conversion                        = '720c',
+    bmdVideoOutputHardwareLetterboxDownconversion                = 'HWlb',
+    bmdVideoOutputHardwareAnamorphicDownconversion               = 'HWam',
+    bmdVideoOutputHardwareCenterCutDownconversion                = 'HWcc',
+    bmdVideoOutputHardware720p1080pCrossconversion               = 'xcap',
+    bmdVideoOutputHardwareAnamorphic720pUpconversion             = 'ua7p',
+    bmdVideoOutputHardwareAnamorphic1080iUpconversion            = 'ua1i',
+    bmdVideoOutputHardwareAnamorphic149To720pUpconversion        = 'u47p',
+    bmdVideoOutputHardwareAnamorphic149To1080iUpconversion       = 'u41i',
+    bmdVideoOutputHardwarePillarbox720pUpconversion              = 'up7p',
+    bmdVideoOutputHardwarePillarbox1080iUpconversion             = 'up1i'
+};
+
+/* Enum BMDVideoInputConversionMode - Video input conversion mode */
+
+typedef uint32_t BMDVideoInputConversionMode;
+enum _BMDVideoInputConversionMode {
+    bmdNoVideoInputConversion                                    = 'none',
+    bmdVideoInputLetterboxDownconversionFromHD1080               = '10lb',
+    bmdVideoInputAnamorphicDownconversionFromHD1080              = '10am',
+    bmdVideoInputLetterboxDownconversionFromHD720                = '72lb',
+    bmdVideoInputAnamorphicDownconversionFromHD720               = '72am',
+    bmdVideoInputLetterboxUpconversion                           = 'lbup',
+    bmdVideoInputAnamorphicUpconversion                          = 'amup'
+};
+
+/* Enum BMDVideo3DPackingFormat - Video 3D packing format */
+
+typedef uint32_t BMDVideo3DPackingFormat;
+enum _BMDVideo3DPackingFormat {
+    bmdVideo3DPackingSidebySideHalf                              = 'sbsh',
+    bmdVideo3DPackingLinebyLine                                  = 'lbyl',
+    bmdVideo3DPackingTopAndBottom                                = 'tabo',
+    bmdVideo3DPackingFramePacking                                = 'frpk',
+    bmdVideo3DPackingLeftOnly                                    = 'left',
+    bmdVideo3DPackingRightOnly                                   = 'righ'
+};
+
+/* Enum BMDIdleVideoOutputOperation - Video output operation when not playing video */
+
+typedef uint32_t BMDIdleVideoOutputOperation;
+enum _BMDIdleVideoOutputOperation {
+    bmdIdleVideoOutputBlack                                      = 'blac',
+    bmdIdleVideoOutputLastFrame                                  = 'lafa',
+    bmdIdleVideoOutputDesktop                                    = 'desk'
+};
+
+/* Enum BMDDeckLinkAttributeID - DeckLink Attribute ID */
+
+typedef uint32_t BMDDeckLinkAttributeID;
+enum _BMDDeckLinkAttributeID {
+
+    /* Flags */
+
+    BMDDeckLinkSupportsInternalKeying                            = 'keyi',
+    BMDDeckLinkSupportsExternalKeying                            = 'keye',
+    BMDDeckLinkSupportsHDKeying                                  = 'keyh',
+    BMDDeckLinkSupportsInputFormatDetection                      = 'infd',
+    BMDDeckLinkHasReferenceInput                                 = 'hrin',
+    BMDDeckLinkHasSerialPort                                     = 'hspt',
+    BMDDeckLinkHasAnalogVideoOutputGain                          = 'avog',
+    BMDDeckLinkCanOnlyAdjustOverallVideoOutputGain               = 'ovog',
+    BMDDeckLinkHasVideoInputAntiAliasingFilter                   = 'aafl',
+    BMDDeckLinkHasBypass                                         = 'byps',
+    BMDDeckLinkSupportsDesktopDisplay                            = 'extd',
+
+    /* Integers */
+
+    BMDDeckLinkMaximumAudioChannels                              = 'mach',
+    BMDDeckLinkNumberOfSubDevices                                = 'nsbd',
+    BMDDeckLinkSubDeviceIndex                                    = 'subi',
+    BMDDeckLinkVideoOutputConnections                            = 'vocn',
+    BMDDeckLinkVideoInputConnections                             = 'vicn',
+    BMDDeckLinkDeviceBusyState                                   = 'dbst',
+
+    /* Floats */
+
+    BMDDeckLinkVideoInputGainMinimum                             = 'vigm',
+    BMDDeckLinkVideoInputGainMaximum                             = 'vigx',
+    BMDDeckLinkVideoOutputGainMinimum                            = 'vogm',
+    BMDDeckLinkVideoOutputGainMaximum                            = 'vogx',
+
+    /* Strings */
+
+    BMDDeckLinkSerialPortDeviceName                              = 'slpn'
+};
+
+/* Enum BMDDeckLinkAPIInformationID - DeckLinkAPI information ID */
+
+typedef uint32_t BMDDeckLinkAPIInformationID;
+enum _BMDDeckLinkAPIInformationID {
+    BMDDeckLinkAPIVersion                                        = 'vers'
+};
+
+/* Enum BMDDeviceBusyState - Current device busy state */
+
+typedef uint32_t BMDDeviceBusyState;
+enum _BMDDeviceBusyState {
+    bmdDeviceCaptureBusy                                         = 1 << 0,
+    bmdDevicePlaybackBusy                                        = 1 << 1,
+    bmdDeviceSerialPortBusy                                      = 1 << 2
+};
+
+/* Enum BMD3DPreviewFormat - Linked Frame preview format */
+
+typedef uint32_t BMD3DPreviewFormat;
+enum _BMD3DPreviewFormat {
+    bmd3DPreviewFormatDefault                                    = 'defa',
+    bmd3DPreviewFormatLeftOnly                                   = 'left',
+    bmd3DPreviewFormatRightOnly                                  = 'righ',
+    bmd3DPreviewFormatSideBySide                                 = 'side',
+    bmd3DPreviewFormatTopBottom                                  = 'topb'
+};
+
+#if defined(__cplusplus)
+
+// Forward Declarations
+
+class IDeckLinkVideoOutputCallback;
+class IDeckLinkInputCallback;
+class IDeckLinkMemoryAllocator;
+class IDeckLinkAudioOutputCallback;
+class IDeckLinkIterator;
+class IDeckLinkAPIInformation;
+class IDeckLinkOutput;
+class IDeckLinkInput;
+class IDeckLinkVideoFrame;
+class IDeckLinkMutableVideoFrame;
+class IDeckLinkVideoFrame3DExtensions;
+class IDeckLinkVideoInputFrame;
+class IDeckLinkVideoFrameAncillary;
+class IDeckLinkAudioInputPacket;
+class IDeckLinkScreenPreviewCallback;
+class IDeckLinkCocoaScreenPreviewCallback;
+class IDeckLinkGLScreenPreviewHelper;
+class IDeckLinkAttributes;
+class IDeckLinkKeyer;
+class IDeckLinkVideoConversion;
+
+/* Interface IDeckLinkVideoOutputCallback - Frame completion callback. */
+
+class IDeckLinkVideoOutputCallback : public IUnknown
+{
+public:
+    virtual HRESULT ScheduledFrameCompleted (/* in */ IDeckLinkVideoFrame *completedFrame, /* in */ BMDOutputFrameCompletionResult result) = 0;
+    virtual HRESULT ScheduledPlaybackHasStopped (void) = 0;
+
+protected:
+    virtual ~IDeckLinkVideoOutputCallback () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkInputCallback - Frame arrival callback. */
+
+class IDeckLinkInputCallback : public IUnknown
+{
+public:
+    virtual HRESULT VideoInputFormatChanged (/* in */ BMDVideoInputFormatChangedEvents notificationEvents, /* in */ IDeckLinkDisplayMode *newDisplayMode, /* in */ BMDDetectedVideoInputFormatFlags detectedSignalFlags) = 0;
+    virtual HRESULT VideoInputFrameArrived (/* in */ IDeckLinkVideoInputFrame* videoFrame, /* in */ IDeckLinkAudioInputPacket* audioPacket) = 0;
+
+protected:
+    virtual ~IDeckLinkInputCallback () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkMemoryAllocator - Memory allocator for video frames. */
+
+class IDeckLinkMemoryAllocator : public IUnknown
+{
+public:
+    virtual HRESULT AllocateBuffer (/* in */ uint32_t bufferSize, /* out */ void **allocatedBuffer) = 0;
+    virtual HRESULT ReleaseBuffer (/* in */ void *buffer) = 0;
+
+    virtual HRESULT Commit (void) = 0;
+    virtual HRESULT Decommit (void) = 0;
+};
+
+/* Interface IDeckLinkAudioOutputCallback - Optional callback to allow audio samples to be pulled as required. */
+
+class IDeckLinkAudioOutputCallback : public IUnknown
+{
+public:
+    virtual HRESULT RenderAudioSamples (/* in */ bool preroll) = 0;
+};
+
+/* Interface IDeckLinkIterator - enumerates installed DeckLink hardware */
+
+class IDeckLinkIterator : public IUnknown
+{
+public:
+    virtual HRESULT Next (/* out */ IDeckLink **deckLinkInstance) = 0;
+};
+
+/* Interface IDeckLinkAPIInformation - DeckLinkAPI attribute interface */
+
+class IDeckLinkAPIInformation : public IUnknown
+{
+public:
+    virtual HRESULT GetFlag (/* in */ BMDDeckLinkAPIInformationID cfgID, /* out */ bool *value) = 0;
+    virtual HRESULT GetInt (/* in */ BMDDeckLinkAPIInformationID cfgID, /* out */ int64_t *value) = 0;
+    virtual HRESULT GetFloat (/* in */ BMDDeckLinkAPIInformationID cfgID, /* out */ double *value) = 0;
+    virtual HRESULT GetString (/* in */ BMDDeckLinkAPIInformationID cfgID, /* out */ CFStringRef *value) = 0;
+
+protected:
+    virtual ~IDeckLinkAPIInformation () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkOutput - Created by QueryInterface from IDeckLink. */
+
+class IDeckLinkOutput : public IUnknown
+{
+public:
+    virtual HRESULT DoesSupportVideoMode (/* in */ BMDDisplayMode displayMode, /* in */ BMDPixelFormat pixelFormat, /* in */ BMDVideoOutputFlags flags, /* out */ BMDDisplayModeSupport *result, /* out */ IDeckLinkDisplayMode **resultDisplayMode) = 0;
+    virtual HRESULT GetDisplayModeIterator (/* out */ IDeckLinkDisplayModeIterator **iterator) = 0;
+
+    virtual HRESULT SetScreenPreviewCallback (/* in */ IDeckLinkScreenPreviewCallback *previewCallback) = 0;
+
+    /* Video Output */
+
+    virtual HRESULT EnableVideoOutput (/* in */ BMDDisplayMode displayMode, /* in */ BMDVideoOutputFlags flags) = 0;
+    virtual HRESULT DisableVideoOutput (void) = 0;
+
+    virtual HRESULT SetVideoOutputFrameMemoryAllocator (/* in */ IDeckLinkMemoryAllocator *theAllocator) = 0;
+    virtual HRESULT CreateVideoFrame (/* in */ int32_t width, /* in */ int32_t height, /* in */ int32_t rowBytes, /* in */ BMDPixelFormat pixelFormat, /* in */ BMDFrameFlags flags, /* out */ IDeckLinkMutableVideoFrame **outFrame) = 0;
+    virtual HRESULT CreateAncillaryData (/* in */ BMDPixelFormat pixelFormat, /* out */ IDeckLinkVideoFrameAncillary **outBuffer) = 0;
+
+    virtual HRESULT DisplayVideoFrameSync (/* in */ IDeckLinkVideoFrame *theFrame) = 0;
+    virtual HRESULT ScheduleVideoFrame (/* in */ IDeckLinkVideoFrame *theFrame, /* in */ BMDTimeValue displayTime, /* in */ BMDTimeValue displayDuration, /* in */ BMDTimeScale timeScale) = 0;
+    virtual HRESULT SetScheduledFrameCompletionCallback (/* in */ IDeckLinkVideoOutputCallback *theCallback) = 0;
+    virtual HRESULT GetBufferedVideoFrameCount (/* out */ uint32_t *bufferedFrameCount) = 0;
+
+    /* Audio Output */
+
+    virtual HRESULT EnableAudioOutput (/* in */ BMDAudioSampleRate sampleRate, /* in */ BMDAudioSampleType sampleType, /* in */ uint32_t channelCount, /* in */ BMDAudioOutputStreamType streamType) = 0;
+    virtual HRESULT DisableAudioOutput (void) = 0;
+
+    virtual HRESULT WriteAudioSamplesSync (/* in */ void *buffer, /* in */ uint32_t sampleFrameCount, /* out */ uint32_t *sampleFramesWritten) = 0;
+
+    virtual HRESULT BeginAudioPreroll (void) = 0;
+    virtual HRESULT EndAudioPreroll (void) = 0;
+    virtual HRESULT ScheduleAudioSamples (/* in */ void *buffer, /* in */ uint32_t sampleFrameCount, /* in */ BMDTimeValue streamTime, /* in */ BMDTimeScale timeScale, /* out */ uint32_t *sampleFramesWritten) = 0;
+
+    virtual HRESULT GetBufferedAudioSampleFrameCount (/* out */ uint32_t *bufferedSampleFrameCount) = 0;
+    virtual HRESULT FlushBufferedAudioSamples (void) = 0;
+
+    virtual HRESULT SetAudioCallback (/* in */ IDeckLinkAudioOutputCallback *theCallback) = 0;
+
+    /* Output Control */
+
+    virtual HRESULT StartScheduledPlayback (/* in */ BMDTimeValue playbackStartTime, /* in */ BMDTimeScale timeScale, /* in */ double playbackSpeed) = 0;
+    virtual HRESULT StopScheduledPlayback (/* in */ BMDTimeValue stopPlaybackAtTime, /* out */ BMDTimeValue *actualStopTime, /* in */ BMDTimeScale timeScale) = 0;
+    virtual HRESULT IsScheduledPlaybackRunning (/* out */ bool *active) = 0;
+    virtual HRESULT GetScheduledStreamTime (/* in */ BMDTimeScale desiredTimeScale, /* out */ BMDTimeValue *streamTime, /* out */ double *playbackSpeed) = 0;
+    virtual HRESULT GetReferenceStatus (/* out */ BMDReferenceStatus *referenceStatus) = 0;
+
+    /* Hardware Timing */
+
+    virtual HRESULT GetHardwareReferenceClock (/* in */ BMDTimeScale desiredTimeScale, /* out */ BMDTimeValue *hardwareTime, /* out */ BMDTimeValue *timeInFrame, /* out */ BMDTimeValue *ticksPerFrame) = 0;
+
+protected:
+    virtual ~IDeckLinkOutput () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkInput - Created by QueryInterface from IDeckLink. */
+
+class IDeckLinkInput : public IUnknown
+{
+public:
+    virtual HRESULT DoesSupportVideoMode (/* in */ BMDDisplayMode displayMode, /* in */ BMDPixelFormat pixelFormat, /* in */ BMDVideoInputFlags flags, /* out */ BMDDisplayModeSupport *result, /* out */ IDeckLinkDisplayMode **resultDisplayMode) = 0;
+    virtual HRESULT GetDisplayModeIterator (/* out */ IDeckLinkDisplayModeIterator **iterator) = 0;
+
+    virtual HRESULT SetScreenPreviewCallback (/* in */ IDeckLinkScreenPreviewCallback *previewCallback) = 0;
+
+    /* Video Input */
+
+    virtual HRESULT EnableVideoInput (/* in */ BMDDisplayMode displayMode, /* in */ BMDPixelFormat pixelFormat, /* in */ BMDVideoInputFlags flags) = 0;
+    virtual HRESULT DisableVideoInput (void) = 0;
+    virtual HRESULT GetAvailableVideoFrameCount (/* out */ uint32_t *availableFrameCount) = 0;
+
+    /* Audio Input */
+
+    virtual HRESULT EnableAudioInput (/* in */ BMDAudioSampleRate sampleRate, /* in */ BMDAudioSampleType sampleType, /* in */ uint32_t channelCount) = 0;
+    virtual HRESULT DisableAudioInput (void) = 0;
+    virtual HRESULT GetAvailableAudioSampleFrameCount (/* out */ uint32_t *availableSampleFrameCount) = 0;
+
+    /* Input Control */
+
+    virtual HRESULT StartStreams (void) = 0;
+    virtual HRESULT StopStreams (void) = 0;
+    virtual HRESULT PauseStreams (void) = 0;
+    virtual HRESULT FlushStreams (void) = 0;
+    virtual HRESULT SetCallback (/* in */ IDeckLinkInputCallback *theCallback) = 0;
+
+    /* Hardware Timing */
+
+    virtual HRESULT GetHardwareReferenceClock (/* in */ BMDTimeScale desiredTimeScale, /* out */ BMDTimeValue *hardwareTime, /* out */ BMDTimeValue *timeInFrame, /* out */ BMDTimeValue *ticksPerFrame) = 0;
+
+protected:
+    virtual ~IDeckLinkInput () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkVideoFrame - Interface to encapsulate a video frame; can be caller-implemented. */
+
+class IDeckLinkVideoFrame : public IUnknown
+{
+public:
+    virtual long GetWidth (void) = 0;
+    virtual long GetHeight (void) = 0;
+    virtual long GetRowBytes (void) = 0;
+    virtual BMDPixelFormat GetPixelFormat (void) = 0;
+    virtual BMDFrameFlags GetFlags (void) = 0;
+    virtual HRESULT GetBytes (/* out */ void **buffer) = 0;
+
+    virtual HRESULT GetTimecode (/* in */ BMDTimecodeFormat format, /* out */ IDeckLinkTimecode **timecode) = 0;
+    virtual HRESULT GetAncillaryData (/* out */ IDeckLinkVideoFrameAncillary **ancillary) = 0;
+
+protected:
+    virtual ~IDeckLinkVideoFrame () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkMutableVideoFrame - Created by IDeckLinkOutput::CreateVideoFrame. */
+
+class IDeckLinkMutableVideoFrame : public IDeckLinkVideoFrame
+{
+public:
+    virtual HRESULT SetFlags (/* in */ BMDFrameFlags newFlags) = 0;
+
+    virtual HRESULT SetTimecode (/* in */ BMDTimecodeFormat format, /* in */ IDeckLinkTimecode *timecode) = 0;
+    virtual HRESULT SetTimecodeFromComponents (/* in */ BMDTimecodeFormat format, /* in */ uint8_t hours, /* in */ uint8_t minutes, /* in */ uint8_t seconds, /* in */ uint8_t frames, /* in */ BMDTimecodeFlags flags) = 0;
+    virtual HRESULT SetAncillaryData (/* in */ IDeckLinkVideoFrameAncillary *ancillary) = 0;
+    virtual HRESULT SetTimecodeUserBits (/* in */ BMDTimecodeFormat format, /* in */ BMDTimecodeUserBits userBits) = 0;
+
+protected:
+    virtual ~IDeckLinkMutableVideoFrame () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkVideoFrame3DExtensions - Optional interface implemented on IDeckLinkVideoFrame to support 3D frames */
+
+class IDeckLinkVideoFrame3DExtensions : public IUnknown
+{
+public:
+    virtual BMDVideo3DPackingFormat Get3DPackingFormat (void) = 0;
+    virtual HRESULT GetFrameForRightEye (/* out */ IDeckLinkVideoFrame* *rightEyeFrame) = 0;
+
+protected:
+    virtual ~IDeckLinkVideoFrame3DExtensions () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkVideoInputFrame - Provided by the IDeckLinkVideoInput frame arrival callback. */
+
+class IDeckLinkVideoInputFrame : public IDeckLinkVideoFrame
+{
+public:
+    virtual HRESULT GetStreamTime (/* out */ BMDTimeValue *frameTime, /* out */ BMDTimeValue *frameDuration, /* in */ BMDTimeScale timeScale) = 0;
+    virtual HRESULT GetHardwareReferenceTimestamp (/* in */ BMDTimeScale timeScale, /* out */ BMDTimeValue *frameTime, /* out */ BMDTimeValue *frameDuration) = 0;
+
+protected:
+    virtual ~IDeckLinkVideoInputFrame () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkVideoFrameAncillary - Obtained through QueryInterface() on an IDeckLinkVideoFrame object. */
+
+class IDeckLinkVideoFrameAncillary : public IUnknown
+{
+public:
+
+    virtual HRESULT GetBufferForVerticalBlankingLine (/* in */ uint32_t lineNumber, /* out */ void **buffer) = 0;
+    virtual BMDPixelFormat GetPixelFormat (void) = 0;
+    virtual BMDDisplayMode GetDisplayMode (void) = 0;
+
+protected:
+    virtual ~IDeckLinkVideoFrameAncillary () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkAudioInputPacket - Provided by the IDeckLinkInput callback. */
+
+class IDeckLinkAudioInputPacket : public IUnknown
+{
+public:
+    virtual long GetSampleFrameCount (void) = 0;
+    virtual HRESULT GetBytes (/* out */ void **buffer) = 0;
+    virtual HRESULT GetPacketTime (/* out */ BMDTimeValue *packetTime, /* in */ BMDTimeScale timeScale) = 0;
+
+protected:
+    virtual ~IDeckLinkAudioInputPacket () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkScreenPreviewCallback - Screen preview callback */
+
+class IDeckLinkScreenPreviewCallback : public IUnknown
+{
+public:
+    virtual HRESULT DrawFrame (/* in */ IDeckLinkVideoFrame *theFrame) = 0;
+
+protected:
+    virtual ~IDeckLinkScreenPreviewCallback () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkCocoaScreenPreviewCallback - Screen preview callback for Cocoa-based applications */
+
+class IDeckLinkCocoaScreenPreviewCallback : public IDeckLinkScreenPreviewCallback
+{
+public:
+
+protected:
+    virtual ~IDeckLinkCocoaScreenPreviewCallback () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkGLScreenPreviewHelper - Created with CoCreateInstance(). */
+
+class IDeckLinkGLScreenPreviewHelper : public IUnknown
+{
+public:
+
+    /* Methods must be called with OpenGL context set */
+
+    virtual HRESULT InitializeGL (void) = 0;
+    virtual HRESULT PaintGL (void) = 0;
+    virtual HRESULT SetFrame (/* in */ IDeckLinkVideoFrame *theFrame) = 0;
+    virtual HRESULT Set3DPreviewFormat (/* in */ BMD3DPreviewFormat previewFormat) = 0;
+
+protected:
+    virtual ~IDeckLinkGLScreenPreviewHelper () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkAttributes - DeckLink Attribute interface */
+
+class IDeckLinkAttributes : public IUnknown
+{
+public:
+    virtual HRESULT GetFlag (/* in */ BMDDeckLinkAttributeID cfgID, /* out */ bool *value) = 0;
+    virtual HRESULT GetInt (/* in */ BMDDeckLinkAttributeID cfgID, /* out */ int64_t *value) = 0;
+    virtual HRESULT GetFloat (/* in */ BMDDeckLinkAttributeID cfgID, /* out */ double *value) = 0;
+    virtual HRESULT GetString (/* in */ BMDDeckLinkAttributeID cfgID, /* out */ CFStringRef *value) = 0;
+
+protected:
+    virtual ~IDeckLinkAttributes () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkKeyer - DeckLink Keyer interface */
+
+class IDeckLinkKeyer : public IUnknown
+{
+public:
+    virtual HRESULT Enable (/* in */ bool isExternal) = 0;
+    virtual HRESULT SetLevel (/* in */ uint8_t level) = 0;
+    virtual HRESULT RampUp (/* in */ uint32_t numberOfFrames) = 0;
+    virtual HRESULT RampDown (/* in */ uint32_t numberOfFrames) = 0;
+    virtual HRESULT Disable (void) = 0;
+
+protected:
+    virtual ~IDeckLinkKeyer () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkVideoConversion - Created with CoCreateInstance(). */
+
+class IDeckLinkVideoConversion : public IUnknown
+{
+public:
+    virtual HRESULT ConvertFrame (/* in */ IDeckLinkVideoFrame* srcFrame, /* in */ IDeckLinkVideoFrame* dstFrame) = 0;
+
+protected:
+    virtual ~IDeckLinkVideoConversion () {}; // call Release method to drop reference count
+};
+
+/* Functions */
+
+extern "C" {
+
+    IDeckLinkIterator* CreateDeckLinkIteratorInstance (void);
+    IDeckLinkAPIInformation* CreateDeckLinkAPIInformationInstance (void);
+    IDeckLinkGLScreenPreviewHelper* CreateOpenGLScreenPreviewHelper (void);
+    IDeckLinkCocoaScreenPreviewCallback* CreateCocoaScreenPreview (void* /* (NSView*) */ parentView);
+    IDeckLinkVideoConversion* CreateVideoConversionInstance (void);
+
+};
+
+
+#endif      // defined(__cplusplus)
+#endif /* defined(BMD_DECKLINKAPI_H) */
diff --git a/sys/decklink/osx/DeckLinkAPIConfiguration.h b/sys/decklink/osx/DeckLinkAPIConfiguration.h
new file mode 100644
index 0000000..f026e73
--- /dev/null
+++ b/sys/decklink/osx/DeckLinkAPIConfiguration.h
@@ -0,0 +1,167 @@
+/* -LICENSE-START-
+** Copyright (c) 2011 Blackmagic Design
+**
+** Permission is hereby granted, free of charge, to any person or organization
+** obtaining a copy of the software and accompanying documentation covered by
+** this license (the "Software") to use, reproduce, display, distribute,
+** execute, and transmit the Software, and to prepare derivative works of the
+** Software, and to permit third-parties to whom the Software is furnished to
+** do so, all subject to the following:
+** 
+** The copyright notices in the Software and this entire statement, including
+** the above license grant, this restriction and the following disclaimer,
+** must be included in all copies of the Software, in whole or in part, and
+** all derivative works of the Software, unless such copies or derivative
+** works are solely in the form of machine-executable object code generated by
+** a source language processor.
+** 
+** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+** DEALINGS IN THE SOFTWARE.
+** -LICENSE-END-
+*/
+
+#ifndef BMD_DECKLINKAPICONFIGURATION_H
+#define BMD_DECKLINKAPICONFIGURATION_H
+
+// Type Declarations
+
+
+// Interface ID Declarations
+
+#define IID_IDeckLinkConfiguration                       /* C679A35B-610C-4D09-B748-1D0478100FC0 */ (REFIID){0xC6,0x79,0xA3,0x5B,0x61,0x0C,0x4D,0x09,0xB7,0x48,0x1D,0x04,0x78,0x10,0x0F,0xC0}
+
+/* Enum BMDDeckLinkConfigurationID - DeckLink Configuration ID */
+
+typedef uint32_t BMDDeckLinkConfigurationID;
+enum _BMDDeckLinkConfigurationID {
+
+    /* Serial port Flags */
+
+    bmdDeckLinkConfigSwapSerialRxTx                              = 'ssrt',
+
+    /* Video Input/Output Flags */
+
+    bmdDeckLinkConfigUse1080pNotPsF                              = 'fpro',
+
+    /* Video Input/Output Integers */
+
+    bmdDeckLinkConfigHDMI3DPackingFormat                         = '3dpf',
+    bmdDeckLinkConfigBypass                                      = 'byps',
+
+    /* Audio Input/Output Flags */
+
+    bmdDeckLinkConfigAnalogAudioConsumerLevels                   = 'aacl',
+
+    /* Video output flags */
+
+    bmdDeckLinkConfigFieldFlickerRemoval                         = 'fdfr',
+    bmdDeckLinkConfigHD1080p24ToHD1080i5994Conversion            = 'to59',
+    bmdDeckLinkConfig444SDIVideoOutput                           = '444o',
+    bmdDeckLinkConfig3GBpsVideoOutput                            = '3gbs',
+    bmdDeckLinkConfigBlackVideoOutputDuringCapture               = 'bvoc',
+    bmdDeckLinkConfigLowLatencyVideoOutput                       = 'llvo',
+
+    /* Video Output Integers */
+
+    bmdDeckLinkConfigVideoOutputConnection                       = 'vocn',
+    bmdDeckLinkConfigVideoOutputConversionMode                   = 'vocm',
+    bmdDeckLinkConfigAnalogVideoOutputFlags                      = 'avof',
+    bmdDeckLinkConfigReferenceInputTimingOffset                  = 'glot',
+    bmdDeckLinkConfigVideoOutputIdleOperation                    = 'voio',
+
+    /* Video Output Floats */
+
+    bmdDeckLinkConfigVideoOutputComponentLumaGain                = 'oclg',
+    bmdDeckLinkConfigVideoOutputComponentChromaBlueGain          = 'occb',
+    bmdDeckLinkConfigVideoOutputComponentChromaRedGain           = 'occr',
+    bmdDeckLinkConfigVideoOutputCompositeLumaGain                = 'oilg',
+    bmdDeckLinkConfigVideoOutputCompositeChromaGain              = 'oicg',
+    bmdDeckLinkConfigVideoOutputSVideoLumaGain                   = 'oslg',
+    bmdDeckLinkConfigVideoOutputSVideoChromaGain                 = 'oscg',
+
+    /* Video Input Flags */
+
+    bmdDeckLinkConfigVideoInputScanning                          = 'visc',	// Applicable to H264 Pro Recorder only
+
+    /* Video Input Integers */
+
+    bmdDeckLinkConfigVideoInputConnection                        = 'vicn',
+    bmdDeckLinkConfigAnalogVideoInputFlags                       = 'avif',
+    bmdDeckLinkConfigVideoInputConversionMode                    = 'vicm',
+    bmdDeckLinkConfig32PulldownSequenceInitialTimecodeFrame      = 'pdif',
+    bmdDeckLinkConfigVANCSourceLine1Mapping                      = 'vsl1',
+    bmdDeckLinkConfigVANCSourceLine2Mapping                      = 'vsl2',
+    bmdDeckLinkConfigVANCSourceLine3Mapping                      = 'vsl3',
+
+    /* Video Input Floats */
+
+    bmdDeckLinkConfigVideoInputComponentLumaGain                 = 'iclg',
+    bmdDeckLinkConfigVideoInputComponentChromaBlueGain           = 'iccb',
+    bmdDeckLinkConfigVideoInputComponentChromaRedGain            = 'iccr',
+    bmdDeckLinkConfigVideoInputCompositeLumaGain                 = 'iilg',
+    bmdDeckLinkConfigVideoInputCompositeChromaGain               = 'iicg',
+    bmdDeckLinkConfigVideoInputSVideoLumaGain                    = 'islg',
+    bmdDeckLinkConfigVideoInputSVideoChromaGain                  = 'iscg',
+
+    /* Audio Input Integers */
+
+    bmdDeckLinkConfigAudioInputConnection                        = 'aicn',
+
+    /* Audio Input Floats */
+
+    bmdDeckLinkConfigAnalogAudioInputScaleChannel1               = 'ais1',
+    bmdDeckLinkConfigAnalogAudioInputScaleChannel2               = 'ais2',
+    bmdDeckLinkConfigAnalogAudioInputScaleChannel3               = 'ais3',
+    bmdDeckLinkConfigAnalogAudioInputScaleChannel4               = 'ais4',
+    bmdDeckLinkConfigDigitalAudioInputScale                      = 'dais',
+
+    /* Audio Output Integers */
+
+    bmdDeckLinkConfigAudioOutputAESAnalogSwitch                  = 'aoaa',
+
+    /* Audio Output Floats */
+
+    bmdDeckLinkConfigAnalogAudioOutputScaleChannel1              = 'aos1',
+    bmdDeckLinkConfigAnalogAudioOutputScaleChannel2              = 'aos2',
+    bmdDeckLinkConfigAnalogAudioOutputScaleChannel3              = 'aos3',
+    bmdDeckLinkConfigAnalogAudioOutputScaleChannel4              = 'aos4',
+    bmdDeckLinkConfigDigitalAudioOutputScale                     = 'daos'
+};
+
+// Forward Declarations
+
+class IDeckLinkConfiguration;
+
+/* Interface IDeckLinkConfiguration - DeckLink Configuration interface */
+
+class IDeckLinkConfiguration : public IUnknown
+{
+public:
+    virtual HRESULT SetFlag (/* in */ BMDDeckLinkConfigurationID cfgID, /* in */ bool value) = 0;
+    virtual HRESULT GetFlag (/* in */ BMDDeckLinkConfigurationID cfgID, /* out */ bool *value) = 0;
+    virtual HRESULT SetInt (/* in */ BMDDeckLinkConfigurationID cfgID, /* in */ int64_t value) = 0;
+    virtual HRESULT GetInt (/* in */ BMDDeckLinkConfigurationID cfgID, /* out */ int64_t *value) = 0;
+    virtual HRESULT SetFloat (/* in */ BMDDeckLinkConfigurationID cfgID, /* in */ double value) = 0;
+    virtual HRESULT GetFloat (/* in */ BMDDeckLinkConfigurationID cfgID, /* out */ double *value) = 0;
+    virtual HRESULT SetString (/* in */ BMDDeckLinkConfigurationID cfgID, /* in */ CFStringRef value) = 0;
+    virtual HRESULT GetString (/* in */ BMDDeckLinkConfigurationID cfgID, /* out */ CFStringRef *value) = 0;
+    virtual HRESULT WriteConfigurationToPreferences (void) = 0;
+
+protected:
+    virtual ~IDeckLinkConfiguration () {}; // call Release method to drop reference count
+};
+
+/* Functions */
+
+extern "C" {
+
+
+};
+
+
+#endif /* defined(BMD_DECKLINKAPICONFIGURATION_H) */
diff --git a/sys/decklink/osx/DeckLinkAPIDeckControl.h b/sys/decklink/osx/DeckLinkAPIDeckControl.h
new file mode 100644
index 0000000..ea32657
--- /dev/null
+++ b/sys/decklink/osx/DeckLinkAPIDeckControl.h
@@ -0,0 +1,206 @@
+/* -LICENSE-START-
+** Copyright (c) 2011 Blackmagic Design
+**
+** Permission is hereby granted, free of charge, to any person or organization
+** obtaining a copy of the software and accompanying documentation covered by
+** this license (the "Software") to use, reproduce, display, distribute,
+** execute, and transmit the Software, and to prepare derivative works of the
+** Software, and to permit third-parties to whom the Software is furnished to
+** do so, all subject to the following:
+** 
+** The copyright notices in the Software and this entire statement, including
+** the above license grant, this restriction and the following disclaimer,
+** must be included in all copies of the Software, in whole or in part, and
+** all derivative works of the Software, unless such copies or derivative
+** works are solely in the form of machine-executable object code generated by
+** a source language processor.
+** 
+** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+** DEALINGS IN THE SOFTWARE.
+** -LICENSE-END-
+*/
+
+#ifndef BMD_DECKLINKAPIDECKCONTROL_H
+#define BMD_DECKLINKAPIDECKCONTROL_H
+
+// Type Declarations
+
+
+// Interface ID Declarations
+
+#define IID_IDeckLinkDeckControlStatusCallback           /* 53436FFB-B434-4906-BADC-AE3060FFE8EF */ (REFIID){0x53,0x43,0x6F,0xFB,0xB4,0x34,0x49,0x06,0xBA,0xDC,0xAE,0x30,0x60,0xFF,0xE8,0xEF}
+#define IID_IDeckLinkDeckControl                         /* 8E1C3ACE-19C7-4E00-8B92-D80431D958BE */ (REFIID){0x8E,0x1C,0x3A,0xCE,0x19,0xC7,0x4E,0x00,0x8B,0x92,0xD8,0x04,0x31,0xD9,0x58,0xBE}
+
+/* Enum BMDDeckControlMode - DeckControl mode */
+
+typedef uint32_t BMDDeckControlMode;
+enum _BMDDeckControlMode {
+    bmdDeckControlNotOpened                                      = 'ntop',
+    bmdDeckControlVTRControlMode                                 = 'vtrc',
+    bmdDeckControlExportMode                                     = 'expm',
+    bmdDeckControlCaptureMode                                    = 'capm'
+};
+
+/* Enum BMDDeckControlEvent - DeckControl event */
+
+typedef uint32_t BMDDeckControlEvent;
+enum _BMDDeckControlEvent {
+    bmdDeckControlAbortedEvent                                   = 'abte',	// This event is triggered when a capture or edit-to-tape operation is aborted.
+
+    /* Export-To-Tape events */
+
+    bmdDeckControlPrepareForExportEvent                          = 'pfee',	// This event is triggered a few frames before reaching the in-point. IDeckLinkInput::StartScheduledPlayback() should be called at this point.
+    bmdDeckControlExportCompleteEvent                            = 'exce',	// This event is triggered a few frames after reaching the out-point. At this point, it is safe to stop playback.
+
+    /* Capture events */
+
+    bmdDeckControlPrepareForCaptureEvent                         = 'pfce',	// This event is triggered a few frames before reaching the in-point. The serial timecode attached to IDeckLinkVideoInputFrames is now valid.
+    bmdDeckControlCaptureCompleteEvent                           = 'ccev'	// This event is triggered a few frames after reaching the out-point.
+};
+
+/* Enum BMDDeckControlVTRControlState - VTR Control state */
+
+typedef uint32_t BMDDeckControlVTRControlState;
+enum _BMDDeckControlVTRControlState {
+    bmdDeckControlNotInVTRControlMode                            = 'nvcm',
+    bmdDeckControlVTRControlPlaying                              = 'vtrp',
+    bmdDeckControlVTRControlRecording                            = 'vtrr',
+    bmdDeckControlVTRControlStill                                = 'vtra',
+    bmdDeckControlVTRControlShuttleForward                       = 'vtsf',
+    bmdDeckControlVTRControlShuttleReverse                       = 'vtsr',
+    bmdDeckControlVTRControlJogForward                           = 'vtjf',
+    bmdDeckControlVTRControlJogReverse                           = 'vtjr',
+    bmdDeckControlVTRControlStopped                              = 'vtro'
+};
+
+/* Enum BMDDeckControlStatusFlags - Deck Control status flags */
+
+typedef uint32_t BMDDeckControlStatusFlags;
+enum _BMDDeckControlStatusFlags {
+    bmdDeckControlStatusDeckConnected                            = 1 << 0,
+    bmdDeckControlStatusRemoteMode                               = 1 << 1,
+    bmdDeckControlStatusRecordInhibited                          = 1 << 2,
+    bmdDeckControlStatusCassetteOut                              = 1 << 3
+};
+
+/* Enum BMDDeckControlExportModeOpsFlags - Export mode flags */
+
+typedef uint32_t BMDDeckControlExportModeOpsFlags;
+enum _BMDDeckControlExportModeOpsFlags {
+    bmdDeckControlExportModeInsertVideo                          = 1 << 0,
+    bmdDeckControlExportModeInsertAudio1                         = 1 << 1,
+    bmdDeckControlExportModeInsertAudio2                         = 1 << 2,
+    bmdDeckControlExportModeInsertAudio3                         = 1 << 3,
+    bmdDeckControlExportModeInsertAudio4                         = 1 << 4,
+    bmdDeckControlExportModeInsertAudio5                         = 1 << 5,
+    bmdDeckControlExportModeInsertAudio6                         = 1 << 6,
+    bmdDeckControlExportModeInsertAudio7                         = 1 << 7,
+    bmdDeckControlExportModeInsertAudio8                         = 1 << 8,
+    bmdDeckControlExportModeInsertAudio9                         = 1 << 9,
+    bmdDeckControlExportModeInsertAudio10                        = 1 << 10,
+    bmdDeckControlExportModeInsertAudio11                        = 1 << 11,
+    bmdDeckControlExportModeInsertAudio12                        = 1 << 12,
+    bmdDeckControlExportModeInsertTimeCode                       = 1 << 13,
+    bmdDeckControlExportModeInsertAssemble                       = 1 << 14,
+    bmdDeckControlExportModeInsertPreview                        = 1 << 15,
+    bmdDeckControlUseManualExport                                = 1 << 16
+};
+
+/* Enum BMDDeckControlError - Deck Control error */
+
+typedef uint32_t BMDDeckControlError;
+enum _BMDDeckControlError {
+    bmdDeckControlNoError                                        = 'noer',
+    bmdDeckControlModeError                                      = 'moer',
+    bmdDeckControlMissedInPointError                             = 'mier',
+    bmdDeckControlDeckTimeoutError                               = 'dter',
+    bmdDeckControlCommandFailedError                             = 'cfer',
+    bmdDeckControlDeviceAlreadyOpenedError                       = 'dalo',
+    bmdDeckControlFailedToOpenDeviceError                        = 'fder',
+    bmdDeckControlInLocalModeError                               = 'lmer',
+    bmdDeckControlEndOfTapeError                                 = 'eter',
+    bmdDeckControlUserAbortError                                 = 'uaer',
+    bmdDeckControlNoTapeInDeckError                              = 'nter',
+    bmdDeckControlNoVideoFromCardError                           = 'nvfc',
+    bmdDeckControlNoCommunicationError                           = 'ncom',
+    bmdDeckControlBufferTooSmallError                            = 'btsm',
+    bmdDeckControlBadChecksumError                               = 'chks',
+    bmdDeckControlUnknownError                                   = 'uner'
+};
+
+// Forward Declarations
+
+class IDeckLinkDeckControlStatusCallback;
+class IDeckLinkDeckControl;
+
+/* Interface IDeckLinkDeckControlStatusCallback - Deck control state change callback. */
+
+class IDeckLinkDeckControlStatusCallback : public IUnknown
+{
+public:
+    virtual HRESULT TimecodeUpdate (/* in */ BMDTimecodeBCD currentTimecode) = 0;
+    virtual HRESULT VTRControlStateChanged (/* in */ BMDDeckControlVTRControlState newState, /* in */ BMDDeckControlError error) = 0;
+    virtual HRESULT DeckControlEventReceived (/* in */ BMDDeckControlEvent event, /* in */ BMDDeckControlError error) = 0;
+    virtual HRESULT DeckControlStatusChanged (/* in */ BMDDeckControlStatusFlags flags, /* in */ uint32_t mask) = 0;
+
+protected:
+    virtual ~IDeckLinkDeckControlStatusCallback () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkDeckControl - Deck Control main interface */
+
+class IDeckLinkDeckControl : public IUnknown
+{
+public:
+    virtual HRESULT Open (/* in */ BMDTimeScale timeScale, /* in */ BMDTimeValue timeValue, /* in */ bool timecodeIsDropFrame, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT Close (/* in */ bool standbyOn) = 0;
+    virtual HRESULT GetCurrentState (/* out */ BMDDeckControlMode *mode, /* out */ BMDDeckControlVTRControlState *vtrControlState, /* out */ BMDDeckControlStatusFlags *flags) = 0;
+    virtual HRESULT SetStandby (/* in */ bool standbyOn) = 0;
+    virtual HRESULT SendCommand (/* in */ uint8_t *inBuffer, /* in */ uint32_t inBufferSize, /* out */ uint8_t *outBuffer, /* out */ uint32_t *outDataSize, /* in */ uint32_t outBufferSize, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT Play (/* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT Stop (/* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT TogglePlayStop (/* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT Eject (/* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT GoToTimecode (/* in */ BMDTimecodeBCD timecode, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT FastForward (/* in */ bool viewTape, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT Rewind (/* in */ bool viewTape, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT StepForward (/* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT StepBack (/* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT Jog (/* in */ double rate, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT Shuttle (/* in */ double rate, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT GetTimecodeString (/* out */ CFStringRef *currentTimeCode, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT GetTimecode (/* out */ IDeckLinkTimecode **currentTimecode, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT GetTimecodeBCD (/* out */ BMDTimecodeBCD *currentTimecode, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT SetPreroll (/* in */ uint32_t prerollSeconds) = 0;
+    virtual HRESULT GetPreroll (/* out */ uint32_t *prerollSeconds) = 0;
+    virtual HRESULT SetExportOffset (/* in */ int32_t exportOffsetFields) = 0;
+    virtual HRESULT GetExportOffset (/* out */ int32_t *exportOffsetFields) = 0;
+    virtual HRESULT GetManualExportOffset (/* out */ int32_t *deckManualExportOffsetFields) = 0;
+    virtual HRESULT SetCaptureOffset (/* in */ int32_t captureOffsetFields) = 0;
+    virtual HRESULT GetCaptureOffset (/* out */ int32_t *captureOffsetFields) = 0;
+    virtual HRESULT StartExport (/* in */ BMDTimecodeBCD inTimecode, /* in */ BMDTimecodeBCD outTimecode, /* in */ BMDDeckControlExportModeOpsFlags exportModeOps, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT StartCapture (/* in */ bool useVITC, /* in */ BMDTimecodeBCD inTimecode, /* in */ BMDTimecodeBCD outTimecode, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT GetDeviceID (/* out */ uint16_t *deviceId, /* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT Abort (void) = 0;
+    virtual HRESULT CrashRecordStart (/* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT CrashRecordStop (/* out */ BMDDeckControlError *error) = 0;
+    virtual HRESULT SetCallback (/* in */ IDeckLinkDeckControlStatusCallback *callback) = 0;
+
+protected:
+    virtual ~IDeckLinkDeckControl () {}; // call Release method to drop reference count
+};
+
+/* Functions */
+
+extern "C" {
+
+
+};
+
+
+#endif /* defined(BMD_DECKLINKAPIDECKCONTROL_H) */
diff --git a/sys/decklink/osx/DeckLinkAPIDiscovery.h b/sys/decklink/osx/DeckLinkAPIDiscovery.h
new file mode 100644
index 0000000..99fc0fe
--- /dev/null
+++ b/sys/decklink/osx/DeckLinkAPIDiscovery.h
@@ -0,0 +1,62 @@
+/* -LICENSE-START-
+** Copyright (c) 2011 Blackmagic Design
+**
+** Permission is hereby granted, free of charge, to any person or organization
+** obtaining a copy of the software and accompanying documentation covered by
+** this license (the "Software") to use, reproduce, display, distribute,
+** execute, and transmit the Software, and to prepare derivative works of the
+** Software, and to permit third-parties to whom the Software is furnished to
+** do so, all subject to the following:
+** 
+** The copyright notices in the Software and this entire statement, including
+** the above license grant, this restriction and the following disclaimer,
+** must be included in all copies of the Software, in whole or in part, and
+** all derivative works of the Software, unless such copies or derivative
+** works are solely in the form of machine-executable object code generated by
+** a source language processor.
+** 
+** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+** DEALINGS IN THE SOFTWARE.
+** -LICENSE-END-
+*/
+
+#ifndef BMD_DECKLINKAPIDISCOVERY_H
+#define BMD_DECKLINKAPIDISCOVERY_H
+
+// Type Declarations
+
+
+// Interface ID Declarations
+
+#define IID_IDeckLink                                    /* C418FBDD-0587-48ED-8FE5-640F0A14AF91 */ (REFIID){0xC4,0x18,0xFB,0xDD,0x05,0x87,0x48,0xED,0x8F,0xE5,0x64,0x0F,0x0A,0x14,0xAF,0x91}
+
+// Forward Declarations
+
+class IDeckLink;
+
+/* Interface IDeckLink - represents a DeckLink device */
+
+class IDeckLink : public IUnknown
+{
+public:
+    virtual HRESULT GetModelName (/* out */ CFStringRef *modelName) = 0;
+    virtual HRESULT GetDisplayName (/* out */ CFStringRef *displayName) = 0;
+
+protected:
+    virtual ~IDeckLink () {}; // call Release method to drop reference count
+};
+
+/* Functions */
+
+extern "C" {
+
+
+};
+
+
+#endif /* defined(BMD_DECKLINKAPIDISCOVERY_H) */
diff --git a/sys/decklink/osx/DeckLinkAPIDispatch-osx.cpp b/sys/decklink/osx/DeckLinkAPIDispatch-osx.cpp
new file mode 100644
index 0000000..18b0122
--- /dev/null
+++ b/sys/decklink/osx/DeckLinkAPIDispatch-osx.cpp
@@ -0,0 +1,178 @@
+/* -LICENSE-START-
+** Copyright (c) 2009 Blackmagic Design
+**
+** Permission is hereby granted, free of charge, to any person or organization
+** obtaining a copy of the software and accompanying documentation covered by
+** this license (the "Software") to use, reproduce, display, distribute,
+** execute, and transmit the Software, and to prepare derivative works of the
+** Software, and to permit third-parties to whom the Software is furnished to
+** do so, all subject to the following:
+** 
+** The copyright notices in the Software and this entire statement, including
+** the above license grant, this restriction and the following disclaimer,
+** must be included in all copies of the Software, in whole or in part, and
+** all derivative works of the Software, unless such copies or derivative
+** works are solely in the form of machine-executable object code generated by
+** a source language processor.
+** 
+** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+** DEALINGS IN THE SOFTWARE.
+** -LICENSE-END-
+*/
+/* DeckLinkAPIDispatch.cpp */
+
+#include "DeckLinkAPI.h"
+#include <pthread.h>
+
+#if BLACKMAGIC_DECKLINK_API_MAGIC != 1
+	#error The DeckLink API version of DeckLinkAPIDispatch.cpp is not the same version as DeckLinkAPI.h
+#endif
+
+#define kDeckLinkAPI_BundlePath "/Library/Application Support/Blackmagic Design/Blackmagic DeckLink/DeckLinkAPI.bundle"
+
+typedef IDeckLinkIterator* (*CreateIteratorFunc)(void);
+typedef IDeckLinkAPIInformation* (*CreateAPIInformationFunc)(void);
+typedef IDeckLinkGLScreenPreviewHelper* (*CreateOpenGLScreenPreviewHelperFunc)(void);
+typedef IDeckLinkCocoaScreenPreviewCallback* (*CreateCocoaScreenPreviewFunc)(void*);
+typedef IDeckLinkVideoConversion* (*CreateVideoConversionInstanceFunc)(void);
+
+static pthread_once_t						gDeckLinkOnceControl		= PTHREAD_ONCE_INIT;
+static CFBundleRef							gDeckLinkAPIBundleRef		= NULL;
+static CreateIteratorFunc					gCreateIteratorFunc			= NULL;
+static CreateAPIInformationFunc				gCreateAPIInformationFunc	= NULL;
+static CreateOpenGLScreenPreviewHelperFunc	gCreateOpenGLPreviewFunc	= NULL;
+static CreateCocoaScreenPreviewFunc			gCreateCocoaPreviewFunc		= NULL;
+static CreateVideoConversionInstanceFunc	gCreateVideoConversionFunc	= NULL;
+
+
+void	InitDeckLinkAPI (void)
+{
+	CFURLRef		bundleURL;
+
+	bundleURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR(kDeckLinkAPI_BundlePath), kCFURLPOSIXPathStyle, true);
+	if (bundleURL != NULL)
+	{
+		gDeckLinkAPIBundleRef = CFBundleCreate(kCFAllocatorDefault, bundleURL);
+		if (gDeckLinkAPIBundleRef != NULL)
+		{
+			gCreateIteratorFunc = (CreateIteratorFunc)CFBundleGetFunctionPointerForName(gDeckLinkAPIBundleRef, CFSTR("CreateDeckLinkIteratorInstance_0002"));
+			gCreateAPIInformationFunc = (CreateAPIInformationFunc)CFBundleGetFunctionPointerForName(gDeckLinkAPIBundleRef, CFSTR("CreateDeckLinkAPIInformationInstance_0001"));
+			gCreateOpenGLPreviewFunc = (CreateOpenGLScreenPreviewHelperFunc)CFBundleGetFunctionPointerForName(gDeckLinkAPIBundleRef, CFSTR("CreateOpenGLScreenPreviewHelper_0001"));
+			gCreateCocoaPreviewFunc = (CreateCocoaScreenPreviewFunc)CFBundleGetFunctionPointerForName(gDeckLinkAPIBundleRef, CFSTR("CreateCocoaScreenPreview_0001"));
+			gCreateVideoConversionFunc = (CreateVideoConversionInstanceFunc)CFBundleGetFunctionPointerForName(gDeckLinkAPIBundleRef, CFSTR("CreateVideoConversionInstance_0001"));
+		}
+		CFRelease(bundleURL);
+	}
+}
+
+bool		IsDeckLinkAPIPresent (void)
+{
+	// If the DeckLink API bundle was successfully loaded, return this knowledge to the caller
+	if (gDeckLinkAPIBundleRef != NULL)
+		return true;
+	
+	return false;
+}
+
+IDeckLinkIterator*		CreateDeckLinkIteratorInstance (void)
+{
+	pthread_once(&gDeckLinkOnceControl, InitDeckLinkAPI);
+	
+	if (gCreateIteratorFunc == NULL)
+		return NULL;
+	
+	return gCreateIteratorFunc();
+}
+
+IDeckLinkAPIInformation*	CreateDeckLinkAPIInformationInstance (void)
+{
+	pthread_once(&gDeckLinkOnceControl, InitDeckLinkAPI);
+	
+	if (gCreateAPIInformationFunc == NULL)
+		return NULL;
+	
+	return gCreateAPIInformationFunc();
+}
+
+IDeckLinkGLScreenPreviewHelper*		CreateOpenGLScreenPreviewHelper (void)
+{
+	pthread_once(&gDeckLinkOnceControl, InitDeckLinkAPI);
+	
+	if (gCreateOpenGLPreviewFunc == NULL)
+		return NULL;
+	
+	return gCreateOpenGLPreviewFunc();
+}
+
+IDeckLinkCocoaScreenPreviewCallback*	CreateCocoaScreenPreview (void* parentView)
+{
+	pthread_once(&gDeckLinkOnceControl, InitDeckLinkAPI);
+	
+	if (gCreateCocoaPreviewFunc == NULL)
+		return NULL;
+	
+	return gCreateCocoaPreviewFunc(parentView);
+}
+
+IDeckLinkVideoConversion* CreateVideoConversionInstance (void)
+{
+	pthread_once(&gDeckLinkOnceControl, InitDeckLinkAPI);
+	
+	if (gCreateVideoConversionFunc == NULL)
+		return NULL;
+	
+	return gCreateVideoConversionFunc();
+}
+
+#define kBMDStreamingAPI_BundlePath "/Library/Application Support/Blackmagic Design/Streaming/BMDStreamingAPI.bundle"
+
+typedef IBMDStreamingDiscovery* (*CreateDiscoveryFunc)(void);
+typedef IBMDStreamingH264NALParser* (*CreateNALParserFunc)(void);
+
+static pthread_once_t      gBMDStreamingOnceControl  = PTHREAD_ONCE_INIT;
+static CFBundleRef         gBMDStreamingAPIBundleRef = NULL;
+static CreateDiscoveryFunc gCreateDiscoveryFunc      = NULL;
+static CreateNALParserFunc gCreateNALParserFunc      = NULL;
+
+void InitBMDStreamingAPI(void)
+{
+	CFURLRef bundleURL;
+
+	bundleURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR(kBMDStreamingAPI_BundlePath), kCFURLPOSIXPathStyle, true);
+	if (bundleURL != NULL)
+	{
+		gBMDStreamingAPIBundleRef = CFBundleCreate(kCFAllocatorDefault, bundleURL);
+		if (gBMDStreamingAPIBundleRef != NULL)
+		{
+			gCreateDiscoveryFunc = (CreateDiscoveryFunc)CFBundleGetFunctionPointerForName(gBMDStreamingAPIBundleRef, CFSTR("CreateBMDStreamingDiscoveryInstance_0001"));
+			gCreateNALParserFunc = (CreateNALParserFunc)CFBundleGetFunctionPointerForName(gBMDStreamingAPIBundleRef, CFSTR("CreateBMDStreamingH264NALParser_0001"));
+		}
+
+		CFRelease(bundleURL);
+	}
+}
+
+IBMDStreamingDiscovery* CreateBMDStreamingDiscoveryInstance()
+{
+	pthread_once(&gBMDStreamingOnceControl, InitBMDStreamingAPI);
+
+	if (gCreateDiscoveryFunc == NULL)
+		return NULL;
+
+	return gCreateDiscoveryFunc();
+}
+
+IBMDStreamingH264NALParser* CreateBMDStreamingH264NALParser()
+{
+	pthread_once(&gBMDStreamingOnceControl, InitBMDStreamingAPI);
+
+	if (gCreateNALParserFunc == NULL)
+		return NULL;
+
+	return gCreateNALParserFunc();
+}
diff --git a/sys/decklink/osx/DeckLinkAPIModes.h b/sys/decklink/osx/DeckLinkAPIModes.h
new file mode 100644
index 0000000..8b07592
--- /dev/null
+++ b/sys/decklink/osx/DeckLinkAPIModes.h
@@ -0,0 +1,155 @@
+/* -LICENSE-START-
+** Copyright (c) 2011 Blackmagic Design
+**
+** Permission is hereby granted, free of charge, to any person or organization
+** obtaining a copy of the software and accompanying documentation covered by
+** this license (the "Software") to use, reproduce, display, distribute,
+** execute, and transmit the Software, and to prepare derivative works of the
+** Software, and to permit third-parties to whom the Software is furnished to
+** do so, all subject to the following:
+** 
+** The copyright notices in the Software and this entire statement, including
+** the above license grant, this restriction and the following disclaimer,
+** must be included in all copies of the Software, in whole or in part, and
+** all derivative works of the Software, unless such copies or derivative
+** works are solely in the form of machine-executable object code generated by
+** a source language processor.
+** 
+** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+** DEALINGS IN THE SOFTWARE.
+** -LICENSE-END-
+*/
+
+#ifndef BMD_DECKLINKAPIMODES_H
+#define BMD_DECKLINKAPIMODES_H
+
+// Type Declarations
+
+
+// Interface ID Declarations
+
+#define IID_IDeckLinkDisplayModeIterator                 /* 9C88499F-F601-4021-B80B-032E4EB41C35 */ (REFIID){0x9C,0x88,0x49,0x9F,0xF6,0x01,0x40,0x21,0xB8,0x0B,0x03,0x2E,0x4E,0xB4,0x1C,0x35}
+#define IID_IDeckLinkDisplayMode                         /* 3EB2C1AB-0A3D-4523-A3AD-F40D7FB14E78 */ (REFIID){0x3E,0xB2,0xC1,0xAB,0x0A,0x3D,0x45,0x23,0xA3,0xAD,0xF4,0x0D,0x7F,0xB1,0x4E,0x78}
+
+/* Enum BMDDisplayMode - Video display modes */
+
+typedef uint32_t BMDDisplayMode;
+enum _BMDDisplayMode {
+
+    /* SD Modes */
+
+    bmdModeNTSC                                                  = 'ntsc',
+    bmdModeNTSC2398                                              = 'nt23',	// 3:2 pulldown
+    bmdModePAL                                                   = 'pal ',
+    bmdModeNTSCp                                                 = 'ntsp',
+    bmdModePALp                                                  = 'palp',
+
+    /* HD 1080 Modes */
+
+    bmdModeHD1080p2398                                           = '23ps',
+    bmdModeHD1080p24                                             = '24ps',
+    bmdModeHD1080p25                                             = 'Hp25',
+    bmdModeHD1080p2997                                           = 'Hp29',
+    bmdModeHD1080p30                                             = 'Hp30',
+    bmdModeHD1080i50                                             = 'Hi50',
+    bmdModeHD1080i5994                                           = 'Hi59',
+    bmdModeHD1080i6000                                           = 'Hi60',	// N.B. This _really_ is 60.00 Hz.
+    bmdModeHD1080p50                                             = 'Hp50',
+    bmdModeHD1080p5994                                           = 'Hp59',
+    bmdModeHD1080p6000                                           = 'Hp60',	// N.B. This _really_ is 60.00 Hz.
+
+    /* HD 720 Modes */
+
+    bmdModeHD720p50                                              = 'hp50',
+    bmdModeHD720p5994                                            = 'hp59',
+    bmdModeHD720p60                                              = 'hp60',
+
+    /* 2k Modes */
+
+    bmdMode2k2398                                                = '2k23',
+    bmdMode2k24                                                  = '2k24',
+    bmdMode2k25                                                  = '2k25',
+
+    /* Special Modes */
+
+    bmdModeUnknown                                               = 'iunk'
+};
+
+/* Enum BMDFieldDominance - Video field dominance */
+
+typedef uint32_t BMDFieldDominance;
+enum _BMDFieldDominance {
+    bmdUnknownFieldDominance                                     = 0,
+    bmdLowerFieldFirst                                           = 'lowr',
+    bmdUpperFieldFirst                                           = 'uppr',
+    bmdProgressiveFrame                                          = 'prog',
+    bmdProgressiveSegmentedFrame                                 = 'psf '
+};
+
+/* Enum BMDPixelFormat - Video pixel formats supported for output/input */
+
+typedef uint32_t BMDPixelFormat;
+enum _BMDPixelFormat {
+    bmdFormat8BitYUV                                             = '2vuy',
+    bmdFormat10BitYUV                                            = 'v210',
+    bmdFormat8BitARGB                                            = 32,
+    bmdFormat8BitBGRA                                            = 'BGRA',
+    bmdFormat10BitRGB                                            = 'r210'	// Big-endian RGB 10-bit per component with SMPTE video levels (64-960). Packed as 2:10:10:10
+};
+
+/* Enum BMDDisplayModeFlags - Flags to describe the characteristics of an IDeckLinkDisplayMode. */
+
+typedef uint32_t BMDDisplayModeFlags;
+enum _BMDDisplayModeFlags {
+    bmdDisplayModeSupports3D                                     = 1 << 0,
+    bmdDisplayModeColorspaceRec601                               = 1 << 1,
+    bmdDisplayModeColorspaceRec709                               = 1 << 2
+};
+
+// Forward Declarations
+
+class IDeckLinkDisplayModeIterator;
+class IDeckLinkDisplayMode;
+
+/* Interface IDeckLinkDisplayModeIterator - enumerates over supported input/output display modes. */
+
+class IDeckLinkDisplayModeIterator : public IUnknown
+{
+public:
+    virtual HRESULT Next (/* out */ IDeckLinkDisplayMode **deckLinkDisplayMode) = 0;
+
+protected:
+    virtual ~IDeckLinkDisplayModeIterator () {}; // call Release method to drop reference count
+};
+
+/* Interface IDeckLinkDisplayMode - represents a display mode */
+
+class IDeckLinkDisplayMode : public IUnknown
+{
+public:
+    virtual HRESULT GetName (/* out */ CFStringRef *name) = 0;
+    virtual BMDDisplayMode GetDisplayMode (void) = 0;
+    virtual long GetWidth (void) = 0;
+    virtual long GetHeight (void) = 0;
+    virtual HRESULT GetFrameRate (/* out */ BMDTimeValue *frameDuration, /* out */ BMDTimeScale *timeScale) = 0;
+    virtual BMDFieldDominance GetFieldDominance (void) = 0;
+    virtual BMDDisplayModeFlags GetFlags (void) = 0;
+
+protected:
+    virtual ~IDeckLinkDisplayMode () {}; // call Release method to drop reference count
+};
+
+/* Functions */
+
+extern "C" {
+
+
+};
+
+
+#endif /* defined(BMD_DECKLINKAPIMODES_H) */
diff --git a/sys/decklink/osx/DeckLinkAPIStreaming.h b/sys/decklink/osx/DeckLinkAPIStreaming.h
new file mode 100644
index 0000000..ecffb8d
--- /dev/null
+++ b/sys/decklink/osx/DeckLinkAPIStreaming.h
@@ -0,0 +1,366 @@
+/* -LICENSE-START-
+** Copyright (c) 2011 Blackmagic Design
+**
+** Permission is hereby granted, free of charge, to any person or organization
+** obtaining a copy of the software and accompanying documentation covered by
+** this license (the "Software") to use, reproduce, display, distribute,
+** execute, and transmit the Software, and to prepare derivative works of the
+** Software, and to permit third-parties to whom the Software is furnished to
+** do so, all subject to the following:
+** 
+** The copyright notices in the Software and this entire statement, including
+** the above license grant, this restriction and the following disclaimer,
+** must be included in all copies of the Software, in whole or in part, and
+** all derivative works of the Software, unless such copies or derivative
+** works are solely in the form of machine-executable object code generated by
+** a source language processor.
+** 
+** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+** DEALINGS IN THE SOFTWARE.
+** -LICENSE-END-
+*/
+
+#ifndef BMD_DECKLINKAPISTREAMING_H
+#define BMD_DECKLINKAPISTREAMING_H
+
+// Type Declarations
+
+
+// Interface ID Declarations
+
+#define IID_IBMDStreamingDeviceNotificationCallback      /* F9531D64-3305-4B29-A387-7F74BB0D0E84 */ (REFIID){0xF9,0x53,0x1D,0x64,0x33,0x05,0x4B,0x29,0xA3,0x87,0x7F,0x74,0xBB,0x0D,0x0E,0x84}
+#define IID_IBMDStreamingH264InputCallback               /* 823C475F-55AE-46F9-890C-537CC5CEDCCA */ (REFIID){0x82,0x3C,0x47,0x5F,0x55,0xAE,0x46,0xF9,0x89,0x0C,0x53,0x7C,0xC5,0xCE,0xDC,0xCA}
+#define IID_IBMDStreamingDiscovery                       /* 2C837444-F989-4D87-901A-47C8A36D096D */ (REFIID){0x2C,0x83,0x74,0x44,0xF9,0x89,0x4D,0x87,0x90,0x1A,0x47,0xC8,0xA3,0x6D,0x09,0x6D}
+#define IID_IBMDStreamingVideoEncodingMode               /* 1AB8035B-CD13-458D-B6DF-5E8F7C2141D9 */ (REFIID){0x1A,0xB8,0x03,0x5B,0xCD,0x13,0x45,0x8D,0xB6,0xDF,0x5E,0x8F,0x7C,0x21,0x41,0xD9}
+#define IID_IBMDStreamingMutableVideoEncodingMode        /* 19BF7D90-1E0A-400D-B2C6-FFC4E78AD49D */ (REFIID){0x19,0xBF,0x7D,0x90,0x1E,0x0A,0x40,0x0D,0xB2,0xC6,0xFF,0xC4,0xE7,0x8A,0xD4,0x9D}
+#define IID_IBMDStreamingVideoEncodingModePresetIterator /* 7AC731A3-C950-4AD0-804A-8377AA51C6C4 */ (REFIID){0x7A,0xC7,0x31,0xA3,0xC9,0x50,0x4A,0xD0,0x80,0x4A,0x83,0x77,0xAA,0x51,0xC6,0xC4}
+#define IID_IBMDStreamingDeviceInput                     /* 24B6B6EC-1727-44BB-9818-34FF086ACF98 */ (REFIID){0x24,0xB6,0xB6,0xEC,0x17,0x27,0x44,0xBB,0x98,0x18,0x34,0xFF,0x08,0x6A,0xCF,0x98}
+#define IID_IBMDStreamingH264NALPacket                   /* E260E955-14BE-4395-9775-9F02CC0A9D89 */ (REFIID){0xE2,0x60,0xE9,0x55,0x14,0xBE,0x43,0x95,0x97,0x75,0x9F,0x02,0xCC,0x0A,0x9D,0x89}
+#define IID_IBMDStreamingAudioPacket                     /* D9EB5902-1AD2-43F4-9E2C-3CFA50B5EE19 */ (REFIID){0xD9,0xEB,0x59,0x02,0x1A,0xD2,0x43,0xF4,0x9E,0x2C,0x3C,0xFA,0x50,0xB5,0xEE,0x19}
+#define IID_IBMDStreamingMPEG2TSPacket                   /* 91810D1C-4FB3-4AAA-AE56-FA301D3DFA4C */ (REFIID){0x91,0x81,0x0D,0x1C,0x4F,0xB3,0x4A,0xAA,0xAE,0x56,0xFA,0x30,0x1D,0x3D,0xFA,0x4C}
+#define IID_IBMDStreamingH264NALParser                   /* 5867F18C-5BFA-4CCC-B2A7-9DFD140417D2 */ (REFIID){0x58,0x67,0xF1,0x8C,0x5B,0xFA,0x4C,0xCC,0xB2,0xA7,0x9D,0xFD,0x14,0x04,0x17,0xD2}
+
+/* Enum BMDStreamingDeviceMode - Device modes */
+
+typedef uint32_t BMDStreamingDeviceMode;
+enum _BMDStreamingDeviceMode {
+    bmdStreamingDeviceIdle                                       = 'idle',
+    bmdStreamingDeviceEncoding                                   = 'enco',
+    bmdStreamingDeviceStopping                                   = 'stop',
+    bmdStreamingDeviceUnknown                                    = 'munk'
+};
+
+/* Enum BMDStreamingEncodingFrameRate - Encoded frame rates */
+
+typedef uint32_t BMDStreamingEncodingFrameRate;
+enum _BMDStreamingEncodingFrameRate {
+
+    /* Interlaced rates */
+
+    bmdStreamingEncodedFrameRate50i                              = 'e50i',
+    bmdStreamingEncodedFrameRate5994i                            = 'e59i',
+    bmdStreamingEncodedFrameRate60i                              = 'e60i',
+
+    /* Progressive rates */
+
+    bmdStreamingEncodedFrameRate2398p                            = 'e23p',
+    bmdStreamingEncodedFrameRate24p                              = 'e24p',
+    bmdStreamingEncodedFrameRate25p                              = 'e25p',
+    bmdStreamingEncodedFrameRate2997p                            = 'e29p',
+    bmdStreamingEncodedFrameRate30p                              = 'e30p',
+    bmdStreamingEncodedFrameRate50p                              = 'e50p',
+    bmdStreamingEncodedFrameRate5994p                            = 'e59p',
+    bmdStreamingEncodedFrameRate60p                              = 'e60p'
+};
+
+/* Enum BMDStreamingEncodingSupport - Output encoding mode supported flag */
+
+typedef uint32_t BMDStreamingEncodingSupport;
+enum _BMDStreamingEncodingSupport {
+    bmdStreamingEncodingModeNotSupported                         = 0,
+    bmdStreamingEncodingModeSupported,                          
+    bmdStreamingEncodingModeSupportedWithChanges                
+};
+
+/* Enum BMDStreamingVideoCodec - Video codecs */
+
+typedef uint32_t BMDStreamingVideoCodec;
+enum _BMDStreamingVideoCodec {
+    bmdStreamingVideoCodecH264                                   = 'H264'
+};
+
+/* Enum BMDStreamingH264Profile - H264 encoding profile */
+
+typedef uint32_t BMDStreamingH264Profile;
+enum _BMDStreamingH264Profile {
+    bmdStreamingH264ProfileHigh                                  = 'high',
+    bmdStreamingH264ProfileMain                                  = 'main',
+    bmdStreamingH264ProfileBaseline                              = 'base'
+};
+
+/* Enum BMDStreamingH264Level - H264 encoding level */
+
+typedef uint32_t BMDStreamingH264Level;
+enum _BMDStreamingH264Level {
+    bmdStreamingH264Level12                                      = 'lv12',
+    bmdStreamingH264Level13                                      = 'lv13',
+    bmdStreamingH264Level2                                       = 'lv2 ',
+    bmdStreamingH264Level21                                      = 'lv21',
+    bmdStreamingH264Level22                                      = 'lv22',
+    bmdStreamingH264Level3                                       = 'lv3 ',
+    bmdStreamingH264Level31                                      = 'lv31',
+    bmdStreamingH264Level32                                      = 'lv32',
+    bmdStreamingH264Level4                                       = 'lv4 ',
+    bmdStreamingH264Level41                                      = 'lv41',
+    bmdStreamingH264Level42                                      = 'lv42'
+};
+
+/* Enum BMDStreamingH264EntropyCoding - H264 entropy coding */
+
+typedef uint32_t BMDStreamingH264EntropyCoding;
+enum _BMDStreamingH264EntropyCoding {
+    bmdStreamingH264EntropyCodingCAVLC                           = 'EVLC',
+    bmdStreamingH264EntropyCodingCABAC                           = 'EBAC'
+};
+
+/* Enum BMDStreamingAudioCodec - Audio codecs */
+
+typedef uint32_t BMDStreamingAudioCodec;
+enum _BMDStreamingAudioCodec {
+    bmdStreamingAudioCodecAAC                                    = 'AAC '
+};
+
+/* Enum BMDStreamingEncodingModePropertyID - Encoding mode properties */
+
+typedef uint32_t BMDStreamingEncodingModePropertyID;
+enum _BMDStreamingEncodingModePropertyID {
+
+    /* Integers, Video Properties */
+
+    bmdStreamingEncodingPropertyVideoFrameRate                   = 'vfrt',	// Uses values of type BMDStreamingEncodingFrameRate
+    bmdStreamingEncodingPropertyVideoBitRateKbps                 = 'vbrt',
+
+    /* Integers, H264 Properties */
+
+    bmdStreamingEncodingPropertyH264Profile                      = 'hprf',
+    bmdStreamingEncodingPropertyH264Level                        = 'hlvl',
+    bmdStreamingEncodingPropertyH264EntropyCoding                = 'hent',
+
+    /* Flags, H264 Properties */
+
+    bmdStreamingEncodingPropertyH264HasBFrames                   = 'hBfr',
+
+    /* Integers, Audio Properties */
+
+    bmdStreamingEncodingPropertyAudioCodec                       = 'acdc',
+    bmdStreamingEncodingPropertyAudioSampleRate                  = 'asrt',
+    bmdStreamingEncodingPropertyAudioChannelCount                = 'achc',
+    bmdStreamingEncodingPropertyAudioBitRateKbps                 = 'abrt'
+};
+
+// Forward Declarations
+
+class IBMDStreamingDeviceNotificationCallback;
+class IBMDStreamingH264InputCallback;
+class IBMDStreamingDiscovery;
+class IBMDStreamingVideoEncodingMode;
+class IBMDStreamingMutableVideoEncodingMode;
+class IBMDStreamingVideoEncodingModePresetIterator;
+class IBMDStreamingDeviceInput;
+class IBMDStreamingH264NALPacket;
+class IBMDStreamingAudioPacket;
+class IBMDStreamingMPEG2TSPacket;
+class IBMDStreamingH264NALParser;
+
+/* Interface IBMDStreamingDeviceNotificationCallback - Device notification callbacks. */
+
+class IBMDStreamingDeviceNotificationCallback : public IUnknown
+{
+public:
+    virtual HRESULT StreamingDeviceArrived (/* in */ IDeckLink* device) = 0;
+    virtual HRESULT StreamingDeviceRemoved (/* in */ IDeckLink* device) = 0;
+    virtual HRESULT StreamingDeviceModeChanged (/* in */ IDeckLink* device, /* in */ BMDStreamingDeviceMode mode) = 0;
+
+protected:
+    virtual ~IBMDStreamingDeviceNotificationCallback () {}; // call Release method to drop reference count
+};
+
+/* Interface IBMDStreamingH264InputCallback - H264 input callbacks. */
+
+class IBMDStreamingH264InputCallback : public IUnknown
+{
+public:
+    virtual HRESULT H264NALPacketArrived (/* in */ IBMDStreamingH264NALPacket* nalPacket) = 0;
+    virtual HRESULT H264AudioPacketArrived (/* in */ IBMDStreamingAudioPacket* audioPacket) = 0;
+    virtual HRESULT MPEG2TSPacketArrived (/* in */ IBMDStreamingMPEG2TSPacket* tsPacket) = 0;
+    virtual HRESULT H264VideoInputConnectorScanningChanged (void) = 0;
+    virtual HRESULT H264VideoInputConnectorChanged (void) = 0;
+    virtual HRESULT H264VideoInputModeChanged (void) = 0;
+
+protected:
+    virtual ~IBMDStreamingH264InputCallback () {}; // call Release method to drop reference count
+};
+
+/* Interface IBMDStreamingDiscovery - Installs device notifications */
+
+class IBMDStreamingDiscovery : public IUnknown
+{
+public:
+    virtual HRESULT InstallDeviceNotifications (/* in */ IBMDStreamingDeviceNotificationCallback* theCallback) = 0;
+    virtual HRESULT UninstallDeviceNotifications (void) = 0;
+
+protected:
+    virtual ~IBMDStreamingDiscovery () {}; // call Release method to drop reference count
+};
+
+/* Interface IBMDStreamingVideoEncodingMode - Represents an encoded video mode. */
+
+class IBMDStreamingVideoEncodingMode : public IUnknown
+{
+public:
+    virtual HRESULT GetName (/* out */ CFStringRef *name) = 0;
+    virtual unsigned int GetPresetID (void) = 0;
+    virtual unsigned int GetSourcePositionX (void) = 0;
+    virtual unsigned int GetSourcePositionY (void) = 0;
+    virtual unsigned int GetSourceWidth (void) = 0;
+    virtual unsigned int GetSourceHeight (void) = 0;
+    virtual unsigned int GetDestWidth (void) = 0;
+    virtual unsigned int GetDestHeight (void) = 0;
+    virtual HRESULT GetFlag (/* in */ BMDStreamingEncodingModePropertyID cfgID, /* out */ bool* value) = 0;
+    virtual HRESULT GetInt (/* in */ BMDStreamingEncodingModePropertyID cfgID, /* out */ int64_t* value) = 0;
+    virtual HRESULT GetFloat (/* in */ BMDStreamingEncodingModePropertyID cfgID, /* out */ double* value) = 0;
+    virtual HRESULT GetString (/* in */ BMDStreamingEncodingModePropertyID cfgID, /* out */ CFStringRef *value) = 0;
+    virtual HRESULT CreateMutableVideoEncodingMode (/* out */ IBMDStreamingMutableVideoEncodingMode** newEncodingMode) = 0; // Creates a mutable copy of the encoding mode
+
+protected:
+    virtual ~IBMDStreamingVideoEncodingMode () {}; // call Release method to drop reference count
+};
+
+/* Interface IBMDStreamingMutableVideoEncodingMode - Represents a mutable encoded video mode. */
+
+class IBMDStreamingMutableVideoEncodingMode : public IBMDStreamingVideoEncodingMode
+{
+public:
+    virtual HRESULT SetSourceRect (/* in */ uint32_t posX, /* in */ uint32_t posY, /* in */ uint32_t width, /* in */ uint32_t height) = 0;
+    virtual HRESULT SetDestSize (/* in */ uint32_t width, /* in */ uint32_t height) = 0;
+    virtual HRESULT SetFlag (/* in */ BMDStreamingEncodingModePropertyID cfgID, /* in */ bool value) = 0;
+    virtual HRESULT SetInt (/* in */ BMDStreamingEncodingModePropertyID cfgID, /* in */ int64_t value) = 0;
+    virtual HRESULT SetFloat (/* in */ BMDStreamingEncodingModePropertyID cfgID, /* in */ double value) = 0;
+    virtual HRESULT SetString (/* in */ BMDStreamingEncodingModePropertyID cfgID, /* in */ CFStringRef value) = 0;
+
+protected:
+    virtual ~IBMDStreamingMutableVideoEncodingMode () {}; // call Release method to drop reference count
+};
+
+/* Interface IBMDStreamingVideoEncodingModePresetIterator - Enumerates encoding mode presets */
+
+class IBMDStreamingVideoEncodingModePresetIterator : public IUnknown
+{
+public:
+    virtual HRESULT Next (/* out */ IBMDStreamingVideoEncodingMode** videoEncodingMode) = 0;
+
+protected:
+    virtual ~IBMDStreamingVideoEncodingModePresetIterator () {}; // call Release method to drop reference count
+};
+
+/* Interface IBMDStreamingDeviceInput - Created by QueryInterface from IDeckLink */
+
+class IBMDStreamingDeviceInput : public IUnknown
+{
+public:
+
+    /* Input modes */
+
+    virtual HRESULT DoesSupportVideoInputMode (/* in */ BMDDisplayMode inputMode, /* out */ bool* result) = 0;
+    virtual HRESULT GetVideoInputModeIterator (/* out */ IDeckLinkDisplayModeIterator** iterator) = 0;
+    virtual HRESULT SetVideoInputMode (/* in */ BMDDisplayMode inputMode) = 0;
+    virtual HRESULT GetCurrentDetectedVideoInputMode (/* out */ BMDDisplayMode* detectedMode) = 0;
+
+    /* Capture modes */
+
+    virtual HRESULT GetVideoEncodingMode (/* out */ IBMDStreamingVideoEncodingMode** encodingMode) = 0;
+    virtual HRESULT GetVideoEncodingModePresetIterator (/* in */ BMDDisplayMode inputMode, /* out */ IBMDStreamingVideoEncodingModePresetIterator** iterator) = 0;
+    virtual HRESULT DoesSupportVideoEncodingMode (/* in */ BMDDisplayMode inputMode, /* in */ IBMDStreamingVideoEncodingMode* encodingMode, /* out */ BMDStreamingEncodingSupport* result, /* out */ IBMDStreamingVideoEncodingMode** changedEncodingMode) = 0;
+    virtual HRESULT SetVideoEncodingMode (/* in */ IBMDStreamingVideoEncodingMode* encodingMode) = 0;
+
+    /* Input control */
+
+    virtual HRESULT StartCapture (void) = 0;
+    virtual HRESULT StopCapture (void) = 0;
+    virtual HRESULT SetCallback (/* in */ IUnknown* theCallback) = 0;
+
+protected:
+    virtual ~IBMDStreamingDeviceInput () {}; // call Release method to drop reference count
+};
+
+/* Interface IBMDStreamingH264NALPacket - Represent an H.264 NAL packet */
+
+class IBMDStreamingH264NALPacket : public IUnknown
+{
+public:
+    virtual long GetPayloadSize (void) = 0;
+    virtual HRESULT GetBytes (/* out */ void** buffer) = 0;
+    virtual HRESULT GetBytesWithSizePrefix (/* out */ void** buffer) = 0; // Contains a 32-bit unsigned big endian size prefix
+    virtual HRESULT GetDisplayTime (/* in */ uint64_t requestedTimeScale, /* out */ uint64_t* displayTime) = 0;
+    virtual HRESULT GetPacketIndex (/* out */ uint32_t* packetIndex) = 0;
+
+protected:
+    virtual ~IBMDStreamingH264NALPacket () {}; // call Release method to drop reference count
+};
+
+/* Interface IBMDStreamingAudioPacket - Represents a chunk of audio data */
+
+class IBMDStreamingAudioPacket : public IUnknown
+{
+public:
+    virtual BMDStreamingAudioCodec GetCodec (void) = 0;
+    virtual long GetPayloadSize (void) = 0;
+    virtual HRESULT GetBytes (/* out */ void** buffer) = 0;
+    virtual HRESULT GetPlayTime (/* in */ uint64_t requestedTimeScale, /* out */ uint64_t* playTime) = 0;
+    virtual HRESULT GetPacketIndex (/* out */ uint32_t* packetIndex) = 0;
+
+protected:
+    virtual ~IBMDStreamingAudioPacket () {}; // call Release method to drop reference count
+};
+
+/* Interface IBMDStreamingMPEG2TSPacket - Represent an MPEG2 Transport Stream packet */
+
+class IBMDStreamingMPEG2TSPacket : public IUnknown
+{
+public:
+    virtual long GetPayloadSize (void) = 0;
+    virtual HRESULT GetBytes (/* out */ void** buffer) = 0;
+
+protected:
+    virtual ~IBMDStreamingMPEG2TSPacket () {}; // call Release method to drop reference count
+};
+
+/* Interface IBMDStreamingH264NALParser - For basic NAL parsing */
+
+class IBMDStreamingH264NALParser : public IUnknown
+{
+public:
+    virtual HRESULT IsNALSequenceParameterSet (/* in */ IBMDStreamingH264NALPacket* nal) = 0;
+    virtual HRESULT IsNALPictureParameterSet (/* in */ IBMDStreamingH264NALPacket* nal) = 0;
+    virtual HRESULT GetProfileAndLevelFromSPS (/* in */ IBMDStreamingH264NALPacket* nal, /* out */ uint32_t* profileIdc, /* out */ uint32_t* profileCompatability, /* out */ uint32_t* levelIdc) = 0;
+
+protected:
+    virtual ~IBMDStreamingH264NALParser () {}; // call Release method to drop reference count
+};
+
+/* Functions */
+
+extern "C" {
+
+    IBMDStreamingDiscovery* CreateBMDStreamingDiscoveryInstance (void);
+    IBMDStreamingH264NALParser* CreateBMDStreamingH264NALParser (void);
+
+};
+
+
+#endif /* defined(BMD_DECKLINKAPISTREAMING_H) */
diff --git a/sys/decklink/osx/DeckLinkAPITypes.h b/sys/decklink/osx/DeckLinkAPITypes.h
new file mode 100644
index 0000000..ed54d8e
--- /dev/null
+++ b/sys/decklink/osx/DeckLinkAPITypes.h
@@ -0,0 +1,89 @@
+/* -LICENSE-START-
+** Copyright (c) 2011 Blackmagic Design
+**
+** Permission is hereby granted, free of charge, to any person or organization
+** obtaining a copy of the software and accompanying documentation covered by
+** this license (the "Software") to use, reproduce, display, distribute,
+** execute, and transmit the Software, and to prepare derivative works of the
+** Software, and to permit third-parties to whom the Software is furnished to
+** do so, all subject to the following:
+** 
+** The copyright notices in the Software and this entire statement, including
+** the above license grant, this restriction and the following disclaimer,
+** must be included in all copies of the Software, in whole or in part, and
+** all derivative works of the Software, unless such copies or derivative
+** works are solely in the form of machine-executable object code generated by
+** a source language processor.
+** 
+** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+** DEALINGS IN THE SOFTWARE.
+** -LICENSE-END-
+*/
+
+#ifndef BMD_DECKLINKAPITYPES_H
+#define BMD_DECKLINKAPITYPES_H
+
+// Type Declarations
+
+typedef int64_t BMDTimeValue;
+typedef int64_t BMDTimeScale;
+typedef uint32_t BMDTimecodeBCD;
+typedef uint32_t BMDTimecodeUserBits;
+
+// Interface ID Declarations
+
+#define IID_IDeckLinkTimecode                            /* BC6CFBD3-8317-4325-AC1C-1216391E9340 */ (REFIID){0xBC,0x6C,0xFB,0xD3,0x83,0x17,0x43,0x25,0xAC,0x1C,0x12,0x16,0x39,0x1E,0x93,0x40}
+
+/* Enum BMDTimecodeFlags - Timecode flags */
+
+typedef uint32_t BMDTimecodeFlags;
+enum _BMDTimecodeFlags {
+    bmdTimecodeFlagDefault                                       = 0,
+    bmdTimecodeIsDropFrame                                       = 1 << 0
+};
+
+/* Enum BMDVideoConnection - Video connection types */
+
+typedef uint32_t BMDVideoConnection;
+enum _BMDVideoConnection {
+    bmdVideoConnectionSDI                                        = 1 << 0,
+    bmdVideoConnectionHDMI                                       = 1 << 1,
+    bmdVideoConnectionOpticalSDI                                 = 1 << 2,
+    bmdVideoConnectionComponent                                  = 1 << 3,
+    bmdVideoConnectionComposite                                  = 1 << 4,
+    bmdVideoConnectionSVideo                                     = 1 << 5
+};
+
+// Forward Declarations
+
+class IDeckLinkTimecode;
+
+/* Interface IDeckLinkTimecode - Used for video frame timecode representation. */
+
+class IDeckLinkTimecode : public IUnknown
+{
+public:
+    virtual BMDTimecodeBCD GetBCD (void) = 0;
+    virtual HRESULT GetComponents (/* out */ uint8_t *hours, /* out */ uint8_t *minutes, /* out */ uint8_t *seconds, /* out */ uint8_t *frames) = 0;
+    virtual HRESULT GetString (/* out */ CFStringRef *timecode) = 0;
+    virtual BMDTimecodeFlags GetFlags (void) = 0;
+    virtual HRESULT GetTimecodeUserBits (/* out */ BMDTimecodeUserBits *userBits) = 0;
+
+protected:
+    virtual ~IDeckLinkTimecode () {}; // call Release method to drop reference count
+};
+
+/* Functions */
+
+extern "C" {
+
+
+};
+
+
+#endif /* defined(BMD_DECKLINKAPITYPES_H) */
diff --git a/sys/decklink/osx/DeckLinkAPIVersion.h b/sys/decklink/osx/DeckLinkAPIVersion.h
new file mode 100644
index 0000000..2681ed0
--- /dev/null
+++ b/sys/decklink/osx/DeckLinkAPIVersion.h
@@ -0,0 +1,37 @@
+/* -LICENSE-START-
+ * ** Copyright (c) 2011 Blackmagic Design
+ * **
+ * ** Permission is hereby granted, free of charge, to any person or organization
+ * ** obtaining a copy of the software and accompanying documentation covered by
+ * ** this license (the "Software") to use, reproduce, display, distribute,
+ * ** execute, and transmit the Software, and to prepare derivative works of the
+ * ** Software, and to permit third-parties to whom the Software is furnished to
+ * ** do so, all subject to the following:
+ * ** 
+ * ** The copyright notices in the Software and this entire statement, including
+ * ** the above license grant, this restriction and the following disclaimer,
+ * ** must be included in all copies of the Software, in whole or in part, and
+ * ** all derivative works of the Software, unless such copies or derivative
+ * ** works are solely in the form of machine-executable object code generated by
+ * ** a source language processor.
+ * ** 
+ * ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+ * ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+ * ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+ * ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * ** DEALINGS IN THE SOFTWARE.
+ * ** -LICENSE-END-
+ * */
+
+/* DeckLinkAPIVersion.h */
+
+#ifndef __DeckLink_API_Verison_h__
+#define __DeckLink_API_Version_h__
+
+#define BLACKMAGIC_DECKLINK_API_VERSION					0x09000000
+#define BLACKMAGIC_DECKLINK_API_VERSION_STRING			"9.0"
+
+#endif	// __DeckLink_API_Version_h__
+
diff --git a/sys/directdraw/gstdirectdrawsink.c b/sys/directdraw/gstdirectdrawsink.c
index bd9b79c..518ca7c 100644
--- a/sys/directdraw/gstdirectdrawsink.c
+++ b/sys/directdraw/gstdirectdrawsink.c
@@ -1416,7 +1416,7 @@ gst_directdraw_sink_setup_ddraw (GstDirectDrawSink * ddrawsink)
   return bRet;
 }
 
-static long FAR PASCAL
+static LRESULT FAR PASCAL
 WndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
 {
   switch (message) {
@@ -2026,7 +2026,7 @@ surface_pitch_bad:
   GST_BUFFER_SIZE (surface) = size;
   surface->surface = NULL;
   GST_CAT_INFO_OBJECT (directdrawsink_debug, ddrawsink,
-      "allocating a system memory buffer of %d bytes", size);
+      "allocating a system memory buffer of %" G_GSIZE_FORMAT " bytes", size);
 
 #endif
 
diff --git a/sys/dvb/camutils.c b/sys/dvb/camutils.c
index b3062b5..721b5cd 100644
--- a/sys/dvb/camutils.c
+++ b/sys/dvb/camutils.c
@@ -21,6 +21,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include <gst/gst.h>
 #include <string.h>
 
diff --git a/sys/dvb/gstdvbsrc.c b/sys/dvb/gstdvbsrc.c
index 7eb2a23..13f5726 100644
--- a/sys/dvb/gstdvbsrc.c
+++ b/sys/dvb/gstdvbsrc.c
@@ -42,6 +42,7 @@
 
 #include "gstdvbsrc.h"
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 #include <sys/ioctl.h>
 #include <sys/poll.h>
 #include <fcntl.h>
@@ -467,6 +468,8 @@ gst_dvbsrc_init (GstDvbSrc * object, GstDvbSrcClass * klass)
 
   /* We are a live source */
   gst_base_src_set_live (GST_BASE_SRC (object), TRUE);
+  /* And we wanted timestamped output */
+  gst_base_src_set_do_timestamp (GST_BASE_SRC (object), TRUE);
 
   object->fd_frontend = -1;
   object->fd_dvr = -1;
@@ -944,7 +947,6 @@ gst_dvbsrc_read_device (GstDvbSrc * object, int size)
   }
 
   GST_BUFFER_SIZE (buf) = count;
-  GST_BUFFER_TIMESTAMP (buf) = GST_CLOCK_TIME_NONE;
   return buf;
 
 stopped:
diff --git a/sys/shm/Makefile.am b/sys/shm/Makefile.am
index bfe7b49..f62e20e 100644
--- a/sys/shm/Makefile.am
+++ b/sys/shm/Makefile.am
@@ -5,9 +5,9 @@ include $(top_srcdir)/common/glib-gen.mak
 plugin_LTLIBRARIES = libgstshm.la
 
 libgstshm_la_SOURCES = shmpipe.c shmalloc.c gstshm.c gstshmsrc.c gstshmsink.c
-libgstshm_la_CFLAGS = $(GST_CFLAGS) -DSHM_PIPE_USE_GLIB
+libgstshm_la_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_CFLAGS) -DSHM_PIPE_USE_GLIB
 libgstshm_la_LIBADD = -lrt
-libgstshm_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS) $(GST_BASE_LIBS) $(GST_PLUGINS_BASE_LIBS)
+libgstshm_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS) $(GST_BASE_LIBS)
 libgstshm_la_LIBTOOLFLAGS = --tag=disable-static
 
 noinst_HEADERS = gstshmsrc.h gstshmsink.h shmpipe.h  shmalloc.h
diff --git a/sys/shm/gstshmsink.c b/sys/shm/gstshmsink.c
index 1b98e47..3ebbc47 100644
--- a/sys/shm/gstshmsink.c
+++ b/sys/shm/gstshmsink.c
@@ -18,8 +18,18 @@
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  */
-
-
+/**
+ * SECTION:element-shmsink
+ *
+ * Send data over shared memory to the matching source.
+ *
+ * <refsect2>
+ * <title>Example launch lines</title>
+ * |[
+ * gst-launch -v videotestsrc !  shmsink socket-path=/tmp/blah shm-size=1000000
+ * ]| Send video to shm buffers.
+ * </refsect2>
+ */
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -27,6 +37,7 @@
 #include "gstshmsink.h"
 
 #include <gst/gst.h>
+#include <gst/glib-compat-private.h>
 
 #include <string.h>
 
@@ -163,10 +174,10 @@ gst_shm_sink_class_init (GstShmSinkClass * klass)
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   g_object_class_install_property (gobject_class, PROP_BUFFER_TIME,
-      g_param_spec_uint64 ("buffer-time",
+      g_param_spec_int64 ("buffer-time",
           "Buffer Time of the shm buffer",
           "Maximum Size of the shm buffer in nanoseconds (-1 to disable)",
-          0, G_MAXUINT64, GST_CLOCK_TIME_NONE,
+          -1, G_MAXINT64, -1,
           G_PARAM_CONSTRUCT | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   signals[SIGNAL_CLIENT_CONNECTED] = g_signal_new ("client-connected",
@@ -238,7 +249,7 @@ gst_shm_sink_set_property (GObject * object, guint prop_id,
       break;
     case PROP_BUFFER_TIME:
       GST_OBJECT_LOCK (object);
-      self->buffer_time = g_value_get_uint64 (value);
+      self->buffer_time = g_value_get_int64 (value);
       GST_OBJECT_UNLOCK (object);
       g_cond_broadcast (self->cond);
       break;
@@ -277,7 +288,7 @@ gst_shm_sink_get_property (GObject * object, guint prop_id,
       g_value_set_boolean (value, self->wait_for_connection);
       break;
     case PROP_BUFFER_TIME:
-      g_value_set_uint64 (value, self->buffer_time);
+      g_value_set_int64 (value, self->buffer_time);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
diff --git a/sys/shm/gstshmsink.h b/sys/shm/gstshmsink.h
index 83dad39..d0db530 100644
--- a/sys/shm/gstshmsink.h
+++ b/sys/shm/gstshmsink.h
@@ -61,7 +61,7 @@ struct _GstShmSink
   gboolean wait_for_connection;
   gboolean stop;
   gboolean unlock;
-  GstClockTime buffer_time;
+  GstClockTimeDiff buffer_time;
 
   GCond *cond;
 };
diff --git a/sys/shm/gstshmsrc.c b/sys/shm/gstshmsrc.c
index cff5d46..fe086b7 100644
--- a/sys/shm/gstshmsrc.c
+++ b/sys/shm/gstshmsrc.c
@@ -18,6 +18,20 @@
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  */
+/**
+ * SECTION:element-shmsrc
+ *
+ * Receive data from the shared memory sink.
+ *
+ * <refsect2>
+ * <title>Example launch lines</title>
+ * |[
+ * gst-launch shmsrc socket-path=/tmp/blah ! \
+ * "video/x-raw-yuv, format=(fourcc)YUY2, color-matrix=(string)sdtv, \
+ * chroma-site=(string)mpeg2, width=(int)320, height=(int)240, framerate=(fraction)30/1" ! autovideosink
+ * ]| Render video from shm buffers.
+ * </refsect2>
+ */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -90,7 +104,7 @@ gst_shm_src_base_init (gpointer g_class)
   gst_element_class_set_details_simple (element_class,
       "Shared Memory Source",
       "Source",
-      "Receive data from the sharem memory sink",
+      "Receive data from the shared memory sink",
       "Olivier Crete <olivier.crete@collabora.co.uk>");
 }
 
diff --git a/sys/vdpau/gstvdp/gstvdpbufferpool.c b/sys/vdpau/gstvdp/gstvdpbufferpool.c
index fea8aea..61c706b 100644
--- a/sys/vdpau/gstvdp/gstvdpbufferpool.c
+++ b/sys/vdpau/gstvdp/gstvdpbufferpool.c
@@ -18,6 +18,9 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
 
 #include "gstvdpbufferpool.h"
 
diff --git a/sys/vdpau/gstvdp/gstvdpdevice.c b/sys/vdpau/gstvdp/gstvdpdevice.c
index 359874b..eb54518 100644
--- a/sys/vdpau/gstvdp/gstvdpdevice.c
+++ b/sys/vdpau/gstvdp/gstvdpdevice.c
@@ -18,6 +18,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #include "gstvdpdevice.h"
 
 GST_DEBUG_CATEGORY_STATIC (gst_vdp_device_debug);
diff --git a/sys/vdpau/gstvdp/gstvdpoutputbufferpool.c b/sys/vdpau/gstvdp/gstvdpoutputbufferpool.c
index 826ef21..27f6689 100644
--- a/sys/vdpau/gstvdp/gstvdpoutputbufferpool.c
+++ b/sys/vdpau/gstvdp/gstvdpoutputbufferpool.c
@@ -3,18 +3,20 @@
  * gst-plugins-bad
  * Copyright (C) Carl-Anton Ingmarsson 2010 <ca.ingmarsson@gmail.com>
  * 
- * gst-plugins-bad is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * 
- * gst-plugins-bad is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along
- * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
  */
 
 #include "gstvdpdevice.h"
diff --git a/sys/vdpau/gstvdp/gstvdpoutputbufferpool.h b/sys/vdpau/gstvdp/gstvdpoutputbufferpool.h
index 354461c..7c40684 100644
--- a/sys/vdpau/gstvdp/gstvdpoutputbufferpool.h
+++ b/sys/vdpau/gstvdp/gstvdpoutputbufferpool.h
@@ -3,18 +3,20 @@
  * gst-plugins-bad
  * Copyright (C) Carl-Anton Ingmarsson 2010 <ca.ingmarsson@gmail.com>
  * 
- * gst-plugins-bad is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * 
- * gst-plugins-bad is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along
- * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
  */
 
 #ifndef _GST_VDP_OUTPUT_BUFFER_POOL_H_
diff --git a/sys/vdpau/gstvdp/gstvdpvideobufferpool.c b/sys/vdpau/gstvdp/gstvdpvideobufferpool.c
index 889367d..fdecb0d 100644
--- a/sys/vdpau/gstvdp/gstvdpvideobufferpool.c
+++ b/sys/vdpau/gstvdp/gstvdpvideobufferpool.c
@@ -3,18 +3,20 @@
  * gst-plugins-bad
  * Copyright (C) Carl-Anton Ingmarsson 2010 <ca.ingmarsson@gmail.com>
  * 
- * gst-plugins-bad is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * 
- * gst-plugins-bad is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along
- * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
  */
 
 #include "gstvdpdevice.h"
diff --git a/sys/vdpau/gstvdp/gstvdpvideobufferpool.h b/sys/vdpau/gstvdp/gstvdpvideobufferpool.h
index e22e9b9..8676102 100644
--- a/sys/vdpau/gstvdp/gstvdpvideobufferpool.h
+++ b/sys/vdpau/gstvdp/gstvdpvideobufferpool.h
@@ -3,18 +3,20 @@
  * gst-plugins-bad
  * Copyright (C) Carl-Anton Ingmarsson 2010 <ca.ingmarsson@gmail.com>
  * 
- * gst-plugins-bad is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * 
- * gst-plugins-bad is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along
- * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
  */
 
 #ifndef _GST_VDP_VIDEO_BUFFERPOOL_H_
diff --git a/sys/vdpau/gstvdpsink.c b/sys/vdpau/gstvdpsink.c
index 7b9fa2e..27847bd 100644
--- a/sys/vdpau/gstvdpsink.c
+++ b/sys/vdpau/gstvdpsink.c
@@ -18,6 +18,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/sys/vdpau/h264/gstvdph264dec.c b/sys/vdpau/h264/gstvdph264dec.c
index 6b6c336..71893ca 100644
--- a/sys/vdpau/h264/gstvdph264dec.c
+++ b/sys/vdpau/h264/gstvdph264dec.c
@@ -687,23 +687,25 @@ gst_vdp_h264_dec_parse_data (GstBaseVideoDecoder * base_video_decoder,
 
   gst_bit_reader_init_from_buffer (&reader, buf);
 
+  if (gst_bit_reader_get_remaining (&reader) <
+      h264_dec->nal_length_size * 8 + 7)
+    goto invalid_packet;
+
   /* skip nal_length or sync code */
-  gst_bit_reader_skip (&reader, h264_dec->nal_length_size * 8);
+  gst_bit_reader_skip_unchecked (&reader, h264_dec->nal_length_size * 8);
+
+  forbidden_zero_bit = gst_bit_reader_get_bits_uint8_unchecked (&reader, 1);
 
-  if (!gst_bit_reader_get_bits_uint8 (&reader, &forbidden_zero_bit, 1))
-    goto invalid_packet;
   if (forbidden_zero_bit != 0) {
     GST_WARNING ("forbidden_zero_bit != 0");
     return GST_FLOW_ERROR;
   }
 
-  if (!gst_bit_reader_get_bits_uint16 (&reader, &nal_unit.ref_idc, 2))
-    goto invalid_packet;
+  nal_unit.ref_idc = gst_bit_reader_get_bits_uint16_unchecked (&reader, 2);
   GST_DEBUG ("nal_ref_idc: %u", nal_unit.ref_idc);
 
   /* read nal_unit_type */
-  if (!gst_bit_reader_get_bits_uint16 (&reader, &nal_unit.type, 5))
-    goto invalid_packet;
+  nal_unit.type = gst_bit_reader_get_bits_uint16_unchecked (&reader, 5);
 
   GST_DEBUG ("nal_unit_type: %u", nal_unit.type);
   if (nal_unit.type == 14 || nal_unit.type == 20) {
@@ -716,7 +718,7 @@ gst_vdp_h264_dec_parse_data (GstBaseVideoDecoder * base_video_decoder,
   size = gst_bit_reader_get_remaining (&reader) / 8;
 
   i = size - 1;
-  while (size >= 0 && data[i] == 0x00) {
+  while ((gint) size > 0 && data[i] == 0x00) {
     size--;
     i--;
   }
@@ -870,8 +872,7 @@ gst_vdp_h264_dec_base_init (gpointer g_class)
       "Decode h264 stream with vdpau",
       "Carl-Anton Ingmarsson <ca.ingmarsson@gmail.com>");
 
-  gst_element_class_add_static_pad_template (element_class,
-      &sink_template);
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
 }
 
 static void
diff --git a/sys/vdpau/mpeg/gstvdpmpegdec.c b/sys/vdpau/mpeg/gstvdpmpegdec.c
index 6a473e4..87456eb 100644
--- a/sys/vdpau/mpeg/gstvdpmpegdec.c
+++ b/sys/vdpau/mpeg/gstvdpmpegdec.c
@@ -415,12 +415,14 @@ gst_vdp_mpeg_dec_parse_data (GstBaseVideoDecoder * base_video_decoder,
   GstBitReader b_reader = GST_BIT_READER_INIT_FROM_BUFFER (buf);
   guint8 start_code;
 
+  if (gst_bit_reader_get_remaining (&b_reader) < 8 * 3 + 8)
+    return GST_FLOW_ERROR;
+
   /* skip sync_code */
-  gst_bit_reader_skip (&b_reader, 8 * 3);
+  gst_bit_reader_skip_unchecked (&b_reader, 8 * 3);
 
   /* start_code */
-  if (!gst_bit_reader_get_bits_uint8 (&b_reader, &start_code, 8))
-    return GST_FLOW_ERROR;
+  start_code = gst_bit_reader_get_bits_uint8_unchecked (&b_reader, 8);
 
   mpeg_frame = GST_VDP_MPEG_FRAME_CAST (frame);
 
@@ -624,8 +626,7 @@ gst_vdp_mpeg_dec_base_init (gpointer gclass)
       "Decode mpeg stream with vdpau",
       "Carl-Anton Ingmarsson <ca.ingmarsson@gmail.com>");
 
-  gst_element_class_add_static_pad_template (element_class,
-      &sink_template);
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
 }
 
 /* initialize the vdpaumpegdecoder's class */
diff --git a/sys/winscreencap/Makefile.am b/sys/winscreencap/Makefile.am
index d14273b..09d80d2 100644
--- a/sys/winscreencap/Makefile.am
+++ b/sys/winscreencap/Makefile.am
@@ -1,8 +1,11 @@
-# This plugin isn't buildable with autotools at this point in time, so just
-# ensure everything's listed in EXTRA_DIST
+plugin_LTLIBRARIES = libgstwinscreencap.la
 
-EXTRA_DIST = \
-	gstdx9screencapsrc.c gstdx9screencapsrc.h \
-	gstgdiscreencapsrc.c gstgdiscreencapsrc.h \
-	gstwinscreencap.c gstwinscreencap.h
+libgstwinscreencap_la_SOURCES = gstdx9screencapsrc.c  gstgdiscreencapsrc.c  gstwinscreencap.c
+libgstwinscreencap_la_CFLAGS = $(GST_CFLAGS) $(GST_BASE_CFLAGS) \
+	$(GST_PLUGINS_BASE_CFLAGS)
+libgstwinscreencap_la_LIBADD = $(GST_BASE_LIBS) $(GST_PLUGINS_BASE_LIBS) \
+	$(DIRECT3D9_LIBS)
+libgstwinscreencap_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstwinscreencap_la_LIBTOOLFLAGS = --tag=disable-static
 
+noinst_HEADERS= gstwinscreencap.h
diff --git a/sys/winscreencap/gstdx9screencapsrc.c b/sys/winscreencap/gstdx9screencapsrc.c
index 72a04ce..029053d 100644
--- a/sys/winscreencap/gstdx9screencapsrc.c
+++ b/sys/winscreencap/gstdx9screencapsrc.c
@@ -296,14 +296,15 @@ gst_dx9screencapsrc_set_caps (GstBaseSrc * bsrc, GstCaps * caps)
     src->src_rect.bottom = src->src_rect.top + src->capture_h;
   }
 
-  if (framerate = gst_structure_get_value (structure, "framerate")) {
+  framerate = gst_structure_get_value (structure, "framerate");
+  if (framerate) {
     src->rate_numerator = gst_value_get_fraction_numerator (framerate);
     src->rate_denominator = gst_value_get_fraction_denominator (framerate);
   }
 
   GST_DEBUG_OBJECT (src, "size %dx%d, %d/%d fps",
-      src->src_rect.right - src->src_rect.left,
-      src->src_rect.bottom - src->src_rect.top,
+      (gint) (src->src_rect.right - src->src_rect.left),
+      (gint) (src->src_rect.bottom - src->src_rect.top),
       src->rate_numerator, src->rate_denominator);
 
   return TRUE;
@@ -390,26 +391,26 @@ gst_dx9screencapsrc_create_caps_from_format (D3DFORMAT fmt,
       depth = 15;
       endianness = G_BYTE_ORDER;
       alpha = GST_VIDEO_ALPHA_MASK_15_INT;
-      red = GST_VIDEO_RED_MASK_15_INT;
-      green = GST_VIDEO_GREEN_MASK_15_INT;
-      blue = GST_VIDEO_BLUE_MASK_15_INT;
+      red = GST_VIDEO_COMP1_MASK_15_INT;
+      green = GST_VIDEO_COMP2_MASK_15_INT;
+      blue = GST_VIDEO_COMP3_MASK_15_INT;
       break;
     case D3DFMT_X1R5G5B5:
       bpp = 16;
       depth = 15;
       endianness = G_BYTE_ORDER;
       alpha = 0;
-      red = GST_VIDEO_RED_MASK_15_INT;
-      green = GST_VIDEO_GREEN_MASK_15_INT;
-      blue = GST_VIDEO_BLUE_MASK_15_INT;
+      red = GST_VIDEO_COMP1_MASK_15_INT;
+      green = GST_VIDEO_COMP2_MASK_15_INT;
+      blue = GST_VIDEO_COMP3_MASK_15_INT;
       break;
     case D3DFMT_R5G6B5:
       bpp = depth = 16;
       endianness = G_BYTE_ORDER;
       alpha = 0;
-      red = GST_VIDEO_RED_MASK_16_INT;
-      green = GST_VIDEO_GREEN_MASK_16_INT;
-      blue = GST_VIDEO_BLUE_MASK_16_INT;
+      red = GST_VIDEO_COMP1_MASK_15_INT;
+      green = GST_VIDEO_COMP2_MASK_15_INT;
+      blue = GST_VIDEO_COMP3_MASK_15_INT;
       break;
     default:
       return NULL;
@@ -478,7 +479,6 @@ static void
 gst_dx9screencapsrc_get_times (GstBaseSrc * basesrc,
     GstBuffer * buffer, GstClockTime * start, GstClockTime * end)
 {
-  GstDX9ScreenCapSrc *src = GST_DX9SCREENCAPSRC (basesrc);
   GstClockTime timestamp;
 
   timestamp = GST_BUFFER_TIMESTAMP (buffer);
@@ -501,7 +501,8 @@ gst_dx9screencapsrc_create (GstPushSrc * push_src, GstBuffer ** buf)
   gint new_buf_size, i;
   gint width, height, stride;
   GstClock *clock;
-  GstClockTime time, buf_time;
+  GstClockTime time = GST_CLOCK_TIME_NONE;
+  GstClockTime buf_time;
   D3DLOCKED_RECT locked_rect;
   LPBYTE p_dst, p_src;
   HRESULT hres;
@@ -536,7 +537,7 @@ gst_dx9screencapsrc_create (GstPushSrc * push_src, GstBuffer ** buf)
   }
 
   GST_LOG_OBJECT (src,
-      "creating buffer of %lu bytes with %dx%d image for frame %d",
+      "creating buffer of %d bytes with %dx%d image for frame %d",
       new_buf_size, width, height, (gint) src->frames);
 
   res = gst_pad_alloc_buffer_and_set_caps (GST_BASE_SRC_PAD (src),
diff --git a/sys/winscreencap/gstgdiscreencapsrc.c b/sys/winscreencap/gstgdiscreencapsrc.c
index a10a2fc..3e0cd6f 100644
--- a/sys/winscreencap/gstgdiscreencapsrc.c
+++ b/sys/winscreencap/gstgdiscreencapsrc.c
@@ -315,7 +315,8 @@ gst_gdiscreencapsrc_set_caps (GstBaseSrc * bsrc, GstCaps * caps)
     src->src_rect.bottom = src->src_rect.top + src->capture_h;
   }
 
-  if (framerate = gst_structure_get_value (structure, "framerate")) {
+  framerate = gst_structure_get_value (structure, "framerate");
+  if (framerate) {
     src->rate_numerator = gst_value_get_fraction_numerator (framerate);
     src->rate_denominator = gst_value_get_fraction_denominator (framerate);
   }
@@ -349,8 +350,8 @@ gst_gdiscreencapsrc_set_caps (GstBaseSrc * bsrc, GstCaps * caps)
   ReleaseDC (capture, device);
 
   GST_DEBUG_OBJECT (src, "size %dx%d, %d/%d fps",
-      src->info.bmiHeader.biWidth,
-      -src->info.bmiHeader.biHeight,
+      (gint) src->info.bmiHeader.biWidth,
+      (gint) (-src->info.bmiHeader.biHeight),
       src->rate_numerator, src->rate_denominator);
 
   return TRUE;
@@ -378,7 +379,8 @@ gst_gdiscreencapsrc_get_caps (GstBaseSrc * bsrc)
   }
 
   GST_DEBUG ("width = %d, height=%d",
-      rect_dst.right - rect_dst.left, rect_dst.bottom - rect_dst.top);
+      (gint) (rect_dst.right - rect_dst.left),
+      (gint) (rect_dst.bottom - rect_dst.top));
 
   return gst_caps_new_simple ("video/x-raw-rgb",
       "bpp", G_TYPE_INT, 24,
@@ -416,7 +418,6 @@ static void
 gst_gdiscreencapsrc_get_times (GstBaseSrc * basesrc, GstBuffer * buffer,
     GstClockTime * start, GstClockTime * end)
 {
-  GstGDIScreenCapSrc *src = GST_GDISCREENCAPSRC (basesrc);
   GstClockTime timestamp;
 
   timestamp = GST_BUFFER_TIMESTAMP (buffer);
@@ -438,7 +439,7 @@ gst_gdiscreencapsrc_create (GstPushSrc * push_src, GstBuffer ** buf)
   GstFlowReturn res;
   gint new_buf_size;
   GstClock *clock;
-  GstClockTime time;
+  GstClockTime time = GST_CLOCK_TIME_NONE;
   GstClockTime base_time;
 
   if (G_UNLIKELY (!src->info.bmiHeader.biWidth ||
@@ -455,9 +456,9 @@ gst_gdiscreencapsrc_create (GstPushSrc * push_src, GstBuffer ** buf)
       (-src->info.bmiHeader.biHeight);
 
   GST_LOG_OBJECT (src,
-      "creating buffer of %lu bytes with %dx%d image for frame %d",
-      new_buf_size, src->info.bmiHeader.biWidth,
-      -src->info.bmiHeader.biHeight, (gint) src->frames);
+      "creating buffer of %d bytes with %dx%d image for frame %d",
+      new_buf_size, (gint) src->info.bmiHeader.biWidth,
+      (gint) (-src->info.bmiHeader.biHeight), (gint) src->frames);
 
   res =
       gst_pad_alloc_buffer_and_set_caps (GST_BASE_SRC_PAD (src),
diff --git a/tests/check/elements/mpegtsmux.c b/tests/check/elements/mpegtsmux.c
index a93ac67..a7beee4 100644
--- a/tests/check/elements/mpegtsmux.c
+++ b/tests/check/elements/mpegtsmux.c
@@ -42,8 +42,6 @@ static GstStaticPadTemplate audio_src_template = GST_STATIC_PAD_TEMPLATE ("src",
 typedef struct _TestData
 {
   GstEvent *sink_event;
-  GstEvent *src_event1;
-  GstEvent *src_event2;
   gint src_events;
 } TestData;
 
@@ -60,14 +58,10 @@ src_event (GstPad * pad, GstEvent * event)
 {
   TestData *data = (TestData *) gst_pad_get_element_private (pad);
 
-  if (event->type == GST_EVENT_CUSTOM_UPSTREAM) {
+  if (event->type == GST_EVENT_CUSTOM_UPSTREAM)
     data->src_events += 1;
-    if (data->src_event1 != NULL)
-      data->src_event2 = event;
-    else
-      data->src_event1 = event;
-  }
 
+  gst_event_unref (event);
   return TRUE;
 }
 
@@ -79,6 +73,7 @@ sink_event (GstPad * pad, GstEvent * event)
   if (event->type == GST_EVENT_CUSTOM_DOWNSTREAM)
     data->sink_event = event;
 
+  gst_event_unref (event);
   return TRUE;
 }
 
diff --git a/tests/examples/camerabin/gst-camera-perf.c b/tests/examples/camerabin/gst-camera-perf.c
index c5554a0..0c56ee6 100644
--- a/tests/examples/camerabin/gst-camera-perf.c
+++ b/tests/examples/camerabin/gst-camera-perf.c
@@ -979,8 +979,10 @@ main (int argc, char *argv[])
   GOptionContext *ctx;
   GError *err = NULL;
 
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
   ctx = g_option_context_new (NULL);
   g_option_context_add_main_entries (ctx, options, NULL);
diff --git a/tests/examples/camerabin/gst-camerabin-test.c b/tests/examples/camerabin/gst-camerabin-test.c
index 27037fa..3f16a7f 100644
--- a/tests/examples/camerabin/gst-camerabin-test.c
+++ b/tests/examples/camerabin/gst-camerabin-test.c
@@ -786,8 +786,10 @@ main (int argc, char *argv[])
   GOptionContext *ctx;
   GError *err = NULL;
 
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
   ctx = g_option_context_new ("\n\ncamerabin command line test application.");
   g_option_context_add_main_entries (ctx, options, NULL);
diff --git a/tests/examples/camerabin2/gst-camerabin2-test.c b/tests/examples/camerabin2/gst-camerabin2-test.c
index f112dbc..cb4b008 100644
--- a/tests/examples/camerabin2/gst-camerabin2-test.c
+++ b/tests/examples/camerabin2/gst-camerabin2-test.c
@@ -1257,8 +1257,10 @@ main (int argc, char *argv[])
   GOptionContext *ctx;
   GError *err = NULL;
 
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
   ctx = g_option_context_new ("\n\ncamerabin command line test application.");
   g_option_context_add_main_entries (ctx, options, NULL);
diff --git a/tests/examples/mxf/mxfdemux-structure.c b/tests/examples/mxf/mxfdemux-structure.c
index 6f735c4..8a6c1b6 100644
--- a/tests/examples/mxf/mxfdemux-structure.c
+++ b/tests/examples/mxf/mxfdemux-structure.c
@@ -184,8 +184,10 @@ main (gint argc, gchar ** argv)
     return -1;
   }
 
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
   gst_init (NULL, NULL);
   gtk_init (NULL, NULL);
diff --git a/tests/examples/opencv/gst_element_print_properties.c b/tests/examples/opencv/gst_element_print_properties.c
index 4192fe8..3d7ae78 100644
--- a/tests/examples/opencv/gst_element_print_properties.c
+++ b/tests/examples/opencv/gst_element_print_properties.c
@@ -20,6 +20,10 @@
  *
  */
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
 
 #include <gst/gst.h>
 #include <string.h>
diff --git a/tests/examples/scaletempo/Makefile.am b/tests/examples/scaletempo/Makefile.am
index 5cdf3c7..aec2f29 100644
--- a/tests/examples/scaletempo/Makefile.am
+++ b/tests/examples/scaletempo/Makefile.am
@@ -1,8 +1,8 @@
 noinst_PROGRAMS = scaletempo-demo
 
 scaletempo_demo_SOURCES = demo-main.c demo-player.c demo-gui.c
-scaletempo_demo_CFLAGS = $(GST_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GTK_CFLAGS) 
-scaletempo_demo_LDFLAGS = $(GST_LIBS) $(GST_PLUGINS_BASE_LIBS) $(GTK_LIBS) -lgstinterfaces-@GST_MAJORMINOR@
+scaletempo_demo_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS) $(GTK_CFLAGS)
+scaletempo_demo_LDFLAGS = $(GST_PLUGINS_BASE_LIBS) -lgstinterfaces-@GST_MAJORMINOR@ $(GST_LIBS) $(GTK_LIBS)
 
 noinst_HEADERS = demo-player.h demo-gui.h
 
diff --git a/tests/examples/scaletempo/demo-gui.c b/tests/examples/scaletempo/demo-gui.c
index c31c2bf..9afce89 100644
--- a/tests/examples/scaletempo/demo-gui.c
+++ b/tests/examples/scaletempo/demo-gui.c
@@ -19,6 +19,11 @@
 #include "config.h"
 #endif
 
+/* FIXME 0.11: suppress warnings for deprecated API such as GStaticRecMutex
+ * with newer GLib versions (>= 2.31.0) */
+#define GLIB_DISABLE_DEPRECATION_WARNINGS
+
+#include <gst/glib-compat-private.h>
 #include <gtk/gtk.h>
 #include <glib/gprintf.h>
 #include <math.h>
diff --git a/tests/examples/scaletempo/demo-main.c b/tests/examples/scaletempo/demo-main.c
index 6ddcde7..d2ed0df 100644
--- a/tests/examples/scaletempo/demo-main.c
+++ b/tests/examples/scaletempo/demo-main.c
@@ -60,8 +60,10 @@ main (int argc, char *argv[])
     {NULL,}
   };
 
+#if !GLIB_CHECK_VERSION (2, 31, 0)
   if (!g_thread_supported ())
     g_thread_init (NULL);
+#endif
 
   ctx = g_option_context_new ("uri ...");
   g_option_context_add_group (ctx, gst_init_get_option_group ());
diff --git a/tools/element-templates/basesrc b/tools/element-templates/basesrc
index 0b7e56f..1be325a 100644
--- a/tools/element-templates/basesrc
+++ b/tools/element-templates/basesrc
@@ -161,10 +161,16 @@ static gboolean
 gst_replace_event (GstBaseSrc * src, GstEvent * event)
 {
   GstReplace *replace = GST_REPLACE (src);
+  gboolean ret;
 
   GST_DEBUG_OBJECT (replace, "event");
 
-  return TRUE;
+  switch (GST_EVENT_TYPE (event)) {
+    default:
+      ret = GST_BASE_SRC_CLASS (parent_class)->event (src, event);
+  }
+
+  return ret;
 }
 
 static GstFlowReturn
@@ -192,10 +198,16 @@ static gboolean
 gst_replace_query (GstBaseSrc * src, GstQuery * query)
 {
   GstReplace *replace = GST_REPLACE (src);
+  gboolean ret;
 
   GST_DEBUG_OBJECT (replace, "query");
 
-  return TRUE;
+  switch (GST_QUERY_TYPE (query)) {
+    default:
+      ret = GST_BASE_SRC_CLASS (parent_class)->query (src, query);
+  }
+
+  return ret;
 }
 
 static gboolean
diff --git a/tools/element-templates/element b/tools/element-templates/element
index ed025ee..f0d76eb 100644
--- a/tools/element-templates/element
+++ b/tools/element-templates/element
@@ -123,7 +123,17 @@ gst_replace_send_event (GstElement * element, GstEvent * event)
 static gboolean
 gst_replace_query (GstElement * element, GstQuery * query)
 {
+  GstReplace *replace = GST_REPLACE (element);
+  gboolean ret;
 
-  return FALSE;
+  GST_DEBUG_OBJECT (replace, "query");
+
+  switch (GST_QUERY_TYPE (query)) {
+    default:
+      ret = GST_ELEMENT_CLASS (parent_class)->query (element, query);
+      break;
+  }
+
+  return ret;
 }
 % end
diff --git a/tools/element-templates/sinkpad-template b/tools/element-templates/sinkpad-template
new file mode 100644
index 0000000..b06b346
--- /dev/null
+++ b/tools/element-templates/sinkpad-template
@@ -0,0 +1,19 @@
+/* vim: set filetype=c: */
+
+% instance-members
+% prototypes
+% pad-template
+static GstStaticPadTemplate gst_replace_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("application/unknown")
+    );
+
+% base-init
+  gst_element_class_add_static_pad_template (element_class,
+      &gst_replace_sink_template);
+% instance-init
+% methods
+% end
+
diff --git a/tools/element-templates/sinkpad-template-video b/tools/element-templates/sinkpad-template-video
new file mode 100644
index 0000000..b317c6f
--- /dev/null
+++ b/tools/element-templates/sinkpad-template-video
@@ -0,0 +1,33 @@
+/* vim: set filetype=c: */
+
+% instance-members
+% prototypes
+% pad-template
+/* FIXME: add/remove formats you can handle */
+#define VIDEO_SINK_CAPS \
+    GST_VIDEO_CAPS_RGBA "; " \
+    GST_VIDEO_CAPS_ARGB "; " \
+    GST_VIDEO_CAPS_BGRA "; " \
+    GST_VIDEO_CAPS_ABGR "; " \
+    GST_VIDEO_CAPS_RGBx "; " \
+    GST_VIDEO_CAPS_xRGB "; " \
+    GST_VIDEO_CAPS_BGRx "; " \
+    GST_VIDEO_CAPS_xBGR "; " \
+    GST_VIDEO_CAPS_RGB  "; " \
+    GST_VIDEO_CAPS_BGR  "; " \
+    GST_VIDEO_CAPS_YUV("{ AYUV }")
+
+static GstStaticPadTemplate gst_replace_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (VIDEO_SINK_CAPS)
+    );
+
+% base-init
+  gst_element_class_add_static_pad_template (element_class,
+      &gst_replace_sink_template);
+% instance-init
+% methods
+% end
+
diff --git a/tools/element-templates/srcpad-template b/tools/element-templates/srcpad-template
new file mode 100644
index 0000000..dd0842b
--- /dev/null
+++ b/tools/element-templates/srcpad-template
@@ -0,0 +1,19 @@
+/* vim: set filetype=c: */
+
+% instance-members
+% prototypes
+% pad-template
+static GstStaticPadTemplate gst_replace_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("application/unknown")
+    );
+
+% base-init
+  gst_element_class_add_static_pad_template (element_class,
+      &gst_replace_src_template);
+% instance-init
+% methods
+% end
+
diff --git a/tools/element-templates/srcpad-template-video b/tools/element-templates/srcpad-template-video
new file mode 100644
index 0000000..4f39320
--- /dev/null
+++ b/tools/element-templates/srcpad-template-video
@@ -0,0 +1,33 @@
+/* vim: set filetype=c: */
+
+% instance-members
+% prototypes
+% pad-template
+/* FIXME: add/remove formats you can handle */
+#define VIDEO_SRC_CAPS \
+    GST_VIDEO_CAPS_RGBA "; " \
+    GST_VIDEO_CAPS_ARGB "; " \
+    GST_VIDEO_CAPS_BGRA "; " \
+    GST_VIDEO_CAPS_ABGR "; " \
+    GST_VIDEO_CAPS_RGBx "; " \
+    GST_VIDEO_CAPS_xRGB "; " \
+    GST_VIDEO_CAPS_BGRx "; " \
+    GST_VIDEO_CAPS_xBGR "; " \
+    GST_VIDEO_CAPS_RGB  "; " \
+    GST_VIDEO_CAPS_BGR  "; " \
+    GST_VIDEO_CAPS_YUV("{ AYUV }")
+
+static GstStaticPadTemplate gst_replace_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (VIDEO_SRC_CAPS)
+    );
+
+% base-init
+  gst_element_class_add_static_pad_template (element_class,
+      &gst_replace_src_template);
+% instance-init
+% methods
+% end
+
diff --git a/tools/element-templates/videofilter b/tools/element-templates/videofilter
new file mode 100644
index 0000000..3a94b08
--- /dev/null
+++ b/tools/element-templates/videofilter
@@ -0,0 +1,78 @@
+/* vim: set filetype=c: */
+% ClassName
+GstVideoFilter
+% TYPE_CLASS_NAME
+GST_TYPE_VIDEO_FILTER
+% pads
+sinkpad-template-video srcpad-template-video
+% pkg-config
+gstreamer-video-0.10
+% includes
+#include <gst/video/video.h>
+#include <gst/video/gstvideofilter.h>
+% prototypes
+static gboolean
+gst_replace_start (GstBaseTransform * trans);
+static gboolean
+gst_replace_stop (GstBaseTransform * trans);
+static GstFlowReturn
+gst_replace_transform_ip (GstBaseTransform * trans, GstBuffer * buf);
+static gboolean
+gst_replace_set_caps (GstBaseTransform * trans, GstCaps * incaps,
+  GstCaps * outcaps);
+% declare-class
+  GstBaseTransformClass *base_transform_class = GST_BASE_TRANSFORM_CLASS (klass);
+% set-methods
+  base_transform_class->start = GST_DEBUG_FUNCPTR (gst_replace_start);
+  base_transform_class->stop = GST_DEBUG_FUNCPTR (gst_replace_stop);
+  base_transform_class->set_caps = GST_DEBUG_FUNCPTR (gst_replace_set_caps);
+  base_transform_class->transform_ip = GST_DEBUG_FUNCPTR (gst_replace_transform_ip);
+% methods
+
+static gboolean
+gst_replace_start (GstBaseTransform * trans)
+{
+  /* GstReplace *replace = GST_REPLACE (trans); */
+
+  /* initialize processing */
+  return TRUE;
+}
+
+static gboolean
+gst_replace_stop (GstBaseTransform * trans)
+{
+  /* GstReplace *replace = GST_REPLACE (trans); */
+
+  /* finalize processing */
+  return TRUE;
+}
+
+static gboolean
+gst_replace_set_caps (GstBaseTransform * trans, GstCaps * incaps,
+  GstCaps * outcaps)
+{
+  /* GstReplace *replace = GST_REPLACE (trans); */
+  GstVideoFormat video_format;
+  int w, h;
+
+  /* parse input caps, output caps are the same so we ignore them */
+  if (!gst_video_format_parse_caps (incaps, &video_format, &w, &h))
+    return FALSE;
+
+  /* You'll need to add those fields to the instance struct first */
+  /* replace->video_format = video_format; */
+  /* replace->width = w; */
+  /* replace->height = h; */
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_replace_transform_ip (GstBaseTransform * trans, GstBuffer * buf)
+{
+  /* GstReplace *replace = GST_REPLACE (trans); */
+
+  /* process the video data in the buffer in-place */
+  return GST_FLOW_OK;
+}
+
+% end
diff --git a/tools/gst-project-maker b/tools/gst-project-maker
new file mode 100755
index 0000000..c75fae6
--- /dev/null
+++ b/tools/gst-project-maker
@@ -0,0 +1,390 @@
+#!/bin/sh
+
+
+prefix=gst
+templatedir=element-templates
+
+while [ "$1" ] ; do
+  case $1 in
+    --help)
+      cat <<-EOF
+Usage: gst-project-maker [OPTIONS] PROJECT_NAME
+Create an autotools project based on GStreamer from a template.
+Options:
+  --help             Print this information
+  --prefix PREFIX    Use PREFIX instead of "gst"
+Example: 'gst-project-maker my_project' will create the project gst-my-project.
+EOF
+      exit 0
+      ;;
+    --prefix)
+      shift
+      prefix=$1
+      ;;
+    -*)
+      echo Unknown option: $1
+      exit 1
+      ;;
+    *)
+      if [ "$name" = "" ]; then
+        name=$1
+      else
+        echo Ignored: $1
+      fi
+  esac
+  shift
+done
+
+if [ "$name" = "" ] ; then
+  echo "Usage: gst-project-maker [OPTIONS] PROJECT_NAME"
+  exit 1
+fi
+
+
+PREFIX=$(echo $prefix | sed -e 's/\(.*\)/\U\1/')
+NAME=$(echo $name | sed -e 's/\(.*\)/\U\1/')
+Prefix=$(echo $prefix | sed -e 's/_\(.\)/\U\1/g' -e 's/^\(.\)/\U\1/')
+Name=$(echo $name | sed -e 's/_\(.\)/\U\1/g' -e 's/^\(.\)/\U\1/')
+
+if [ "$prefix" != "gst" ] ; then
+  cmdline_prefix="--prefix $prefix"
+else
+  cmdline_prefix=""
+fi
+
+GST_IS_REPLACE=${PREFIX}_IS_${NAME}
+GST_REPLACE=${PREFIX}_${NAME}
+GST_TYPE_REPLACE=${PREFIX}_TYPE_${NAME}
+GstReplace=${Prefix}${Name}
+gst_replace=${prefix}_${name}
+gst__replace=${prefix}-${name}
+gstreplace=${prefix}$(echo $name | sed -e 's/_//g')
+replace=$(echo $name | sed -e 's/_//g')
+
+if [ "$REAL_NAME" = "" ] ; then
+  REAL_NAME=FIXME
+fi
+if [ "$EMAIL_ADDRESS" = "" ] ; then
+  EMAIL_ADDRESS=fixme@example.com
+fi
+
+
+
+basedir=`pwd`/$gst__replace
+
+rm -rf $basedir
+mkdir $basedir
+
+cat >$basedir/AUTHORS <<EOF
+$REAL_NAME <$EMAIL_ADDRESS>
+EOF
+
+cat >$basedir/COPYING <<EOF
+Put your license here.
+EOF
+
+cat >$basedir/ChangeLog <<EOF
+Put your changelog here.
+EOF
+
+cat >$basedir/NEWS <<EOF
+News about your project.
+EOF
+
+cat >$basedir/README <<EOF
+README for your project.
+EOF
+
+cat >$basedir/autogen.sh <<EOF
+#!/bin/sh
+# you can either set the environment variables AUTOCONF, AUTOHEADER, AUTOMAKE,
+# ACLOCAL, AUTOPOINT and/or LIBTOOLIZE to the right versions, or leave them
+# unset and get the defaults
+
+autoreconf --verbose --force --install --make || {
+ echo 'autogen.sh failed';
+ exit 1;
+}
+
+./configure || {
+ echo 'configure failed';
+ exit 1;
+}
+
+echo
+echo "Now type 'make' to compile this module."
+echo
+EOF
+chmod 755 $basedir/autogen.sh
+
+cat >$basedir/configure.ac <<EOF
+dnl required version of autoconf
+AC_PREREQ([2.53])
+
+dnl TODO: fill in your package name and package version here
+AC_INIT([${gst__replace}],[0.10.0])
+
+dnl required versions of gstreamer and plugins-base
+GST_REQUIRED=0.10.16
+GSTPB_REQUIRED=0.10.16
+
+AC_CONFIG_SRCDIR([plugins/${gstreplace}.c])
+AC_CONFIG_HEADERS([config.h])
+
+dnl required version of automake
+AM_INIT_AUTOMAKE([1.10])
+AC_CONFIG_MACRO_DIR([m4])
+
+dnl enable mainainer mode by default
+AM_MAINTAINER_MODE([enable])
+
+dnl check for tools (compiler etc.)
+AC_PROG_CC
+AM_PROG_CC_C_O
+
+dnl required version of libtool
+LT_PREREQ([2.2.6])
+LT_INIT
+
+dnl give error and exit if we don't have pkgconfig
+AC_CHECK_PROG(HAVE_PKGCONFIG, pkg-config, [ ], [
+  AC_MSG_ERROR([You need to have pkg-config installed!])
+])
+
+dnl Check for the required version of GStreamer core (and gst-plugins-base)
+dnl This will export GST_CFLAGS and GST_LIBS variables for use in Makefile.am
+dnl
+dnl If you need libraries from gst-plugins-base here, also add:
+dnl for libgstaudio-0.10: gstreamer-audio-0.10 >= \$GST_REQUIRED
+dnl for libgstvideo-0.10: gstreamer-video-0.10 >= \$GST_REQUIRED
+dnl for libgsttag-0.10: gstreamer-tag-0.10 >= \$GST_REQUIRED
+dnl for libgstpbutils-0.10: gstreamer-pbutils-0.10 >= \$GST_REQUIRED
+dnl for libgstfft-0.10: gstreamer-fft-0.10 >= \$GST_REQUIRED
+dnl for libgstinterfaces-0.10: gstreamer-interfaces-0.10 >= \$GST_REQUIRED
+dnl for libgstrtp-0.10: gstreamer-rtp-0.10 >= \$GST_REQUIRED
+dnl for libgstrtsp-0.10: gstreamer-rtsp-0.10 >= \$GST_REQUIRED
+dnl etc.
+PKG_CHECK_MODULES(GST, [
+  gstreamer-0.10 >= \$GST_REQUIRED
+  gstreamer-base-0.10 >= \$GST_REQUIRED
+  gstreamer-controller-0.10 >= \$GST_REQUIRED
+], [
+  AC_SUBST(GST_CFLAGS)
+  AC_SUBST(GST_LIBS)
+], [
+  AC_MSG_ERROR([
+      You need to install or upgrade the GStreamer development
+      packages on your system. On debian-based systems these are
+      libgstreamer0.10-dev and libgstreamer-plugins-base0.10-dev.
+      on RPM-based systems gstreamer0.10-devel, libgstreamer0.10-devel
+      or similar. The minimum version required is \$GST_REQUIRED.
+  ])
+])
+
+dnl check if compiler understands -Wall (if yes, add -Wall to GST_CFLAGS)
+AC_MSG_CHECKING([to see if compiler understands -Wall])
+save_CFLAGS="\$CFLAGS"
+CFLAGS="\$CFLAGS -Wall"
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([ ], [ ])], [
+  GST_CFLAGS="\$GST_CFLAGS -Wall"
+  AC_MSG_RESULT([yes])
+], [
+  AC_MSG_RESULT([no])
+])
+
+dnl set the plugindir where plugins should be installed (for plugins/Makefile.am)
+if test "x\${prefix}" = "x\$HOME"; then
+  plugindir="\$HOME/.gstreamer-0.10/plugins"
+else
+  plugindir="\\\$(libdir)/gstreamer-0.10"
+fi
+AC_SUBST(plugindir)
+
+dnl set proper LDFLAGS for plugins
+GST_PLUGIN_LDFLAGS='-module -avoid-version -export-symbols-regex [_]*\(gst_\|Gst\|GST_\).*'
+AC_SUBST(GST_PLUGIN_LDFLAGS)
+
+AC_CONFIG_FILES([Makefile plugins/Makefile tools/Makefile])
+AC_OUTPUT
+EOF
+
+cat >$basedir/Makefile.am <<EOF
+SUBDIRS = plugins tools
+
+EXTRA_DIST = autogen.sh
+
+ACLOCAL_AMFLAGS = -I m4
+EOF
+
+mkdir -p $basedir/m4
+
+mkdir -p $basedir/plugins
+
+cat >$basedir/plugins/Makefile.am <<EOF
+plugin_LTLIBRARIES = lib$gstreplace.la
+
+# sources used to compile this plug-in
+lib${gstreplace}_la_SOURCES = ${gstreplace}plugin.c ${gstreplace}.c ${gstreplace}.h
+
+# compiler and linker flags used to compile this plugin, set in configure.ac
+lib${gstreplace}_la_CFLAGS = \$(GST_CFLAGS)
+lib${gstreplace}_la_LIBADD = \$(GST_LIBS)
+lib${gstreplace}_la_LDFLAGS = \$(GST_PLUGIN_LDFLAGS)
+lib${gstreplace}_la_LIBTOOLFLAGS = --tag=disable-static
+
+EOF
+
+
+generate()
+{
+cat <<EOF
+/*
+ * GStreamer
+ * Copyright (C) $(date +%Y) $REAL_NAME <$EMAIL_ADDRESS>
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Alternatively, the contents of this file may be used under the
+ * GNU Lesser General Public License Version 2.1 (the "LGPL"), in
+ * which case the following provisions apply instead of the ones
+ * mentioned above:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <gst/gst.h>
+#include "gstreplace.h"
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  gst_element_register (plugin, "replace", GST_RANK_NONE,
+      GST_TYPE_REPLACE);
+
+  return TRUE;
+}
+
+GST_PLUGIN_DEFINE (
+    GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "replace",
+    "FIXME Template plugin",
+    plugin_init,
+    VERSION,
+    "LGPL", /* FIXME */
+    "GStreamer",
+    "http://gstreamer.net/"
+)
+EOF
+}
+
+
+generate | sed \
+  -e "s/GST_BASE_REPLACE/$GST_BASE_REPLACE/g" \
+  -e "s/GST_TYPE_BASE_REPLACE/$GST_TYPE_BASE_REPLACE/g" \
+  -e "s/GstBaseReplace/$GstBaseReplace/g" \
+  -e "s/GST_IS_REPLACE/$GST_IS_REPLACE/g" \
+  -e "s/GST_REPLACE/$GST_REPLACE/g" \
+  -e "s/GST_TYPE_REPLACE/$GST_TYPE_REPLACE/g" \
+  -e "s/GstReplace/$GstReplace/g" \
+  -e "s/gst_replace/$gst_replace/g" \
+  -e "s/gstreplace/$gstreplace/g" \
+  -e "s/replace/$replace/g" >$basedir/plugins/${gstreplace}plugin.c
+
+gst-indent $basedir/plugins/${gstreplace}plugin.c
+rm -f $basedir/plugins/${gstreplace}plugin.c~
+
+cat >$basedir/plugins/${gstreplace}.c <<EOF
+/* This file should be replaced by element source generated by
+ * gst-element-maker, or by your own source code.  To generate suitable
+ * element source using gst-element-maker, run:
+ *
+ *   gst-element-maker $cmdline_prefix $replace BASE_CLASS
+ *
+ * Where BASE_CLASS is replaced by one of the base class templates,
+ * such as basesrc, basetransform, audiofilter, videofilter2, etc.
+ * Then copy the resulting $gstreplace.c file over this file, and
+ * $gstreplace.h over $gstreplace.h.
+ */
+/* The rest of this file is shim code to allow the project to compile */
+EOF
+
+cat >$basedir/plugins/${gstreplace}.h <<EOF
+/* This file should be replaced by element header generated by
+ * gst-element-maker, or by your own source code.  To generate suitable
+ * element header using gst-element-maker, run:
+ *
+ *   gst-element-maker $cmdline_prefix $replace BASE_CLASS
+ *
+ * Where BASE_CLASS is replaced by one of the base class templates,
+ * such as basesrc, basetransform, audiofilter, videofilter2, etc.
+ * Then copy the resulting $gstreplace.h file over this file, and
+ * $gstreplace.c over $gstreplace.c.
+ */
+/* The rest of this file is shim code to allow the project to compile */
+#define ${GST_TYPE_REPLACE} G_TYPE_NONE
+EOF
+
+
+mkdir -p $basedir/tools
+
+cat >$basedir/tools/Makefile.am <<EOF
+bin_PROGRAMS = ${gst__replace}
+
+# sources used to compile this plug-in
+${gst_replace}_SOURCES = ${gstreplace}.c
+
+# compiler and linker flags used to compile the program, set in configure.ac
+${gst_replace}_CFLAGS = \$(GST_CFLAGS)
+${gst_replace}_LDADD = \$(GST_LIBS)
+
+EOF
+
+cat >$basedir/tools/${gstreplace}.c <<EOF
+/* This file should be replaced by application source generated by
+ * gst-app-maker, or by your own source code.  To generate suitable
+ * app source using gst-app-maker, run:
+ *
+ *   gst-app-maker $cmdline_prefix $replace
+ *
+ * Then copy the resulting $gstreplace.c file over this file.
+ */
+/* The rest of this file is shim code to allow the project to compile */
+#include <stdio.h>
+int main (void) { printf ("FIXME\n"); return 0; }
+EOF
+
+
diff --git a/win32/common/config.h b/win32/common/config.h
index ea4458c..c2904cf 100644
--- a/win32/common/config.h
+++ b/win32/common/config.h
@@ -24,7 +24,7 @@
 #define GST_LICENSE "LGPL"
 
 /* package name in plugins */
-#define GST_PACKAGE_NAME "GStreamer Bad Plug-ins source release"
+#define GST_PACKAGE_NAME "GStreamer Bad Plug-ins git"
 
 /* package origin */
 #define GST_PACKAGE_ORIGIN "Unknown package origin"
@@ -199,7 +199,7 @@
 #undef USE_POISONING
 
 /* Version number of package */
-#define VERSION "0.10.23"
+#define VERSION "0.10.23.1"
 
 /* Define to 1 if your processor stores words with the most significant byte
    first (like Motorola and SPARC, unlike Intel and VAX). */
