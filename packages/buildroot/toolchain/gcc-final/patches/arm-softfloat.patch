--- a/gcc/config/arm/linux-elf.h
+++ b/gcc/config/arm/linux-elf.h
@@ -39,7 +39,7 @@
 
 #undef  MULTILIB_DEFAULTS
 #define MULTILIB_DEFAULTS \
-	{ "marm", "mlittle-endian", "mhard-float", "mno-thumb-interwork" }
+	{ "marm", "mlittle-endian", "msoft-float" "mhard-float", "mno-thumb-interwork" }
 
 /* Now we define the strings used to build the spec file.  */
 #undef  LIB_SPEC
@@ -48,7 +48,7 @@
    %{shared:-lc} \
    %{!shared:%{profile:-lc_p}%{!profile:-lc}}"
 
-#define LIBGCC_SPEC "%{msoft-float:-lfloat} %{mfloat-abi=soft*:-lfloat} -lgcc"
+#define LIBGCC_SPEC "-lgcc"
 
 #define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
 
--- a/gcc/config/arm/t-linux
+++ b/gcc/config/arm/t-linux
@@ -4,7 +4,10 @@ TARGET_LIBGCC2_CFLAGS = -fomit-frame-poi
 LIBGCC2_DEBUG_CFLAGS = -g0
 
 LIB1ASMSRC = arm/lib1funcs.asm
-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_lnx
+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_lnx \
+	_negdf2 _addsubdf3 _muldivdf3 _cmpdf2 _unorddf2 _fixdfsi _fixunsdfsi \
+	_truncdfsf2 _negsf2 _addsubsf3 _muldivsf3 _cmpsf2 _unordsf2 _fixsfsi \
+	_fixunssfsi
 
 # MULTILIB_OPTIONS = mhard-float/msoft-float
 # MULTILIB_DIRNAMES = hard-float soft-float
--- a/gcc/libgcc2.c	2007-07-27 09:19:45.000000000 +0200
+++ b/gcc/libgcc2.c	2007-07-27 09:20:57.000000000 +0200
@@ -1390,223 +1390,6 @@
 }
 #endif
 
-#if (defined(L_floatdisf) && LIBGCC2_HAS_SF_MODE)	\
-     || (defined(L_floatdidf) && LIBGCC2_HAS_DF_MODE)
-#define DI_SIZE (W_TYPE_SIZE * 2)
-#define F_MODE_OK(SIZE) \
-  (SIZE < DI_SIZE							\
-   && SIZE > (DI_SIZE - SIZE + FSSIZE)					\
-   /* Don't use IBM Extended Double TFmode for TI->SF calculations.	\
-      The conversion from long double to float suffers from double	\
-      rounding, because we convert via double.  In any case, the	\
-      fallback code is faster.  */					\
-   && !IS_IBM_EXTENDED (SIZE))
-#if defined(L_floatdisf)
-#define FUNC __floatdisf
-#define FSTYPE SFtype
-#define FSSIZE SF_SIZE
-#else
-#define FUNC __floatdidf
-#define FSTYPE DFtype
-#define FSSIZE DF_SIZE
-#endif
-
-FSTYPE
-FUNC (DWtype u)
-{
-#if FSSIZE >= W_TYPE_SIZE
-  /* When the word size is small, we never get any rounding error.  */
-  FSTYPE f = (Wtype) (u >> W_TYPE_SIZE);
-  f *= Wtype_MAXp1_F;
-  f += (UWtype)u;
-  return f;
-#elif (LIBGCC2_HAS_DF_MODE && F_MODE_OK (DF_SIZE))	\
-     || (LIBGCC2_HAS_XF_MODE && F_MODE_OK (XF_SIZE))	\
-     || (LIBGCC2_HAS_TF_MODE && F_MODE_OK (TF_SIZE))
-
-#if (LIBGCC2_HAS_DF_MODE && F_MODE_OK (DF_SIZE))
-# define FSIZE DF_SIZE
-# define FTYPE DFtype
-#elif (LIBGCC2_HAS_XF_MODE && F_MODE_OK (XF_SIZE))
-# define FSIZE XF_SIZE
-# define FTYPE XFtype
-#elif (LIBGCC2_HAS_TF_MODE && F_MODE_OK (TF_SIZE))
-# define FSIZE TF_SIZE
-# define FTYPE TFtype
-#else
-# error
-#endif
-
-#define REP_BIT ((UDWtype) 1 << (DI_SIZE - FSIZE))
-
-  /* Protect against double-rounding error.
-     Represent any low-order bits, that might be truncated by a bit that
-     won't be lost.  The bit can go in anywhere below the rounding position
-     of the FSTYPE.  A fixed mask and bit position handles all usual
-     configurations.  */
-  if (! (- ((DWtype) 1 << FSIZE) < u
-	 && u < ((DWtype) 1 << FSIZE)))
-    {
-      if ((UDWtype) u & (REP_BIT - 1))
-	{
-	  u &= ~ (REP_BIT - 1);
-	  u |= REP_BIT;
-	}
-    }
-
-  /* Do the calculation in a wider type so that we don't lose any of
-     the precision of the high word while multiplying it.  */
-  FTYPE f = (Wtype) (u >> W_TYPE_SIZE);
-  f *= Wtype_MAXp1_F;
-  f += (UWtype)u;
-  return (FSTYPE) f;
-#else
-#if FSSIZE >= W_TYPE_SIZE - 2
-# error
-#endif
-  /* Finally, the word size is larger than the number of bits in the
-     required FSTYPE, and we've got no suitable wider type.  The only
-     way to avoid double rounding is to special case the
-     extraction.  */
-
-  /* If there are no high bits set, fall back to one conversion.  */
-  if ((Wtype)u == u)
-    return (FSTYPE)(Wtype)u;
-
-  /* Otherwise, find the power of two.  */
-  Wtype hi = u >> W_TYPE_SIZE;
-  if (hi < 0)
-    hi = -hi;
-
-  UWtype count, shift;
-  count_leading_zeros (count, hi);
-
-  /* No leading bits means u == minimum.  */
-  if (count == 0)
-    return -(Wtype_MAXp1_F * (Wtype_MAXp1_F / 2));
-
-  shift = 1 + W_TYPE_SIZE - count;
-
-  /* Shift down the most significant bits.  */
-  hi = u >> shift;
-
-  /* If we lost any nonzero bits, set the lsb to ensure correct rounding.  */
-  if (u & (((DWtype)1 << shift) - 1))
-    hi |= 1;
-
-  /* Convert the one word of data, and rescale.  */
-  FSTYPE f = hi;
-  f *= (UDWtype)1 << shift;
-  return f;
-#endif
-}
-#endif
-
-#if (defined(L_floatundisf) && LIBGCC2_HAS_SF_MODE)	\
-     || (defined(L_floatundidf) && LIBGCC2_HAS_DF_MODE)
-#define DI_SIZE (W_TYPE_SIZE * 2)
-#define F_MODE_OK(SIZE) \
-  (SIZE < DI_SIZE							\
-   && SIZE > (DI_SIZE - SIZE + FSSIZE)					\
-   /* Don't use IBM Extended Double TFmode for TI->SF calculations.	\
-      The conversion from long double to float suffers from double	\
-      rounding, because we convert via double.  In any case, the	\
-      fallback code is faster.  */					\
-   && !IS_IBM_EXTENDED (SIZE))
-#if defined(L_floatundisf)
-#define FUNC __floatundisf
-#define FSTYPE SFtype
-#define FSSIZE SF_SIZE
-#else
-#define FUNC __floatundidf
-#define FSTYPE DFtype
-#define FSSIZE DF_SIZE
-#endif
-
-FSTYPE
-FUNC (UDWtype u)
-{
-#if FSSIZE >= W_TYPE_SIZE
-  /* When the word size is small, we never get any rounding error.  */
-  FSTYPE f = (UWtype) (u >> W_TYPE_SIZE);
-  f *= Wtype_MAXp1_F;
-  f += (UWtype)u;
-  return f;
-#elif (LIBGCC2_HAS_DF_MODE && F_MODE_OK (DF_SIZE))	\
-     || (LIBGCC2_HAS_XF_MODE && F_MODE_OK (XF_SIZE))	\
-     || (LIBGCC2_HAS_TF_MODE && F_MODE_OK (TF_SIZE))
-
-#if (LIBGCC2_HAS_DF_MODE && F_MODE_OK (DF_SIZE))
-# define FSIZE DF_SIZE
-# define FTYPE DFtype
-#elif (LIBGCC2_HAS_XF_MODE && F_MODE_OK (XF_SIZE))
-# define FSIZE XF_SIZE
-# define FTYPE XFtype
-#elif (LIBGCC2_HAS_TF_MODE && F_MODE_OK (TF_SIZE))
-# define FSIZE TF_SIZE
-# define FTYPE TFtype
-#else
-# error
-#endif
-
-#define REP_BIT ((UDWtype) 1 << (DI_SIZE - FSIZE))
-
-  /* Protect against double-rounding error.
-     Represent any low-order bits, that might be truncated by a bit that
-     won't be lost.  The bit can go in anywhere below the rounding position
-     of the FSTYPE.  A fixed mask and bit position handles all usual
-     configurations.  */
-  if (u >= ((UDWtype) 1 << FSIZE))
-    {
-      if ((UDWtype) u & (REP_BIT - 1))
-	{
-	  u &= ~ (REP_BIT - 1);
-	  u |= REP_BIT;
-	}
-    }
-
-  /* Do the calculation in a wider type so that we don't lose any of
-     the precision of the high word while multiplying it.  */
-  FTYPE f = (UWtype) (u >> W_TYPE_SIZE);
-  f *= Wtype_MAXp1_F;
-  f += (UWtype)u;
-  return (FSTYPE) f;
-#else
-#if FSSIZE == W_TYPE_SIZE - 1
-# error
-#endif
-  /* Finally, the word size is larger than the number of bits in the
-     required FSTYPE, and we've got no suitable wider type.  The only
-     way to avoid double rounding is to special case the
-     extraction.  */
-
-  /* If there are no high bits set, fall back to one conversion.  */
-  if ((UWtype)u == u)
-    return (FSTYPE)(UWtype)u;
-
-  /* Otherwise, find the power of two.  */
-  UWtype hi = u >> W_TYPE_SIZE;
-
-  UWtype count, shift;
-  count_leading_zeros (count, hi);
-
-  shift = W_TYPE_SIZE - count;
-
-  /* Shift down the most significant bits.  */
-  hi = u >> shift;
-
-  /* If we lost any nonzero bits, set the lsb to ensure correct rounding.  */
-  if (u & (((UDWtype)1 << shift) - 1))
-    hi |= 1;
-
-  /* Convert the one word of data, and rescale.  */
-  FSTYPE f = hi;
-  f *= (UDWtype)1 << shift;
-  return f;
-#endif
-}
-#endif
-
 #if defined(L_fixunsxfsi) && LIBGCC2_HAS_XF_MODE
 /* Reenable the normal types, in case limits.h needs them.  */
 #undef char
