1. Provided by Sebastian Ohl <sebastian@ohl.name>
   http://bugs.debian.org/495487#62

--- xf86-input-tslib-0.0.5/src/tslib.c	2009-02-22 10:47:56.000000000 +0100
+++ xf86-input-tslib-0.0.5.my/src/tslib.c	2009-02-22 10:46:18.000000000 +0100
@@ -50,18 +50,24 @@
 #include <mipointer.h>
 
 #include <tslib.h>
+#include <sys/time.h>
+#include <time.h>
 
 #ifdef XFree86LOADER
 #include <xf86Module.h>
 #endif
 
-#define MAXBUTTONS 1
+#define MAXBUTTONS 3
+#define TIME23RDBUTTON 0.5
+#define MOVEMENT23RDBUTTON 4
 
 #define DEFAULT_HEIGHT		240
 #define DEFAULT_WIDTH		320
 
 enum { TSLIB_ROTATE_NONE=0, TSLIB_ROTATE_CW=270, TSLIB_ROTATE_UD=180, TSLIB_ROTATE_CCW=90 };
 
+enum button_state { BUTTON_NOT_PRESSED = 0, BUTTON_1_PRESSED = 1, BUTTON_3_CLICK = 3, BUTTON_3_CLICKED=4, BUTTON_EMULATION_OFF=-1 };
+
 struct ts_priv {
 	XISBuffer *buffer;
 	struct tsdev *ts;
@@ -70,6 +76,9 @@
 	int rotate;
 	int height;
 	int width;
+	enum button_state state;
+	struct timeval button_down_start;
+	int button_down_x,button_down_y;
 };
 
 static void
@@ -111,14 +120,30 @@
 	return TRUE;
 }
 
+struct timeval TimevalDiff(struct timeval a, struct timeval b)
+{
+	struct timeval t;
+	t.tv_sec = a.tv_sec-b.tv_sec;
+	t.tv_usec = a.tv_usec - b.tv_usec;
+	if (t.tv_usec < 0) {
+		t.tv_sec--;
+		t.tv_usec += 1000000;
+	}
+    return t;
+}
+
 static void ReadInput (LocalDevicePtr local)
 {
 	struct ts_priv *priv = (struct ts_priv *) (local->private);
 	struct ts_sample samp;
 	int ret;
 	int x,y;
+	struct timeval now;
 
 	while((ret = ts_read(priv->ts, &samp, 1)) == 1) {
+	 	gettimeofday(&now, NULL);
+	 	struct timeval pressureTime = TimevalDiff(now,priv->button_down_start);
+
 		if(samp.pressure) {
 			int tmp_x = samp.x;
 
@@ -149,13 +174,85 @@
 
 		}
 
-		if(!!priv->lastp != !!samp.pressure) {
-			priv->lastp = samp.pressure;
-
-			xf86PostButtonEvent(local->dev, TRUE,
-				1, !!samp.pressure, 0, 2,
-				priv->lastx,
-				priv->lasty);
+  
+ 	 	/* button pressed state machine
+ 	 	 * if pressed than press button 1, start timer and remember the tab position
+ 	 	 * if pressed longer than TIME23RDBUTTON and it is not moved more than MOVEMENT23RDBUTTON release button 1 and click button 3
+ 	 	 * if still pressed do nothing until the pressure is released
+ 	 	 */
+ 	 	switch (priv->state) {
+             case BUTTON_EMULATION_OFF :
+                 if(priv->lastp != samp.pressure) {
+                     priv->lastp = samp.pressure;
+     
+                     xf86PostButtonEvent(local->dev, TRUE,
+                         1, !!samp.pressure, 0, 2,
+                         priv->lastx,
+                         priv->lasty);
+                 }
+                 break;
+ 	 		case BUTTON_NOT_PRESSED :
+ 	 			if (samp.pressure) {
+ 	 				priv->button_down_start = now;
+ 	 				priv->button_down_y = samp.y;
+ 	 				priv->button_down_x = samp.x;
+ 	 				priv->state = BUTTON_1_PRESSED;
+ 	 				//ErrorF("b1 down");
+ 	 				xf86PostButtonEvent(local->dev, TRUE,
+ 	 					priv->state, TRUE, 0, 2,
+ 	 					priv->lastx,
+ 	 					priv->lasty);
+ 	 			}
+ 	 			break;
+ 	 		case BUTTON_1_PRESSED :
+ 	 			if (samp.pressure) {	
+ 	 				//ErrorF("%d %d ",pressureTime.tv_sec,pressureTime.tv_usec);
+ 	 				if ((((double)pressureTime.tv_sec)+(((double)pressureTime.tv_usec)*1e-6) > TIME23RDBUTTON) &&
+ 	 				   (abs(priv->lastx-priv->button_down_x) < MOVEMENT23RDBUTTON &&
+ 	 				    abs(priv->lasty-priv->button_down_y) < MOVEMENT23RDBUTTON))
+ 	 				{
+ 	 					//ErrorF("b1 up");
+ 	 					xf86PostButtonEvent(local->dev, TRUE,
+ 	 						priv->state, FALSE, 0, 2,
+ 	 						priv->lastx,
+ 	 						priv->lasty);
+ 	 					priv->state = BUTTON_3_CLICK;
+ 	 					//ErrorF("b3 down");
+ 	 					xf86PostButtonEvent(local->dev, TRUE,
+ 	 						priv->state, TRUE, 0, 2,
+ 	 						priv->lastx,
+ 	 						priv->lasty);
+ 	 				} 
+ 	 				if (abs(priv->lastx-priv->button_down_x) > MOVEMENT23RDBUTTON ||
+ 	 				    abs(priv->lasty-priv->button_down_y) > MOVEMENT23RDBUTTON) {
+ 	 					priv->button_down_start = now;
+ 	 					priv->button_down_y = samp.y;
+ 	 					priv->button_down_x = samp.x;
+ 	 					//ErrorF("b1 state reset");
+ 	 				}
+ 	 			} else {
+ 	 				//ErrorF("b1 up");
+ 	 				xf86PostButtonEvent(local->dev, TRUE,
+ 	 					priv->state, FALSE, 0, 2,
+ 	 					priv->lastx,
+ 	 					priv->lasty);
+ 	 				priv->state = BUTTON_NOT_PRESSED;
+ 	 			}
+ 	 			break;
+ 	 		case BUTTON_3_CLICK :
+ 	 			//ErrorF("b3 up");
+ 	 			xf86PostButtonEvent(local->dev, TRUE,
+ 	 				priv->state, FALSE, 0, 2,
+ 	 				priv->lastx,
+ 	 				priv->lasty);
+ 	 			priv->state = BUTTON_3_CLICKED;
+ 	 			break;
+ 	 		case BUTTON_3_CLICKED :
+ 	 			if (!samp.pressure) {
+ 	 				//ErrorF("b3 free");
+ 	 				priv->state = BUTTON_NOT_PRESSED;
+ 	 			}
+ 	 			break;
 		}
 	}
 
@@ -358,6 +455,11 @@
 
 	pInfo->fd = ts_fd(priv->ts);
 
+	priv->state = BUTTON_NOT_PRESSED;
+	if (xf86SetIntOption(pInfo->options, "EmulateRightButton", 0) == 0) {
+		priv->state = BUTTON_EMULATION_OFF;
+	}
+		
 	/* Mark the device configured */
 	pInfo->flags |= XI86_CONFIGURED;
 
